(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(global = global || self, factory(global.threeVP = {}));
}(this, function (exports) { 'use strict';

	if (Number.EPSILON === undefined) {
	  Number.EPSILON = Math.pow(2, -52);
	}
	if (Number.isInteger === undefined) {
	  Number.isInteger = function (value) {
	    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
	  };
	}
	if (Math.sign === undefined) {
	  Math.sign = function (x) {
	    return x < 0 ? -1 : x > 0 ? 1 : +x;
	  };
	}
	if (("name" in Function.prototype) === false) {
	  Object.defineProperty(Function.prototype, "name", {
	    get: function () {
	      return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1];
	    }
	  });
	}
	if (Object.assign === undefined) {
	  Object.assign = function (target) {
	    if (target === undefined || target === null) {
	      throw new TypeError("Cannot convert undefined or null to object");
	    }
	    var output = Object(target);
	    for (var index = 1; index < arguments.length; index++) {
	      var source = arguments[index];
	      if (source !== undefined && source !== null) {
	        for (var nextKey in source) {
	          if (Object.prototype.hasOwnProperty.call(source, nextKey)) {
	            output[nextKey] = source[nextKey];
	          }
	        }
	      }
	    }
	    return output;
	  };
	}
	var REVISION = "114";
	var MOUSE = {
	  LEFT: 0,
	  MIDDLE: 1,
	  RIGHT: 2,
	  ROTATE: 0,
	  DOLLY: 1,
	  PAN: 2
	};
	var TOUCH = {
	  ROTATE: 0,
	  PAN: 1,
	  DOLLY_PAN: 2,
	  DOLLY_ROTATE: 3
	};
	var CullFaceNone = 0;
	var CullFaceBack = 1;
	var CullFaceFront = 2;
	var CullFaceFrontBack = 3;
	var FrontFaceDirectionCW = 0;
	var FrontFaceDirectionCCW = 1;
	var BasicShadowMap = 0;
	var PCFShadowMap = 1;
	var PCFSoftShadowMap = 2;
	var VSMShadowMap = 3;
	var FrontSide = 0;
	var BackSide = 1;
	var DoubleSide = 2;
	var FlatShading = 1;
	var SmoothShading = 2;
	var NoBlending = 0;
	var NormalBlending = 1;
	var AdditiveBlending = 2;
	var SubtractiveBlending = 3;
	var MultiplyBlending = 4;
	var CustomBlending = 5;
	var AddEquation = 100;
	var SubtractEquation = 101;
	var ReverseSubtractEquation = 102;
	var MinEquation = 103;
	var MaxEquation = 104;
	var ZeroFactor = 200;
	var OneFactor = 201;
	var SrcColorFactor = 202;
	var OneMinusSrcColorFactor = 203;
	var SrcAlphaFactor = 204;
	var OneMinusSrcAlphaFactor = 205;
	var DstAlphaFactor = 206;
	var OneMinusDstAlphaFactor = 207;
	var DstColorFactor = 208;
	var OneMinusDstColorFactor = 209;
	var SrcAlphaSaturateFactor = 210;
	var NeverDepth = 0;
	var AlwaysDepth = 1;
	var LessDepth = 2;
	var LessEqualDepth = 3;
	var EqualDepth = 4;
	var GreaterEqualDepth = 5;
	var GreaterDepth = 6;
	var NotEqualDepth = 7;
	var MultiplyOperation = 0;
	var MixOperation = 1;
	var AddOperation = 2;
	var NoToneMapping = 0;
	var LinearToneMapping = 1;
	var ReinhardToneMapping = 2;
	var Uncharted2ToneMapping = 3;
	var CineonToneMapping = 4;
	var ACESFilmicToneMapping = 5;
	var UVMapping = 300;
	var CubeReflectionMapping = 301;
	var CubeRefractionMapping = 302;
	var EquirectangularReflectionMapping = 303;
	var EquirectangularRefractionMapping = 304;
	var SphericalReflectionMapping = 305;
	var CubeUVReflectionMapping = 306;
	var CubeUVRefractionMapping = 307;
	var RepeatWrapping = 1000;
	var ClampToEdgeWrapping = 1001;
	var MirroredRepeatWrapping = 1002;
	var NearestFilter = 1003;
	var NearestMipmapNearestFilter = 1004;
	var NearestMipMapNearestFilter = 1004;
	var NearestMipmapLinearFilter = 1005;
	var NearestMipMapLinearFilter = 1005;
	var LinearFilter = 1006;
	var LinearMipmapNearestFilter = 1007;
	var LinearMipMapNearestFilter = 1007;
	var LinearMipmapLinearFilter = 1008;
	var LinearMipMapLinearFilter = 1008;
	var UnsignedByteType = 1009;
	var ByteType = 1010;
	var ShortType = 1011;
	var UnsignedShortType = 1012;
	var IntType = 1013;
	var UnsignedIntType = 1014;
	var FloatType = 1015;
	var HalfFloatType = 1016;
	var UnsignedShort4444Type = 1017;
	var UnsignedShort5551Type = 1018;
	var UnsignedShort565Type = 1019;
	var UnsignedInt248Type = 1020;
	var AlphaFormat = 1021;
	var RGBFormat = 1022;
	var RGBAFormat = 1023;
	var LuminanceFormat = 1024;
	var LuminanceAlphaFormat = 1025;
	var RGBEFormat = RGBAFormat;
	var DepthFormat = 1026;
	var DepthStencilFormat = 1027;
	var RedFormat = 1028;
	var RedIntegerFormat = 1029;
	var RGFormat = 1030;
	var RGIntegerFormat = 1031;
	var RGBIntegerFormat = 1032;
	var RGBAIntegerFormat = 1033;
	var RGB_S3TC_DXT1_Format = 33776;
	var RGBA_S3TC_DXT1_Format = 33777;
	var RGBA_S3TC_DXT3_Format = 33778;
	var RGBA_S3TC_DXT5_Format = 33779;
	var RGB_PVRTC_4BPPV1_Format = 35840;
	var RGB_PVRTC_2BPPV1_Format = 35841;
	var RGBA_PVRTC_4BPPV1_Format = 35842;
	var RGBA_PVRTC_2BPPV1_Format = 35843;
	var RGB_ETC1_Format = 36196;
	var RGB_ETC2_Format = 37492;
	var RGBA_ETC2_EAC_Format = 37496;
	var RGBA_ASTC_4x4_Format = 37808;
	var RGBA_ASTC_5x4_Format = 37809;
	var RGBA_ASTC_5x5_Format = 37810;
	var RGBA_ASTC_6x5_Format = 37811;
	var RGBA_ASTC_6x6_Format = 37812;
	var RGBA_ASTC_8x5_Format = 37813;
	var RGBA_ASTC_8x6_Format = 37814;
	var RGBA_ASTC_8x8_Format = 37815;
	var RGBA_ASTC_10x5_Format = 37816;
	var RGBA_ASTC_10x6_Format = 37817;
	var RGBA_ASTC_10x8_Format = 37818;
	var RGBA_ASTC_10x10_Format = 37819;
	var RGBA_ASTC_12x10_Format = 37820;
	var RGBA_ASTC_12x12_Format = 37821;
	var SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
	var SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
	var SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
	var SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
	var SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
	var SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
	var SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
	var SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
	var SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
	var SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
	var SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
	var SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
	var SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
	var SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
	var LoopOnce = 2200;
	var LoopRepeat = 2201;
	var LoopPingPong = 2202;
	var InterpolateDiscrete = 2300;
	var InterpolateLinear = 2301;
	var InterpolateSmooth = 2302;
	var ZeroCurvatureEnding = 2400;
	var ZeroSlopeEnding = 2401;
	var WrapAroundEnding = 2402;
	var TrianglesDrawMode = 0;
	var TriangleStripDrawMode = 1;
	var TriangleFanDrawMode = 2;
	var LinearEncoding = 3000;
	var sRGBEncoding = 3001;
	var GammaEncoding = 3007;
	var RGBEEncoding = 3002;
	var LogLuvEncoding = 3003;
	var RGBM7Encoding = 3004;
	var RGBM16Encoding = 3005;
	var RGBDEncoding = 3006;
	var BasicDepthPacking = 3200;
	var RGBADepthPacking = 3201;
	var TangentSpaceNormalMap = 0;
	var ObjectSpaceNormalMap = 1;
	var ZeroStencilOp = 0;
	var KeepStencilOp = 7680;
	var ReplaceStencilOp = 7681;
	var IncrementStencilOp = 7682;
	var DecrementStencilOp = 7683;
	var IncrementWrapStencilOp = 34055;
	var DecrementWrapStencilOp = 34056;
	var InvertStencilOp = 5386;
	var NeverStencilFunc = 512;
	var LessStencilFunc = 513;
	var EqualStencilFunc = 514;
	var LessEqualStencilFunc = 515;
	var GreaterStencilFunc = 516;
	var NotEqualStencilFunc = 517;
	var GreaterEqualStencilFunc = 518;
	var AlwaysStencilFunc = 519;
	var StaticDrawUsage = 35044;
	var DynamicDrawUsage = 35048;
	var StreamDrawUsage = 35040;
	var StaticReadUsage = 35045;
	var DynamicReadUsage = 35049;
	var StreamReadUsage = 35041;
	var StaticCopyUsage = 35046;
	var DynamicCopyUsage = 35050;
	var StreamCopyUsage = 35042;
	function EventDispatcher() {}
	Object.assign(EventDispatcher.prototype, {
	  addEventListener: function (type, listener) {
	    if (this._listeners === undefined) this._listeners = {};
	    var listeners = this._listeners;
	    if (listeners[type] === undefined) {
	      listeners[type] = [];
	    }
	    if (listeners[type].indexOf(listener) === -1) {
	      listeners[type].push(listener);
	    }
	  },
	  hasEventListener: function (type, listener) {
	    if (this._listeners === undefined) return false;
	    var listeners = this._listeners;
	    return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
	  },
	  removeEventListener: function (type, listener) {
	    if (this._listeners === undefined) return;
	    var listeners = this._listeners;
	    var listenerArray = listeners[type];
	    if (listenerArray !== undefined) {
	      var index = listenerArray.indexOf(listener);
	      if (index !== -1) {
	        listenerArray.splice(index, 1);
	      }
	    }
	  },
	  dispatchEvent: function (event) {
	    if (this._listeners === undefined) return;
	    var listeners = this._listeners;
	    var listenerArray = listeners[event.type];
	    if (listenerArray !== undefined) {
	      event.target = this;
	      var array = listenerArray.slice(0);
	      for (var i = 0, l = array.length; i < l; i++) {
	        array[i].call(this, event);
	      }
	    }
	  }
	});
	var _lut = [];
	for (var i = 0; i < 256; i++) {
	  _lut[i] = (i < 16 ? "0" : "") + i.toString(16);
	}
	var MathUtils = {
	  DEG2RAD: Math.PI / 180,
	  RAD2DEG: 180 / Math.PI,
	  generateUUID: function () {
	    var d0 = Math.random() * 4294967295 | 0;
	    var d1 = Math.random() * 4294967295 | 0;
	    var d2 = Math.random() * 4294967295 | 0;
	    var d3 = Math.random() * 4294967295 | 0;
	    var uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
	    return uuid.toUpperCase();
	  },
	  clamp: function (value, min, max) {
	    return Math.max(min, Math.min(max, value));
	  },
	  euclideanModulo: function (n, m) {
	    return (n % m + m) % m;
	  },
	  mapLinear: function (x, a1, a2, b1, b2) {
	    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
	  },
	  lerp: function (x, y, t) {
	    return (1 - t) * x + t * y;
	  },
	  smoothstep: function (x, min, max) {
	    if (x <= min) return 0;
	    if (x >= max) return 1;
	    x = (x - min) / (max - min);
	    return x * x * (3 - 2 * x);
	  },
	  smootherstep: function (x, min, max) {
	    if (x <= min) return 0;
	    if (x >= max) return 1;
	    x = (x - min) / (max - min);
	    return x * x * x * (x * (x * 6 - 15) + 10);
	  },
	  randInt: function (low, high) {
	    return low + Math.floor(Math.random() * (high - low + 1));
	  },
	  randFloat: function (low, high) {
	    return low + Math.random() * (high - low);
	  },
	  randFloatSpread: function (range) {
	    return range * (0.5 - Math.random());
	  },
	  degToRad: function (degrees) {
	    return degrees * MathUtils.DEG2RAD;
	  },
	  radToDeg: function (radians) {
	    return radians * MathUtils.RAD2DEG;
	  },
	  isPowerOfTwo: function (value) {
	    return (value & value - 1) === 0 && value !== 0;
	  },
	  ceilPowerOfTwo: function (value) {
	    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
	  },
	  floorPowerOfTwo: function (value) {
	    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
	  },
	  setQuaternionFromProperEuler: function (q, a, b, c, order) {
	    var cos = Math.cos;
	    var sin = Math.sin;
	    var c2 = cos(b / 2);
	    var s2 = sin(b / 2);
	    var c13 = cos((a + c) / 2);
	    var s13 = sin((a + c) / 2);
	    var c1_3 = cos((a - c) / 2);
	    var s1_3 = sin((a - c) / 2);
	    var c3_1 = cos((c - a) / 2);
	    var s3_1 = sin((c - a) / 2);
	    if (order === "XYX") {
	      q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
	    } else if (order === "YZY") {
	      q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
	    } else if (order === "ZXZ") {
	      q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
	    } else if (order === "XZX") {
	      q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
	    } else if (order === "YXY") {
	      q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
	    } else if (order === "ZYZ") {
	      q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
	    } else {
	      console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order.");
	    }
	  }
	};
	function Vector2(x, y) {
	  this.x = x || 0;
	  this.y = y || 0;
	}
	Object.defineProperties(Vector2.prototype, {
	  "width": {
	    get: function () {
	      return this.x;
	    },
	    set: function (value) {
	      this.x = value;
	    }
	  },
	  "height": {
	    get: function () {
	      return this.y;
	    },
	    set: function (value) {
	      this.y = value;
	    }
	  }
	});
	Object.assign(Vector2.prototype, {
	  isVector2: true,
	  set: function (x, y) {
	    this.x = x;
	    this.y = y;
	    return this;
	  },
	  setScalar: function (scalar) {
	    this.x = scalar;
	    this.y = scalar;
	    return this;
	  },
	  setX: function (x) {
	    this.x = x;
	    return this;
	  },
	  setY: function (y) {
	    this.y = y;
	    return this;
	  },
	  setComponent: function (index, value) {
	    switch (index) {
	      case 0:
	        this.x = value;
	        break;
	      case 1:
	        this.y = value;
	        break;
	      default:
	        throw new Error("index is out of range: " + index);
	    }
	    return this;
	  },
	  getComponent: function (index) {
	    switch (index) {
	      case 0:
	        return this.x;
	      case 1:
	        return this.y;
	      default:
	        throw new Error("index is out of range: " + index);
	    }
	  },
	  clone: function () {
	    return new this.constructor(this.x, this.y);
	  },
	  copy: function (v) {
	    this.x = v.x;
	    this.y = v.y;
	    return this;
	  },
	  add: function (v, w) {
	    if (w !== undefined) {
	      console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
	      return this.addVectors(v, w);
	    }
	    this.x += v.x;
	    this.y += v.y;
	    return this;
	  },
	  addScalar: function (s) {
	    this.x += s;
	    this.y += s;
	    return this;
	  },
	  addVectors: function (a, b) {
	    this.x = a.x + b.x;
	    this.y = a.y + b.y;
	    return this;
	  },
	  addScaledVector: function (v, s) {
	    this.x += v.x * s;
	    this.y += v.y * s;
	    return this;
	  },
	  sub: function (v, w) {
	    if (w !== undefined) {
	      console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
	      return this.subVectors(v, w);
	    }
	    this.x -= v.x;
	    this.y -= v.y;
	    return this;
	  },
	  subScalar: function (s) {
	    this.x -= s;
	    this.y -= s;
	    return this;
	  },
	  subVectors: function (a, b) {
	    this.x = a.x - b.x;
	    this.y = a.y - b.y;
	    return this;
	  },
	  multiply: function (v) {
	    this.x *= v.x;
	    this.y *= v.y;
	    return this;
	  },
	  multiplyScalar: function (scalar) {
	    this.x *= scalar;
	    this.y *= scalar;
	    return this;
	  },
	  divide: function (v) {
	    this.x /= v.x;
	    this.y /= v.y;
	    return this;
	  },
	  divideScalar: function (scalar) {
	    return this.multiplyScalar(1 / scalar);
	  },
	  applyMatrix3: function (m) {
	    var x = this.x, y = this.y;
	    var e = m.elements;
	    this.x = e[0] * x + e[3] * y + e[6];
	    this.y = e[1] * x + e[4] * y + e[7];
	    return this;
	  },
	  min: function (v) {
	    this.x = Math.min(this.x, v.x);
	    this.y = Math.min(this.y, v.y);
	    return this;
	  },
	  max: function (v) {
	    this.x = Math.max(this.x, v.x);
	    this.y = Math.max(this.y, v.y);
	    return this;
	  },
	  clamp: function (min, max) {
	    this.x = Math.max(min.x, Math.min(max.x, this.x));
	    this.y = Math.max(min.y, Math.min(max.y, this.y));
	    return this;
	  },
	  clampScalar: function (minVal, maxVal) {
	    this.x = Math.max(minVal, Math.min(maxVal, this.x));
	    this.y = Math.max(minVal, Math.min(maxVal, this.y));
	    return this;
	  },
	  clampLength: function (min, max) {
	    var length = this.length();
	    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
	  },
	  floor: function () {
	    this.x = Math.floor(this.x);
	    this.y = Math.floor(this.y);
	    return this;
	  },
	  ceil: function () {
	    this.x = Math.ceil(this.x);
	    this.y = Math.ceil(this.y);
	    return this;
	  },
	  round: function () {
	    this.x = Math.round(this.x);
	    this.y = Math.round(this.y);
	    return this;
	  },
	  roundToZero: function () {
	    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
	    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
	    return this;
	  },
	  negate: function () {
	    this.x = -this.x;
	    this.y = -this.y;
	    return this;
	  },
	  dot: function (v) {
	    return this.x * v.x + this.y * v.y;
	  },
	  cross: function (v) {
	    return this.x * v.y - this.y * v.x;
	  },
	  lengthSq: function () {
	    return this.x * this.x + this.y * this.y;
	  },
	  length: function () {
	    return Math.sqrt(this.x * this.x + this.y * this.y);
	  },
	  manhattanLength: function () {
	    return Math.abs(this.x) + Math.abs(this.y);
	  },
	  normalize: function () {
	    return this.divideScalar(this.length() || 1);
	  },
	  angle: function () {
	    var angle = Math.atan2(-this.y, -this.x) + Math.PI;
	    return angle;
	  },
	  distanceTo: function (v) {
	    return Math.sqrt(this.distanceToSquared(v));
	  },
	  distanceToSquared: function (v) {
	    var dx = this.x - v.x, dy = this.y - v.y;
	    return dx * dx + dy * dy;
	  },
	  manhattanDistanceTo: function (v) {
	    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
	  },
	  setLength: function (length) {
	    return this.normalize().multiplyScalar(length);
	  },
	  lerp: function (v, alpha) {
	    this.x += (v.x - this.x) * alpha;
	    this.y += (v.y - this.y) * alpha;
	    return this;
	  },
	  lerpVectors: function (v1, v2, alpha) {
	    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
	  },
	  equals: function (v) {
	    return v.x === this.x && v.y === this.y;
	  },
	  fromArray: function (array, offset) {
	    if (offset === undefined) offset = 0;
	    this.x = array[offset];
	    this.y = array[offset + 1];
	    return this;
	  },
	  toArray: function (array, offset) {
	    if (array === undefined) array = [];
	    if (offset === undefined) offset = 0;
	    array[offset] = this.x;
	    array[offset + 1] = this.y;
	    return array;
	  },
	  fromBufferAttribute: function (attribute, index, offset) {
	    if (offset !== undefined) {
	      console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute().");
	    }
	    this.x = attribute.getX(index);
	    this.y = attribute.getY(index);
	    return this;
	  },
	  rotateAround: function (center, angle) {
	    var c = Math.cos(angle), s = Math.sin(angle);
	    var x = this.x - center.x;
	    var y = this.y - center.y;
	    this.x = x * c - y * s + center.x;
	    this.y = x * s + y * c + center.y;
	    return this;
	  }
	});
	function Matrix3() {
	  this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
	  if (arguments.length > 0) {
	    console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.");
	  }
	}
	Object.assign(Matrix3.prototype, {
	  isMatrix3: true,
	  set: function (n11, n12, n13, n21, n22, n23, n31, n32, n33) {
	    var te = this.elements;
	    te[0] = n11;
	    te[1] = n21;
	    te[2] = n31;
	    te[3] = n12;
	    te[4] = n22;
	    te[5] = n32;
	    te[6] = n13;
	    te[7] = n23;
	    te[8] = n33;
	    return this;
	  },
	  identity: function () {
	    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
	    return this;
	  },
	  clone: function () {
	    return new this.constructor().fromArray(this.elements);
	  },
	  copy: function (m) {
	    var te = this.elements;
	    var me = m.elements;
	    te[0] = me[0];
	    te[1] = me[1];
	    te[2] = me[2];
	    te[3] = me[3];
	    te[4] = me[4];
	    te[5] = me[5];
	    te[6] = me[6];
	    te[7] = me[7];
	    te[8] = me[8];
	    return this;
	  },
	  extractBasis: function (xAxis, yAxis, zAxis) {
	    xAxis.setFromMatrix3Column(this, 0);
	    yAxis.setFromMatrix3Column(this, 1);
	    zAxis.setFromMatrix3Column(this, 2);
	    return this;
	  },
	  setFromMatrix4: function (m) {
	    var me = m.elements;
	    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
	    return this;
	  },
	  multiply: function (m) {
	    return this.multiplyMatrices(this, m);
	  },
	  premultiply: function (m) {
	    return this.multiplyMatrices(m, this);
	  },
	  multiplyMatrices: function (a, b) {
	    var ae = a.elements;
	    var be = b.elements;
	    var te = this.elements;
	    var a11 = ae[0], a12 = ae[3], a13 = ae[6];
	    var a21 = ae[1], a22 = ae[4], a23 = ae[7];
	    var a31 = ae[2], a32 = ae[5], a33 = ae[8];
	    var b11 = be[0], b12 = be[3], b13 = be[6];
	    var b21 = be[1], b22 = be[4], b23 = be[7];
	    var b31 = be[2], b32 = be[5], b33 = be[8];
	    te[0] = a11 * b11 + a12 * b21 + a13 * b31;
	    te[3] = a11 * b12 + a12 * b22 + a13 * b32;
	    te[6] = a11 * b13 + a12 * b23 + a13 * b33;
	    te[1] = a21 * b11 + a22 * b21 + a23 * b31;
	    te[4] = a21 * b12 + a22 * b22 + a23 * b32;
	    te[7] = a21 * b13 + a22 * b23 + a23 * b33;
	    te[2] = a31 * b11 + a32 * b21 + a33 * b31;
	    te[5] = a31 * b12 + a32 * b22 + a33 * b32;
	    te[8] = a31 * b13 + a32 * b23 + a33 * b33;
	    return this;
	  },
	  multiplyScalar: function (s) {
	    var te = this.elements;
	    te[0] *= s;
	    te[3] *= s;
	    te[6] *= s;
	    te[1] *= s;
	    te[4] *= s;
	    te[7] *= s;
	    te[2] *= s;
	    te[5] *= s;
	    te[8] *= s;
	    return this;
	  },
	  determinant: function () {
	    var te = this.elements;
	    var a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
	    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
	  },
	  getInverse: function (matrix, throwOnDegenerate) {
	    if (matrix && matrix.isMatrix4) {
	      console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
	    }
	    var me = matrix.elements, te = this.elements, n11 = me[0], n21 = me[1], n31 = me[2], n12 = me[3], n22 = me[4], n32 = me[5], n13 = me[6], n23 = me[7], n33 = me[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
	    if (det === 0) {
	      var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
	      if (throwOnDegenerate === true) {
	        throw new Error(msg);
	      } else {
	        console.warn(msg);
	      }
	      return this.identity();
	    }
	    var detInv = 1 / det;
	    te[0] = t11 * detInv;
	    te[1] = (n31 * n23 - n33 * n21) * detInv;
	    te[2] = (n32 * n21 - n31 * n22) * detInv;
	    te[3] = t12 * detInv;
	    te[4] = (n33 * n11 - n31 * n13) * detInv;
	    te[5] = (n31 * n12 - n32 * n11) * detInv;
	    te[6] = t13 * detInv;
	    te[7] = (n21 * n13 - n23 * n11) * detInv;
	    te[8] = (n22 * n11 - n21 * n12) * detInv;
	    return this;
	  },
	  transpose: function () {
	    var tmp, m = this.elements;
	    tmp = m[1];
	    m[1] = m[3];
	    m[3] = tmp;
	    tmp = m[2];
	    m[2] = m[6];
	    m[6] = tmp;
	    tmp = m[5];
	    m[5] = m[7];
	    m[7] = tmp;
	    return this;
	  },
	  getNormalMatrix: function (matrix4) {
	    return this.setFromMatrix4(matrix4).getInverse(this).transpose();
	  },
	  transposeIntoArray: function (r) {
	    var m = this.elements;
	    r[0] = m[0];
	    r[1] = m[3];
	    r[2] = m[6];
	    r[3] = m[1];
	    r[4] = m[4];
	    r[5] = m[7];
	    r[6] = m[2];
	    r[7] = m[5];
	    r[8] = m[8];
	    return this;
	  },
	  setUvTransform: function (tx, ty, sx, sy, rotation, cx, cy) {
	    var c = Math.cos(rotation);
	    var s = Math.sin(rotation);
	    this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
	  },
	  scale: function (sx, sy) {
	    var te = this.elements;
	    te[0] *= sx;
	    te[3] *= sx;
	    te[6] *= sx;
	    te[1] *= sy;
	    te[4] *= sy;
	    te[7] *= sy;
	    return this;
	  },
	  rotate: function (theta) {
	    var c = Math.cos(theta);
	    var s = Math.sin(theta);
	    var te = this.elements;
	    var a11 = te[0], a12 = te[3], a13 = te[6];
	    var a21 = te[1], a22 = te[4], a23 = te[7];
	    te[0] = c * a11 + s * a21;
	    te[3] = c * a12 + s * a22;
	    te[6] = c * a13 + s * a23;
	    te[1] = -s * a11 + c * a21;
	    te[4] = -s * a12 + c * a22;
	    te[7] = -s * a13 + c * a23;
	    return this;
	  },
	  translate: function (tx, ty) {
	    var te = this.elements;
	    te[0] += tx * te[2];
	    te[3] += tx * te[5];
	    te[6] += tx * te[8];
	    te[1] += ty * te[2];
	    te[4] += ty * te[5];
	    te[7] += ty * te[8];
	    return this;
	  },
	  equals: function (matrix) {
	    var te = this.elements;
	    var me = matrix.elements;
	    for (var i = 0; i < 9; i++) {
	      if (te[i] !== me[i]) return false;
	    }
	    return true;
	  },
	  fromArray: function (array, offset) {
	    if (offset === undefined) offset = 0;
	    for (var i = 0; i < 9; i++) {
	      this.elements[i] = array[i + offset];
	    }
	    return this;
	  },
	  toArray: function (array, offset) {
	    if (array === undefined) array = [];
	    if (offset === undefined) offset = 0;
	    var te = this.elements;
	    array[offset] = te[0];
	    array[offset + 1] = te[1];
	    array[offset + 2] = te[2];
	    array[offset + 3] = te[3];
	    array[offset + 4] = te[4];
	    array[offset + 5] = te[5];
	    array[offset + 6] = te[6];
	    array[offset + 7] = te[7];
	    array[offset + 8] = te[8];
	    return array;
	  }
	});
	var _canvas;
	var ImageUtils = {
	  getDataURL: function (image) {
	    var canvas;
	    if (typeof HTMLCanvasElement == "undefined") {
	      return image.src;
	    } else if (image instanceof HTMLCanvasElement) {
	      canvas = image;
	    } else {
	      if (_canvas === undefined) _canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
	      _canvas.width = image.width;
	      _canvas.height = image.height;
	      var context = _canvas.getContext("2d");
	      if (image instanceof ImageData) {
	        context.putImageData(image, 0, 0);
	      } else {
	        context.drawImage(image, 0, 0, image.width, image.height);
	      }
	      canvas = _canvas;
	    }
	    if (canvas.width > 2048 || canvas.height > 2048) {
	      return canvas.toDataURL("image/jpeg", 0.6);
	    } else {
	      return canvas.toDataURL("image/png");
	    }
	  }
	};
	var textureId = 0;
	function Texture(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
	  Object.defineProperty(this, "id", {
	    value: textureId++
	  });
	  this.uuid = MathUtils.generateUUID();
	  this.name = "";
	  this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
	  this.mipmaps = [];
	  this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;
	  this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
	  this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;
	  this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
	  this.minFilter = minFilter !== undefined ? minFilter : LinearMipmapLinearFilter;
	  this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
	  this.format = format !== undefined ? format : RGBAFormat;
	  this.internalFormat = null;
	  this.type = type !== undefined ? type : UnsignedByteType;
	  this.offset = new Vector2(0, 0);
	  this.repeat = new Vector2(1, 1);
	  this.center = new Vector2(0, 0);
	  this.rotation = 0;
	  this.matrixAutoUpdate = true;
	  this.matrix = new Matrix3();
	  this.generateMipmaps = true;
	  this.premultiplyAlpha = false;
	  this.flipY = true;
	  this.unpackAlignment = 4;
	  this.encoding = encoding !== undefined ? encoding : LinearEncoding;
	  this.version = 0;
	  this.onUpdate = null;
	}
	Texture.DEFAULT_IMAGE = undefined;
	Texture.DEFAULT_MAPPING = UVMapping;
	Texture.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
	  constructor: Texture,
	  isTexture: true,
	  updateMatrix: function () {
	    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
	  },
	  clone: function () {
	    return new this.constructor().copy(this);
	  },
	  copy: function (source) {
	    this.name = source.name;
	    this.image = source.image;
	    this.mipmaps = source.mipmaps.slice(0);
	    this.mapping = source.mapping;
	    this.wrapS = source.wrapS;
	    this.wrapT = source.wrapT;
	    this.magFilter = source.magFilter;
	    this.minFilter = source.minFilter;
	    this.anisotropy = source.anisotropy;
	    this.format = source.format;
	    this.internalFormat = source.internalFormat;
	    this.type = source.type;
	    this.offset.copy(source.offset);
	    this.repeat.copy(source.repeat);
	    this.center.copy(source.center);
	    this.rotation = source.rotation;
	    this.matrixAutoUpdate = source.matrixAutoUpdate;
	    this.matrix.copy(source.matrix);
	    this.generateMipmaps = source.generateMipmaps;
	    this.premultiplyAlpha = source.premultiplyAlpha;
	    this.flipY = source.flipY;
	    this.unpackAlignment = source.unpackAlignment;
	    this.encoding = source.encoding;
	    return this;
	  },
	  toJSON: function (meta) {
	    var isRootObject = meta === undefined || typeof meta === "string";
	    if (!isRootObject && meta.textures[this.uuid] !== undefined) {
	      return meta.textures[this.uuid];
	    }
	    var output = {
	      metadata: {
	        version: 4.5,
	        type: "Texture",
	        generator: "Texture.toJSON"
	      },
	      uuid: this.uuid,
	      name: this.name,
	      mapping: this.mapping,
	      repeat: [this.repeat.x, this.repeat.y],
	      offset: [this.offset.x, this.offset.y],
	      center: [this.center.x, this.center.y],
	      rotation: this.rotation,
	      wrap: [this.wrapS, this.wrapT],
	      format: this.format,
	      type: this.type,
	      encoding: this.encoding,
	      minFilter: this.minFilter,
	      magFilter: this.magFilter,
	      anisotropy: this.anisotropy,
	      flipY: this.flipY,
	      premultiplyAlpha: this.premultiplyAlpha,
	      unpackAlignment: this.unpackAlignment
	    };
	    if (this.image !== undefined) {
	      var image = this.image;
	      if (image.uuid === undefined) {
	        image.uuid = MathUtils.generateUUID();
	      }
	      if (!isRootObject && meta.images[image.uuid] === undefined) {
	        var url;
	        if (Array.isArray(image)) {
	          url = [];
	          for (var i = 0, l = image.length; i < l; i++) {
	            url.push(ImageUtils.getDataURL(image[i]));
	          }
	        } else {
	          url = ImageUtils.getDataURL(image);
	        }
	        meta.images[image.uuid] = {
	          uuid: image.uuid,
	          url: url
	        };
	      }
	      output.image = image.uuid;
	    }
	    if (!isRootObject) {
	      meta.textures[this.uuid] = output;
	    }
	    return output;
	  },
	  dispose: function () {
	    this.dispatchEvent({
	      type: "dispose"
	    });
	  },
	  transformUv: function (uv) {
	    if (this.mapping !== UVMapping) return uv;
	    uv.applyMatrix3(this.matrix);
	    if (uv.x < 0 || uv.x > 1) {
	      switch (this.wrapS) {
	        case RepeatWrapping:
	          uv.x = uv.x - Math.floor(uv.x);
	          break;
	        case ClampToEdgeWrapping:
	          uv.x = uv.x < 0 ? 0 : 1;
	          break;
	        case MirroredRepeatWrapping:
	          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
	            uv.x = Math.ceil(uv.x) - uv.x;
	          } else {
	            uv.x = uv.x - Math.floor(uv.x);
	          }
	          break;
	      }
	    }
	    if (uv.y < 0 || uv.y > 1) {
	      switch (this.wrapT) {
	        case RepeatWrapping:
	          uv.y = uv.y - Math.floor(uv.y);
	          break;
	        case ClampToEdgeWrapping:
	          uv.y = uv.y < 0 ? 0 : 1;
	          break;
	        case MirroredRepeatWrapping:
	          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
	            uv.y = Math.ceil(uv.y) - uv.y;
	          } else {
	            uv.y = uv.y - Math.floor(uv.y);
	          }
	          break;
	      }
	    }
	    if (this.flipY) {
	      uv.y = 1 - uv.y;
	    }
	    return uv;
	  }
	});
	Object.defineProperty(Texture.prototype, "needsUpdate", {
	  set: function (value) {
	    if (value === true) this.version++;
	  }
	});
	function Vector4(x, y, z, w) {
	  this.x = x || 0;
	  this.y = y || 0;
	  this.z = z || 0;
	  this.w = w !== undefined ? w : 1;
	}
	Object.defineProperties(Vector4.prototype, {
	  "width": {
	    get: function () {
	      return this.z;
	    },
	    set: function (value) {
	      this.z = value;
	    }
	  },
	  "height": {
	    get: function () {
	      return this.w;
	    },
	    set: function (value) {
	      this.w = value;
	    }
	  }
	});
	Object.assign(Vector4.prototype, {
	  isVector4: true,
	  set: function (x, y, z, w) {
	    this.x = x;
	    this.y = y;
	    this.z = z;
	    this.w = w;
	    return this;
	  },
	  setScalar: function (scalar) {
	    this.x = scalar;
	    this.y = scalar;
	    this.z = scalar;
	    this.w = scalar;
	    return this;
	  },
	  setX: function (x) {
	    this.x = x;
	    return this;
	  },
	  setY: function (y) {
	    this.y = y;
	    return this;
	  },
	  setZ: function (z) {
	    this.z = z;
	    return this;
	  },
	  setW: function (w) {
	    this.w = w;
	    return this;
	  },
	  setComponent: function (index, value) {
	    switch (index) {
	      case 0:
	        this.x = value;
	        break;
	      case 1:
	        this.y = value;
	        break;
	      case 2:
	        this.z = value;
	        break;
	      case 3:
	        this.w = value;
	        break;
	      default:
	        throw new Error("index is out of range: " + index);
	    }
	    return this;
	  },
	  getComponent: function (index) {
	    switch (index) {
	      case 0:
	        return this.x;
	      case 1:
	        return this.y;
	      case 2:
	        return this.z;
	      case 3:
	        return this.w;
	      default:
	        throw new Error("index is out of range: " + index);
	    }
	  },
	  clone: function () {
	    return new this.constructor(this.x, this.y, this.z, this.w);
	  },
	  copy: function (v) {
	    this.x = v.x;
	    this.y = v.y;
	    this.z = v.z;
	    this.w = v.w !== undefined ? v.w : 1;
	    return this;
	  },
	  add: function (v, w) {
	    if (w !== undefined) {
	      console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
	      return this.addVectors(v, w);
	    }
	    this.x += v.x;
	    this.y += v.y;
	    this.z += v.z;
	    this.w += v.w;
	    return this;
	  },
	  addScalar: function (s) {
	    this.x += s;
	    this.y += s;
	    this.z += s;
	    this.w += s;
	    return this;
	  },
	  addVectors: function (a, b) {
	    this.x = a.x + b.x;
	    this.y = a.y + b.y;
	    this.z = a.z + b.z;
	    this.w = a.w + b.w;
	    return this;
	  },
	  addScaledVector: function (v, s) {
	    this.x += v.x * s;
	    this.y += v.y * s;
	    this.z += v.z * s;
	    this.w += v.w * s;
	    return this;
	  },
	  sub: function (v, w) {
	    if (w !== undefined) {
	      console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
	      return this.subVectors(v, w);
	    }
	    this.x -= v.x;
	    this.y -= v.y;
	    this.z -= v.z;
	    this.w -= v.w;
	    return this;
	  },
	  subScalar: function (s) {
	    this.x -= s;
	    this.y -= s;
	    this.z -= s;
	    this.w -= s;
	    return this;
	  },
	  subVectors: function (a, b) {
	    this.x = a.x - b.x;
	    this.y = a.y - b.y;
	    this.z = a.z - b.z;
	    this.w = a.w - b.w;
	    return this;
	  },
	  multiplyScalar: function (scalar) {
	    this.x *= scalar;
	    this.y *= scalar;
	    this.z *= scalar;
	    this.w *= scalar;
	    return this;
	  },
	  applyMatrix4: function (m) {
	    var x = this.x, y = this.y, z = this.z, w = this.w;
	    var e = m.elements;
	    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
	    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
	    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
	    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
	    return this;
	  },
	  divideScalar: function (scalar) {
	    return this.multiplyScalar(1 / scalar);
	  },
	  setAxisAngleFromQuaternion: function (q) {
	    this.w = 2 * Math.acos(q.w);
	    var s = Math.sqrt(1 - q.w * q.w);
	    if (s < 0.0001) {
	      this.x = 1;
	      this.y = 0;
	      this.z = 0;
	    } else {
	      this.x = q.x / s;
	      this.y = q.y / s;
	      this.z = q.z / s;
	    }
	    return this;
	  },
	  setAxisAngleFromRotationMatrix: function (m) {
	    var angle, x, y, z, epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];
	    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
	      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
	        this.set(1, 0, 0, 0);
	        return this;
	      }
	      angle = Math.PI;
	      var xx = (m11 + 1) / 2;
	      var yy = (m22 + 1) / 2;
	      var zz = (m33 + 1) / 2;
	      var xy = (m12 + m21) / 4;
	      var xz = (m13 + m31) / 4;
	      var yz = (m23 + m32) / 4;
	      if (xx > yy && xx > zz) {
	        if (xx < epsilon) {
	          x = 0;
	          y = 0.707106781;
	          z = 0.707106781;
	        } else {
	          x = Math.sqrt(xx);
	          y = xy / x;
	          z = xz / x;
	        }
	      } else if (yy > zz) {
	        if (yy < epsilon) {
	          x = 0.707106781;
	          y = 0;
	          z = 0.707106781;
	        } else {
	          y = Math.sqrt(yy);
	          x = xy / y;
	          z = yz / y;
	        }
	      } else {
	        if (zz < epsilon) {
	          x = 0.707106781;
	          y = 0.707106781;
	          z = 0;
	        } else {
	          z = Math.sqrt(zz);
	          x = xz / z;
	          y = yz / z;
	        }
	      }
	      this.set(x, y, z, angle);
	      return this;
	    }
	    var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
	    if (Math.abs(s) < 0.001) s = 1;
	    this.x = (m32 - m23) / s;
	    this.y = (m13 - m31) / s;
	    this.z = (m21 - m12) / s;
	    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
	    return this;
	  },
	  min: function (v) {
	    this.x = Math.min(this.x, v.x);
	    this.y = Math.min(this.y, v.y);
	    this.z = Math.min(this.z, v.z);
	    this.w = Math.min(this.w, v.w);
	    return this;
	  },
	  max: function (v) {
	    this.x = Math.max(this.x, v.x);
	    this.y = Math.max(this.y, v.y);
	    this.z = Math.max(this.z, v.z);
	    this.w = Math.max(this.w, v.w);
	    return this;
	  },
	  clamp: function (min, max) {
	    this.x = Math.max(min.x, Math.min(max.x, this.x));
	    this.y = Math.max(min.y, Math.min(max.y, this.y));
	    this.z = Math.max(min.z, Math.min(max.z, this.z));
	    this.w = Math.max(min.w, Math.min(max.w, this.w));
	    return this;
	  },
	  clampScalar: function (minVal, maxVal) {
	    this.x = Math.max(minVal, Math.min(maxVal, this.x));
	    this.y = Math.max(minVal, Math.min(maxVal, this.y));
	    this.z = Math.max(minVal, Math.min(maxVal, this.z));
	    this.w = Math.max(minVal, Math.min(maxVal, this.w));
	    return this;
	  },
	  clampLength: function (min, max) {
	    var length = this.length();
	    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
	  },
	  floor: function () {
	    this.x = Math.floor(this.x);
	    this.y = Math.floor(this.y);
	    this.z = Math.floor(this.z);
	    this.w = Math.floor(this.w);
	    return this;
	  },
	  ceil: function () {
	    this.x = Math.ceil(this.x);
	    this.y = Math.ceil(this.y);
	    this.z = Math.ceil(this.z);
	    this.w = Math.ceil(this.w);
	    return this;
	  },
	  round: function () {
	    this.x = Math.round(this.x);
	    this.y = Math.round(this.y);
	    this.z = Math.round(this.z);
	    this.w = Math.round(this.w);
	    return this;
	  },
	  roundToZero: function () {
	    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
	    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
	    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
	    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);
	    return this;
	  },
	  negate: function () {
	    this.x = -this.x;
	    this.y = -this.y;
	    this.z = -this.z;
	    this.w = -this.w;
	    return this;
	  },
	  dot: function (v) {
	    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
	  },
	  lengthSq: function () {
	    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	  },
	  length: function () {
	    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
	  },
	  manhattanLength: function () {
	    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
	  },
	  normalize: function () {
	    return this.divideScalar(this.length() || 1);
	  },
	  setLength: function (length) {
	    return this.normalize().multiplyScalar(length);
	  },
	  lerp: function (v, alpha) {
	    this.x += (v.x - this.x) * alpha;
	    this.y += (v.y - this.y) * alpha;
	    this.z += (v.z - this.z) * alpha;
	    this.w += (v.w - this.w) * alpha;
	    return this;
	  },
	  lerpVectors: function (v1, v2, alpha) {
	    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
	  },
	  equals: function (v) {
	    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
	  },
	  fromArray: function (array, offset) {
	    if (offset === undefined) offset = 0;
	    this.x = array[offset];
	    this.y = array[offset + 1];
	    this.z = array[offset + 2];
	    this.w = array[offset + 3];
	    return this;
	  },
	  toArray: function (array, offset) {
	    if (array === undefined) array = [];
	    if (offset === undefined) offset = 0;
	    array[offset] = this.x;
	    array[offset + 1] = this.y;
	    array[offset + 2] = this.z;
	    array[offset + 3] = this.w;
	    return array;
	  },
	  fromBufferAttribute: function (attribute, index, offset) {
	    if (offset !== undefined) {
	      console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute().");
	    }
	    this.x = attribute.getX(index);
	    this.y = attribute.getY(index);
	    this.z = attribute.getZ(index);
	    this.w = attribute.getW(index);
	    return this;
	  }
	});
	function WebGLRenderTarget(width, height, options) {
	  this.width = width;
	  this.height = height;
	  this.scissor = new Vector4(0, 0, width, height);
	  this.scissorTest = false;
	  this.viewport = new Vector4(0, 0, width, height);
	  options = options || ({});
	  this.texture = new Texture(undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);
	  this.texture.image = {};
	  this.texture.image.width = width;
	  this.texture.image.height = height;
	  this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
	  this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
	  this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
	  this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
	  this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
	}
	WebGLRenderTarget.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
	  constructor: WebGLRenderTarget,
	  isWebGLRenderTarget: true,
	  setSize: function (width, height) {
	    if (this.width !== width || this.height !== height) {
	      this.width = width;
	      this.height = height;
	      this.texture.image.width = width;
	      this.texture.image.height = height;
	      this.dispose();
	    }
	    this.viewport.set(0, 0, width, height);
	    this.scissor.set(0, 0, width, height);
	  },
	  clone: function () {
	    return new this.constructor().copy(this);
	  },
	  copy: function (source) {
	    this.width = source.width;
	    this.height = source.height;
	    this.viewport.copy(source.viewport);
	    this.texture = source.texture.clone();
	    this.depthBuffer = source.depthBuffer;
	    this.stencilBuffer = source.stencilBuffer;
	    this.depthTexture = source.depthTexture;
	    return this;
	  },
	  dispose: function () {
	    this.dispatchEvent({
	      type: "dispose"
	    });
	  }
	});
	function WebGLMultisampleRenderTarget(width, height, options) {
	  WebGLRenderTarget.call(this, width, height, options);
	  this.samples = 4;
	}
	WebGLMultisampleRenderTarget.prototype = Object.assign(Object.create(WebGLRenderTarget.prototype), {
	  constructor: WebGLMultisampleRenderTarget,
	  isWebGLMultisampleRenderTarget: true,
	  copy: function (source) {
	    WebGLRenderTarget.prototype.copy.call(this, source);
	    this.samples = source.samples;
	    return this;
	  }
	});
	function Quaternion(x, y, z, w) {
	  this._x = x || 0;
	  this._y = y || 0;
	  this._z = z || 0;
	  this._w = w !== undefined ? w : 1;
	}
	Object.assign(Quaternion, {
	  slerp: function (qa, qb, qm, t) {
	    return qm.copy(qa).slerp(qb, t);
	  },
	  slerpFlat: function (dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
	    var x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3], x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
	    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
	      var s = 1 - t, cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;
	      if (sqrSin > Number.EPSILON) {
	        var sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);
	        s = Math.sin(s * len) / sin;
	        t = Math.sin(t * len) / sin;
	      }
	      var tDir = t * dir;
	      x0 = x0 * s + x1 * tDir;
	      y0 = y0 * s + y1 * tDir;
	      z0 = z0 * s + z1 * tDir;
	      w0 = w0 * s + w1 * tDir;
	      if (s === 1 - t) {
	        var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
	        x0 *= f;
	        y0 *= f;
	        z0 *= f;
	        w0 *= f;
	      }
	    }
	    dst[dstOffset] = x0;
	    dst[dstOffset + 1] = y0;
	    dst[dstOffset + 2] = z0;
	    dst[dstOffset + 3] = w0;
	  }
	});
	Object.defineProperties(Quaternion.prototype, {
	  x: {
	    get: function () {
	      return this._x;
	    },
	    set: function (value) {
	      this._x = value;
	      this._onChangeCallback();
	    }
	  },
	  y: {
	    get: function () {
	      return this._y;
	    },
	    set: function (value) {
	      this._y = value;
	      this._onChangeCallback();
	    }
	  },
	  z: {
	    get: function () {
	      return this._z;
	    },
	    set: function (value) {
	      this._z = value;
	      this._onChangeCallback();
	    }
	  },
	  w: {
	    get: function () {
	      return this._w;
	    },
	    set: function (value) {
	      this._w = value;
	      this._onChangeCallback();
	    }
	  }
	});
	Object.assign(Quaternion.prototype, {
	  isQuaternion: true,
	  set: function (x, y, z, w) {
	    this._x = x;
	    this._y = y;
	    this._z = z;
	    this._w = w;
	    this._onChangeCallback();
	    return this;
	  },
	  clone: function () {
	    return new this.constructor(this._x, this._y, this._z, this._w);
	  },
	  copy: function (quaternion) {
	    this._x = quaternion.x;
	    this._y = quaternion.y;
	    this._z = quaternion.z;
	    this._w = quaternion.w;
	    this._onChangeCallback();
	    return this;
	  },
	  setFromEuler: function (euler, update) {
	    if (!(euler && euler.isEuler)) {
	      throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
	    }
	    var x = euler._x, y = euler._y, z = euler._z, order = euler.order;
	    var cos = Math.cos;
	    var sin = Math.sin;
	    var c1 = cos(x / 2);
	    var c2 = cos(y / 2);
	    var c3 = cos(z / 2);
	    var s1 = sin(x / 2);
	    var s2 = sin(y / 2);
	    var s3 = sin(z / 2);
	    if (order === "XYZ") {
	      this._x = s1 * c2 * c3 + c1 * s2 * s3;
	      this._y = c1 * s2 * c3 - s1 * c2 * s3;
	      this._z = c1 * c2 * s3 + s1 * s2 * c3;
	      this._w = c1 * c2 * c3 - s1 * s2 * s3;
	    } else if (order === "YXZ") {
	      this._x = s1 * c2 * c3 + c1 * s2 * s3;
	      this._y = c1 * s2 * c3 - s1 * c2 * s3;
	      this._z = c1 * c2 * s3 - s1 * s2 * c3;
	      this._w = c1 * c2 * c3 + s1 * s2 * s3;
	    } else if (order === "ZXY") {
	      this._x = s1 * c2 * c3 - c1 * s2 * s3;
	      this._y = c1 * s2 * c3 + s1 * c2 * s3;
	      this._z = c1 * c2 * s3 + s1 * s2 * c3;
	      this._w = c1 * c2 * c3 - s1 * s2 * s3;
	    } else if (order === "ZYX") {
	      this._x = s1 * c2 * c3 - c1 * s2 * s3;
	      this._y = c1 * s2 * c3 + s1 * c2 * s3;
	      this._z = c1 * c2 * s3 - s1 * s2 * c3;
	      this._w = c1 * c2 * c3 + s1 * s2 * s3;
	    } else if (order === "YZX") {
	      this._x = s1 * c2 * c3 + c1 * s2 * s3;
	      this._y = c1 * s2 * c3 + s1 * c2 * s3;
	      this._z = c1 * c2 * s3 - s1 * s2 * c3;
	      this._w = c1 * c2 * c3 - s1 * s2 * s3;
	    } else if (order === "XZY") {
	      this._x = s1 * c2 * c3 - c1 * s2 * s3;
	      this._y = c1 * s2 * c3 - s1 * c2 * s3;
	      this._z = c1 * c2 * s3 + s1 * s2 * c3;
	      this._w = c1 * c2 * c3 + s1 * s2 * s3;
	    }
	    if (update !== false) this._onChangeCallback();
	    return this;
	  },
	  setFromAxisAngle: function (axis, angle) {
	    var halfAngle = angle / 2, s = Math.sin(halfAngle);
	    this._x = axis.x * s;
	    this._y = axis.y * s;
	    this._z = axis.z * s;
	    this._w = Math.cos(halfAngle);
	    this._onChangeCallback();
	    return this;
	  },
	  setFromRotationMatrix: function (m) {
	    var te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33, s;
	    if (trace > 0) {
	      s = 0.5 / Math.sqrt(trace + 1);
	      this._w = 0.25 / s;
	      this._x = (m32 - m23) * s;
	      this._y = (m13 - m31) * s;
	      this._z = (m21 - m12) * s;
	    } else if (m11 > m22 && m11 > m33) {
	      s = 2 * Math.sqrt(1 + m11 - m22 - m33);
	      this._w = (m32 - m23) / s;
	      this._x = 0.25 * s;
	      this._y = (m12 + m21) / s;
	      this._z = (m13 + m31) / s;
	    } else if (m22 > m33) {
	      s = 2 * Math.sqrt(1 + m22 - m11 - m33);
	      this._w = (m13 - m31) / s;
	      this._x = (m12 + m21) / s;
	      this._y = 0.25 * s;
	      this._z = (m23 + m32) / s;
	    } else {
	      s = 2 * Math.sqrt(1 + m33 - m11 - m22);
	      this._w = (m21 - m12) / s;
	      this._x = (m13 + m31) / s;
	      this._y = (m23 + m32) / s;
	      this._z = 0.25 * s;
	    }
	    this._onChangeCallback();
	    return this;
	  },
	  setFromUnitVectors: function (vFrom, vTo) {
	    var EPS = 0.000001;
	    var r = vFrom.dot(vTo) + 1;
	    if (r < EPS) {
	      r = 0;
	      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
	        this._x = -vFrom.y;
	        this._y = vFrom.x;
	        this._z = 0;
	        this._w = r;
	      } else {
	        this._x = 0;
	        this._y = -vFrom.z;
	        this._z = vFrom.y;
	        this._w = r;
	      }
	    } else {
	      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
	      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
	      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
	      this._w = r;
	    }
	    return this.normalize();
	  },
	  angleTo: function (q) {
	    return 2 * Math.acos(Math.abs(MathUtils.clamp(this.dot(q), -1, 1)));
	  },
	  rotateTowards: function (q, step) {
	    var angle = this.angleTo(q);
	    if (angle === 0) return this;
	    var t = Math.min(1, step / angle);
	    this.slerp(q, t);
	    return this;
	  },
	  inverse: function () {
	    return this.conjugate();
	  },
	  conjugate: function () {
	    this._x *= -1;
	    this._y *= -1;
	    this._z *= -1;
	    this._onChangeCallback();
	    return this;
	  },
	  dot: function (v) {
	    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
	  },
	  lengthSq: function () {
	    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
	  },
	  length: function () {
	    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
	  },
	  normalize: function () {
	    var l = this.length();
	    if (l === 0) {
	      this._x = 0;
	      this._y = 0;
	      this._z = 0;
	      this._w = 1;
	    } else {
	      l = 1 / l;
	      this._x = this._x * l;
	      this._y = this._y * l;
	      this._z = this._z * l;
	      this._w = this._w * l;
	    }
	    this._onChangeCallback();
	    return this;
	  },
	  multiply: function (q, p) {
	    if (p !== undefined) {
	      console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.");
	      return this.multiplyQuaternions(q, p);
	    }
	    return this.multiplyQuaternions(this, q);
	  },
	  premultiply: function (q) {
	    return this.multiplyQuaternions(q, this);
	  },
	  multiplyQuaternions: function (a, b) {
	    var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
	    var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
	    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
	    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
	    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
	    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
	    this._onChangeCallback();
	    return this;
	  },
	  slerp: function (qb, t) {
	    if (t === 0) return this;
	    if (t === 1) return this.copy(qb);
	    var x = this._x, y = this._y, z = this._z, w = this._w;
	    var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
	    if (cosHalfTheta < 0) {
	      this._w = -qb._w;
	      this._x = -qb._x;
	      this._y = -qb._y;
	      this._z = -qb._z;
	      cosHalfTheta = -cosHalfTheta;
	    } else {
	      this.copy(qb);
	    }
	    if (cosHalfTheta >= 1) {
	      this._w = w;
	      this._x = x;
	      this._y = y;
	      this._z = z;
	      return this;
	    }
	    var sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;
	    if (sqrSinHalfTheta <= Number.EPSILON) {
	      var s = 1 - t;
	      this._w = s * w + t * this._w;
	      this._x = s * x + t * this._x;
	      this._y = s * y + t * this._y;
	      this._z = s * z + t * this._z;
	      this.normalize();
	      this._onChangeCallback();
	      return this;
	    }
	    var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
	    var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
	    var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
	    this._w = w * ratioA + this._w * ratioB;
	    this._x = x * ratioA + this._x * ratioB;
	    this._y = y * ratioA + this._y * ratioB;
	    this._z = z * ratioA + this._z * ratioB;
	    this._onChangeCallback();
	    return this;
	  },
	  equals: function (quaternion) {
	    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
	  },
	  fromArray: function (array, offset) {
	    if (offset === undefined) offset = 0;
	    this._x = array[offset];
	    this._y = array[offset + 1];
	    this._z = array[offset + 2];
	    this._w = array[offset + 3];
	    this._onChangeCallback();
	    return this;
	  },
	  toArray: function (array, offset) {
	    if (array === undefined) array = [];
	    if (offset === undefined) offset = 0;
	    array[offset] = this._x;
	    array[offset + 1] = this._y;
	    array[offset + 2] = this._z;
	    array[offset + 3] = this._w;
	    return array;
	  },
	  _onChange: function (callback) {
	    this._onChangeCallback = callback;
	    return this;
	  },
	  _onChangeCallback: function () {}
	});
	var _vector = new Vector3();
	var _quaternion = new Quaternion();
	function Vector3(x, y, z) {
	  this.x = x || 0;
	  this.y = y || 0;
	  this.z = z || 0;
	}
	Object.assign(Vector3.prototype, {
	  isVector3: true,
	  set: function (x, y, z) {
	    this.x = x;
	    this.y = y;
	    this.z = z;
	    return this;
	  },
	  setScalar: function (scalar) {
	    this.x = scalar;
	    this.y = scalar;
	    this.z = scalar;
	    return this;
	  },
	  setX: function (x) {
	    this.x = x;
	    return this;
	  },
	  setY: function (y) {
	    this.y = y;
	    return this;
	  },
	  setZ: function (z) {
	    this.z = z;
	    return this;
	  },
	  setComponent: function (index, value) {
	    switch (index) {
	      case 0:
	        this.x = value;
	        break;
	      case 1:
	        this.y = value;
	        break;
	      case 2:
	        this.z = value;
	        break;
	      default:
	        throw new Error("index is out of range: " + index);
	    }
	    return this;
	  },
	  getComponent: function (index) {
	    switch (index) {
	      case 0:
	        return this.x;
	      case 1:
	        return this.y;
	      case 2:
	        return this.z;
	      default:
	        throw new Error("index is out of range: " + index);
	    }
	  },
	  clone: function () {
	    return new this.constructor(this.x, this.y, this.z);
	  },
	  copy: function (v) {
	    this.x = v.x;
	    this.y = v.y;
	    this.z = v.z;
	    return this;
	  },
	  add: function (v, w) {
	    if (w !== undefined) {
	      console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.");
	      return this.addVectors(v, w);
	    }
	    this.x += v.x;
	    this.y += v.y;
	    this.z += v.z;
	    return this;
	  },
	  addScalar: function (s) {
	    this.x += s;
	    this.y += s;
	    this.z += s;
	    return this;
	  },
	  addVectors: function (a, b) {
	    this.x = a.x + b.x;
	    this.y = a.y + b.y;
	    this.z = a.z + b.z;
	    return this;
	  },
	  addScaledVector: function (v, s) {
	    this.x += v.x * s;
	    this.y += v.y * s;
	    this.z += v.z * s;
	    return this;
	  },
	  sub: function (v, w) {
	    if (w !== undefined) {
	      console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.");
	      return this.subVectors(v, w);
	    }
	    this.x -= v.x;
	    this.y -= v.y;
	    this.z -= v.z;
	    return this;
	  },
	  subScalar: function (s) {
	    this.x -= s;
	    this.y -= s;
	    this.z -= s;
	    return this;
	  },
	  subVectors: function (a, b) {
	    this.x = a.x - b.x;
	    this.y = a.y - b.y;
	    this.z = a.z - b.z;
	    return this;
	  },
	  multiply: function (v, w) {
	    if (w !== undefined) {
	      console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.");
	      return this.multiplyVectors(v, w);
	    }
	    this.x *= v.x;
	    this.y *= v.y;
	    this.z *= v.z;
	    return this;
	  },
	  multiplyScalar: function (scalar) {
	    this.x *= scalar;
	    this.y *= scalar;
	    this.z *= scalar;
	    return this;
	  },
	  multiplyVectors: function (a, b) {
	    this.x = a.x * b.x;
	    this.y = a.y * b.y;
	    this.z = a.z * b.z;
	    return this;
	  },
	  applyEuler: function (euler) {
	    if (!(euler && euler.isEuler)) {
	      console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.");
	    }
	    return this.applyQuaternion(_quaternion.setFromEuler(euler));
	  },
	  applyAxisAngle: function (axis, angle) {
	    return this.applyQuaternion(_quaternion.setFromAxisAngle(axis, angle));
	  },
	  applyMatrix3: function (m) {
	    var x = this.x, y = this.y, z = this.z;
	    var e = m.elements;
	    this.x = e[0] * x + e[3] * y + e[6] * z;
	    this.y = e[1] * x + e[4] * y + e[7] * z;
	    this.z = e[2] * x + e[5] * y + e[8] * z;
	    return this;
	  },
	  applyNormalMatrix: function (m) {
	    return this.applyMatrix3(m).normalize();
	  },
	  applyMatrix4: function (m) {
	    var x = this.x, y = this.y, z = this.z;
	    var e = m.elements;
	    var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
	    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
	    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
	    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
	    return this;
	  },
	  applyQuaternion: function (q) {
	    var x = this.x, y = this.y, z = this.z;
	    var qx = q.x, qy = q.y, qz = q.z, qw = q.w;
	    var ix = qw * x + qy * z - qz * y;
	    var iy = qw * y + qz * x - qx * z;
	    var iz = qw * z + qx * y - qy * x;
	    var iw = -qx * x - qy * y - qz * z;
	    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
	    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
	    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
	    return this;
	  },
	  project: function (camera) {
	    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
	  },
	  unproject: function (camera) {
	    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
	  },
	  transformDirection: function (m) {
	    var x = this.x, y = this.y, z = this.z;
	    var e = m.elements;
	    this.x = e[0] * x + e[4] * y + e[8] * z;
	    this.y = e[1] * x + e[5] * y + e[9] * z;
	    this.z = e[2] * x + e[6] * y + e[10] * z;
	    return this.normalize();
	  },
	  divide: function (v) {
	    this.x /= v.x;
	    this.y /= v.y;
	    this.z /= v.z;
	    return this;
	  },
	  divideScalar: function (scalar) {
	    return this.multiplyScalar(1 / scalar);
	  },
	  min: function (v) {
	    this.x = Math.min(this.x, v.x);
	    this.y = Math.min(this.y, v.y);
	    this.z = Math.min(this.z, v.z);
	    return this;
	  },
	  max: function (v) {
	    this.x = Math.max(this.x, v.x);
	    this.y = Math.max(this.y, v.y);
	    this.z = Math.max(this.z, v.z);
	    return this;
	  },
	  clamp: function (min, max) {
	    this.x = Math.max(min.x, Math.min(max.x, this.x));
	    this.y = Math.max(min.y, Math.min(max.y, this.y));
	    this.z = Math.max(min.z, Math.min(max.z, this.z));
	    return this;
	  },
	  clampScalar: function (minVal, maxVal) {
	    this.x = Math.max(minVal, Math.min(maxVal, this.x));
	    this.y = Math.max(minVal, Math.min(maxVal, this.y));
	    this.z = Math.max(minVal, Math.min(maxVal, this.z));
	    return this;
	  },
	  clampLength: function (min, max) {
	    var length = this.length();
	    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));
	  },
	  floor: function () {
	    this.x = Math.floor(this.x);
	    this.y = Math.floor(this.y);
	    this.z = Math.floor(this.z);
	    return this;
	  },
	  ceil: function () {
	    this.x = Math.ceil(this.x);
	    this.y = Math.ceil(this.y);
	    this.z = Math.ceil(this.z);
	    return this;
	  },
	  round: function () {
	    this.x = Math.round(this.x);
	    this.y = Math.round(this.y);
	    this.z = Math.round(this.z);
	    return this;
	  },
	  roundToZero: function () {
	    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);
	    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);
	    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);
	    return this;
	  },
	  negate: function () {
	    this.x = -this.x;
	    this.y = -this.y;
	    this.z = -this.z;
	    return this;
	  },
	  dot: function (v) {
	    return this.x * v.x + this.y * v.y + this.z * v.z;
	  },
	  lengthSq: function () {
	    return this.x * this.x + this.y * this.y + this.z * this.z;
	  },
	  length: function () {
	    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
	  },
	  manhattanLength: function () {
	    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
	  },
	  normalize: function () {
	    return this.divideScalar(this.length() || 1);
	  },
	  setLength: function (length) {
	    return this.normalize().multiplyScalar(length);
	  },
	  lerp: function (v, alpha) {
	    this.x += (v.x - this.x) * alpha;
	    this.y += (v.y - this.y) * alpha;
	    this.z += (v.z - this.z) * alpha;
	    return this;
	  },
	  lerpVectors: function (v1, v2, alpha) {
	    return this.subVectors(v2, v1).multiplyScalar(alpha).add(v1);
	  },
	  cross: function (v, w) {
	    if (w !== undefined) {
	      console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.");
	      return this.crossVectors(v, w);
	    }
	    return this.crossVectors(this, v);
	  },
	  crossVectors: function (a, b) {
	    var ax = a.x, ay = a.y, az = a.z;
	    var bx = b.x, by = b.y, bz = b.z;
	    this.x = ay * bz - az * by;
	    this.y = az * bx - ax * bz;
	    this.z = ax * by - ay * bx;
	    return this;
	  },
	  projectOnVector: function (v) {
	    var denominator = v.lengthSq();
	    if (denominator === 0) return this.set(0, 0, 0);
	    var scalar = v.dot(this) / denominator;
	    return this.copy(v).multiplyScalar(scalar);
	  },
	  projectOnPlane: function (planeNormal) {
	    _vector.copy(this).projectOnVector(planeNormal);
	    return this.sub(_vector);
	  },
	  reflect: function (normal) {
	    return this.sub(_vector.copy(normal).multiplyScalar(2 * this.dot(normal)));
	  },
	  angleTo: function (v) {
	    var denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
	    if (denominator === 0) return Math.PI / 2;
	    var theta = this.dot(v) / denominator;
	    return Math.acos(MathUtils.clamp(theta, -1, 1));
	  },
	  distanceTo: function (v) {
	    return Math.sqrt(this.distanceToSquared(v));
	  },
	  distanceToSquared: function (v) {
	    var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
	    return dx * dx + dy * dy + dz * dz;
	  },
	  manhattanDistanceTo: function (v) {
	    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
	  },
	  setFromSpherical: function (s) {
	    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
	  },
	  setFromSphericalCoords: function (radius, phi, theta) {
	    var sinPhiRadius = Math.sin(phi) * radius;
	    this.x = sinPhiRadius * Math.sin(theta);
	    this.y = Math.cos(phi) * radius;
	    this.z = sinPhiRadius * Math.cos(theta);
	    return this;
	  },
	  setFromCylindrical: function (c) {
	    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
	  },
	  setFromCylindricalCoords: function (radius, theta, y) {
	    this.x = radius * Math.sin(theta);
	    this.y = y;
	    this.z = radius * Math.cos(theta);
	    return this;
	  },
	  setFromMatrixPosition: function (m) {
	    var e = m.elements;
	    this.x = e[12];
	    this.y = e[13];
	    this.z = e[14];
	    return this;
	  },
	  setFromMatrixScale: function (m) {
	    var sx = this.setFromMatrixColumn(m, 0).length();
	    var sy = this.setFromMatrixColumn(m, 1).length();
	    var sz = this.setFromMatrixColumn(m, 2).length();
	    this.x = sx;
	    this.y = sy;
	    this.z = sz;
	    return this;
	  },
	  setFromMatrixColumn: function (m, index) {
	    return this.fromArray(m.elements, index * 4);
	  },
	  setFromMatrix3Column: function (m, index) {
	    return this.fromArray(m.elements, index * 3);
	  },
	  equals: function (v) {
	    return v.x === this.x && v.y === this.y && v.z === this.z;
	  },
	  fromArray: function (array, offset) {
	    if (offset === undefined) offset = 0;
	    this.x = array[offset];
	    this.y = array[offset + 1];
	    this.z = array[offset + 2];
	    return this;
	  },
	  toArray: function (array, offset) {
	    if (array === undefined) array = [];
	    if (offset === undefined) offset = 0;
	    array[offset] = this.x;
	    array[offset + 1] = this.y;
	    array[offset + 2] = this.z;
	    return array;
	  },
	  fromBufferAttribute: function (attribute, index, offset) {
	    if (offset !== undefined) {
	      console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute().");
	    }
	    this.x = attribute.getX(index);
	    this.y = attribute.getY(index);
	    this.z = attribute.getZ(index);
	    return this;
	  }
	});
	var _v1 = new Vector3();
	var _m1 = new Matrix4();
	var _zero = new Vector3(0, 0, 0);
	var _one = new Vector3(1, 1, 1);
	var _x = new Vector3();
	var _y = new Vector3();
	var _z = new Vector3();
	function Matrix4() {
	  this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
	  if (arguments.length > 0) {
	    console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.");
	  }
	}
	Object.assign(Matrix4.prototype, {
	  isMatrix4: true,
	  set: function (n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
	    var te = this.elements;
	    te[0] = n11;
	    te[4] = n12;
	    te[8] = n13;
	    te[12] = n14;
	    te[1] = n21;
	    te[5] = n22;
	    te[9] = n23;
	    te[13] = n24;
	    te[2] = n31;
	    te[6] = n32;
	    te[10] = n33;
	    te[14] = n34;
	    te[3] = n41;
	    te[7] = n42;
	    te[11] = n43;
	    te[15] = n44;
	    return this;
	  },
	  identity: function () {
	    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
	    return this;
	  },
	  clone: function () {
	    return new Matrix4().fromArray(this.elements);
	  },
	  copy: function (m) {
	    var te = this.elements;
	    var me = m.elements;
	    te[0] = me[0];
	    te[1] = me[1];
	    te[2] = me[2];
	    te[3] = me[3];
	    te[4] = me[4];
	    te[5] = me[5];
	    te[6] = me[6];
	    te[7] = me[7];
	    te[8] = me[8];
	    te[9] = me[9];
	    te[10] = me[10];
	    te[11] = me[11];
	    te[12] = me[12];
	    te[13] = me[13];
	    te[14] = me[14];
	    te[15] = me[15];
	    return this;
	  },
	  copyPosition: function (m) {
	    var te = this.elements, me = m.elements;
	    te[12] = me[12];
	    te[13] = me[13];
	    te[14] = me[14];
	    return this;
	  },
	  extractBasis: function (xAxis, yAxis, zAxis) {
	    xAxis.setFromMatrixColumn(this, 0);
	    yAxis.setFromMatrixColumn(this, 1);
	    zAxis.setFromMatrixColumn(this, 2);
	    return this;
	  },
	  makeBasis: function (xAxis, yAxis, zAxis) {
	    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
	    return this;
	  },
	  extractRotation: function (m) {
	    var te = this.elements;
	    var me = m.elements;
	    var scaleX = 1 / _v1.setFromMatrixColumn(m, 0).length();
	    var scaleY = 1 / _v1.setFromMatrixColumn(m, 1).length();
	    var scaleZ = 1 / _v1.setFromMatrixColumn(m, 2).length();
	    te[0] = me[0] * scaleX;
	    te[1] = me[1] * scaleX;
	    te[2] = me[2] * scaleX;
	    te[3] = 0;
	    te[4] = me[4] * scaleY;
	    te[5] = me[5] * scaleY;
	    te[6] = me[6] * scaleY;
	    te[7] = 0;
	    te[8] = me[8] * scaleZ;
	    te[9] = me[9] * scaleZ;
	    te[10] = me[10] * scaleZ;
	    te[11] = 0;
	    te[12] = 0;
	    te[13] = 0;
	    te[14] = 0;
	    te[15] = 1;
	    return this;
	  },
	  makeRotationFromEuler: function (euler) {
	    if (!(euler && euler.isEuler)) {
	      console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
	    }
	    var te = this.elements;
	    var x = euler.x, y = euler.y, z = euler.z;
	    var a = Math.cos(x), b = Math.sin(x);
	    var c = Math.cos(y), d = Math.sin(y);
	    var e = Math.cos(z), f = Math.sin(z);
	    if (euler.order === "XYZ") {
	      var ae = a * e, af = a * f, be = b * e, bf = b * f;
	      te[0] = c * e;
	      te[4] = -c * f;
	      te[8] = d;
	      te[1] = af + be * d;
	      te[5] = ae - bf * d;
	      te[9] = -b * c;
	      te[2] = bf - ae * d;
	      te[6] = be + af * d;
	      te[10] = a * c;
	    } else if (euler.order === "YXZ") {
	      var ce = c * e, cf = c * f, de = d * e, df = d * f;
	      te[0] = ce + df * b;
	      te[4] = de * b - cf;
	      te[8] = a * d;
	      te[1] = a * f;
	      te[5] = a * e;
	      te[9] = -b;
	      te[2] = cf * b - de;
	      te[6] = df + ce * b;
	      te[10] = a * c;
	    } else if (euler.order === "ZXY") {
	      var ce = c * e, cf = c * f, de = d * e, df = d * f;
	      te[0] = ce - df * b;
	      te[4] = -a * f;
	      te[8] = de + cf * b;
	      te[1] = cf + de * b;
	      te[5] = a * e;
	      te[9] = df - ce * b;
	      te[2] = -a * d;
	      te[6] = b;
	      te[10] = a * c;
	    } else if (euler.order === "ZYX") {
	      var ae = a * e, af = a * f, be = b * e, bf = b * f;
	      te[0] = c * e;
	      te[4] = be * d - af;
	      te[8] = ae * d + bf;
	      te[1] = c * f;
	      te[5] = bf * d + ae;
	      te[9] = af * d - be;
	      te[2] = -d;
	      te[6] = b * c;
	      te[10] = a * c;
	    } else if (euler.order === "YZX") {
	      var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	      te[0] = c * e;
	      te[4] = bd - ac * f;
	      te[8] = bc * f + ad;
	      te[1] = f;
	      te[5] = a * e;
	      te[9] = -b * e;
	      te[2] = -d * e;
	      te[6] = ad * f + bc;
	      te[10] = ac - bd * f;
	    } else if (euler.order === "XZY") {
	      var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	      te[0] = c * e;
	      te[4] = -f;
	      te[8] = d * e;
	      te[1] = ac * f + bd;
	      te[5] = a * e;
	      te[9] = ad * f - bc;
	      te[2] = bc * f - ad;
	      te[6] = b * e;
	      te[10] = bd * f + ac;
	    }
	    te[3] = 0;
	    te[7] = 0;
	    te[11] = 0;
	    te[12] = 0;
	    te[13] = 0;
	    te[14] = 0;
	    te[15] = 1;
	    return this;
	  },
	  makeRotationFromQuaternion: function (q) {
	    return this.compose(_zero, q, _one);
	  },
	  lookAt: function (eye, target, up) {
	    var te = this.elements;
	    _z.subVectors(eye, target);
	    if (_z.lengthSq() === 0) {
	      _z.z = 1;
	    }
	    _z.normalize();
	    _x.crossVectors(up, _z);
	    if (_x.lengthSq() === 0) {
	      if (Math.abs(up.z) === 1) {
	        _z.x += 0.0001;
	      } else {
	        _z.z += 0.0001;
	      }
	      _z.normalize();
	      _x.crossVectors(up, _z);
	    }
	    _x.normalize();
	    _y.crossVectors(_z, _x);
	    te[0] = _x.x;
	    te[4] = _y.x;
	    te[8] = _z.x;
	    te[1] = _x.y;
	    te[5] = _y.y;
	    te[9] = _z.y;
	    te[2] = _x.z;
	    te[6] = _y.z;
	    te[10] = _z.z;
	    return this;
	  },
	  multiply: function (m, n) {
	    if (n !== undefined) {
	      console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.");
	      return this.multiplyMatrices(m, n);
	    }
	    return this.multiplyMatrices(this, m);
	  },
	  premultiply: function (m) {
	    return this.multiplyMatrices(m, this);
	  },
	  multiplyMatrices: function (a, b) {
	    var ae = a.elements;
	    var be = b.elements;
	    var te = this.elements;
	    var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
	    var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
	    var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
	    var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
	    var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
	    var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
	    var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
	    var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
	    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
	    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
	    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
	    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
	    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
	    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
	    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
	    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
	    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
	    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
	    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
	    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
	    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
	    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
	    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
	    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
	    return this;
	  },
	  multiplyScalar: function (s) {
	    var te = this.elements;
	    te[0] *= s;
	    te[4] *= s;
	    te[8] *= s;
	    te[12] *= s;
	    te[1] *= s;
	    te[5] *= s;
	    te[9] *= s;
	    te[13] *= s;
	    te[2] *= s;
	    te[6] *= s;
	    te[10] *= s;
	    te[14] *= s;
	    te[3] *= s;
	    te[7] *= s;
	    te[11] *= s;
	    te[15] *= s;
	    return this;
	  },
	  determinant: function () {
	    var te = this.elements;
	    var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
	    var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
	    var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
	    var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
	    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
	  },
	  transpose: function () {
	    var te = this.elements;
	    var tmp;
	    tmp = te[1];
	    te[1] = te[4];
	    te[4] = tmp;
	    tmp = te[2];
	    te[2] = te[8];
	    te[8] = tmp;
	    tmp = te[6];
	    te[6] = te[9];
	    te[9] = tmp;
	    tmp = te[3];
	    te[3] = te[12];
	    te[12] = tmp;
	    tmp = te[7];
	    te[7] = te[13];
	    te[13] = tmp;
	    tmp = te[11];
	    te[11] = te[14];
	    te[14] = tmp;
	    return this;
	  },
	  setPosition: function (x, y, z) {
	    var te = this.elements;
	    if (x.isVector3) {
	      te[12] = x.x;
	      te[13] = x.y;
	      te[14] = x.z;
	    } else {
	      te[12] = x;
	      te[13] = y;
	      te[14] = z;
	    }
	    return this;
	  },
	  getInverse: function (m, throwOnDegenerate) {
	    var te = this.elements, me = m.elements, n11 = me[0], n21 = me[1], n31 = me[2], n41 = me[3], n12 = me[4], n22 = me[5], n32 = me[6], n42 = me[7], n13 = me[8], n23 = me[9], n33 = me[10], n43 = me[11], n14 = me[12], n24 = me[13], n34 = me[14], n44 = me[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
	    var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
	    if (det === 0) {
	      var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
	      if (throwOnDegenerate === true) {
	        throw new Error(msg);
	      } else {
	        console.warn(msg);
	      }
	      return this.identity();
	    }
	    var detInv = 1 / det;
	    te[0] = t11 * detInv;
	    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
	    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
	    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
	    te[4] = t12 * detInv;
	    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
	    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
	    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
	    te[8] = t13 * detInv;
	    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
	    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
	    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
	    te[12] = t14 * detInv;
	    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
	    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
	    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
	    return this;
	  },
	  scale: function (v) {
	    var te = this.elements;
	    var x = v.x, y = v.y, z = v.z;
	    te[0] *= x;
	    te[4] *= y;
	    te[8] *= z;
	    te[1] *= x;
	    te[5] *= y;
	    te[9] *= z;
	    te[2] *= x;
	    te[6] *= y;
	    te[10] *= z;
	    te[3] *= x;
	    te[7] *= y;
	    te[11] *= z;
	    return this;
	  },
	  getMaxScaleOnAxis: function () {
	    var te = this.elements;
	    var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
	    var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
	    var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
	    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
	  },
	  makeTranslation: function (x, y, z) {
	    this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
	    return this;
	  },
	  makeRotationX: function (theta) {
	    var c = Math.cos(theta), s = Math.sin(theta);
	    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
	    return this;
	  },
	  makeRotationY: function (theta) {
	    var c = Math.cos(theta), s = Math.sin(theta);
	    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
	    return this;
	  },
	  makeRotationZ: function (theta) {
	    var c = Math.cos(theta), s = Math.sin(theta);
	    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
	    return this;
	  },
	  makeRotationAxis: function (axis, angle) {
	    var c = Math.cos(angle);
	    var s = Math.sin(angle);
	    var t = 1 - c;
	    var x = axis.x, y = axis.y, z = axis.z;
	    var tx = t * x, ty = t * y;
	    this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
	    return this;
	  },
	  makeScale: function (x, y, z) {
	    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
	    return this;
	  },
	  makeShear: function (x, y, z) {
	    this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);
	    return this;
	  },
	  compose: function (position, quaternion, scale) {
	    var te = this.elements;
	    var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
	    var x2 = x + x, y2 = y + y, z2 = z + z;
	    var xx = x * x2, xy = x * y2, xz = x * z2;
	    var yy = y * y2, yz = y * z2, zz = z * z2;
	    var wx = w * x2, wy = w * y2, wz = w * z2;
	    var sx = scale.x, sy = scale.y, sz = scale.z;
	    te[0] = (1 - (yy + zz)) * sx;
	    te[1] = (xy + wz) * sx;
	    te[2] = (xz - wy) * sx;
	    te[3] = 0;
	    te[4] = (xy - wz) * sy;
	    te[5] = (1 - (xx + zz)) * sy;
	    te[6] = (yz + wx) * sy;
	    te[7] = 0;
	    te[8] = (xz + wy) * sz;
	    te[9] = (yz - wx) * sz;
	    te[10] = (1 - (xx + yy)) * sz;
	    te[11] = 0;
	    te[12] = position.x;
	    te[13] = position.y;
	    te[14] = position.z;
	    te[15] = 1;
	    return this;
	  },
	  decompose: function (position, quaternion, scale) {
	    var te = this.elements;
	    var sx = _v1.set(te[0], te[1], te[2]).length();
	    var sy = _v1.set(te[4], te[5], te[6]).length();
	    var sz = _v1.set(te[8], te[9], te[10]).length();
	    var det = this.determinant();
	    if (det < 0) sx = -sx;
	    position.x = te[12];
	    position.y = te[13];
	    position.z = te[14];
	    _m1.copy(this);
	    var invSX = 1 / sx;
	    var invSY = 1 / sy;
	    var invSZ = 1 / sz;
	    _m1.elements[0] *= invSX;
	    _m1.elements[1] *= invSX;
	    _m1.elements[2] *= invSX;
	    _m1.elements[4] *= invSY;
	    _m1.elements[5] *= invSY;
	    _m1.elements[6] *= invSY;
	    _m1.elements[8] *= invSZ;
	    _m1.elements[9] *= invSZ;
	    _m1.elements[10] *= invSZ;
	    quaternion.setFromRotationMatrix(_m1);
	    scale.x = sx;
	    scale.y = sy;
	    scale.z = sz;
	    return this;
	  },
	  makePerspective: function (left, right, top, bottom, near, far) {
	    if (far === undefined) {
	      console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
	    }
	    var te = this.elements;
	    var x = 2 * near / (right - left);
	    var y = 2 * near / (top - bottom);
	    var a = (right + left) / (right - left);
	    var b = (top + bottom) / (top - bottom);
	    var c = -(far + near) / (far - near);
	    var d = -2 * far * near / (far - near);
	    te[0] = x;
	    te[4] = 0;
	    te[8] = a;
	    te[12] = 0;
	    te[1] = 0;
	    te[5] = y;
	    te[9] = b;
	    te[13] = 0;
	    te[2] = 0;
	    te[6] = 0;
	    te[10] = c;
	    te[14] = d;
	    te[3] = 0;
	    te[7] = 0;
	    te[11] = -1;
	    te[15] = 0;
	    return this;
	  },
	  makeOrthographic: function (left, right, top, bottom, near, far) {
	    var te = this.elements;
	    var w = 1 / (right - left);
	    var h = 1 / (top - bottom);
	    var p = 1 / (far - near);
	    var x = (right + left) * w;
	    var y = (top + bottom) * h;
	    var z = (far + near) * p;
	    te[0] = 2 * w;
	    te[4] = 0;
	    te[8] = 0;
	    te[12] = -x;
	    te[1] = 0;
	    te[5] = 2 * h;
	    te[9] = 0;
	    te[13] = -y;
	    te[2] = 0;
	    te[6] = 0;
	    te[10] = -2 * p;
	    te[14] = -z;
	    te[3] = 0;
	    te[7] = 0;
	    te[11] = 0;
	    te[15] = 1;
	    return this;
	  },
	  equals: function (matrix) {
	    var te = this.elements;
	    var me = matrix.elements;
	    for (var i = 0; i < 16; i++) {
	      if (te[i] !== me[i]) return false;
	    }
	    return true;
	  },
	  fromArray: function (array, offset) {
	    if (offset === undefined) offset = 0;
	    for (var i = 0; i < 16; i++) {
	      this.elements[i] = array[i + offset];
	    }
	    return this;
	  },
	  toArray: function (array, offset) {
	    if (array === undefined) array = [];
	    if (offset === undefined) offset = 0;
	    var te = this.elements;
	    array[offset] = te[0];
	    array[offset + 1] = te[1];
	    array[offset + 2] = te[2];
	    array[offset + 3] = te[3];
	    array[offset + 4] = te[4];
	    array[offset + 5] = te[5];
	    array[offset + 6] = te[6];
	    array[offset + 7] = te[7];
	    array[offset + 8] = te[8];
	    array[offset + 9] = te[9];
	    array[offset + 10] = te[10];
	    array[offset + 11] = te[11];
	    array[offset + 12] = te[12];
	    array[offset + 13] = te[13];
	    array[offset + 14] = te[14];
	    array[offset + 15] = te[15];
	    return array;
	  }
	});
	var _matrix = new Matrix4();
	var _quaternion$1 = new Quaternion();
	function Euler(x, y, z, order) {
	  this._x = x || 0;
	  this._y = y || 0;
	  this._z = z || 0;
	  this._order = order || Euler.DefaultOrder;
	}
	Euler.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
	Euler.DefaultOrder = "XYZ";
	Object.defineProperties(Euler.prototype, {
	  x: {
	    get: function () {
	      return this._x;
	    },
	    set: function (value) {
	      this._x = value;
	      this._onChangeCallback();
	    }
	  },
	  y: {
	    get: function () {
	      return this._y;
	    },
	    set: function (value) {
	      this._y = value;
	      this._onChangeCallback();
	    }
	  },
	  z: {
	    get: function () {
	      return this._z;
	    },
	    set: function (value) {
	      this._z = value;
	      this._onChangeCallback();
	    }
	  },
	  order: {
	    get: function () {
	      return this._order;
	    },
	    set: function (value) {
	      this._order = value;
	      this._onChangeCallback();
	    }
	  }
	});
	Object.assign(Euler.prototype, {
	  isEuler: true,
	  set: function (x, y, z, order) {
	    this._x = x;
	    this._y = y;
	    this._z = z;
	    this._order = order || this._order;
	    this._onChangeCallback();
	    return this;
	  },
	  clone: function () {
	    return new this.constructor(this._x, this._y, this._z, this._order);
	  },
	  copy: function (euler) {
	    this._x = euler._x;
	    this._y = euler._y;
	    this._z = euler._z;
	    this._order = euler._order;
	    this._onChangeCallback();
	    return this;
	  },
	  setFromRotationMatrix: function (m, order, update) {
	    var clamp = MathUtils.clamp;
	    var te = m.elements;
	    var m11 = te[0], m12 = te[4], m13 = te[8];
	    var m21 = te[1], m22 = te[5], m23 = te[9];
	    var m31 = te[2], m32 = te[6], m33 = te[10];
	    order = order || this._order;
	    if (order === "XYZ") {
	      this._y = Math.asin(clamp(m13, -1, 1));
	      if (Math.abs(m13) < 0.9999999) {
	        this._x = Math.atan2(-m23, m33);
	        this._z = Math.atan2(-m12, m11);
	      } else {
	        this._x = Math.atan2(m32, m22);
	        this._z = 0;
	      }
	    } else if (order === "YXZ") {
	      this._x = Math.asin(-clamp(m23, -1, 1));
	      if (Math.abs(m23) < 0.9999999) {
	        this._y = Math.atan2(m13, m33);
	        this._z = Math.atan2(m21, m22);
	      } else {
	        this._y = Math.atan2(-m31, m11);
	        this._z = 0;
	      }
	    } else if (order === "ZXY") {
	      this._x = Math.asin(clamp(m32, -1, 1));
	      if (Math.abs(m32) < 0.9999999) {
	        this._y = Math.atan2(-m31, m33);
	        this._z = Math.atan2(-m12, m22);
	      } else {
	        this._y = 0;
	        this._z = Math.atan2(m21, m11);
	      }
	    } else if (order === "ZYX") {
	      this._y = Math.asin(-clamp(m31, -1, 1));
	      if (Math.abs(m31) < 0.9999999) {
	        this._x = Math.atan2(m32, m33);
	        this._z = Math.atan2(m21, m11);
	      } else {
	        this._x = 0;
	        this._z = Math.atan2(-m12, m22);
	      }
	    } else if (order === "YZX") {
	      this._z = Math.asin(clamp(m21, -1, 1));
	      if (Math.abs(m21) < 0.9999999) {
	        this._x = Math.atan2(-m23, m22);
	        this._y = Math.atan2(-m31, m11);
	      } else {
	        this._x = 0;
	        this._y = Math.atan2(m13, m33);
	      }
	    } else if (order === "XZY") {
	      this._z = Math.asin(-clamp(m12, -1, 1));
	      if (Math.abs(m12) < 0.9999999) {
	        this._x = Math.atan2(m32, m22);
	        this._y = Math.atan2(m13, m11);
	      } else {
	        this._x = Math.atan2(-m23, m33);
	        this._y = 0;
	      }
	    } else {
	      console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + order);
	    }
	    this._order = order;
	    if (update !== false) this._onChangeCallback();
	    return this;
	  },
	  setFromQuaternion: function (q, order, update) {
	    _matrix.makeRotationFromQuaternion(q);
	    return this.setFromRotationMatrix(_matrix, order, update);
	  },
	  setFromVector3: function (v, order) {
	    return this.set(v.x, v.y, v.z, order || this._order);
	  },
	  reorder: function (newOrder) {
	    _quaternion$1.setFromEuler(this);
	    return this.setFromQuaternion(_quaternion$1, newOrder);
	  },
	  equals: function (euler) {
	    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
	  },
	  fromArray: function (array) {
	    this._x = array[0];
	    this._y = array[1];
	    this._z = array[2];
	    if (array[3] !== undefined) this._order = array[3];
	    this._onChangeCallback();
	    return this;
	  },
	  toArray: function (array, offset) {
	    if (array === undefined) array = [];
	    if (offset === undefined) offset = 0;
	    array[offset] = this._x;
	    array[offset + 1] = this._y;
	    array[offset + 2] = this._z;
	    array[offset + 3] = this._order;
	    return array;
	  },
	  toVector3: function (optionalResult) {
	    if (optionalResult) {
	      return optionalResult.set(this._x, this._y, this._z);
	    } else {
	      return new Vector3(this._x, this._y, this._z);
	    }
	  },
	  _onChange: function (callback) {
	    this._onChangeCallback = callback;
	    return this;
	  },
	  _onChangeCallback: function () {}
	});
	function Layers() {
	  this.mask = 1 | 0;
	}
	Object.assign(Layers.prototype, {
	  set: function (channel) {
	    this.mask = 1 << channel | 0;
	  },
	  enable: function (channel) {
	    this.mask |= 1 << channel | 0;
	  },
	  enableAll: function () {
	    this.mask = 4294967295 | 0;
	  },
	  toggle: function (channel) {
	    this.mask ^= 1 << channel | 0;
	  },
	  disable: function (channel) {
	    this.mask &= ~(1 << channel | 0);
	  },
	  disableAll: function () {
	    this.mask = 0;
	  },
	  test: function (layers) {
	    return (this.mask & layers.mask) !== 0;
	  }
	});
	var _object3DId = 0;
	var _v1$1 = new Vector3();
	var _q1 = new Quaternion();
	var _m1$1 = new Matrix4();
	var _target = new Vector3();
	var _position = new Vector3();
	var _scale = new Vector3();
	var _quaternion$2 = new Quaternion();
	var _xAxis = new Vector3(1, 0, 0);
	var _yAxis = new Vector3(0, 1, 0);
	var _zAxis = new Vector3(0, 0, 1);
	var _addedEvent = {
	  type: "added"
	};
	var _removedEvent = {
	  type: "removed"
	};
	function Object3D() {
	  Object.defineProperty(this, "id", {
	    value: _object3DId++
	  });
	  this.uuid = MathUtils.generateUUID();
	  this.name = "";
	  this.type = "Object3D";
	  this.parent = null;
	  this.children = [];
	  this.up = Object3D.DefaultUp.clone();
	  var position = new Vector3();
	  var rotation = new Euler();
	  var quaternion = new Quaternion();
	  var scale = new Vector3(1, 1, 1);
	  function onRotationChange() {
	    quaternion.setFromEuler(rotation, false);
	  }
	  function onQuaternionChange() {
	    rotation.setFromQuaternion(quaternion, undefined, false);
	  }
	  rotation._onChange(onRotationChange);
	  quaternion._onChange(onQuaternionChange);
	  Object.defineProperties(this, {
	    position: {
	      configurable: true,
	      enumerable: true,
	      value: position
	    },
	    rotation: {
	      configurable: true,
	      enumerable: true,
	      value: rotation
	    },
	    quaternion: {
	      configurable: true,
	      enumerable: true,
	      value: quaternion
	    },
	    scale: {
	      configurable: true,
	      enumerable: true,
	      value: scale
	    },
	    modelViewMatrix: {
	      value: new Matrix4()
	    },
	    normalMatrix: {
	      value: new Matrix3()
	    }
	  });
	  this.matrix = new Matrix4();
	  this.matrixWorld = new Matrix4();
	  this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
	  this.matrixWorldNeedsUpdate = false;
	  this.layers = new Layers();
	  this.visible = true;
	  this.castShadow = false;
	  this.receiveShadow = false;
	  this.frustumCulled = true;
	  this.renderOrder = 0;
	  this.userData = {};
	}
	Object3D.DefaultUp = new Vector3(0, 1, 0);
	Object3D.DefaultMatrixAutoUpdate = true;
	Object3D.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
	  constructor: Object3D,
	  isObject3D: true,
	  onBeforeRender: function () {},
	  onAfterRender: function () {},
	  applyMatrix4: function (matrix) {
	    if (this.matrixAutoUpdate) this.updateMatrix();
	    this.matrix.premultiply(matrix);
	    this.matrix.decompose(this.position, this.quaternion, this.scale);
	  },
	  applyQuaternion: function (q) {
	    this.quaternion.premultiply(q);
	    return this;
	  },
	  setRotationFromAxisAngle: function (axis, angle) {
	    this.quaternion.setFromAxisAngle(axis, angle);
	  },
	  setRotationFromEuler: function (euler) {
	    this.quaternion.setFromEuler(euler, true);
	  },
	  setRotationFromMatrix: function (m) {
	    this.quaternion.setFromRotationMatrix(m);
	  },
	  setRotationFromQuaternion: function (q) {
	    this.quaternion.copy(q);
	  },
	  rotateOnAxis: function (axis, angle) {
	    _q1.setFromAxisAngle(axis, angle);
	    this.quaternion.multiply(_q1);
	    return this;
	  },
	  rotateOnWorldAxis: function (axis, angle) {
	    _q1.setFromAxisAngle(axis, angle);
	    this.quaternion.premultiply(_q1);
	    return this;
	  },
	  rotateX: function (angle) {
	    return this.rotateOnAxis(_xAxis, angle);
	  },
	  rotateY: function (angle) {
	    return this.rotateOnAxis(_yAxis, angle);
	  },
	  rotateZ: function (angle) {
	    return this.rotateOnAxis(_zAxis, angle);
	  },
	  translateOnAxis: function (axis, distance) {
	    _v1$1.copy(axis).applyQuaternion(this.quaternion);
	    this.position.add(_v1$1.multiplyScalar(distance));
	    return this;
	  },
	  translateX: function (distance) {
	    return this.translateOnAxis(_xAxis, distance);
	  },
	  translateY: function (distance) {
	    return this.translateOnAxis(_yAxis, distance);
	  },
	  translateZ: function (distance) {
	    return this.translateOnAxis(_zAxis, distance);
	  },
	  localToWorld: function (vector) {
	    return vector.applyMatrix4(this.matrixWorld);
	  },
	  worldToLocal: function (vector) {
	    return vector.applyMatrix4(_m1$1.getInverse(this.matrixWorld));
	  },
	  lookAt: function (x, y, z) {
	    if (x.isVector3) {
	      _target.copy(x);
	    } else {
	      _target.set(x, y, z);
	    }
	    var parent = this.parent;
	    this.updateWorldMatrix(true, false);
	    _position.setFromMatrixPosition(this.matrixWorld);
	    if (this.isCamera || this.isLight) {
	      _m1$1.lookAt(_position, _target, this.up);
	    } else {
	      _m1$1.lookAt(_target, _position, this.up);
	    }
	    this.quaternion.setFromRotationMatrix(_m1$1);
	    if (parent) {
	      _m1$1.extractRotation(parent.matrixWorld);
	      _q1.setFromRotationMatrix(_m1$1);
	      this.quaternion.premultiply(_q1.inverse());
	    }
	  },
	  add: function (object) {
	    if (arguments.length > 1) {
	      for (var i = 0; i < arguments.length; i++) {
	        this.add(arguments[i]);
	      }
	      return this;
	    }
	    if (object === this) {
	      console.error("THREE.Object3D.add: object can't be added as a child of itself.", object);
	      return this;
	    }
	    if (object && object.isObject3D) {
	      if (object.parent !== null) {
	        object.parent.remove(object);
	      }
	      object.parent = this;
	      this.children.push(object);
	      object.dispatchEvent(_addedEvent);
	    } else {
	      console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object);
	    }
	    return this;
	  },
	  remove: function (object) {
	    if (arguments.length > 1) {
	      for (var i = 0; i < arguments.length; i++) {
	        this.remove(arguments[i]);
	      }
	      return this;
	    }
	    var index = this.children.indexOf(object);
	    if (index !== -1) {
	      object.parent = null;
	      this.children.splice(index, 1);
	      object.dispatchEvent(_removedEvent);
	    }
	    return this;
	  },
	  attach: function (object) {
	    this.updateWorldMatrix(true, false);
	    _m1$1.getInverse(this.matrixWorld);
	    if (object.parent !== null) {
	      object.parent.updateWorldMatrix(true, false);
	      _m1$1.multiply(object.parent.matrixWorld);
	    }
	    object.applyMatrix4(_m1$1);
	    object.updateWorldMatrix(false, false);
	    this.add(object);
	    return this;
	  },
	  getObjectById: function (id) {
	    return this.getObjectByProperty("id", id);
	  },
	  getObjectByName: function (name) {
	    return this.getObjectByProperty("name", name);
	  },
	  getObjectByProperty: function (name, value) {
	    if (this[name] === value) return this;
	    for (var i = 0, l = this.children.length; i < l; i++) {
	      var child = this.children[i];
	      var object = child.getObjectByProperty(name, value);
	      if (object !== undefined) {
	        return object;
	      }
	    }
	    return undefined;
	  },
	  getWorldPosition: function (target) {
	    if (target === undefined) {
	      console.warn("THREE.Object3D: .getWorldPosition() target is now required");
	      target = new Vector3();
	    }
	    this.updateMatrixWorld(true);
	    return target.setFromMatrixPosition(this.matrixWorld);
	  },
	  getWorldQuaternion: function (target) {
	    if (target === undefined) {
	      console.warn("THREE.Object3D: .getWorldQuaternion() target is now required");
	      target = new Quaternion();
	    }
	    this.updateMatrixWorld(true);
	    this.matrixWorld.decompose(_position, target, _scale);
	    return target;
	  },
	  getWorldScale: function (target) {
	    if (target === undefined) {
	      console.warn("THREE.Object3D: .getWorldScale() target is now required");
	      target = new Vector3();
	    }
	    this.updateMatrixWorld(true);
	    this.matrixWorld.decompose(_position, _quaternion$2, target);
	    return target;
	  },
	  getWorldDirection: function (target) {
	    if (target === undefined) {
	      console.warn("THREE.Object3D: .getWorldDirection() target is now required");
	      target = new Vector3();
	    }
	    this.updateMatrixWorld(true);
	    var e = this.matrixWorld.elements;
	    return target.set(e[8], e[9], e[10]).normalize();
	  },
	  raycast: function () {},
	  traverse: function (callback) {
	    callback(this);
	    var children = this.children;
	    for (var i = 0, l = children.length; i < l; i++) {
	      children[i].traverse(callback);
	    }
	  },
	  traverseVisible: function (callback) {
	    if (this.visible === false) return;
	    callback(this);
	    var children = this.children;
	    for (var i = 0, l = children.length; i < l; i++) {
	      children[i].traverseVisible(callback);
	    }
	  },
	  traverseAncestors: function (callback) {
	    var parent = this.parent;
	    if (parent !== null) {
	      callback(parent);
	      parent.traverseAncestors(callback);
	    }
	  },
	  updateMatrix: function () {
	    this.matrix.compose(this.position, this.quaternion, this.scale);
	    this.matrixWorldNeedsUpdate = true;
	  },
	  updateMatrixWorld: function (force) {
	    if (this.matrixAutoUpdate) this.updateMatrix();
	    if (this.matrixWorldNeedsUpdate || force) {
	      if (this.parent === null) {
	        this.matrixWorld.copy(this.matrix);
	      } else {
	        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
	      }
	      this.matrixWorldNeedsUpdate = false;
	      force = true;
	    }
	    var children = this.children;
	    for (var i = 0, l = children.length; i < l; i++) {
	      children[i].updateMatrixWorld(force);
	    }
	  },
	  updateWorldMatrix: function (updateParents, updateChildren) {
	    var parent = this.parent;
	    if (updateParents === true && parent !== null) {
	      parent.updateWorldMatrix(true, false);
	    }
	    if (this.matrixAutoUpdate) this.updateMatrix();
	    if (this.parent === null) {
	      this.matrixWorld.copy(this.matrix);
	    } else {
	      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
	    }
	    if (updateChildren === true) {
	      var children = this.children;
	      for (var i = 0, l = children.length; i < l; i++) {
	        children[i].updateWorldMatrix(false, true);
	      }
	    }
	  },
	  toJSON: function (meta) {
	    var isRootObject = meta === undefined || typeof meta === "string";
	    var output = {};
	    if (isRootObject) {
	      meta = {
	        geometries: {},
	        materials: {},
	        textures: {},
	        images: {},
	        shapes: {}
	      };
	      output.metadata = {
	        version: 4.5,
	        type: "Object",
	        generator: "Object3D.toJSON"
	      };
	    }
	    var object = {};
	    object.uuid = this.uuid;
	    object.type = this.type;
	    if (this.name !== "") object.name = this.name;
	    if (this.castShadow === true) object.castShadow = true;
	    if (this.receiveShadow === true) object.receiveShadow = true;
	    if (this.visible === false) object.visible = false;
	    if (this.frustumCulled === false) object.frustumCulled = false;
	    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
	    if (JSON.stringify(this.userData) !== "{}") object.userData = this.userData;
	    object.layers = this.layers.mask;
	    object.matrix = this.matrix.toArray();
	    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;
	    if (this.isInstancedMesh) {
	      object.type = "InstancedMesh";
	      object.count = this.count;
	      object.instanceMatrix = this.instanceMatrix.toJSON();
	    }
	    function serialize(library, element) {
	      if (library[element.uuid] === undefined) {
	        library[element.uuid] = element.toJSON(meta);
	      }
	      return element.uuid;
	    }
	    if (this.isMesh || this.isLine || this.isPoints) {
	      object.geometry = serialize(meta.geometries, this.geometry);
	      var parameters = this.geometry.parameters;
	      if (parameters !== undefined && parameters.shapes !== undefined) {
	        var shapes = parameters.shapes;
	        if (Array.isArray(shapes)) {
	          for (var i = 0, l = shapes.length; i < l; i++) {
	            var shape = shapes[i];
	            serialize(meta.shapes, shape);
	          }
	        } else {
	          serialize(meta.shapes, shapes);
	        }
	      }
	    }
	    if (this.material !== undefined) {
	      if (Array.isArray(this.material)) {
	        var uuids = [];
	        for (var i = 0, l = this.material.length; i < l; i++) {
	          uuids.push(serialize(meta.materials, this.material[i]));
	        }
	        object.material = uuids;
	      } else {
	        object.material = serialize(meta.materials, this.material);
	      }
	    }
	    if (this.children.length > 0) {
	      object.children = [];
	      for (var i = 0; i < this.children.length; i++) {
	        object.children.push(this.children[i].toJSON(meta).object);
	      }
	    }
	    if (isRootObject) {
	      var geometries = extractFromCache(meta.geometries);
	      var materials = extractFromCache(meta.materials);
	      var textures = extractFromCache(meta.textures);
	      var images = extractFromCache(meta.images);
	      var shapes = extractFromCache(meta.shapes);
	      if (geometries.length > 0) output.geometries = geometries;
	      if (materials.length > 0) output.materials = materials;
	      if (textures.length > 0) output.textures = textures;
	      if (images.length > 0) output.images = images;
	      if (shapes.length > 0) output.shapes = shapes;
	    }
	    output.object = object;
	    return output;
	    function extractFromCache(cache) {
	      var values = [];
	      for (var key in cache) {
	        var data = cache[key];
	        delete data.metadata;
	        values.push(data);
	      }
	      return values;
	    }
	  },
	  clone: function (recursive) {
	    return new this.constructor().copy(this, recursive);
	  },
	  copy: function (source, recursive) {
	    if (recursive === undefined) recursive = true;
	    this.name = source.name;
	    this.up.copy(source.up);
	    this.position.copy(source.position);
	    this.quaternion.copy(source.quaternion);
	    this.scale.copy(source.scale);
	    this.matrix.copy(source.matrix);
	    this.matrixWorld.copy(source.matrixWorld);
	    this.matrixAutoUpdate = source.matrixAutoUpdate;
	    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
	    this.layers.mask = source.layers.mask;
	    this.visible = source.visible;
	    this.castShadow = source.castShadow;
	    this.receiveShadow = source.receiveShadow;
	    this.frustumCulled = source.frustumCulled;
	    this.renderOrder = source.renderOrder;
	    this.userData = JSON.parse(JSON.stringify(source.userData));
	    if (recursive === true) {
	      for (var i = 0; i < source.children.length; i++) {
	        var child = source.children[i];
	        this.add(child.clone());
	      }
	    }
	    return this;
	  }
	});
	function Scene() {
	  Object3D.call(this);
	  this.type = "Scene";
	  this.background = null;
	  this.environment = null;
	  this.fog = null;
	  this.overrideMaterial = null;
	  this.autoUpdate = true;
	  if (typeof __THREE_DEVTOOLS__ !== "undefined") {
	    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
	      detail: this
	    }));
	  }
	}
	Scene.prototype = Object.assign(Object.create(Object3D.prototype), {
	  constructor: Scene,
	  isScene: true,
	  copy: function (source, recursive) {
	    Object3D.prototype.copy.call(this, source, recursive);
	    if (source.background !== null) this.background = source.background.clone();
	    if (source.environment !== null) this.environment = source.environment.clone();
	    if (source.fog !== null) this.fog = source.fog.clone();
	    if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
	    this.autoUpdate = source.autoUpdate;
	    this.matrixAutoUpdate = source.matrixAutoUpdate;
	    return this;
	  },
	  toJSON: function (meta) {
	    var data = Object3D.prototype.toJSON.call(this, meta);
	    if (this.background !== null) data.object.background = this.background.toJSON(meta);
	    if (this.environment !== null) data.object.environment = this.environment.toJSON(meta);
	    if (this.fog !== null) data.object.fog = this.fog.toJSON();
	    return data;
	  },
	  dispose: function () {
	    this.dispatchEvent({
	      type: "dispose"
	    });
	  }
	});
	var _points = [new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3(), new Vector3()];
	var _vector$1 = new Vector3();
	var _box = new Box3();
	var _v0 = new Vector3();
	var _v1$2 = new Vector3();
	var _v2 = new Vector3();
	var _f0 = new Vector3();
	var _f1 = new Vector3();
	var _f2 = new Vector3();
	var _center = new Vector3();
	var _extents = new Vector3();
	var _triangleNormal = new Vector3();
	var _testAxis = new Vector3();
	function Box3(min, max) {
	  this.min = min !== undefined ? min : new Vector3(+Infinity, +Infinity, +Infinity);
	  this.max = max !== undefined ? max : new Vector3(-Infinity, -Infinity, -Infinity);
	}
	Object.assign(Box3.prototype, {
	  isBox3: true,
	  set: function (min, max) {
	    this.min.copy(min);
	    this.max.copy(max);
	    return this;
	  },
	  setFromArray: function (array) {
	    var minX = +Infinity;
	    var minY = +Infinity;
	    var minZ = +Infinity;
	    var maxX = -Infinity;
	    var maxY = -Infinity;
	    var maxZ = -Infinity;
	    for (var i = 0, l = array.length; i < l; i += 3) {
	      var x = array[i];
	      var y = array[i + 1];
	      var z = array[i + 2];
	      if (x < minX) minX = x;
	      if (y < minY) minY = y;
	      if (z < minZ) minZ = z;
	      if (x > maxX) maxX = x;
	      if (y > maxY) maxY = y;
	      if (z > maxZ) maxZ = z;
	    }
	    this.min.set(minX, minY, minZ);
	    this.max.set(maxX, maxY, maxZ);
	    return this;
	  },
	  setFromBufferAttribute: function (attribute) {
	    var minX = +Infinity;
	    var minY = +Infinity;
	    var minZ = +Infinity;
	    var maxX = -Infinity;
	    var maxY = -Infinity;
	    var maxZ = -Infinity;
	    for (var i = 0, l = attribute.count; i < l; i++) {
	      var x = attribute.getX(i);
	      var y = attribute.getY(i);
	      var z = attribute.getZ(i);
	      if (x < minX) minX = x;
	      if (y < minY) minY = y;
	      if (z < minZ) minZ = z;
	      if (x > maxX) maxX = x;
	      if (y > maxY) maxY = y;
	      if (z > maxZ) maxZ = z;
	    }
	    this.min.set(minX, minY, minZ);
	    this.max.set(maxX, maxY, maxZ);
	    return this;
	  },
	  setFromPoints: function (points) {
	    this.makeEmpty();
	    for (var i = 0, il = points.length; i < il; i++) {
	      this.expandByPoint(points[i]);
	    }
	    return this;
	  },
	  setFromCenterAndSize: function (center, size) {
	    var halfSize = _vector$1.copy(size).multiplyScalar(0.5);
	    this.min.copy(center).sub(halfSize);
	    this.max.copy(center).add(halfSize);
	    return this;
	  },
	  setFromObject: function (object) {
	    this.makeEmpty();
	    return this.expandByObject(object);
	  },
	  clone: function () {
	    return new this.constructor().copy(this);
	  },
	  copy: function (box) {
	    this.min.copy(box.min);
	    this.max.copy(box.max);
	    return this;
	  },
	  makeEmpty: function () {
	    this.min.x = this.min.y = this.min.z = +Infinity;
	    this.max.x = this.max.y = this.max.z = -Infinity;
	    return this;
	  },
	  isEmpty: function () {
	    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
	  },
	  getCenter: function (target) {
	    if (target === undefined) {
	      console.warn("THREE.Box3: .getCenter() target is now required");
	      target = new Vector3();
	    }
	    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
	  },
	  getSize: function (target) {
	    if (target === undefined) {
	      console.warn("THREE.Box3: .getSize() target is now required");
	      target = new Vector3();
	    }
	    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
	  },
	  expandByPoint: function (point) {
	    this.min.min(point);
	    this.max.max(point);
	    return this;
	  },
	  expandByVector: function (vector) {
	    this.min.sub(vector);
	    this.max.add(vector);
	    return this;
	  },
	  expandByScalar: function (scalar) {
	    this.min.addScalar(-scalar);
	    this.max.addScalar(scalar);
	    return this;
	  },
	  expandByObject: function (object) {
	    object.updateWorldMatrix(false, false);
	    var geometry = object.geometry;
	    if (geometry !== undefined) {
	      if (geometry.boundingBox === null) {
	        geometry.computeBoundingBox();
	      }
	      _box.copy(geometry.boundingBox);
	      _box.applyMatrix4(object.matrixWorld);
	      this.union(_box);
	    }
	    var children = object.children;
	    for (var i = 0, l = children.length; i < l; i++) {
	      this.expandByObject(children[i]);
	    }
	    return this;
	  },
	  containsPoint: function (point) {
	    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;
	  },
	  containsBox: function (box) {
	    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
	  },
	  getParameter: function (point, target) {
	    if (target === undefined) {
	      console.warn("THREE.Box3: .getParameter() target is now required");
	      target = new Vector3();
	    }
	    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
	  },
	  intersectsBox: function (box) {
	    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
	  },
	  intersectsSphere: function (sphere) {
	    this.clampPoint(sphere.center, _vector$1);
	    return _vector$1.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
	  },
	  intersectsPlane: function (plane) {
	    var min, max;
	    if (plane.normal.x > 0) {
	      min = plane.normal.x * this.min.x;
	      max = plane.normal.x * this.max.x;
	    } else {
	      min = plane.normal.x * this.max.x;
	      max = plane.normal.x * this.min.x;
	    }
	    if (plane.normal.y > 0) {
	      min += plane.normal.y * this.min.y;
	      max += plane.normal.y * this.max.y;
	    } else {
	      min += plane.normal.y * this.max.y;
	      max += plane.normal.y * this.min.y;
	    }
	    if (plane.normal.z > 0) {
	      min += plane.normal.z * this.min.z;
	      max += plane.normal.z * this.max.z;
	    } else {
	      min += plane.normal.z * this.max.z;
	      max += plane.normal.z * this.min.z;
	    }
	    return min <= -plane.constant && max >= -plane.constant;
	  },
	  intersectsTriangle: function (triangle) {
	    if (this.isEmpty()) {
	      return false;
	    }
	    this.getCenter(_center);
	    _extents.subVectors(this.max, _center);
	    _v0.subVectors(triangle.a, _center);
	    _v1$2.subVectors(triangle.b, _center);
	    _v2.subVectors(triangle.c, _center);
	    _f0.subVectors(_v1$2, _v0);
	    _f1.subVectors(_v2, _v1$2);
	    _f2.subVectors(_v0, _v2);
	    var axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];
	    if (!satForAxes(axes, _v0, _v1$2, _v2, _extents)) {
	      return false;
	    }
	    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
	    if (!satForAxes(axes, _v0, _v1$2, _v2, _extents)) {
	      return false;
	    }
	    _triangleNormal.crossVectors(_f0, _f1);
	    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
	    return satForAxes(axes, _v0, _v1$2, _v2, _extents);
	  },
	  clampPoint: function (point, target) {
	    if (target === undefined) {
	      console.warn("THREE.Box3: .clampPoint() target is now required");
	      target = new Vector3();
	    }
	    return target.copy(point).clamp(this.min, this.max);
	  },
	  distanceToPoint: function (point) {
	    var clampedPoint = _vector$1.copy(point).clamp(this.min, this.max);
	    return clampedPoint.sub(point).length();
	  },
	  getBoundingSphere: function (target) {
	    if (target === undefined) {
	      console.error("THREE.Box3: .getBoundingSphere() target is now required");
	    }
	    this.getCenter(target.center);
	    target.radius = this.getSize(_vector$1).length() * 0.5;
	    return target;
	  },
	  intersect: function (box) {
	    this.min.max(box.min);
	    this.max.min(box.max);
	    if (this.isEmpty()) this.makeEmpty();
	    return this;
	  },
	  union: function (box) {
	    this.min.min(box.min);
	    this.max.max(box.max);
	    return this;
	  },
	  applyMatrix4: function (matrix) {
	    if (this.isEmpty()) return this;
	    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
	    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
	    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
	    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
	    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
	    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
	    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
	    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
	    this.setFromPoints(_points);
	    return this;
	  },
	  translate: function (offset) {
	    this.min.add(offset);
	    this.max.add(offset);
	    return this;
	  },
	  equals: function (box) {
	    return box.min.equals(this.min) && box.max.equals(this.max);
	  }
	});
	function satForAxes(axes, v0, v1, v2, extents) {
	  var i, j;
	  for ((i = 0, j = axes.length - 3); i <= j; i += 3) {
	    _testAxis.fromArray(axes, i);
	    var r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
	    var p0 = v0.dot(_testAxis);
	    var p1 = v1.dot(_testAxis);
	    var p2 = v2.dot(_testAxis);
	    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
	      return false;
	    }
	  }
	  return true;
	}
	var _box$1 = new Box3();
	function Sphere(center, radius) {
	  this.center = center !== undefined ? center : new Vector3();
	  this.radius = radius !== undefined ? radius : 0;
	}
	Object.assign(Sphere.prototype, {
	  set: function (center, radius) {
	    this.center.copy(center);
	    this.radius = radius;
	    return this;
	  },
	  setFromPoints: function (points, optionalCenter) {
	    var center = this.center;
	    if (optionalCenter !== undefined) {
	      center.copy(optionalCenter);
	    } else {
	      _box$1.setFromPoints(points).getCenter(center);
	    }
	    var maxRadiusSq = 0;
	    for (var i = 0, il = points.length; i < il; i++) {
	      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
	    }
	    this.radius = Math.sqrt(maxRadiusSq);
	    return this;
	  },
	  clone: function () {
	    return new this.constructor().copy(this);
	  },
	  copy: function (sphere) {
	    this.center.copy(sphere.center);
	    this.radius = sphere.radius;
	    return this;
	  },
	  empty: function () {
	    return this.radius <= 0;
	  },
	  containsPoint: function (point) {
	    return point.distanceToSquared(this.center) <= this.radius * this.radius;
	  },
	  distanceToPoint: function (point) {
	    return point.distanceTo(this.center) - this.radius;
	  },
	  intersectsSphere: function (sphere) {
	    var radiusSum = this.radius + sphere.radius;
	    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
	  },
	  intersectsBox: function (box) {
	    return box.intersectsSphere(this);
	  },
	  intersectsPlane: function (plane) {
	    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
	  },
	  clampPoint: function (point, target) {
	    var deltaLengthSq = this.center.distanceToSquared(point);
	    if (target === undefined) {
	      console.warn("THREE.Sphere: .clampPoint() target is now required");
	      target = new Vector3();
	    }
	    target.copy(point);
	    if (deltaLengthSq > this.radius * this.radius) {
	      target.sub(this.center).normalize();
	      target.multiplyScalar(this.radius).add(this.center);
	    }
	    return target;
	  },
	  getBoundingBox: function (target) {
	    if (target === undefined) {
	      console.warn("THREE.Sphere: .getBoundingBox() target is now required");
	      target = new Box3();
	    }
	    target.set(this.center, this.center);
	    target.expandByScalar(this.radius);
	    return target;
	  },
	  applyMatrix4: function (matrix) {
	    this.center.applyMatrix4(matrix);
	    this.radius = this.radius * matrix.getMaxScaleOnAxis();
	    return this;
	  },
	  translate: function (offset) {
	    this.center.add(offset);
	    return this;
	  },
	  equals: function (sphere) {
	    return sphere.center.equals(this.center) && sphere.radius === this.radius;
	  }
	});
	var _vector$2 = new Vector3();
	var _segCenter = new Vector3();
	var _segDir = new Vector3();
	var _diff = new Vector3();
	var _edge1 = new Vector3();
	var _edge2 = new Vector3();
	var _normal = new Vector3();
	function Ray(origin, direction) {
	  this.origin = origin !== undefined ? origin : new Vector3();
	  this.direction = direction !== undefined ? direction : new Vector3(0, 0, -1);
	}
	Object.assign(Ray.prototype, {
	  set: function (origin, direction) {
	    this.origin.copy(origin);
	    this.direction.copy(direction);
	    return this;
	  },
	  clone: function () {
	    return new this.constructor().copy(this);
	  },
	  copy: function (ray) {
	    this.origin.copy(ray.origin);
	    this.direction.copy(ray.direction);
	    return this;
	  },
	  at: function (t, target) {
	    if (target === undefined) {
	      console.warn("THREE.Ray: .at() target is now required");
	      target = new Vector3();
	    }
	    return target.copy(this.direction).multiplyScalar(t).add(this.origin);
	  },
	  lookAt: function (v) {
	    this.direction.copy(v).sub(this.origin).normalize();
	    return this;
	  },
	  recast: function (t) {
	    this.origin.copy(this.at(t, _vector$2));
	    return this;
	  },
	  closestPointToPoint: function (point, target) {
	    if (target === undefined) {
	      console.warn("THREE.Ray: .closestPointToPoint() target is now required");
	      target = new Vector3();
	    }
	    target.subVectors(point, this.origin);
	    var directionDistance = target.dot(this.direction);
	    if (directionDistance < 0) {
	      return target.copy(this.origin);
	    }
	    return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
	  },
	  distanceToPoint: function (point) {
	    return Math.sqrt(this.distanceSqToPoint(point));
	  },
	  distanceSqToPoint: function (point) {
	    var directionDistance = _vector$2.subVectors(point, this.origin).dot(this.direction);
	    if (directionDistance < 0) {
	      return this.origin.distanceToSquared(point);
	    }
	    _vector$2.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);
	    return _vector$2.distanceToSquared(point);
	  },
	  distanceSqToSegment: function (v0, v1, optionalPointOnRay, optionalPointOnSegment) {
	    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
	    _segDir.copy(v1).sub(v0).normalize();
	    _diff.copy(this.origin).sub(_segCenter);
	    var segExtent = v0.distanceTo(v1) * 0.5;
	    var a01 = -this.direction.dot(_segDir);
	    var b0 = _diff.dot(this.direction);
	    var b1 = -_diff.dot(_segDir);
	    var c = _diff.lengthSq();
	    var det = Math.abs(1 - a01 * a01);
	    var s0, s1, sqrDist, extDet;
	    if (det > 0) {
	      s0 = a01 * b1 - b0;
	      s1 = a01 * b0 - b1;
	      extDet = segExtent * det;
	      if (s0 >= 0) {
	        if (s1 >= -extDet) {
	          if (s1 <= extDet) {
	            var invDet = 1 / det;
	            s0 *= invDet;
	            s1 *= invDet;
	            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
	          } else {
	            s1 = segExtent;
	            s0 = Math.max(0, -(a01 * s1 + b0));
	            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
	          }
	        } else {
	          s1 = -segExtent;
	          s0 = Math.max(0, -(a01 * s1 + b0));
	          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
	        }
	      } else {
	        if (s1 <= -extDet) {
	          s0 = Math.max(0, -(-a01 * segExtent + b0));
	          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
	          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
	        } else if (s1 <= extDet) {
	          s0 = 0;
	          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
	          sqrDist = s1 * (s1 + 2 * b1) + c;
	        } else {
	          s0 = Math.max(0, -(a01 * segExtent + b0));
	          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
	          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
	        }
	      }
	    } else {
	      s1 = a01 > 0 ? -segExtent : segExtent;
	      s0 = Math.max(0, -(a01 * s1 + b0));
	      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
	    }
	    if (optionalPointOnRay) {
	      optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);
	    }
	    if (optionalPointOnSegment) {
	      optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);
	    }
	    return sqrDist;
	  },
	  intersectSphere: function (sphere, target) {
	    _vector$2.subVectors(sphere.center, this.origin);
	    var tca = _vector$2.dot(this.direction);
	    var d2 = _vector$2.dot(_vector$2) - tca * tca;
	    var radius2 = sphere.radius * sphere.radius;
	    if (d2 > radius2) return null;
	    var thc = Math.sqrt(radius2 - d2);
	    var t0 = tca - thc;
	    var t1 = tca + thc;
	    if (t0 < 0 && t1 < 0) return null;
	    if (t0 < 0) return this.at(t1, target);
	    return this.at(t0, target);
	  },
	  intersectsSphere: function (sphere) {
	    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
	  },
	  distanceToPlane: function (plane) {
	    var denominator = plane.normal.dot(this.direction);
	    if (denominator === 0) {
	      if (plane.distanceToPoint(this.origin) === 0) {
	        return 0;
	      }
	      return null;
	    }
	    var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
	    return t >= 0 ? t : null;
	  },
	  intersectPlane: function (plane, target) {
	    var t = this.distanceToPlane(plane);
	    if (t === null) {
	      return null;
	    }
	    return this.at(t, target);
	  },
	  intersectsPlane: function (plane) {
	    var distToPoint = plane.distanceToPoint(this.origin);
	    if (distToPoint === 0) {
	      return true;
	    }
	    var denominator = plane.normal.dot(this.direction);
	    if (denominator * distToPoint < 0) {
	      return true;
	    }
	    return false;
	  },
	  intersectBox: function (box, target) {
	    var tmin, tmax, tymin, tymax, tzmin, tzmax;
	    var invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
	    var origin = this.origin;
	    if (invdirx >= 0) {
	      tmin = (box.min.x - origin.x) * invdirx;
	      tmax = (box.max.x - origin.x) * invdirx;
	    } else {
	      tmin = (box.max.x - origin.x) * invdirx;
	      tmax = (box.min.x - origin.x) * invdirx;
	    }
	    if (invdiry >= 0) {
	      tymin = (box.min.y - origin.y) * invdiry;
	      tymax = (box.max.y - origin.y) * invdiry;
	    } else {
	      tymin = (box.max.y - origin.y) * invdiry;
	      tymax = (box.min.y - origin.y) * invdiry;
	    }
	    if (tmin > tymax || tymin > tmax) return null;
	    if (tymin > tmin || tmin !== tmin) tmin = tymin;
	    if (tymax < tmax || tmax !== tmax) tmax = tymax;
	    if (invdirz >= 0) {
	      tzmin = (box.min.z - origin.z) * invdirz;
	      tzmax = (box.max.z - origin.z) * invdirz;
	    } else {
	      tzmin = (box.max.z - origin.z) * invdirz;
	      tzmax = (box.min.z - origin.z) * invdirz;
	    }
	    if (tmin > tzmax || tzmin > tmax) return null;
	    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
	    if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
	    if (tmax < 0) return null;
	    return this.at(tmin >= 0 ? tmin : tmax, target);
	  },
	  intersectsBox: function (box) {
	    return this.intersectBox(box, _vector$2) !== null;
	  },
	  intersectTriangle: function (a, b, c, backfaceCulling, target) {
	    _edge1.subVectors(b, a);
	    _edge2.subVectors(c, a);
	    _normal.crossVectors(_edge1, _edge2);
	    var DdN = this.direction.dot(_normal);
	    var sign;
	    if (DdN > 0) {
	      if (backfaceCulling) return null;
	      sign = 1;
	    } else if (DdN < 0) {
	      sign = -1;
	      DdN = -DdN;
	    } else {
	      return null;
	    }
	    _diff.subVectors(this.origin, a);
	    var DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
	    if (DdQxE2 < 0) {
	      return null;
	    }
	    var DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));
	    if (DdE1xQ < 0) {
	      return null;
	    }
	    if (DdQxE2 + DdE1xQ > DdN) {
	      return null;
	    }
	    var QdN = -sign * _diff.dot(_normal);
	    if (QdN < 0) {
	      return null;
	    }
	    return this.at(QdN / DdN, target);
	  },
	  applyMatrix4: function (matrix4) {
	    this.origin.applyMatrix4(matrix4);
	    this.direction.transformDirection(matrix4);
	    return this;
	  },
	  equals: function (ray) {
	    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
	  }
	});
	var _vector1 = new Vector3();
	var _vector2 = new Vector3();
	var _normalMatrix = new Matrix3();
	function Plane(normal, constant) {
	  this.normal = normal !== undefined ? normal : new Vector3(1, 0, 0);
	  this.constant = constant !== undefined ? constant : 0;
	}
	Object.assign(Plane.prototype, {
	  isPlane: true,
	  set: function (normal, constant) {
	    this.normal.copy(normal);
	    this.constant = constant;
	    return this;
	  },
	  setComponents: function (x, y, z, w) {
	    this.normal.set(x, y, z);
	    this.constant = w;
	    return this;
	  },
	  setFromNormalAndCoplanarPoint: function (normal, point) {
	    this.normal.copy(normal);
	    this.constant = -point.dot(this.normal);
	    return this;
	  },
	  setFromCoplanarPoints: function (a, b, c) {
	    var normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();
	    this.setFromNormalAndCoplanarPoint(normal, a);
	    return this;
	  },
	  clone: function () {
	    return new this.constructor().copy(this);
	  },
	  copy: function (plane) {
	    this.normal.copy(plane.normal);
	    this.constant = plane.constant;
	    return this;
	  },
	  normalize: function () {
	    var inverseNormalLength = 1 / this.normal.length();
	    this.normal.multiplyScalar(inverseNormalLength);
	    this.constant *= inverseNormalLength;
	    return this;
	  },
	  negate: function () {
	    this.constant *= -1;
	    this.normal.negate();
	    return this;
	  },
	  distanceToPoint: function (point) {
	    return this.normal.dot(point) + this.constant;
	  },
	  distanceToSphere: function (sphere) {
	    return this.distanceToPoint(sphere.center) - sphere.radius;
	  },
	  projectPoint: function (point, target) {
	    if (target === undefined) {
	      console.warn("THREE.Plane: .projectPoint() target is now required");
	      target = new Vector3();
	    }
	    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);
	  },
	  intersectLine: function (line, target) {
	    if (target === undefined) {
	      console.warn("THREE.Plane: .intersectLine() target is now required");
	      target = new Vector3();
	    }
	    var direction = line.delta(_vector1);
	    var denominator = this.normal.dot(direction);
	    if (denominator === 0) {
	      if (this.distanceToPoint(line.start) === 0) {
	        return target.copy(line.start);
	      }
	      return undefined;
	    }
	    var t = -(line.start.dot(this.normal) + this.constant) / denominator;
	    if (t < 0 || t > 1) {
	      return undefined;
	    }
	    return target.copy(direction).multiplyScalar(t).add(line.start);
	  },
	  intersectsLine: function (line) {
	    var startSign = this.distanceToPoint(line.start);
	    var endSign = this.distanceToPoint(line.end);
	    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
	  },
	  intersectsBox: function (box) {
	    return box.intersectsPlane(this);
	  },
	  intersectsSphere: function (sphere) {
	    return sphere.intersectsPlane(this);
	  },
	  coplanarPoint: function (target) {
	    if (target === undefined) {
	      console.warn("THREE.Plane: .coplanarPoint() target is now required");
	      target = new Vector3();
	    }
	    return target.copy(this.normal).multiplyScalar(-this.constant);
	  },
	  applyMatrix4: function (matrix, optionalNormalMatrix) {
	    var normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
	    var referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
	    var normal = this.normal.applyMatrix3(normalMatrix).normalize();
	    this.constant = -referencePoint.dot(normal);
	    return this;
	  },
	  translate: function (offset) {
	    this.constant -= offset.dot(this.normal);
	    return this;
	  },
	  equals: function (plane) {
	    return plane.normal.equals(this.normal) && plane.constant === this.constant;
	  }
	});
	var _v0$1 = new Vector3();
	var _v1$3 = new Vector3();
	var _v2$1 = new Vector3();
	var _v3 = new Vector3();
	var _vab = new Vector3();
	var _vac = new Vector3();
	var _vbc = new Vector3();
	var _vap = new Vector3();
	var _vbp = new Vector3();
	var _vcp = new Vector3();
	function Triangle(a, b, c) {
	  this.a = a !== undefined ? a : new Vector3();
	  this.b = b !== undefined ? b : new Vector3();
	  this.c = c !== undefined ? c : new Vector3();
	}
	Object.assign(Triangle, {
	  getNormal: function (a, b, c, target) {
	    if (target === undefined) {
	      console.warn("THREE.Triangle: .getNormal() target is now required");
	      target = new Vector3();
	    }
	    target.subVectors(c, b);
	    _v0$1.subVectors(a, b);
	    target.cross(_v0$1);
	    var targetLengthSq = target.lengthSq();
	    if (targetLengthSq > 0) {
	      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
	    }
	    return target.set(0, 0, 0);
	  },
	  getBarycoord: function (point, a, b, c, target) {
	    _v0$1.subVectors(c, a);
	    _v1$3.subVectors(b, a);
	    _v2$1.subVectors(point, a);
	    var dot00 = _v0$1.dot(_v0$1);
	    var dot01 = _v0$1.dot(_v1$3);
	    var dot02 = _v0$1.dot(_v2$1);
	    var dot11 = _v1$3.dot(_v1$3);
	    var dot12 = _v1$3.dot(_v2$1);
	    var denom = dot00 * dot11 - dot01 * dot01;
	    if (target === undefined) {
	      console.warn("THREE.Triangle: .getBarycoord() target is now required");
	      target = new Vector3();
	    }
	    if (denom === 0) {
	      return target.set(-2, -1, -1);
	    }
	    var invDenom = 1 / denom;
	    var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
	    var v = (dot00 * dot12 - dot01 * dot02) * invDenom;
	    return target.set(1 - u - v, v, u);
	  },
	  containsPoint: function (point, a, b, c) {
	    Triangle.getBarycoord(point, a, b, c, _v3);
	    return _v3.x >= 0 && _v3.y >= 0 && _v3.x + _v3.y <= 1;
	  },
	  getUV: function (point, p1, p2, p3, uv1, uv2, uv3, target) {
	    this.getBarycoord(point, p1, p2, p3, _v3);
	    target.set(0, 0);
	    target.addScaledVector(uv1, _v3.x);
	    target.addScaledVector(uv2, _v3.y);
	    target.addScaledVector(uv3, _v3.z);
	    return target;
	  },
	  isFrontFacing: function (a, b, c, direction) {
	    _v0$1.subVectors(c, b);
	    _v1$3.subVectors(a, b);
	    return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
	  }
	});
	Object.assign(Triangle.prototype, {
	  set: function (a, b, c) {
	    this.a.copy(a);
	    this.b.copy(b);
	    this.c.copy(c);
	    return this;
	  },
	  setFromPointsAndIndices: function (points, i0, i1, i2) {
	    this.a.copy(points[i0]);
	    this.b.copy(points[i1]);
	    this.c.copy(points[i2]);
	    return this;
	  },
	  clone: function () {
	    return new this.constructor().copy(this);
	  },
	  copy: function (triangle) {
	    this.a.copy(triangle.a);
	    this.b.copy(triangle.b);
	    this.c.copy(triangle.c);
	    return this;
	  },
	  getArea: function () {
	    _v0$1.subVectors(this.c, this.b);
	    _v1$3.subVectors(this.a, this.b);
	    return _v0$1.cross(_v1$3).length() * 0.5;
	  },
	  getMidpoint: function (target) {
	    if (target === undefined) {
	      console.warn("THREE.Triangle: .getMidpoint() target is now required");
	      target = new Vector3();
	    }
	    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
	  },
	  getNormal: function (target) {
	    return Triangle.getNormal(this.a, this.b, this.c, target);
	  },
	  getPlane: function (target) {
	    if (target === undefined) {
	      console.warn("THREE.Triangle: .getPlane() target is now required");
	      target = new Plane();
	    }
	    return target.setFromCoplanarPoints(this.a, this.b, this.c);
	  },
	  getBarycoord: function (point, target) {
	    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
	  },
	  getUV: function (point, uv1, uv2, uv3, target) {
	    return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);
	  },
	  containsPoint: function (point) {
	    return Triangle.containsPoint(point, this.a, this.b, this.c);
	  },
	  isFrontFacing: function (direction) {
	    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
	  },
	  intersectsBox: function (box) {
	    return box.intersectsTriangle(this);
	  },
	  closestPointToPoint: function (p, target) {
	    if (target === undefined) {
	      console.warn("THREE.Triangle: .closestPointToPoint() target is now required");
	      target = new Vector3();
	    }
	    var a = this.a, b = this.b, c = this.c;
	    var v, w;
	    _vab.subVectors(b, a);
	    _vac.subVectors(c, a);
	    _vap.subVectors(p, a);
	    var d1 = _vab.dot(_vap);
	    var d2 = _vac.dot(_vap);
	    if (d1 <= 0 && d2 <= 0) {
	      return target.copy(a);
	    }
	    _vbp.subVectors(p, b);
	    var d3 = _vab.dot(_vbp);
	    var d4 = _vac.dot(_vbp);
	    if (d3 >= 0 && d4 <= d3) {
	      return target.copy(b);
	    }
	    var vc = d1 * d4 - d3 * d2;
	    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
	      v = d1 / (d1 - d3);
	      return target.copy(a).addScaledVector(_vab, v);
	    }
	    _vcp.subVectors(p, c);
	    var d5 = _vab.dot(_vcp);
	    var d6 = _vac.dot(_vcp);
	    if (d6 >= 0 && d5 <= d6) {
	      return target.copy(c);
	    }
	    var vb = d5 * d2 - d1 * d6;
	    if (vb <= 0 && d2 >= 0 && d6 <= 0) {
	      w = d2 / (d2 - d6);
	      return target.copy(a).addScaledVector(_vac, w);
	    }
	    var va = d3 * d6 - d5 * d4;
	    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
	      _vbc.subVectors(c, b);
	      w = (d4 - d3) / (d4 - d3 + (d5 - d6));
	      return target.copy(b).addScaledVector(_vbc, w);
	    }
	    var denom = 1 / (va + vb + vc);
	    v = vb * denom;
	    w = vc * denom;
	    return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
	  },
	  equals: function (triangle) {
	    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
	  }
	});
	var _colorKeywords = {
	  "aliceblue": 15792383,
	  "antiquewhite": 16444375,
	  "aqua": 65535,
	  "aquamarine": 8388564,
	  "azure": 15794175,
	  "beige": 16119260,
	  "bisque": 16770244,
	  "black": 0,
	  "blanchedalmond": 16772045,
	  "blue": 255,
	  "blueviolet": 9055202,
	  "brown": 10824234,
	  "burlywood": 14596231,
	  "cadetblue": 6266528,
	  "chartreuse": 8388352,
	  "chocolate": 13789470,
	  "coral": 16744272,
	  "cornflowerblue": 6591981,
	  "cornsilk": 16775388,
	  "crimson": 14423100,
	  "cyan": 65535,
	  "darkblue": 139,
	  "darkcyan": 35723,
	  "darkgoldenrod": 12092939,
	  "darkgray": 11119017,
	  "darkgreen": 25600,
	  "darkgrey": 11119017,
	  "darkkhaki": 12433259,
	  "darkmagenta": 9109643,
	  "darkolivegreen": 5597999,
	  "darkorange": 16747520,
	  "darkorchid": 10040012,
	  "darkred": 9109504,
	  "darksalmon": 15308410,
	  "darkseagreen": 9419919,
	  "darkslateblue": 4734347,
	  "darkslategray": 3100495,
	  "darkslategrey": 3100495,
	  "darkturquoise": 52945,
	  "darkviolet": 9699539,
	  "deeppink": 16716947,
	  "deepskyblue": 49151,
	  "dimgray": 6908265,
	  "dimgrey": 6908265,
	  "dodgerblue": 2003199,
	  "firebrick": 11674146,
	  "floralwhite": 16775920,
	  "forestgreen": 2263842,
	  "fuchsia": 16711935,
	  "gainsboro": 14474460,
	  "ghostwhite": 16316671,
	  "gold": 16766720,
	  "goldenrod": 14329120,
	  "gray": 8421504,
	  "green": 32768,
	  "greenyellow": 11403055,
	  "grey": 8421504,
	  "honeydew": 15794160,
	  "hotpink": 16738740,
	  "indianred": 13458524,
	  "indigo": 4915330,
	  "ivory": 16777200,
	  "khaki": 15787660,
	  "lavender": 15132410,
	  "lavenderblush": 16773365,
	  "lawngreen": 8190976,
	  "lemonchiffon": 16775885,
	  "lightblue": 11393254,
	  "lightcoral": 15761536,
	  "lightcyan": 14745599,
	  "lightgoldenrodyellow": 16448210,
	  "lightgray": 13882323,
	  "lightgreen": 9498256,
	  "lightgrey": 13882323,
	  "lightpink": 16758465,
	  "lightsalmon": 16752762,
	  "lightseagreen": 2142890,
	  "lightskyblue": 8900346,
	  "lightslategray": 7833753,
	  "lightslategrey": 7833753,
	  "lightsteelblue": 11584734,
	  "lightyellow": 16777184,
	  "lime": 65280,
	  "limegreen": 3329330,
	  "linen": 16445670,
	  "magenta": 16711935,
	  "maroon": 8388608,
	  "mediumaquamarine": 6737322,
	  "mediumblue": 205,
	  "mediumorchid": 12211667,
	  "mediumpurple": 9662683,
	  "mediumseagreen": 3978097,
	  "mediumslateblue": 8087790,
	  "mediumspringgreen": 64154,
	  "mediumturquoise": 4772300,
	  "mediumvioletred": 13047173,
	  "midnightblue": 1644912,
	  "mintcream": 16121850,
	  "mistyrose": 16770273,
	  "moccasin": 16770229,
	  "navajowhite": 16768685,
	  "navy": 128,
	  "oldlace": 16643558,
	  "olive": 8421376,
	  "olivedrab": 7048739,
	  "orange": 16753920,
	  "orangered": 16729344,
	  "orchid": 14315734,
	  "palegoldenrod": 15657130,
	  "palegreen": 10025880,
	  "paleturquoise": 11529966,
	  "palevioletred": 14381203,
	  "papayawhip": 16773077,
	  "peachpuff": 16767673,
	  "peru": 13468991,
	  "pink": 16761035,
	  "plum": 14524637,
	  "powderblue": 11591910,
	  "purple": 8388736,
	  "rebeccapurple": 6697881,
	  "red": 16711680,
	  "rosybrown": 12357519,
	  "royalblue": 4286945,
	  "saddlebrown": 9127187,
	  "salmon": 16416882,
	  "sandybrown": 16032864,
	  "seagreen": 3050327,
	  "seashell": 16774638,
	  "sienna": 10506797,
	  "silver": 12632256,
	  "skyblue": 8900331,
	  "slateblue": 6970061,
	  "slategray": 7372944,
	  "slategrey": 7372944,
	  "snow": 16775930,
	  "springgreen": 65407,
	  "steelblue": 4620980,
	  "tan": 13808780,
	  "teal": 32896,
	  "thistle": 14204888,
	  "tomato": 16737095,
	  "turquoise": 4251856,
	  "violet": 15631086,
	  "wheat": 16113331,
	  "white": 16777215,
	  "whitesmoke": 16119285,
	  "yellow": 16776960,
	  "yellowgreen": 10145074
	};
	var _hslA = {
	  h: 0,
	  s: 0,
	  l: 0
	};
	var _hslB = {
	  h: 0,
	  s: 0,
	  l: 0
	};
	function Color(r, g, b) {
	  if (g === undefined && b === undefined) {
	    return this.set(r);
	  }
	  return this.setRGB(r, g, b);
	}
	function hue2rgb(p, q, t) {
	  if (t < 0) t += 1;
	  if (t > 1) t -= 1;
	  if (t < 1 / 6) return p + (q - p) * 6 * t;
	  if (t < 1 / 2) return q;
	  if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
	  return p;
	}
	function SRGBToLinear(c) {
	  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
	}
	function LinearToSRGB(c) {
	  return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
	}
	Object.assign(Color.prototype, {
	  isColor: true,
	  r: 1,
	  g: 1,
	  b: 1,
	  set: function (value) {
	    if (value && value.isColor) {
	      this.copy(value);
	    } else if (typeof value === "number") {
	      this.setHex(value);
	    } else if (typeof value === "string") {
	      this.setStyle(value);
	    }
	    return this;
	  },
	  setScalar: function (scalar) {
	    this.r = scalar;
	    this.g = scalar;
	    this.b = scalar;
	    return this;
	  },
	  setHex: function (hex) {
	    hex = Math.floor(hex);
	    this.r = (hex >> 16 & 255) / 255;
	    this.g = (hex >> 8 & 255) / 255;
	    this.b = (hex & 255) / 255;
	    return this;
	  },
	  setRGB: function (r, g, b) {
	    this.r = r;
	    this.g = g;
	    this.b = b;
	    return this;
	  },
	  setHSL: function (h, s, l) {
	    h = MathUtils.euclideanModulo(h, 1);
	    s = MathUtils.clamp(s, 0, 1);
	    l = MathUtils.clamp(l, 0, 1);
	    if (s === 0) {
	      this.r = this.g = this.b = l;
	    } else {
	      var p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
	      var q = 2 * l - p;
	      this.r = hue2rgb(q, p, h + 1 / 3);
	      this.g = hue2rgb(q, p, h);
	      this.b = hue2rgb(q, p, h - 1 / 3);
	    }
	    return this;
	  },
	  setStyle: function (style) {
	    function handleAlpha(string) {
	      if (string === undefined) return;
	      if (parseFloat(string) < 1) {
	        console.warn("THREE.Color: Alpha component of " + style + " will be ignored.");
	      }
	    }
	    var m;
	    if (m = (/^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/).exec(style)) {
	      var color;
	      var name = m[1];
	      var components = m[2];
	      switch (name) {
	        case "rgb":
	        case "rgba":
	          if (color = (/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/).exec(components)) {
	            this.r = Math.min(255, parseInt(color[1], 10)) / 255;
	            this.g = Math.min(255, parseInt(color[2], 10)) / 255;
	            this.b = Math.min(255, parseInt(color[3], 10)) / 255;
	            handleAlpha(color[5]);
	            return this;
	          }
	          if (color = (/^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/).exec(components)) {
	            this.r = Math.min(100, parseInt(color[1], 10)) / 100;
	            this.g = Math.min(100, parseInt(color[2], 10)) / 100;
	            this.b = Math.min(100, parseInt(color[3], 10)) / 100;
	            handleAlpha(color[5]);
	            return this;
	          }
	          break;
	        case "hsl":
	        case "hsla":
	          if (color = (/^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/).exec(components)) {
	            var h = parseFloat(color[1]) / 360;
	            var s = parseInt(color[2], 10) / 100;
	            var l = parseInt(color[3], 10) / 100;
	            handleAlpha(color[5]);
	            return this.setHSL(h, s, l);
	          }
	          break;
	      }
	    } else if (m = (/^\#([A-Fa-f0-9]+)$/).exec(style)) {
	      var hex = m[1];
	      var size = hex.length;
	      if (size === 3) {
	        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
	        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
	        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
	        return this;
	      } else if (size === 6) {
	        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
	        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
	        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
	        return this;
	      }
	    }
	    if (style && style.length > 0) {
	      return this.setColorName(style);
	    }
	    return this;
	  },
	  setColorName: function (style) {
	    var hex = _colorKeywords[style];
	    if (hex !== undefined) {
	      this.setHex(hex);
	    } else {
	      console.warn("THREE.Color: Unknown color " + style);
	    }
	    return this;
	  },
	  clone: function () {
	    return new this.constructor(this.r, this.g, this.b);
	  },
	  copy: function (color) {
	    this.r = color.r;
	    this.g = color.g;
	    this.b = color.b;
	    return this;
	  },
	  copyGammaToLinear: function (color, gammaFactor) {
	    if (gammaFactor === undefined) gammaFactor = 2;
	    this.r = Math.pow(color.r, gammaFactor);
	    this.g = Math.pow(color.g, gammaFactor);
	    this.b = Math.pow(color.b, gammaFactor);
	    return this;
	  },
	  copyLinearToGamma: function (color, gammaFactor) {
	    if (gammaFactor === undefined) gammaFactor = 2;
	    var safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
	    this.r = Math.pow(color.r, safeInverse);
	    this.g = Math.pow(color.g, safeInverse);
	    this.b = Math.pow(color.b, safeInverse);
	    return this;
	  },
	  convertGammaToLinear: function (gammaFactor) {
	    this.copyGammaToLinear(this, gammaFactor);
	    return this;
	  },
	  convertLinearToGamma: function (gammaFactor) {
	    this.copyLinearToGamma(this, gammaFactor);
	    return this;
	  },
	  copySRGBToLinear: function (color) {
	    this.r = SRGBToLinear(color.r);
	    this.g = SRGBToLinear(color.g);
	    this.b = SRGBToLinear(color.b);
	    return this;
	  },
	  copyLinearToSRGB: function (color) {
	    this.r = LinearToSRGB(color.r);
	    this.g = LinearToSRGB(color.g);
	    this.b = LinearToSRGB(color.b);
	    return this;
	  },
	  convertSRGBToLinear: function () {
	    this.copySRGBToLinear(this);
	    return this;
	  },
	  convertLinearToSRGB: function () {
	    this.copyLinearToSRGB(this);
	    return this;
	  },
	  getHex: function () {
	    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;
	  },
	  getHexString: function () {
	    return ("000000" + this.getHex().toString(16)).slice(-6);
	  },
	  getHSL: function (target) {
	    if (target === undefined) {
	      console.warn("THREE.Color: .getHSL() target is now required");
	      target = {
	        h: 0,
	        s: 0,
	        l: 0
	      };
	    }
	    var r = this.r, g = this.g, b = this.b;
	    var max = Math.max(r, g, b);
	    var min = Math.min(r, g, b);
	    var hue, saturation;
	    var lightness = (min + max) / 2;
	    if (min === max) {
	      hue = 0;
	      saturation = 0;
	    } else {
	      var delta = max - min;
	      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
	      switch (max) {
	        case r:
	          hue = (g - b) / delta + (g < b ? 6 : 0);
	          break;
	        case g:
	          hue = (b - r) / delta + 2;
	          break;
	        case b:
	          hue = (r - g) / delta + 4;
	          break;
	      }
	      hue /= 6;
	    }
	    target.h = hue;
	    target.s = saturation;
	    target.l = lightness;
	    return target;
	  },
	  getStyle: function () {
	    return "rgb(" + (this.r * 255 | 0) + "," + (this.g * 255 | 0) + "," + (this.b * 255 | 0) + ")";
	  },
	  offsetHSL: function (h, s, l) {
	    this.getHSL(_hslA);
	    _hslA.h += h;
	    _hslA.s += s;
	    _hslA.l += l;
	    this.setHSL(_hslA.h, _hslA.s, _hslA.l);
	    return this;
	  },
	  add: function (color) {
	    this.r += color.r;
	    this.g += color.g;
	    this.b += color.b;
	    return this;
	  },
	  addColors: function (color1, color2) {
	    this.r = color1.r + color2.r;
	    this.g = color1.g + color2.g;
	    this.b = color1.b + color2.b;
	    return this;
	  },
	  addScalar: function (s) {
	    this.r += s;
	    this.g += s;
	    this.b += s;
	    return this;
	  },
	  sub: function (color) {
	    this.r = Math.max(0, this.r - color.r);
	    this.g = Math.max(0, this.g - color.g);
	    this.b = Math.max(0, this.b - color.b);
	    return this;
	  },
	  multiply: function (color) {
	    this.r *= color.r;
	    this.g *= color.g;
	    this.b *= color.b;
	    return this;
	  },
	  multiplyScalar: function (s) {
	    this.r *= s;
	    this.g *= s;
	    this.b *= s;
	    return this;
	  },
	  lerp: function (color, alpha) {
	    this.r += (color.r - this.r) * alpha;
	    this.g += (color.g - this.g) * alpha;
	    this.b += (color.b - this.b) * alpha;
	    return this;
	  },
	  lerpHSL: function (color, alpha) {
	    this.getHSL(_hslA);
	    color.getHSL(_hslB);
	    var h = MathUtils.lerp(_hslA.h, _hslB.h, alpha);
	    var s = MathUtils.lerp(_hslA.s, _hslB.s, alpha);
	    var l = MathUtils.lerp(_hslA.l, _hslB.l, alpha);
	    this.setHSL(h, s, l);
	    return this;
	  },
	  equals: function (c) {
	    return c.r === this.r && c.g === this.g && c.b === this.b;
	  },
	  fromArray: function (array, offset) {
	    if (offset === undefined) offset = 0;
	    this.r = array[offset];
	    this.g = array[offset + 1];
	    this.b = array[offset + 2];
	    return this;
	  },
	  toArray: function (array, offset) {
	    if (array === undefined) array = [];
	    if (offset === undefined) offset = 0;
	    array[offset] = this.r;
	    array[offset + 1] = this.g;
	    array[offset + 2] = this.b;
	    return array;
	  },
	  toJSON: function () {
	    return this.getHex();
	  }
	});
	Color.NAMES = _colorKeywords;
	function Face3(a, b, c, normal, color, materialIndex) {
	  this.a = a;
	  this.b = b;
	  this.c = c;
	  this.normal = normal && normal.isVector3 ? normal : new Vector3();
	  this.vertexNormals = Array.isArray(normal) ? normal : [];
	  this.color = color && color.isColor ? color : new Color();
	  this.vertexColors = Array.isArray(color) ? color : [];
	  this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
	}
	Object.assign(Face3.prototype, {
	  clone: function () {
	    return new this.constructor().copy(this);
	  },
	  copy: function (source) {
	    this.a = source.a;
	    this.b = source.b;
	    this.c = source.c;
	    this.normal.copy(source.normal);
	    this.color.copy(source.color);
	    this.materialIndex = source.materialIndex;
	    for (var i = 0, il = source.vertexNormals.length; i < il; i++) {
	      this.vertexNormals[i] = source.vertexNormals[i].clone();
	    }
	    for (var i = 0, il = source.vertexColors.length; i < il; i++) {
	      this.vertexColors[i] = source.vertexColors[i].clone();
	    }
	    return this;
	  }
	});
	var materialId = 0;
	function Material() {
	  Object.defineProperty(this, "id", {
	    value: materialId++
	  });
	  this.uuid = MathUtils.generateUUID();
	  this.name = "";
	  this.type = "Material";
	  this.fog = true;
	  this.blending = NormalBlending;
	  this.side = FrontSide;
	  this.flatShading = false;
	  this.vertexColors = false;
	  this.opacity = 1;
	  this.transparent = false;
	  this.blendSrc = SrcAlphaFactor;
	  this.blendDst = OneMinusSrcAlphaFactor;
	  this.blendEquation = AddEquation;
	  this.blendSrcAlpha = null;
	  this.blendDstAlpha = null;
	  this.blendEquationAlpha = null;
	  this.depthFunc = LessEqualDepth;
	  this.depthTest = true;
	  this.depthWrite = true;
	  this.stencilWriteMask = 255;
	  this.stencilFunc = AlwaysStencilFunc;
	  this.stencilRef = 0;
	  this.stencilFuncMask = 255;
	  this.stencilFail = KeepStencilOp;
	  this.stencilZFail = KeepStencilOp;
	  this.stencilZPass = KeepStencilOp;
	  this.stencilWrite = false;
	  this.clippingPlanes = null;
	  this.clipIntersection = false;
	  this.clipShadows = false;
	  this.shadowSide = null;
	  this.colorWrite = true;
	  this.precision = null;
	  this.polygonOffset = false;
	  this.polygonOffsetFactor = 0;
	  this.polygonOffsetUnits = 0;
	  this.dithering = false;
	  this.alphaTest = 0;
	  this.premultipliedAlpha = false;
	  this.visible = true;
	  this.toneMapped = true;
	  this.userData = {};
	  this.version = 0;
	}
	Material.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
	  constructor: Material,
	  isMaterial: true,
	  onBeforeCompile: function () {},
	  setValues: function (values) {
	    if (values === undefined) return;
	    for (var key in values) {
	      var newValue = values[key];
	      if (newValue === undefined) {
	        console.warn("THREE.Material: '" + key + "' parameter is undefined.");
	        continue;
	      }
	      if (key === "shading") {
	        console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
	        this.flatShading = newValue === FlatShading ? true : false;
	        continue;
	      }
	      var currentValue = this[key];
	      if (currentValue === undefined) {
	        console.warn("THREE." + this.type + ": '" + key + "' is not a property of this material.");
	        continue;
	      }
	      if (currentValue && currentValue.isColor) {
	        currentValue.set(newValue);
	      } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
	        currentValue.copy(newValue);
	      } else {
	        this[key] = newValue;
	      }
	    }
	  },
	  toJSON: function (meta) {
	    var isRoot = meta === undefined || typeof meta === "string";
	    if (isRoot) {
	      meta = {
	        textures: {},
	        images: {}
	      };
	    }
	    var data = {
	      metadata: {
	        version: 4.5,
	        type: "Material",
	        generator: "Material.toJSON"
	      }
	    };
	    data.uuid = this.uuid;
	    data.type = this.type;
	    if (this.name !== "") data.name = this.name;
	    if (this.color && this.color.isColor) data.color = this.color.getHex();
	    if (this.roughness !== undefined) data.roughness = this.roughness;
	    if (this.metalness !== undefined) data.metalness = this.metalness;
	    if (this.sheen && this.sheen.isColor) data.sheen = this.sheen.getHex();
	    if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
	    if (this.emissiveIntensity && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
	    if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
	    if (this.shininess !== undefined) data.shininess = this.shininess;
	    if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
	    if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;
	    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
	      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
	      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
	    }
	    if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
	    if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
	    if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
	    if (this.lightMap && this.lightMap.isTexture) data.lightMap = this.lightMap.toJSON(meta).uuid;
	    if (this.aoMap && this.aoMap.isTexture) {
	      data.aoMap = this.aoMap.toJSON(meta).uuid;
	      data.aoMapIntensity = this.aoMapIntensity;
	    }
	    if (this.bumpMap && this.bumpMap.isTexture) {
	      data.bumpMap = this.bumpMap.toJSON(meta).uuid;
	      data.bumpScale = this.bumpScale;
	    }
	    if (this.normalMap && this.normalMap.isTexture) {
	      data.normalMap = this.normalMap.toJSON(meta).uuid;
	      data.normalMapType = this.normalMapType;
	      data.normalScale = this.normalScale.toArray();
	    }
	    if (this.displacementMap && this.displacementMap.isTexture) {
	      data.displacementMap = this.displacementMap.toJSON(meta).uuid;
	      data.displacementScale = this.displacementScale;
	      data.displacementBias = this.displacementBias;
	    }
	    if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
	    if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
	    if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
	    if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
	    if (this.envMap && this.envMap.isTexture) {
	      data.envMap = this.envMap.toJSON(meta).uuid;
	      data.reflectivity = this.reflectivity;
	      data.refractionRatio = this.refractionRatio;
	      if (this.combine !== undefined) data.combine = this.combine;
	      if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
	    }
	    if (this.gradientMap && this.gradientMap.isTexture) {
	      data.gradientMap = this.gradientMap.toJSON(meta).uuid;
	    }
	    if (this.size !== undefined) data.size = this.size;
	    if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
	    if (this.blending !== NormalBlending) data.blending = this.blending;
	    if (this.flatShading === true) data.flatShading = this.flatShading;
	    if (this.side !== FrontSide) data.side = this.side;
	    if (this.vertexColors) data.vertexColors = true;
	    if (this.opacity < 1) data.opacity = this.opacity;
	    if (this.transparent === true) data.transparent = this.transparent;
	    data.depthFunc = this.depthFunc;
	    data.depthTest = this.depthTest;
	    data.depthWrite = this.depthWrite;
	    data.stencilWrite = this.stencilWrite;
	    data.stencilWriteMask = this.stencilWriteMask;
	    data.stencilFunc = this.stencilFunc;
	    data.stencilRef = this.stencilRef;
	    data.stencilFuncMask = this.stencilFuncMask;
	    data.stencilFail = this.stencilFail;
	    data.stencilZFail = this.stencilZFail;
	    data.stencilZPass = this.stencilZPass;
	    if (this.rotation && this.rotation !== 0) data.rotation = this.rotation;
	    if (this.polygonOffset === true) data.polygonOffset = true;
	    if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
	    if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
	    if (this.linewidth && this.linewidth !== 1) data.linewidth = this.linewidth;
	    if (this.dashSize !== undefined) data.dashSize = this.dashSize;
	    if (this.gapSize !== undefined) data.gapSize = this.gapSize;
	    if (this.scale !== undefined) data.scale = this.scale;
	    if (this.dithering === true) data.dithering = true;
	    if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
	    if (this.premultipliedAlpha === true) data.premultipliedAlpha = this.premultipliedAlpha;
	    if (this.wireframe === true) data.wireframe = this.wireframe;
	    if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
	    if (this.wireframeLinecap !== "round") data.wireframeLinecap = this.wireframeLinecap;
	    if (this.wireframeLinejoin !== "round") data.wireframeLinejoin = this.wireframeLinejoin;
	    if (this.morphTargets === true) data.morphTargets = true;
	    if (this.morphNormals === true) data.morphNormals = true;
	    if (this.skinning === true) data.skinning = true;
	    if (this.visible === false) data.visible = false;
	    if (this.toneMapped === false) data.toneMapped = false;
	    if (JSON.stringify(this.userData) !== "{}") data.userData = this.userData;
	    function extractFromCache(cache) {
	      var values = [];
	      for (var key in cache) {
	        var data = cache[key];
	        delete data.metadata;
	        values.push(data);
	      }
	      return values;
	    }
	    if (isRoot) {
	      var textures = extractFromCache(meta.textures);
	      var images = extractFromCache(meta.images);
	      if (textures.length > 0) data.textures = textures;
	      if (images.length > 0) data.images = images;
	    }
	    return data;
	  },
	  clone: function () {
	    return new this.constructor().copy(this);
	  },
	  copy: function (source) {
	    this.name = source.name;
	    this.fog = source.fog;
	    this.blending = source.blending;
	    this.side = source.side;
	    this.flatShading = source.flatShading;
	    this.vertexColors = source.vertexColors;
	    this.opacity = source.opacity;
	    this.transparent = source.transparent;
	    this.blendSrc = source.blendSrc;
	    this.blendDst = source.blendDst;
	    this.blendEquation = source.blendEquation;
	    this.blendSrcAlpha = source.blendSrcAlpha;
	    this.blendDstAlpha = source.blendDstAlpha;
	    this.blendEquationAlpha = source.blendEquationAlpha;
	    this.depthFunc = source.depthFunc;
	    this.depthTest = source.depthTest;
	    this.depthWrite = source.depthWrite;
	    this.stencilWriteMask = source.stencilWriteMask;
	    this.stencilFunc = source.stencilFunc;
	    this.stencilRef = source.stencilRef;
	    this.stencilFuncMask = source.stencilFuncMask;
	    this.stencilFail = source.stencilFail;
	    this.stencilZFail = source.stencilZFail;
	    this.stencilZPass = source.stencilZPass;
	    this.stencilWrite = source.stencilWrite;
	    var srcPlanes = source.clippingPlanes, dstPlanes = null;
	    if (srcPlanes !== null) {
	      var n = srcPlanes.length;
	      dstPlanes = new Array(n);
	      for (var i = 0; i !== n; ++i) dstPlanes[i] = srcPlanes[i].clone();
	    }
	    this.clippingPlanes = dstPlanes;
	    this.clipIntersection = source.clipIntersection;
	    this.clipShadows = source.clipShadows;
	    this.shadowSide = source.shadowSide;
	    this.colorWrite = source.colorWrite;
	    this.precision = source.precision;
	    this.polygonOffset = source.polygonOffset;
	    this.polygonOffsetFactor = source.polygonOffsetFactor;
	    this.polygonOffsetUnits = source.polygonOffsetUnits;
	    this.dithering = source.dithering;
	    this.alphaTest = source.alphaTest;
	    this.premultipliedAlpha = source.premultipliedAlpha;
	    this.visible = source.visible;
	    this.toneMapped = source.toneMapped;
	    this.userData = JSON.parse(JSON.stringify(source.userData));
	    return this;
	  },
	  dispose: function () {
	    this.dispatchEvent({
	      type: "dispose"
	    });
	  }
	});
	Object.defineProperty(Material.prototype, "needsUpdate", {
	  set: function (value) {
	    if (value === true) this.version++;
	  }
	});
	function MeshBasicMaterial(parameters) {
	  Material.call(this);
	  this.type = "MeshBasicMaterial";
	  this.color = new Color(16777215);
	  this.map = null;
	  this.lightMap = null;
	  this.lightMapIntensity = 1;
	  this.aoMap = null;
	  this.aoMapIntensity = 1;
	  this.specularMap = null;
	  this.alphaMap = null;
	  this.envMap = null;
	  this.combine = MultiplyOperation;
	  this.reflectivity = 1;
	  this.refractionRatio = 0.98;
	  this.wireframe = false;
	  this.wireframeLinewidth = 1;
	  this.wireframeLinecap = "round";
	  this.wireframeLinejoin = "round";
	  this.skinning = false;
	  this.morphTargets = false;
	  this.setValues(parameters);
	}
	MeshBasicMaterial.prototype = Object.create(Material.prototype);
	MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
	MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
	MeshBasicMaterial.prototype.copy = function (source) {
	  Material.prototype.copy.call(this, source);
	  this.color.copy(source.color);
	  this.map = source.map;
	  this.lightMap = source.lightMap;
	  this.lightMapIntensity = source.lightMapIntensity;
	  this.aoMap = source.aoMap;
	  this.aoMapIntensity = source.aoMapIntensity;
	  this.specularMap = source.specularMap;
	  this.alphaMap = source.alphaMap;
	  this.envMap = source.envMap;
	  this.combine = source.combine;
	  this.reflectivity = source.reflectivity;
	  this.refractionRatio = source.refractionRatio;
	  this.wireframe = source.wireframe;
	  this.wireframeLinewidth = source.wireframeLinewidth;
	  this.wireframeLinecap = source.wireframeLinecap;
	  this.wireframeLinejoin = source.wireframeLinejoin;
	  this.skinning = source.skinning;
	  this.morphTargets = source.morphTargets;
	  return this;
	};
	var _vector$3 = new Vector3();
	function BufferAttribute(array, itemSize, normalized) {
	  if (Array.isArray(array)) {
	    throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
	  }
	  this.name = "";
	  this.array = array;
	  this.itemSize = itemSize;
	  this.count = array !== undefined ? array.length / itemSize : 0;
	  this.normalized = normalized === true;
	  this.usage = StaticDrawUsage;
	  this.updateRange = {
	    offset: 0,
	    count: -1
	  };
	  this.version = 0;
	}
	Object.defineProperty(BufferAttribute.prototype, "needsUpdate", {
	  set: function (value) {
	    if (value === true) this.version++;
	  }
	});
	Object.assign(BufferAttribute.prototype, {
	  isBufferAttribute: true,
	  onUploadCallback: function () {},
	  setUsage: function (value) {
	    this.usage = value;
	    return this;
	  },
	  copy: function (source) {
	    this.name = source.name;
	    this.array = new source.array.constructor(source.array);
	    this.itemSize = source.itemSize;
	    this.count = source.count;
	    this.normalized = source.normalized;
	    this.usage = source.usage;
	    return this;
	  },
	  copyAt: function (index1, attribute, index2) {
	    index1 *= this.itemSize;
	    index2 *= attribute.itemSize;
	    for (var i = 0, l = this.itemSize; i < l; i++) {
	      this.array[index1 + i] = attribute.array[index2 + i];
	    }
	    return this;
	  },
	  copyArray: function (array) {
	    this.array.set(array);
	    return this;
	  },
	  copyColorsArray: function (colors) {
	    var array = this.array, offset = 0;
	    for (var i = 0, l = colors.length; i < l; i++) {
	      var color = colors[i];
	      if (color === undefined) {
	        console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i);
	        color = new Color();
	      }
	      array[offset++] = color.r;
	      array[offset++] = color.g;
	      array[offset++] = color.b;
	    }
	    return this;
	  },
	  copyVector2sArray: function (vectors) {
	    var array = this.array, offset = 0;
	    for (var i = 0, l = vectors.length; i < l; i++) {
	      var vector = vectors[i];
	      if (vector === undefined) {
	        console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i);
	        vector = new Vector2();
	      }
	      array[offset++] = vector.x;
	      array[offset++] = vector.y;
	    }
	    return this;
	  },
	  copyVector3sArray: function (vectors) {
	    var array = this.array, offset = 0;
	    for (var i = 0, l = vectors.length; i < l; i++) {
	      var vector = vectors[i];
	      if (vector === undefined) {
	        console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i);
	        vector = new Vector3();
	      }
	      array[offset++] = vector.x;
	      array[offset++] = vector.y;
	      array[offset++] = vector.z;
	    }
	    return this;
	  },
	  copyVector4sArray: function (vectors) {
	    var array = this.array, offset = 0;
	    for (var i = 0, l = vectors.length; i < l; i++) {
	      var vector = vectors[i];
	      if (vector === undefined) {
	        console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i);
	        vector = new Vector4();
	      }
	      array[offset++] = vector.x;
	      array[offset++] = vector.y;
	      array[offset++] = vector.z;
	      array[offset++] = vector.w;
	    }
	    return this;
	  },
	  applyMatrix3: function (m) {
	    for (var i = 0, l = this.count; i < l; i++) {
	      _vector$3.x = this.getX(i);
	      _vector$3.y = this.getY(i);
	      _vector$3.z = this.getZ(i);
	      _vector$3.applyMatrix3(m);
	      this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
	    }
	    return this;
	  },
	  applyMatrix4: function (m) {
	    for (var i = 0, l = this.count; i < l; i++) {
	      _vector$3.x = this.getX(i);
	      _vector$3.y = this.getY(i);
	      _vector$3.z = this.getZ(i);
	      _vector$3.applyMatrix4(m);
	      this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
	    }
	    return this;
	  },
	  applyNormalMatrix: function (m) {
	    for (var i = 0, l = this.count; i < l; i++) {
	      _vector$3.x = this.getX(i);
	      _vector$3.y = this.getY(i);
	      _vector$3.z = this.getZ(i);
	      _vector$3.applyNormalMatrix(m);
	      this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
	    }
	    return this;
	  },
	  transformDirection: function (m) {
	    for (var i = 0, l = this.count; i < l; i++) {
	      _vector$3.x = this.getX(i);
	      _vector$3.y = this.getY(i);
	      _vector$3.z = this.getZ(i);
	      _vector$3.transformDirection(m);
	      this.setXYZ(i, _vector$3.x, _vector$3.y, _vector$3.z);
	    }
	    return this;
	  },
	  set: function (value, offset) {
	    if (offset === undefined) offset = 0;
	    this.array.set(value, offset);
	    return this;
	  },
	  getX: function (index) {
	    return this.array[index * this.itemSize];
	  },
	  setX: function (index, x) {
	    this.array[index * this.itemSize] = x;
	    return this;
	  },
	  getY: function (index) {
	    return this.array[index * this.itemSize + 1];
	  },
	  setY: function (index, y) {
	    this.array[index * this.itemSize + 1] = y;
	    return this;
	  },
	  getZ: function (index) {
	    return this.array[index * this.itemSize + 2];
	  },
	  setZ: function (index, z) {
	    this.array[index * this.itemSize + 2] = z;
	    return this;
	  },
	  getW: function (index) {
	    return this.array[index * this.itemSize + 3];
	  },
	  setW: function (index, w) {
	    this.array[index * this.itemSize + 3] = w;
	    return this;
	  },
	  setXY: function (index, x, y) {
	    index *= this.itemSize;
	    this.array[index + 0] = x;
	    this.array[index + 1] = y;
	    return this;
	  },
	  setXYZ: function (index, x, y, z) {
	    index *= this.itemSize;
	    this.array[index + 0] = x;
	    this.array[index + 1] = y;
	    this.array[index + 2] = z;
	    return this;
	  },
	  setXYZW: function (index, x, y, z, w) {
	    index *= this.itemSize;
	    this.array[index + 0] = x;
	    this.array[index + 1] = y;
	    this.array[index + 2] = z;
	    this.array[index + 3] = w;
	    return this;
	  },
	  onUpload: function (callback) {
	    this.onUploadCallback = callback;
	    return this;
	  },
	  clone: function () {
	    return new this.constructor(this.array, this.itemSize).copy(this);
	  },
	  toJSON: function () {
	    return {
	      itemSize: this.itemSize,
	      type: this.array.constructor.name,
	      array: Array.prototype.slice.call(this.array),
	      normalized: this.normalized
	    };
	  }
	});
	function Int8BufferAttribute(array, itemSize, normalized) {
	  BufferAttribute.call(this, new Int8Array(array), itemSize, normalized);
	}
	Int8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
	Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
	function Uint8BufferAttribute(array, itemSize, normalized) {
	  BufferAttribute.call(this, new Uint8Array(array), itemSize, normalized);
	}
	Uint8BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
	Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
	function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
	  BufferAttribute.call(this, new Uint8ClampedArray(array), itemSize, normalized);
	}
	Uint8ClampedBufferAttribute.prototype = Object.create(BufferAttribute.prototype);
	Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
	function Int16BufferAttribute(array, itemSize, normalized) {
	  BufferAttribute.call(this, new Int16Array(array), itemSize, normalized);
	}
	Int16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
	Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
	function Uint16BufferAttribute(array, itemSize, normalized) {
	  BufferAttribute.call(this, new Uint16Array(array), itemSize, normalized);
	}
	Uint16BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
	Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
	function Int32BufferAttribute(array, itemSize, normalized) {
	  BufferAttribute.call(this, new Int32Array(array), itemSize, normalized);
	}
	Int32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
	Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
	function Uint32BufferAttribute(array, itemSize, normalized) {
	  BufferAttribute.call(this, new Uint32Array(array), itemSize, normalized);
	}
	Uint32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
	Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
	function Float32BufferAttribute(array, itemSize, normalized) {
	  BufferAttribute.call(this, new Float32Array(array), itemSize, normalized);
	}
	Float32BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
	Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
	function Float64BufferAttribute(array, itemSize, normalized) {
	  BufferAttribute.call(this, new Float64Array(array), itemSize, normalized);
	}
	Float64BufferAttribute.prototype = Object.create(BufferAttribute.prototype);
	Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
	function DirectGeometry() {
	  this.vertices = [];
	  this.normals = [];
	  this.colors = [];
	  this.uvs = [];
	  this.uvs2 = [];
	  this.groups = [];
	  this.morphTargets = {};
	  this.skinWeights = [];
	  this.skinIndices = [];
	  this.boundingBox = null;
	  this.boundingSphere = null;
	  this.verticesNeedUpdate = false;
	  this.normalsNeedUpdate = false;
	  this.colorsNeedUpdate = false;
	  this.uvsNeedUpdate = false;
	  this.groupsNeedUpdate = false;
	}
	Object.assign(DirectGeometry.prototype, {
	  computeGroups: function (geometry) {
	    var group;
	    var groups = [];
	    var materialIndex = undefined;
	    var faces = geometry.faces;
	    for (var i = 0; i < faces.length; i++) {
	      var face = faces[i];
	      if (face.materialIndex !== materialIndex) {
	        materialIndex = face.materialIndex;
	        if (group !== undefined) {
	          group.count = i * 3 - group.start;
	          groups.push(group);
	        }
	        group = {
	          start: i * 3,
	          materialIndex: materialIndex
	        };
	      }
	    }
	    if (group !== undefined) {
	      group.count = i * 3 - group.start;
	      groups.push(group);
	    }
	    this.groups = groups;
	  },
	  fromGeometry: function (geometry) {
	    var faces = geometry.faces;
	    var vertices = geometry.vertices;
	    var faceVertexUvs = geometry.faceVertexUvs;
	    var hasFaceVertexUv = faceVertexUvs[0] && faceVertexUvs[0].length > 0;
	    var hasFaceVertexUv2 = faceVertexUvs[1] && faceVertexUvs[1].length > 0;
	    var morphTargets = geometry.morphTargets;
	    var morphTargetsLength = morphTargets.length;
	    var morphTargetsPosition;
	    if (morphTargetsLength > 0) {
	      morphTargetsPosition = [];
	      for (var i = 0; i < morphTargetsLength; i++) {
	        morphTargetsPosition[i] = {
	          name: morphTargets[i].name,
	          data: []
	        };
	      }
	      this.morphTargets.position = morphTargetsPosition;
	    }
	    var morphNormals = geometry.morphNormals;
	    var morphNormalsLength = morphNormals.length;
	    var morphTargetsNormal;
	    if (morphNormalsLength > 0) {
	      morphTargetsNormal = [];
	      for (var i = 0; i < morphNormalsLength; i++) {
	        morphTargetsNormal[i] = {
	          name: morphNormals[i].name,
	          data: []
	        };
	      }
	      this.morphTargets.normal = morphTargetsNormal;
	    }
	    var skinIndices = geometry.skinIndices;
	    var skinWeights = geometry.skinWeights;
	    var hasSkinIndices = skinIndices.length === vertices.length;
	    var hasSkinWeights = skinWeights.length === vertices.length;
	    if (vertices.length > 0 && faces.length === 0) {
	      console.error("THREE.DirectGeometry: Faceless geometries are not supported.");
	    }
	    for (var i = 0; i < faces.length; i++) {
	      var face = faces[i];
	      this.vertices.push(vertices[face.a], vertices[face.b], vertices[face.c]);
	      var vertexNormals = face.vertexNormals;
	      if (vertexNormals.length === 3) {
	        this.normals.push(vertexNormals[0], vertexNormals[1], vertexNormals[2]);
	      } else {
	        var normal = face.normal;
	        this.normals.push(normal, normal, normal);
	      }
	      var vertexColors = face.vertexColors;
	      if (vertexColors.length === 3) {
	        this.colors.push(vertexColors[0], vertexColors[1], vertexColors[2]);
	      } else {
	        var color = face.color;
	        this.colors.push(color, color, color);
	      }
	      if (hasFaceVertexUv === true) {
	        var vertexUvs = faceVertexUvs[0][i];
	        if (vertexUvs !== undefined) {
	          this.uvs.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
	        } else {
	          console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", i);
	          this.uvs.push(new Vector2(), new Vector2(), new Vector2());
	        }
	      }
	      if (hasFaceVertexUv2 === true) {
	        var vertexUvs = faceVertexUvs[1][i];
	        if (vertexUvs !== undefined) {
	          this.uvs2.push(vertexUvs[0], vertexUvs[1], vertexUvs[2]);
	        } else {
	          console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", i);
	          this.uvs2.push(new Vector2(), new Vector2(), new Vector2());
	        }
	      }
	      for (var j = 0; j < morphTargetsLength; j++) {
	        var morphTarget = morphTargets[j].vertices;
	        morphTargetsPosition[j].data.push(morphTarget[face.a], morphTarget[face.b], morphTarget[face.c]);
	      }
	      for (var j = 0; j < morphNormalsLength; j++) {
	        var morphNormal = morphNormals[j].vertexNormals[i];
	        morphTargetsNormal[j].data.push(morphNormal.a, morphNormal.b, morphNormal.c);
	      }
	      if (hasSkinIndices) {
	        this.skinIndices.push(skinIndices[face.a], skinIndices[face.b], skinIndices[face.c]);
	      }
	      if (hasSkinWeights) {
	        this.skinWeights.push(skinWeights[face.a], skinWeights[face.b], skinWeights[face.c]);
	      }
	    }
	    this.computeGroups(geometry);
	    this.verticesNeedUpdate = geometry.verticesNeedUpdate;
	    this.normalsNeedUpdate = geometry.normalsNeedUpdate;
	    this.colorsNeedUpdate = geometry.colorsNeedUpdate;
	    this.uvsNeedUpdate = geometry.uvsNeedUpdate;
	    this.groupsNeedUpdate = geometry.groupsNeedUpdate;
	    if (geometry.boundingSphere !== null) {
	      this.boundingSphere = geometry.boundingSphere.clone();
	    }
	    if (geometry.boundingBox !== null) {
	      this.boundingBox = geometry.boundingBox.clone();
	    }
	    return this;
	  }
	});
	function arrayMax(array) {
	  if (array.length === 0) return -Infinity;
	  var max = array[0];
	  for (var i = 1, l = array.length; i < l; ++i) {
	    if (array[i] > max) max = array[i];
	  }
	  return max;
	}
	var _bufferGeometryId = 1;
	var _m1$2 = new Matrix4();
	var _obj = new Object3D();
	var _offset = new Vector3();
	var _box$2 = new Box3();
	var _boxMorphTargets = new Box3();
	var _vector$4 = new Vector3();
	function BufferGeometry() {
	  Object.defineProperty(this, "id", {
	    value: _bufferGeometryId += 2
	  });
	  this.uuid = MathUtils.generateUUID();
	  this.name = "";
	  this.type = "BufferGeometry";
	  this.index = null;
	  this.attributes = {};
	  this.morphAttributes = {};
	  this.morphTargetsRelative = false;
	  this.groups = [];
	  this.boundingBox = null;
	  this.boundingSphere = null;
	  this.drawRange = {
	    start: 0,
	    count: Infinity
	  };
	  this.userData = {};
	}
	BufferGeometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
	  constructor: BufferGeometry,
	  isBufferGeometry: true,
	  getIndex: function () {
	    return this.index;
	  },
	  setIndex: function (index) {
	    if (Array.isArray(index)) {
	      this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
	    } else {
	      this.index = index;
	    }
	  },
	  getAttribute: function (name) {
	    return this.attributes[name];
	  },
	  setAttribute: function (name, attribute) {
	    this.attributes[name] = attribute;
	    return this;
	  },
	  deleteAttribute: function (name) {
	    delete this.attributes[name];
	    return this;
	  },
	  addGroup: function (start, count, materialIndex) {
	    this.groups.push({
	      start: start,
	      count: count,
	      materialIndex: materialIndex !== undefined ? materialIndex : 0
	    });
	  },
	  clearGroups: function () {
	    this.groups = [];
	  },
	  setDrawRange: function (start, count) {
	    this.drawRange.start = start;
	    this.drawRange.count = count;
	  },
	  applyMatrix4: function (matrix) {
	    var position = this.attributes.position;
	    if (position !== undefined) {
	      position.applyMatrix4(matrix);
	      position.needsUpdate = true;
	    }
	    var normal = this.attributes.normal;
	    if (normal !== undefined) {
	      var normalMatrix = new Matrix3().getNormalMatrix(matrix);
	      normal.applyNormalMatrix(normalMatrix);
	      normal.needsUpdate = true;
	    }
	    var tangent = this.attributes.tangent;
	    if (tangent !== undefined) {
	      tangent.transformDirection(matrix);
	      tangent.needsUpdate = true;
	    }
	    if (this.boundingBox !== null) {
	      this.computeBoundingBox();
	    }
	    if (this.boundingSphere !== null) {
	      this.computeBoundingSphere();
	    }
	    return this;
	  },
	  rotateX: function (angle) {
	    _m1$2.makeRotationX(angle);
	    this.applyMatrix4(_m1$2);
	    return this;
	  },
	  rotateY: function (angle) {
	    _m1$2.makeRotationY(angle);
	    this.applyMatrix4(_m1$2);
	    return this;
	  },
	  rotateZ: function (angle) {
	    _m1$2.makeRotationZ(angle);
	    this.applyMatrix4(_m1$2);
	    return this;
	  },
	  translate: function (x, y, z) {
	    _m1$2.makeTranslation(x, y, z);
	    this.applyMatrix4(_m1$2);
	    return this;
	  },
	  scale: function (x, y, z) {
	    _m1$2.makeScale(x, y, z);
	    this.applyMatrix4(_m1$2);
	    return this;
	  },
	  lookAt: function (vector) {
	    _obj.lookAt(vector);
	    _obj.updateMatrix();
	    this.applyMatrix4(_obj.matrix);
	    return this;
	  },
	  center: function () {
	    this.computeBoundingBox();
	    this.boundingBox.getCenter(_offset).negate();
	    this.translate(_offset.x, _offset.y, _offset.z);
	    return this;
	  },
	  setFromObject: function (object) {
	    var geometry = object.geometry;
	    if (object.isPoints || object.isLine) {
	      var positions = new Float32BufferAttribute(geometry.vertices.length * 3, 3);
	      var colors = new Float32BufferAttribute(geometry.colors.length * 3, 3);
	      this.setAttribute("position", positions.copyVector3sArray(geometry.vertices));
	      this.setAttribute("color", colors.copyColorsArray(geometry.colors));
	      if (geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length) {
	        var lineDistances = new Float32BufferAttribute(geometry.lineDistances.length, 1);
	        this.setAttribute("lineDistance", lineDistances.copyArray(geometry.lineDistances));
	      }
	      if (geometry.boundingSphere !== null) {
	        this.boundingSphere = geometry.boundingSphere.clone();
	      }
	      if (geometry.boundingBox !== null) {
	        this.boundingBox = geometry.boundingBox.clone();
	      }
	    } else if (object.isMesh) {
	      if (geometry && geometry.isGeometry) {
	        this.fromGeometry(geometry);
	      }
	    }
	    return this;
	  },
	  setFromPoints: function (points) {
	    var position = [];
	    for (var i = 0, l = points.length; i < l; i++) {
	      var point = points[i];
	      position.push(point.x, point.y, point.z || 0);
	    }
	    this.setAttribute("position", new Float32BufferAttribute(position, 3));
	    return this;
	  },
	  updateFromObject: function (object) {
	    var geometry = object.geometry;
	    if (object.isMesh) {
	      var direct = geometry.__directGeometry;
	      if (geometry.elementsNeedUpdate === true) {
	        direct = undefined;
	        geometry.elementsNeedUpdate = false;
	      }
	      if (direct === undefined) {
	        return this.fromGeometry(geometry);
	      }
	      direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
	      direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
	      direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
	      direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
	      direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
	      geometry.verticesNeedUpdate = false;
	      geometry.normalsNeedUpdate = false;
	      geometry.colorsNeedUpdate = false;
	      geometry.uvsNeedUpdate = false;
	      geometry.groupsNeedUpdate = false;
	      geometry = direct;
	    }
	    var attribute;
	    if (geometry.verticesNeedUpdate === true) {
	      attribute = this.attributes.position;
	      if (attribute !== undefined) {
	        attribute.copyVector3sArray(geometry.vertices);
	        attribute.needsUpdate = true;
	      }
	      geometry.verticesNeedUpdate = false;
	    }
	    if (geometry.normalsNeedUpdate === true) {
	      attribute = this.attributes.normal;
	      if (attribute !== undefined) {
	        attribute.copyVector3sArray(geometry.normals);
	        attribute.needsUpdate = true;
	      }
	      geometry.normalsNeedUpdate = false;
	    }
	    if (geometry.colorsNeedUpdate === true) {
	      attribute = this.attributes.color;
	      if (attribute !== undefined) {
	        attribute.copyColorsArray(geometry.colors);
	        attribute.needsUpdate = true;
	      }
	      geometry.colorsNeedUpdate = false;
	    }
	    if (geometry.uvsNeedUpdate) {
	      attribute = this.attributes.uv;
	      if (attribute !== undefined) {
	        attribute.copyVector2sArray(geometry.uvs);
	        attribute.needsUpdate = true;
	      }
	      geometry.uvsNeedUpdate = false;
	    }
	    if (geometry.lineDistancesNeedUpdate) {
	      attribute = this.attributes.lineDistance;
	      if (attribute !== undefined) {
	        attribute.copyArray(geometry.lineDistances);
	        attribute.needsUpdate = true;
	      }
	      geometry.lineDistancesNeedUpdate = false;
	    }
	    if (geometry.groupsNeedUpdate) {
	      geometry.computeGroups(object.geometry);
	      this.groups = geometry.groups;
	      geometry.groupsNeedUpdate = false;
	    }
	    return this;
	  },
	  fromGeometry: function (geometry) {
	    geometry.__directGeometry = new DirectGeometry().fromGeometry(geometry);
	    return this.fromDirectGeometry(geometry.__directGeometry);
	  },
	  fromDirectGeometry: function (geometry) {
	    var positions = new Float32Array(geometry.vertices.length * 3);
	    this.setAttribute("position", new BufferAttribute(positions, 3).copyVector3sArray(geometry.vertices));
	    if (geometry.normals.length > 0) {
	      var normals = new Float32Array(geometry.normals.length * 3);
	      this.setAttribute("normal", new BufferAttribute(normals, 3).copyVector3sArray(geometry.normals));
	    }
	    if (geometry.colors.length > 0) {
	      var colors = new Float32Array(geometry.colors.length * 3);
	      this.setAttribute("color", new BufferAttribute(colors, 3).copyColorsArray(geometry.colors));
	    }
	    if (geometry.uvs.length > 0) {
	      var uvs = new Float32Array(geometry.uvs.length * 2);
	      this.setAttribute("uv", new BufferAttribute(uvs, 2).copyVector2sArray(geometry.uvs));
	    }
	    if (geometry.uvs2.length > 0) {
	      var uvs2 = new Float32Array(geometry.uvs2.length * 2);
	      this.setAttribute("uv2", new BufferAttribute(uvs2, 2).copyVector2sArray(geometry.uvs2));
	    }
	    this.groups = geometry.groups;
	    for (var name in geometry.morphTargets) {
	      var array = [];
	      var morphTargets = geometry.morphTargets[name];
	      for (var i = 0, l = morphTargets.length; i < l; i++) {
	        var morphTarget = morphTargets[i];
	        var attribute = new Float32BufferAttribute(morphTarget.data.length * 3, 3);
	        attribute.name = morphTarget.name;
	        array.push(attribute.copyVector3sArray(morphTarget.data));
	      }
	      this.morphAttributes[name] = array;
	    }
	    if (geometry.skinIndices.length > 0) {
	      var skinIndices = new Float32BufferAttribute(geometry.skinIndices.length * 4, 4);
	      this.setAttribute("skinIndex", skinIndices.copyVector4sArray(geometry.skinIndices));
	    }
	    if (geometry.skinWeights.length > 0) {
	      var skinWeights = new Float32BufferAttribute(geometry.skinWeights.length * 4, 4);
	      this.setAttribute("skinWeight", skinWeights.copyVector4sArray(geometry.skinWeights));
	    }
	    if (geometry.boundingSphere !== null) {
	      this.boundingSphere = geometry.boundingSphere.clone();
	    }
	    if (geometry.boundingBox !== null) {
	      this.boundingBox = geometry.boundingBox.clone();
	    }
	    return this;
	  },
	  computeBoundingBox: function () {
	    if (this.boundingBox === null) {
	      this.boundingBox = new Box3();
	    }
	    var position = this.attributes.position;
	    var morphAttributesPosition = this.morphAttributes.position;
	    if (position !== undefined) {
	      this.boundingBox.setFromBufferAttribute(position);
	      if (morphAttributesPosition) {
	        for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
	          var morphAttribute = morphAttributesPosition[i];
	          _box$2.setFromBufferAttribute(morphAttribute);
	          if (this.morphTargetsRelative) {
	            _vector$4.addVectors(this.boundingBox.min, _box$2.min);
	            this.boundingBox.expandByPoint(_vector$4);
	            _vector$4.addVectors(this.boundingBox.max, _box$2.max);
	            this.boundingBox.expandByPoint(_vector$4);
	          } else {
	            this.boundingBox.expandByPoint(_box$2.min);
	            this.boundingBox.expandByPoint(_box$2.max);
	          }
	        }
	      }
	    } else {
	      this.boundingBox.makeEmpty();
	    }
	    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
	      console.error("THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.", this);
	    }
	  },
	  computeBoundingSphere: function () {
	    if (this.boundingSphere === null) {
	      this.boundingSphere = new Sphere();
	    }
	    var position = this.attributes.position;
	    var morphAttributesPosition = this.morphAttributes.position;
	    if (position) {
	      var center = this.boundingSphere.center;
	      _box$2.setFromBufferAttribute(position);
	      if (morphAttributesPosition) {
	        for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
	          var morphAttribute = morphAttributesPosition[i];
	          _boxMorphTargets.setFromBufferAttribute(morphAttribute);
	          if (this.morphTargetsRelative) {
	            _vector$4.addVectors(_box$2.min, _boxMorphTargets.min);
	            _box$2.expandByPoint(_vector$4);
	            _vector$4.addVectors(_box$2.max, _boxMorphTargets.max);
	            _box$2.expandByPoint(_vector$4);
	          } else {
	            _box$2.expandByPoint(_boxMorphTargets.min);
	            _box$2.expandByPoint(_boxMorphTargets.max);
	          }
	        }
	      }
	      _box$2.getCenter(center);
	      var maxRadiusSq = 0;
	      for (var i = 0, il = position.count; i < il; i++) {
	        _vector$4.fromBufferAttribute(position, i);
	        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$4));
	      }
	      if (morphAttributesPosition) {
	        for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
	          var morphAttribute = morphAttributesPosition[i];
	          var morphTargetsRelative = this.morphTargetsRelative;
	          for (var j = 0, jl = morphAttribute.count; j < jl; j++) {
	            _vector$4.fromBufferAttribute(morphAttribute, j);
	            if (morphTargetsRelative) {
	              _offset.fromBufferAttribute(position, j);
	              _vector$4.add(_offset);
	            }
	            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$4));
	          }
	        }
	      }
	      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
	      if (isNaN(this.boundingSphere.radius)) {
	        console.error("THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.", this);
	      }
	    }
	  },
	  computeFaceNormals: function () {},
	  computeVertexNormals: function () {
	    var index = this.index;
	    var attributes = this.attributes;
	    if (attributes.position) {
	      var positions = attributes.position.array;
	      if (attributes.normal === undefined) {
	        this.setAttribute("normal", new BufferAttribute(new Float32Array(positions.length), 3));
	      } else {
	        var array = attributes.normal.array;
	        for (var i = 0, il = array.length; i < il; i++) {
	          array[i] = 0;
	        }
	      }
	      var normals = attributes.normal.array;
	      var vA, vB, vC;
	      var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
	      var cb = new Vector3(), ab = new Vector3();
	      if (index) {
	        var indices = index.array;
	        for (var i = 0, il = index.count; i < il; i += 3) {
	          vA = indices[i + 0] * 3;
	          vB = indices[i + 1] * 3;
	          vC = indices[i + 2] * 3;
	          pA.fromArray(positions, vA);
	          pB.fromArray(positions, vB);
	          pC.fromArray(positions, vC);
	          cb.subVectors(pC, pB);
	          ab.subVectors(pA, pB);
	          cb.cross(ab);
	          normals[vA] += cb.x;
	          normals[vA + 1] += cb.y;
	          normals[vA + 2] += cb.z;
	          normals[vB] += cb.x;
	          normals[vB + 1] += cb.y;
	          normals[vB + 2] += cb.z;
	          normals[vC] += cb.x;
	          normals[vC + 1] += cb.y;
	          normals[vC + 2] += cb.z;
	        }
	      } else {
	        for (var i = 0, il = positions.length; i < il; i += 9) {
	          pA.fromArray(positions, i);
	          pB.fromArray(positions, i + 3);
	          pC.fromArray(positions, i + 6);
	          cb.subVectors(pC, pB);
	          ab.subVectors(pA, pB);
	          cb.cross(ab);
	          normals[i] = cb.x;
	          normals[i + 1] = cb.y;
	          normals[i + 2] = cb.z;
	          normals[i + 3] = cb.x;
	          normals[i + 4] = cb.y;
	          normals[i + 5] = cb.z;
	          normals[i + 6] = cb.x;
	          normals[i + 7] = cb.y;
	          normals[i + 8] = cb.z;
	        }
	      }
	      this.normalizeNormals();
	      attributes.normal.needsUpdate = true;
	    }
	  },
	  merge: function (geometry, offset) {
	    if (!(geometry && geometry.isBufferGeometry)) {
	      console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", geometry);
	      return;
	    }
	    if (offset === undefined) {
	      offset = 0;
	      console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. " + "Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.");
	    }
	    var attributes = this.attributes;
	    for (var key in attributes) {
	      if (geometry.attributes[key] === undefined) continue;
	      var attribute1 = attributes[key];
	      var attributeArray1 = attribute1.array;
	      var attribute2 = geometry.attributes[key];
	      var attributeArray2 = attribute2.array;
	      var attributeOffset = attribute2.itemSize * offset;
	      var length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);
	      for (var i = 0, j = attributeOffset; i < length; (i++, j++)) {
	        attributeArray1[j] = attributeArray2[i];
	      }
	    }
	    return this;
	  },
	  normalizeNormals: function () {
	    var normals = this.attributes.normal;
	    for (var i = 0, il = normals.count; i < il; i++) {
	      _vector$4.x = normals.getX(i);
	      _vector$4.y = normals.getY(i);
	      _vector$4.z = normals.getZ(i);
	      _vector$4.normalize();
	      normals.setXYZ(i, _vector$4.x, _vector$4.y, _vector$4.z);
	    }
	  },
	  toNonIndexed: function () {
	    function convertBufferAttribute(attribute, indices) {
	      var array = attribute.array;
	      var itemSize = attribute.itemSize;
	      var array2 = new array.constructor(indices.length * itemSize);
	      var index = 0, index2 = 0;
	      for (var i = 0, l = indices.length; i < l; i++) {
	        index = indices[i] * itemSize;
	        for (var j = 0; j < itemSize; j++) {
	          array2[index2++] = array[index++];
	        }
	      }
	      return new BufferAttribute(array2, itemSize);
	    }
	    if (this.index === null) {
	      console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.");
	      return this;
	    }
	    var geometry2 = new BufferGeometry();
	    var indices = this.index.array;
	    var attributes = this.attributes;
	    for (var name in attributes) {
	      var attribute = attributes[name];
	      var newAttribute = convertBufferAttribute(attribute, indices);
	      geometry2.setAttribute(name, newAttribute);
	    }
	    var morphAttributes = this.morphAttributes;
	    for (name in morphAttributes) {
	      var morphArray = [];
	      var morphAttribute = morphAttributes[name];
	      for (var i = 0, il = morphAttribute.length; i < il; i++) {
	        var attribute = morphAttribute[i];
	        var newAttribute = convertBufferAttribute(attribute, indices);
	        morphArray.push(newAttribute);
	      }
	      geometry2.morphAttributes[name] = morphArray;
	    }
	    geometry2.morphTargetsRelative = this.morphTargetsRelative;
	    var groups = this.groups;
	    for (var i = 0, l = groups.length; i < l; i++) {
	      var group = groups[i];
	      geometry2.addGroup(group.start, group.count, group.materialIndex);
	    }
	    return geometry2;
	  },
	  toJSON: function () {
	    var data = {
	      metadata: {
	        version: 4.5,
	        type: "BufferGeometry",
	        generator: "BufferGeometry.toJSON"
	      }
	    };
	    data.uuid = this.uuid;
	    data.type = this.type;
	    if (this.name !== "") data.name = this.name;
	    if (Object.keys(this.userData).length > 0) data.userData = this.userData;
	    if (this.parameters !== undefined) {
	      var parameters = this.parameters;
	      for (var key in parameters) {
	        if (parameters[key] !== undefined) data[key] = parameters[key];
	      }
	      return data;
	    }
	    data.data = {
	      attributes: {}
	    };
	    var index = this.index;
	    if (index !== null) {
	      data.data.index = {
	        type: index.array.constructor.name,
	        array: Array.prototype.slice.call(index.array)
	      };
	    }
	    var attributes = this.attributes;
	    for (var key in attributes) {
	      var attribute = attributes[key];
	      var attributeData = attribute.toJSON();
	      if (attribute.name !== "") attributeData.name = attribute.name;
	      data.data.attributes[key] = attributeData;
	    }
	    var morphAttributes = {};
	    var hasMorphAttributes = false;
	    for (var key in this.morphAttributes) {
	      var attributeArray = this.morphAttributes[key];
	      var array = [];
	      for (var i = 0, il = attributeArray.length; i < il; i++) {
	        var attribute = attributeArray[i];
	        var attributeData = attribute.toJSON();
	        if (attribute.name !== "") attributeData.name = attribute.name;
	        array.push(attributeData);
	      }
	      if (array.length > 0) {
	        morphAttributes[key] = array;
	        hasMorphAttributes = true;
	      }
	    }
	    if (hasMorphAttributes) {
	      data.data.morphAttributes = morphAttributes;
	      data.data.morphTargetsRelative = this.morphTargetsRelative;
	    }
	    var groups = this.groups;
	    if (groups.length > 0) {
	      data.data.groups = JSON.parse(JSON.stringify(groups));
	    }
	    var boundingSphere = this.boundingSphere;
	    if (boundingSphere !== null) {
	      data.data.boundingSphere = {
	        center: boundingSphere.center.toArray(),
	        radius: boundingSphere.radius
	      };
	    }
	    return data;
	  },
	  clone: function () {
	    return new BufferGeometry().copy(this);
	  },
	  copy: function (source) {
	    var name, i, l;
	    this.index = null;
	    this.attributes = {};
	    this.morphAttributes = {};
	    this.groups = [];
	    this.boundingBox = null;
	    this.boundingSphere = null;
	    this.name = source.name;
	    var index = source.index;
	    if (index !== null) {
	      this.setIndex(index.clone());
	    }
	    var attributes = source.attributes;
	    for (name in attributes) {
	      var attribute = attributes[name];
	      this.setAttribute(name, attribute.clone());
	    }
	    var morphAttributes = source.morphAttributes;
	    for (name in morphAttributes) {
	      var array = [];
	      var morphAttribute = morphAttributes[name];
	      for ((i = 0, l = morphAttribute.length); i < l; i++) {
	        array.push(morphAttribute[i].clone());
	      }
	      this.morphAttributes[name] = array;
	    }
	    this.morphTargetsRelative = source.morphTargetsRelative;
	    var groups = source.groups;
	    for ((i = 0, l = groups.length); i < l; i++) {
	      var group = groups[i];
	      this.addGroup(group.start, group.count, group.materialIndex);
	    }
	    var boundingBox = source.boundingBox;
	    if (boundingBox !== null) {
	      this.boundingBox = boundingBox.clone();
	    }
	    var boundingSphere = source.boundingSphere;
	    if (boundingSphere !== null) {
	      this.boundingSphere = boundingSphere.clone();
	    }
	    this.drawRange.start = source.drawRange.start;
	    this.drawRange.count = source.drawRange.count;
	    this.userData = source.userData;
	    return this;
	  },
	  dispose: function () {
	    this.dispatchEvent({
	      type: "dispose"
	    });
	  }
	});
	var _inverseMatrix = new Matrix4();
	var _ray = new Ray();
	var _sphere = new Sphere();
	var _vA = new Vector3();
	var _vB = new Vector3();
	var _vC = new Vector3();
	var _tempA = new Vector3();
	var _tempB = new Vector3();
	var _tempC = new Vector3();
	var _morphA = new Vector3();
	var _morphB = new Vector3();
	var _morphC = new Vector3();
	var _uvA = new Vector2();
	var _uvB = new Vector2();
	var _uvC = new Vector2();
	var _intersectionPoint = new Vector3();
	var _intersectionPointWorld = new Vector3();
	function Mesh(geometry, material) {
	  Object3D.call(this);
	  this.type = "Mesh";
	  this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
	  this.material = material !== undefined ? material : new MeshBasicMaterial();
	  this.updateMorphTargets();
	}
	Mesh.prototype = Object.assign(Object.create(Object3D.prototype), {
	  constructor: Mesh,
	  isMesh: true,
	  copy: function (source) {
	    Object3D.prototype.copy.call(this, source);
	    if (source.morphTargetInfluences !== undefined) {
	      this.morphTargetInfluences = source.morphTargetInfluences.slice();
	    }
	    if (source.morphTargetDictionary !== undefined) {
	      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
	    }
	    return this;
	  },
	  updateMorphTargets: function () {
	    var geometry = this.geometry;
	    var m, ml, name;
	    if (geometry.isBufferGeometry) {
	      var morphAttributes = geometry.morphAttributes;
	      var keys = Object.keys(morphAttributes);
	      if (keys.length > 0) {
	        var morphAttribute = morphAttributes[keys[0]];
	        if (morphAttribute !== undefined) {
	          this.morphTargetInfluences = [];
	          this.morphTargetDictionary = {};
	          for ((m = 0, ml = morphAttribute.length); m < ml; m++) {
	            name = morphAttribute[m].name || String(m);
	            this.morphTargetInfluences.push(0);
	            this.morphTargetDictionary[name] = m;
	          }
	        }
	      }
	    } else {
	      var morphTargets = geometry.morphTargets;
	      if (morphTargets !== undefined && morphTargets.length > 0) {
	        console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
	      }
	    }
	  },
	  raycast: function (raycaster, intersects) {
	    var geometry = this.geometry;
	    var material = this.material;
	    var matrixWorld = this.matrixWorld;
	    if (material === undefined) return;
	    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
	    _sphere.copy(geometry.boundingSphere);
	    _sphere.applyMatrix4(matrixWorld);
	    if (raycaster.ray.intersectsSphere(_sphere) === false) return;
	    _inverseMatrix.getInverse(matrixWorld);
	    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
	    if (geometry.boundingBox !== null) {
	      if (_ray.intersectsBox(geometry.boundingBox) === false) return;
	    }
	    var intersection;
	    if (geometry.isBufferGeometry) {
	      var a, b, c;
	      var index = geometry.index;
	      var position = geometry.attributes.position;
	      var morphPosition = geometry.morphAttributes.position;
	      var morphTargetsRelative = geometry.morphTargetsRelative;
	      var uv = geometry.attributes.uv;
	      var uv2 = geometry.attributes.uv2;
	      var groups = geometry.groups;
	      var drawRange = geometry.drawRange;
	      var i, j, il, jl;
	      var group, groupMaterial;
	      var start, end;
	      if (index !== null) {
	        if (Array.isArray(material)) {
	          for ((i = 0, il = groups.length); i < il; i++) {
	            group = groups[i];
	            groupMaterial = material[group.materialIndex];
	            start = Math.max(group.start, drawRange.start);
	            end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
	            for ((j = start, jl = end); j < jl; j += 3) {
	              a = index.getX(j);
	              b = index.getX(j + 1);
	              c = index.getX(j + 2);
	              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
	              if (intersection) {
	                intersection.faceIndex = Math.floor(j / 3);
	                intersection.face.materialIndex = group.materialIndex;
	                intersects.push(intersection);
	              }
	            }
	          }
	        } else {
	          start = Math.max(0, drawRange.start);
	          end = Math.min(index.count, drawRange.start + drawRange.count);
	          for ((i = start, il = end); i < il; i += 3) {
	            a = index.getX(i);
	            b = index.getX(i + 1);
	            c = index.getX(i + 2);
	            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
	            if (intersection) {
	              intersection.faceIndex = Math.floor(i / 3);
	              intersects.push(intersection);
	            }
	          }
	        }
	      } else if (position !== undefined) {
	        if (Array.isArray(material)) {
	          for ((i = 0, il = groups.length); i < il; i++) {
	            group = groups[i];
	            groupMaterial = material[group.materialIndex];
	            start = Math.max(group.start, drawRange.start);
	            end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
	            for ((j = start, jl = end); j < jl; j += 3) {
	              a = j;
	              b = j + 1;
	              c = j + 2;
	              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
	              if (intersection) {
	                intersection.faceIndex = Math.floor(j / 3);
	                intersection.face.materialIndex = group.materialIndex;
	                intersects.push(intersection);
	              }
	            }
	          }
	        } else {
	          start = Math.max(0, drawRange.start);
	          end = Math.min(position.count, drawRange.start + drawRange.count);
	          for ((i = start, il = end); i < il; i += 3) {
	            a = i;
	            b = i + 1;
	            c = i + 2;
	            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);
	            if (intersection) {
	              intersection.faceIndex = Math.floor(i / 3);
	              intersects.push(intersection);
	            }
	          }
	        }
	      }
	    } else if (geometry.isGeometry) {
	      var fvA, fvB, fvC;
	      var isMultiMaterial = Array.isArray(material);
	      var vertices = geometry.vertices;
	      var faces = geometry.faces;
	      var uvs;
	      var faceVertexUvs = geometry.faceVertexUvs[0];
	      if (faceVertexUvs.length > 0) uvs = faceVertexUvs;
	      for (var f = 0, fl = faces.length; f < fl; f++) {
	        var face = faces[f];
	        var faceMaterial = isMultiMaterial ? material[face.materialIndex] : material;
	        if (faceMaterial === undefined) continue;
	        fvA = vertices[face.a];
	        fvB = vertices[face.b];
	        fvC = vertices[face.c];
	        intersection = checkIntersection(this, faceMaterial, raycaster, _ray, fvA, fvB, fvC, _intersectionPoint);
	        if (intersection) {
	          if (uvs && uvs[f]) {
	            var uvs_f = uvs[f];
	            _uvA.copy(uvs_f[0]);
	            _uvB.copy(uvs_f[1]);
	            _uvC.copy(uvs_f[2]);
	            intersection.uv = Triangle.getUV(_intersectionPoint, fvA, fvB, fvC, _uvA, _uvB, _uvC, new Vector2());
	          }
	          intersection.face = face;
	          intersection.faceIndex = f;
	          intersects.push(intersection);
	        }
	      }
	    }
	  },
	  clone: function () {
	    return new this.constructor(this.geometry, this.material).copy(this);
	  }
	});
	function checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {
	  var intersect;
	  if (material.side === BackSide) {
	    intersect = ray.intersectTriangle(pC, pB, pA, true, point);
	  } else {
	    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);
	  }
	  if (intersect === null) return null;
	  _intersectionPointWorld.copy(point);
	  _intersectionPointWorld.applyMatrix4(object.matrixWorld);
	  var distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
	  if (distance < raycaster.near || distance > raycaster.far) return null;
	  return {
	    distance: distance,
	    point: _intersectionPointWorld.clone(),
	    object: object
	  };
	}
	function checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {
	  _vA.fromBufferAttribute(position, a);
	  _vB.fromBufferAttribute(position, b);
	  _vC.fromBufferAttribute(position, c);
	  var morphInfluences = object.morphTargetInfluences;
	  if (material.morphTargets && morphPosition && morphInfluences) {
	    _morphA.set(0, 0, 0);
	    _morphB.set(0, 0, 0);
	    _morphC.set(0, 0, 0);
	    for (var i = 0, il = morphPosition.length; i < il; i++) {
	      var influence = morphInfluences[i];
	      var morphAttribute = morphPosition[i];
	      if (influence === 0) continue;
	      _tempA.fromBufferAttribute(morphAttribute, a);
	      _tempB.fromBufferAttribute(morphAttribute, b);
	      _tempC.fromBufferAttribute(morphAttribute, c);
	      if (morphTargetsRelative) {
	        _morphA.addScaledVector(_tempA, influence);
	        _morphB.addScaledVector(_tempB, influence);
	        _morphC.addScaledVector(_tempC, influence);
	      } else {
	        _morphA.addScaledVector(_tempA.sub(_vA), influence);
	        _morphB.addScaledVector(_tempB.sub(_vB), influence);
	        _morphC.addScaledVector(_tempC.sub(_vC), influence);
	      }
	    }
	    _vA.add(_morphA);
	    _vB.add(_morphB);
	    _vC.add(_morphC);
	  }
	  var intersection = checkIntersection(object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint);
	  if (intersection) {
	    if (uv) {
	      _uvA.fromBufferAttribute(uv, a);
	      _uvB.fromBufferAttribute(uv, b);
	      _uvC.fromBufferAttribute(uv, c);
	      intersection.uv = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
	    }
	    if (uv2) {
	      _uvA.fromBufferAttribute(uv2, a);
	      _uvB.fromBufferAttribute(uv2, b);
	      _uvC.fromBufferAttribute(uv2, c);
	      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
	    }
	    var face = new Face3(a, b, c);
	    Triangle.getNormal(_vA, _vB, _vC, face.normal);
	    intersection.face = face;
	  }
	  return intersection;
	}
	var _geometryId = 0;
	var _m1$3 = new Matrix4();
	var _obj$1 = new Object3D();
	var _offset$1 = new Vector3();
	function Geometry() {
	  Object.defineProperty(this, "id", {
	    value: _geometryId += 2
	  });
	  this.uuid = MathUtils.generateUUID();
	  this.name = "";
	  this.type = "Geometry";
	  this.vertices = [];
	  this.colors = [];
	  this.faces = [];
	  this.faceVertexUvs = [[]];
	  this.morphTargets = [];
	  this.morphNormals = [];
	  this.skinWeights = [];
	  this.skinIndices = [];
	  this.lineDistances = [];
	  this.boundingBox = null;
	  this.boundingSphere = null;
	  this.elementsNeedUpdate = false;
	  this.verticesNeedUpdate = false;
	  this.uvsNeedUpdate = false;
	  this.normalsNeedUpdate = false;
	  this.colorsNeedUpdate = false;
	  this.lineDistancesNeedUpdate = false;
	  this.groupsNeedUpdate = false;
	}
	Geometry.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
	  constructor: Geometry,
	  isGeometry: true,
	  applyMatrix4: function (matrix) {
	    var normalMatrix = new Matrix3().getNormalMatrix(matrix);
	    for (var i = 0, il = this.vertices.length; i < il; i++) {
	      var vertex = this.vertices[i];
	      vertex.applyMatrix4(matrix);
	    }
	    for (var i = 0, il = this.faces.length; i < il; i++) {
	      var face = this.faces[i];
	      face.normal.applyMatrix3(normalMatrix).normalize();
	      for (var j = 0, jl = face.vertexNormals.length; j < jl; j++) {
	        face.vertexNormals[j].applyMatrix3(normalMatrix).normalize();
	      }
	    }
	    if (this.boundingBox !== null) {
	      this.computeBoundingBox();
	    }
	    if (this.boundingSphere !== null) {
	      this.computeBoundingSphere();
	    }
	    this.verticesNeedUpdate = true;
	    this.normalsNeedUpdate = true;
	    return this;
	  },
	  rotateX: function (angle) {
	    _m1$3.makeRotationX(angle);
	    this.applyMatrix4(_m1$3);
	    return this;
	  },
	  rotateY: function (angle) {
	    _m1$3.makeRotationY(angle);
	    this.applyMatrix4(_m1$3);
	    return this;
	  },
	  rotateZ: function (angle) {
	    _m1$3.makeRotationZ(angle);
	    this.applyMatrix4(_m1$3);
	    return this;
	  },
	  translate: function (x, y, z) {
	    _m1$3.makeTranslation(x, y, z);
	    this.applyMatrix4(_m1$3);
	    return this;
	  },
	  scale: function (x, y, z) {
	    _m1$3.makeScale(x, y, z);
	    this.applyMatrix4(_m1$3);
	    return this;
	  },
	  lookAt: function (vector) {
	    _obj$1.lookAt(vector);
	    _obj$1.updateMatrix();
	    this.applyMatrix4(_obj$1.matrix);
	    return this;
	  },
	  fromBufferGeometry: function (geometry) {
	    var scope = this;
	    var indices = geometry.index !== null ? geometry.index.array : undefined;
	    var attributes = geometry.attributes;
	    if (attributes.position === undefined) {
	      console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.");
	      return this;
	    }
	    var positions = attributes.position.array;
	    var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
	    var colors = attributes.color !== undefined ? attributes.color.array : undefined;
	    var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
	    var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
	    if (uvs2 !== undefined) this.faceVertexUvs[1] = [];
	    for (var i = 0; i < positions.length; i += 3) {
	      scope.vertices.push(new Vector3().fromArray(positions, i));
	      if (colors !== undefined) {
	        scope.colors.push(new Color().fromArray(colors, i));
	      }
	    }
	    function addFace(a, b, c, materialIndex) {
	      var vertexColors = colors === undefined ? [] : [scope.colors[a].clone(), scope.colors[b].clone(), scope.colors[c].clone()];
	      var vertexNormals = normals === undefined ? [] : [new Vector3().fromArray(normals, a * 3), new Vector3().fromArray(normals, b * 3), new Vector3().fromArray(normals, c * 3)];
	      var face = new Face3(a, b, c, vertexNormals, vertexColors, materialIndex);
	      scope.faces.push(face);
	      if (uvs !== undefined) {
	        scope.faceVertexUvs[0].push([new Vector2().fromArray(uvs, a * 2), new Vector2().fromArray(uvs, b * 2), new Vector2().fromArray(uvs, c * 2)]);
	      }
	      if (uvs2 !== undefined) {
	        scope.faceVertexUvs[1].push([new Vector2().fromArray(uvs2, a * 2), new Vector2().fromArray(uvs2, b * 2), new Vector2().fromArray(uvs2, c * 2)]);
	      }
	    }
	    var groups = geometry.groups;
	    if (groups.length > 0) {
	      for (var i = 0; i < groups.length; i++) {
	        var group = groups[i];
	        var start = group.start;
	        var count = group.count;
	        for (var j = start, jl = start + count; j < jl; j += 3) {
	          if (indices !== undefined) {
	            addFace(indices[j], indices[j + 1], indices[j + 2], group.materialIndex);
	          } else {
	            addFace(j, j + 1, j + 2, group.materialIndex);
	          }
	        }
	      }
	    } else {
	      if (indices !== undefined) {
	        for (var i = 0; i < indices.length; i += 3) {
	          addFace(indices[i], indices[i + 1], indices[i + 2]);
	        }
	      } else {
	        for (var i = 0; i < positions.length / 3; i += 3) {
	          addFace(i, i + 1, i + 2);
	        }
	      }
	    }
	    this.computeFaceNormals();
	    if (geometry.boundingBox !== null) {
	      this.boundingBox = geometry.boundingBox.clone();
	    }
	    if (geometry.boundingSphere !== null) {
	      this.boundingSphere = geometry.boundingSphere.clone();
	    }
	    return this;
	  },
	  center: function () {
	    this.computeBoundingBox();
	    this.boundingBox.getCenter(_offset$1).negate();
	    this.translate(_offset$1.x, _offset$1.y, _offset$1.z);
	    return this;
	  },
	  normalize: function () {
	    this.computeBoundingSphere();
	    var center = this.boundingSphere.center;
	    var radius = this.boundingSphere.radius;
	    var s = radius === 0 ? 1 : 1 / radius;
	    var matrix = new Matrix4();
	    matrix.set(s, 0, 0, -s * center.x, 0, s, 0, -s * center.y, 0, 0, s, -s * center.z, 0, 0, 0, 1);
	    this.applyMatrix4(matrix);
	    return this;
	  },
	  computeFaceNormals: function () {
	    var cb = new Vector3(), ab = new Vector3();
	    for (var f = 0, fl = this.faces.length; f < fl; f++) {
	      var face = this.faces[f];
	      var vA = this.vertices[face.a];
	      var vB = this.vertices[face.b];
	      var vC = this.vertices[face.c];
	      cb.subVectors(vC, vB);
	      ab.subVectors(vA, vB);
	      cb.cross(ab);
	      cb.normalize();
	      face.normal.copy(cb);
	    }
	  },
	  computeVertexNormals: function (areaWeighted) {
	    if (areaWeighted === undefined) areaWeighted = true;
	    var v, vl, f, fl, face, vertices;
	    vertices = new Array(this.vertices.length);
	    for ((v = 0, vl = this.vertices.length); v < vl; v++) {
	      vertices[v] = new Vector3();
	    }
	    if (areaWeighted) {
	      var vA, vB, vC;
	      var cb = new Vector3(), ab = new Vector3();
	      for ((f = 0, fl = this.faces.length); f < fl; f++) {
	        face = this.faces[f];
	        vA = this.vertices[face.a];
	        vB = this.vertices[face.b];
	        vC = this.vertices[face.c];
	        cb.subVectors(vC, vB);
	        ab.subVectors(vA, vB);
	        cb.cross(ab);
	        vertices[face.a].add(cb);
	        vertices[face.b].add(cb);
	        vertices[face.c].add(cb);
	      }
	    } else {
	      this.computeFaceNormals();
	      for ((f = 0, fl = this.faces.length); f < fl; f++) {
	        face = this.faces[f];
	        vertices[face.a].add(face.normal);
	        vertices[face.b].add(face.normal);
	        vertices[face.c].add(face.normal);
	      }
	    }
	    for ((v = 0, vl = this.vertices.length); v < vl; v++) {
	      vertices[v].normalize();
	    }
	    for ((f = 0, fl = this.faces.length); f < fl; f++) {
	      face = this.faces[f];
	      var vertexNormals = face.vertexNormals;
	      if (vertexNormals.length === 3) {
	        vertexNormals[0].copy(vertices[face.a]);
	        vertexNormals[1].copy(vertices[face.b]);
	        vertexNormals[2].copy(vertices[face.c]);
	      } else {
	        vertexNormals[0] = vertices[face.a].clone();
	        vertexNormals[1] = vertices[face.b].clone();
	        vertexNormals[2] = vertices[face.c].clone();
	      }
	    }
	    if (this.faces.length > 0) {
	      this.normalsNeedUpdate = true;
	    }
	  },
	  computeFlatVertexNormals: function () {
	    var f, fl, face;
	    this.computeFaceNormals();
	    for ((f = 0, fl = this.faces.length); f < fl; f++) {
	      face = this.faces[f];
	      var vertexNormals = face.vertexNormals;
	      if (vertexNormals.length === 3) {
	        vertexNormals[0].copy(face.normal);
	        vertexNormals[1].copy(face.normal);
	        vertexNormals[2].copy(face.normal);
	      } else {
	        vertexNormals[0] = face.normal.clone();
	        vertexNormals[1] = face.normal.clone();
	        vertexNormals[2] = face.normal.clone();
	      }
	    }
	    if (this.faces.length > 0) {
	      this.normalsNeedUpdate = true;
	    }
	  },
	  computeMorphNormals: function () {
	    var i, il, f, fl, face;
	    for ((f = 0, fl = this.faces.length); f < fl; f++) {
	      face = this.faces[f];
	      if (!face.__originalFaceNormal) {
	        face.__originalFaceNormal = face.normal.clone();
	      } else {
	        face.__originalFaceNormal.copy(face.normal);
	      }
	      if (!face.__originalVertexNormals) face.__originalVertexNormals = [];
	      for ((i = 0, il = face.vertexNormals.length); i < il; i++) {
	        if (!face.__originalVertexNormals[i]) {
	          face.__originalVertexNormals[i] = face.vertexNormals[i].clone();
	        } else {
	          face.__originalVertexNormals[i].copy(face.vertexNormals[i]);
	        }
	      }
	    }
	    var tmpGeo = new Geometry();
	    tmpGeo.faces = this.faces;
	    for ((i = 0, il = this.morphTargets.length); i < il; i++) {
	      if (!this.morphNormals[i]) {
	        this.morphNormals[i] = {};
	        this.morphNormals[i].faceNormals = [];
	        this.morphNormals[i].vertexNormals = [];
	        var dstNormalsFace = this.morphNormals[i].faceNormals;
	        var dstNormalsVertex = this.morphNormals[i].vertexNormals;
	        var faceNormal, vertexNormals;
	        for ((f = 0, fl = this.faces.length); f < fl; f++) {
	          faceNormal = new Vector3();
	          vertexNormals = {
	            a: new Vector3(),
	            b: new Vector3(),
	            c: new Vector3()
	          };
	          dstNormalsFace.push(faceNormal);
	          dstNormalsVertex.push(vertexNormals);
	        }
	      }
	      var morphNormals = this.morphNormals[i];
	      tmpGeo.vertices = this.morphTargets[i].vertices;
	      tmpGeo.computeFaceNormals();
	      tmpGeo.computeVertexNormals();
	      var faceNormal, vertexNormals;
	      for ((f = 0, fl = this.faces.length); f < fl; f++) {
	        face = this.faces[f];
	        faceNormal = morphNormals.faceNormals[f];
	        vertexNormals = morphNormals.vertexNormals[f];
	        faceNormal.copy(face.normal);
	        vertexNormals.a.copy(face.vertexNormals[0]);
	        vertexNormals.b.copy(face.vertexNormals[1]);
	        vertexNormals.c.copy(face.vertexNormals[2]);
	      }
	    }
	    for ((f = 0, fl = this.faces.length); f < fl; f++) {
	      face = this.faces[f];
	      face.normal = face.__originalFaceNormal;
	      face.vertexNormals = face.__originalVertexNormals;
	    }
	  },
	  computeBoundingBox: function () {
	    if (this.boundingBox === null) {
	      this.boundingBox = new Box3();
	    }
	    this.boundingBox.setFromPoints(this.vertices);
	  },
	  computeBoundingSphere: function () {
	    if (this.boundingSphere === null) {
	      this.boundingSphere = new Sphere();
	    }
	    this.boundingSphere.setFromPoints(this.vertices);
	  },
	  merge: function (geometry, matrix, materialIndexOffset) {
	    if (!(geometry && geometry.isGeometry)) {
	      console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", geometry);
	      return;
	    }
	    var normalMatrix, vertexOffset = this.vertices.length, vertices1 = this.vertices, vertices2 = geometry.vertices, faces1 = this.faces, faces2 = geometry.faces, colors1 = this.colors, colors2 = geometry.colors;
	    if (materialIndexOffset === undefined) materialIndexOffset = 0;
	    if (matrix !== undefined) {
	      normalMatrix = new Matrix3().getNormalMatrix(matrix);
	    }
	    for (var i = 0, il = vertices2.length; i < il; i++) {
	      var vertex = vertices2[i];
	      var vertexCopy = vertex.clone();
	      if (matrix !== undefined) vertexCopy.applyMatrix4(matrix);
	      vertices1.push(vertexCopy);
	    }
	    for (var i = 0, il = colors2.length; i < il; i++) {
	      colors1.push(colors2[i].clone());
	    }
	    for ((i = 0, il = faces2.length); i < il; i++) {
	      var face = faces2[i], faceCopy, normal, color, faceVertexNormals = face.vertexNormals, faceVertexColors = face.vertexColors;
	      faceCopy = new Face3(face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset);
	      faceCopy.normal.copy(face.normal);
	      if (normalMatrix !== undefined) {
	        faceCopy.normal.applyMatrix3(normalMatrix).normalize();
	      }
	      for (var j = 0, jl = faceVertexNormals.length; j < jl; j++) {
	        normal = faceVertexNormals[j].clone();
	        if (normalMatrix !== undefined) {
	          normal.applyMatrix3(normalMatrix).normalize();
	        }
	        faceCopy.vertexNormals.push(normal);
	      }
	      faceCopy.color.copy(face.color);
	      for (var j = 0, jl = faceVertexColors.length; j < jl; j++) {
	        color = faceVertexColors[j];
	        faceCopy.vertexColors.push(color.clone());
	      }
	      faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
	      faces1.push(faceCopy);
	    }
	    for (var i = 0, il = geometry.faceVertexUvs.length; i < il; i++) {
	      var faceVertexUvs2 = geometry.faceVertexUvs[i];
	      if (this.faceVertexUvs[i] === undefined) this.faceVertexUvs[i] = [];
	      for (var j = 0, jl = faceVertexUvs2.length; j < jl; j++) {
	        var uvs2 = faceVertexUvs2[j], uvsCopy = [];
	        for (var k = 0, kl = uvs2.length; k < kl; k++) {
	          uvsCopy.push(uvs2[k].clone());
	        }
	        this.faceVertexUvs[i].push(uvsCopy);
	      }
	    }
	  },
	  mergeMesh: function (mesh) {
	    if (!(mesh && mesh.isMesh)) {
	      console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", mesh);
	      return;
	    }
	    if (mesh.matrixAutoUpdate) mesh.updateMatrix();
	    this.merge(mesh.geometry, mesh.matrix);
	  },
	  mergeVertices: function () {
	    var verticesMap = {};
	    var unique = [], changes = [];
	    var v, key;
	    var precisionPoints = 4;
	    var precision = Math.pow(10, precisionPoints);
	    var i, il, face;
	    var indices, j, jl;
	    for ((i = 0, il = this.vertices.length); i < il; i++) {
	      v = this.vertices[i];
	      key = Math.round(v.x * precision) + "_" + Math.round(v.y * precision) + "_" + Math.round(v.z * precision);
	      if (verticesMap[key] === undefined) {
	        verticesMap[key] = i;
	        unique.push(this.vertices[i]);
	        changes[i] = unique.length - 1;
	      } else {
	        changes[i] = changes[verticesMap[key]];
	      }
	    }
	    var faceIndicesToRemove = [];
	    for ((i = 0, il = this.faces.length); i < il; i++) {
	      face = this.faces[i];
	      face.a = changes[face.a];
	      face.b = changes[face.b];
	      face.c = changes[face.c];
	      indices = [face.a, face.b, face.c];
	      for (var n = 0; n < 3; n++) {
	        if (indices[n] === indices[(n + 1) % 3]) {
	          faceIndicesToRemove.push(i);
	          break;
	        }
	      }
	    }
	    for (i = faceIndicesToRemove.length - 1; i >= 0; i--) {
	      var idx = faceIndicesToRemove[i];
	      this.faces.splice(idx, 1);
	      for ((j = 0, jl = this.faceVertexUvs.length); j < jl; j++) {
	        this.faceVertexUvs[j].splice(idx, 1);
	      }
	    }
	    var diff = this.vertices.length - unique.length;
	    this.vertices = unique;
	    return diff;
	  },
	  setFromPoints: function (points) {
	    this.vertices = [];
	    for (var i = 0, l = points.length; i < l; i++) {
	      var point = points[i];
	      this.vertices.push(new Vector3(point.x, point.y, point.z || 0));
	    }
	    return this;
	  },
	  sortFacesByMaterialIndex: function () {
	    var faces = this.faces;
	    var length = faces.length;
	    for (var i = 0; i < length; i++) {
	      faces[i]._id = i;
	    }
	    function materialIndexSort(a, b) {
	      return a.materialIndex - b.materialIndex;
	    }
	    faces.sort(materialIndexSort);
	    var uvs1 = this.faceVertexUvs[0];
	    var uvs2 = this.faceVertexUvs[1];
	    var newUvs1, newUvs2;
	    if (uvs1 && uvs1.length === length) newUvs1 = [];
	    if (uvs2 && uvs2.length === length) newUvs2 = [];
	    for (var i = 0; i < length; i++) {
	      var id = faces[i]._id;
	      if (newUvs1) newUvs1.push(uvs1[id]);
	      if (newUvs2) newUvs2.push(uvs2[id]);
	    }
	    if (newUvs1) this.faceVertexUvs[0] = newUvs1;
	    if (newUvs2) this.faceVertexUvs[1] = newUvs2;
	  },
	  toJSON: function () {
	    var data = {
	      metadata: {
	        version: 4.5,
	        type: "Geometry",
	        generator: "Geometry.toJSON"
	      }
	    };
	    data.uuid = this.uuid;
	    data.type = this.type;
	    if (this.name !== "") data.name = this.name;
	    if (this.parameters !== undefined) {
	      var parameters = this.parameters;
	      for (var key in parameters) {
	        if (parameters[key] !== undefined) data[key] = parameters[key];
	      }
	      return data;
	    }
	    var vertices = [];
	    for (var i = 0; i < this.vertices.length; i++) {
	      var vertex = this.vertices[i];
	      vertices.push(vertex.x, vertex.y, vertex.z);
	    }
	    var faces = [];
	    var normals = [];
	    var normalsHash = {};
	    var colors = [];
	    var colorsHash = {};
	    var uvs = [];
	    var uvsHash = {};
	    for (var i = 0; i < this.faces.length; i++) {
	      var face = this.faces[i];
	      var hasMaterial = true;
	      var hasFaceUv = false;
	      var hasFaceVertexUv = this.faceVertexUvs[0][i] !== undefined;
	      var hasFaceNormal = face.normal.length() > 0;
	      var hasFaceVertexNormal = face.vertexNormals.length > 0;
	      var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
	      var hasFaceVertexColor = face.vertexColors.length > 0;
	      var faceType = 0;
	      faceType = setBit(faceType, 0, 0);
	      faceType = setBit(faceType, 1, hasMaterial);
	      faceType = setBit(faceType, 2, hasFaceUv);
	      faceType = setBit(faceType, 3, hasFaceVertexUv);
	      faceType = setBit(faceType, 4, hasFaceNormal);
	      faceType = setBit(faceType, 5, hasFaceVertexNormal);
	      faceType = setBit(faceType, 6, hasFaceColor);
	      faceType = setBit(faceType, 7, hasFaceVertexColor);
	      faces.push(faceType);
	      faces.push(face.a, face.b, face.c);
	      faces.push(face.materialIndex);
	      if (hasFaceVertexUv) {
	        var faceVertexUvs = this.faceVertexUvs[0][i];
	        faces.push(getUvIndex(faceVertexUvs[0]), getUvIndex(faceVertexUvs[1]), getUvIndex(faceVertexUvs[2]));
	      }
	      if (hasFaceNormal) {
	        faces.push(getNormalIndex(face.normal));
	      }
	      if (hasFaceVertexNormal) {
	        var vertexNormals = face.vertexNormals;
	        faces.push(getNormalIndex(vertexNormals[0]), getNormalIndex(vertexNormals[1]), getNormalIndex(vertexNormals[2]));
	      }
	      if (hasFaceColor) {
	        faces.push(getColorIndex(face.color));
	      }
	      if (hasFaceVertexColor) {
	        var vertexColors = face.vertexColors;
	        faces.push(getColorIndex(vertexColors[0]), getColorIndex(vertexColors[1]), getColorIndex(vertexColors[2]));
	      }
	    }
	    function setBit(value, position, enabled) {
	      return enabled ? value | 1 << position : value & ~(1 << position);
	    }
	    function getNormalIndex(normal) {
	      var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
	      if (normalsHash[hash] !== undefined) {
	        return normalsHash[hash];
	      }
	      normalsHash[hash] = normals.length / 3;
	      normals.push(normal.x, normal.y, normal.z);
	      return normalsHash[hash];
	    }
	    function getColorIndex(color) {
	      var hash = color.r.toString() + color.g.toString() + color.b.toString();
	      if (colorsHash[hash] !== undefined) {
	        return colorsHash[hash];
	      }
	      colorsHash[hash] = colors.length;
	      colors.push(color.getHex());
	      return colorsHash[hash];
	    }
	    function getUvIndex(uv) {
	      var hash = uv.x.toString() + uv.y.toString();
	      if (uvsHash[hash] !== undefined) {
	        return uvsHash[hash];
	      }
	      uvsHash[hash] = uvs.length / 2;
	      uvs.push(uv.x, uv.y);
	      return uvsHash[hash];
	    }
	    data.data = {};
	    data.data.vertices = vertices;
	    data.data.normals = normals;
	    if (colors.length > 0) data.data.colors = colors;
	    if (uvs.length > 0) data.data.uvs = [uvs];
	    data.data.faces = faces;
	    return data;
	  },
	  clone: function () {
	    return new Geometry().copy(this);
	  },
	  copy: function (source) {
	    var i, il, j, jl, k, kl;
	    this.vertices = [];
	    this.colors = [];
	    this.faces = [];
	    this.faceVertexUvs = [[]];
	    this.morphTargets = [];
	    this.morphNormals = [];
	    this.skinWeights = [];
	    this.skinIndices = [];
	    this.lineDistances = [];
	    this.boundingBox = null;
	    this.boundingSphere = null;
	    this.name = source.name;
	    var vertices = source.vertices;
	    for ((i = 0, il = vertices.length); i < il; i++) {
	      this.vertices.push(vertices[i].clone());
	    }
	    var colors = source.colors;
	    for ((i = 0, il = colors.length); i < il; i++) {
	      this.colors.push(colors[i].clone());
	    }
	    var faces = source.faces;
	    for ((i = 0, il = faces.length); i < il; i++) {
	      this.faces.push(faces[i].clone());
	    }
	    for ((i = 0, il = source.faceVertexUvs.length); i < il; i++) {
	      var faceVertexUvs = source.faceVertexUvs[i];
	      if (this.faceVertexUvs[i] === undefined) {
	        this.faceVertexUvs[i] = [];
	      }
	      for ((j = 0, jl = faceVertexUvs.length); j < jl; j++) {
	        var uvs = faceVertexUvs[j], uvsCopy = [];
	        for ((k = 0, kl = uvs.length); k < kl; k++) {
	          var uv = uvs[k];
	          uvsCopy.push(uv.clone());
	        }
	        this.faceVertexUvs[i].push(uvsCopy);
	      }
	    }
	    var morphTargets = source.morphTargets;
	    for ((i = 0, il = morphTargets.length); i < il; i++) {
	      var morphTarget = {};
	      morphTarget.name = morphTargets[i].name;
	      if (morphTargets[i].vertices !== undefined) {
	        morphTarget.vertices = [];
	        for ((j = 0, jl = morphTargets[i].vertices.length); j < jl; j++) {
	          morphTarget.vertices.push(morphTargets[i].vertices[j].clone());
	        }
	      }
	      if (morphTargets[i].normals !== undefined) {
	        morphTarget.normals = [];
	        for ((j = 0, jl = morphTargets[i].normals.length); j < jl; j++) {
	          morphTarget.normals.push(morphTargets[i].normals[j].clone());
	        }
	      }
	      this.morphTargets.push(morphTarget);
	    }
	    var morphNormals = source.morphNormals;
	    for ((i = 0, il = morphNormals.length); i < il; i++) {
	      var morphNormal = {};
	      if (morphNormals[i].vertexNormals !== undefined) {
	        morphNormal.vertexNormals = [];
	        for ((j = 0, jl = morphNormals[i].vertexNormals.length); j < jl; j++) {
	          var srcVertexNormal = morphNormals[i].vertexNormals[j];
	          var destVertexNormal = {};
	          destVertexNormal.a = srcVertexNormal.a.clone();
	          destVertexNormal.b = srcVertexNormal.b.clone();
	          destVertexNormal.c = srcVertexNormal.c.clone();
	          morphNormal.vertexNormals.push(destVertexNormal);
	        }
	      }
	      if (morphNormals[i].faceNormals !== undefined) {
	        morphNormal.faceNormals = [];
	        for ((j = 0, jl = morphNormals[i].faceNormals.length); j < jl; j++) {
	          morphNormal.faceNormals.push(morphNormals[i].faceNormals[j].clone());
	        }
	      }
	      this.morphNormals.push(morphNormal);
	    }
	    var skinWeights = source.skinWeights;
	    for ((i = 0, il = skinWeights.length); i < il; i++) {
	      this.skinWeights.push(skinWeights[i].clone());
	    }
	    var skinIndices = source.skinIndices;
	    for ((i = 0, il = skinIndices.length); i < il; i++) {
	      this.skinIndices.push(skinIndices[i].clone());
	    }
	    var lineDistances = source.lineDistances;
	    for ((i = 0, il = lineDistances.length); i < il; i++) {
	      this.lineDistances.push(lineDistances[i]);
	    }
	    var boundingBox = source.boundingBox;
	    if (boundingBox !== null) {
	      this.boundingBox = boundingBox.clone();
	    }
	    var boundingSphere = source.boundingSphere;
	    if (boundingSphere !== null) {
	      this.boundingSphere = boundingSphere.clone();
	    }
	    this.elementsNeedUpdate = source.elementsNeedUpdate;
	    this.verticesNeedUpdate = source.verticesNeedUpdate;
	    this.uvsNeedUpdate = source.uvsNeedUpdate;
	    this.normalsNeedUpdate = source.normalsNeedUpdate;
	    this.colorsNeedUpdate = source.colorsNeedUpdate;
	    this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
	    this.groupsNeedUpdate = source.groupsNeedUpdate;
	    return this;
	  },
	  dispose: function () {
	    this.dispatchEvent({
	      type: "dispose"
	    });
	  }
	});
	class BoxGeometry extends Geometry {
	  constructor(width, height, depth, widthSegments, heightSegments, depthSegments) {
	    super();
	    this.type = "BoxGeometry";
	    this.parameters = {
	      width: width,
	      height: height,
	      depth: depth,
	      widthSegments: widthSegments,
	      heightSegments: heightSegments,
	      depthSegments: depthSegments
	    };
	    this.fromBufferGeometry(new BoxBufferGeometry(width, height, depth, widthSegments, heightSegments, depthSegments));
	    this.mergeVertices();
	  }
	}
	class BoxBufferGeometry extends BufferGeometry {
	  constructor(width, height, depth, widthSegments, heightSegments, depthSegments) {
	    super();
	    this.type = "BoxBufferGeometry";
	    this.parameters = {
	      width: width,
	      height: height,
	      depth: depth,
	      widthSegments: widthSegments,
	      heightSegments: heightSegments,
	      depthSegments: depthSegments
	    };
	    var scope = this;
	    width = width || 1;
	    height = height || 1;
	    depth = depth || 1;
	    widthSegments = Math.floor(widthSegments) || 1;
	    heightSegments = Math.floor(heightSegments) || 1;
	    depthSegments = Math.floor(depthSegments) || 1;
	    var indices = [];
	    var vertices = [];
	    var normals = [];
	    var uvs = [];
	    var numberOfVertices = 0;
	    var groupStart = 0;
	    buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
	    buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
	    buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
	    buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
	    buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
	    buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
	    this.setIndex(indices);
	    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
	    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
	    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
	    function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
	      var segmentWidth = width / gridX;
	      var segmentHeight = height / gridY;
	      var widthHalf = width / 2;
	      var heightHalf = height / 2;
	      var depthHalf = depth / 2;
	      var gridX1 = gridX + 1;
	      var gridY1 = gridY + 1;
	      var vertexCounter = 0;
	      var groupCount = 0;
	      var ix, iy;
	      var vector = new Vector3();
	      for (iy = 0; iy < gridY1; iy++) {
	        var y = iy * segmentHeight - heightHalf;
	        for (ix = 0; ix < gridX1; ix++) {
	          var x = ix * segmentWidth - widthHalf;
	          vector[u] = x * udir;
	          vector[v] = y * vdir;
	          vector[w] = depthHalf;
	          vertices.push(vector.x, vector.y, vector.z);
	          vector[u] = 0;
	          vector[v] = 0;
	          vector[w] = depth > 0 ? 1 : -1;
	          normals.push(vector.x, vector.y, vector.z);
	          uvs.push(ix / gridX);
	          uvs.push(1 - iy / gridY);
	          vertexCounter += 1;
	        }
	      }
	      for (iy = 0; iy < gridY; iy++) {
	        for (ix = 0; ix < gridX; ix++) {
	          var a = numberOfVertices + ix + gridX1 * iy;
	          var b = numberOfVertices + ix + gridX1 * (iy + 1);
	          var c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
	          var d = numberOfVertices + (ix + 1) + gridX1 * iy;
	          indices.push(a, b, d);
	          indices.push(b, c, d);
	          groupCount += 6;
	        }
	      }
	      scope.addGroup(groupStart, groupCount, materialIndex);
	      groupStart += groupCount;
	      numberOfVertices += vertexCounter;
	    }
	  }
	}
	function cloneUniforms(src) {
	  var dst = {};
	  for (var u in src) {
	    dst[u] = {};
	    for (var p in src[u]) {
	      var property = src[u][p];
	      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture)) {
	        dst[u][p] = property.clone();
	      } else if (Array.isArray(property)) {
	        dst[u][p] = property.slice();
	      } else {
	        dst[u][p] = property;
	      }
	    }
	  }
	  return dst;
	}
	function mergeUniforms(uniforms) {
	  var merged = {};
	  for (var u = 0; u < uniforms.length; u++) {
	    var tmp = cloneUniforms(uniforms[u]);
	    for (var p in tmp) {
	      merged[p] = tmp[p];
	    }
	  }
	  return merged;
	}
	var UniformsUtils = {
	  clone: cloneUniforms,
	  merge: mergeUniforms
	};
	var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
	var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
	function ShaderMaterial(parameters) {
	  Material.call(this);
	  this.type = "ShaderMaterial";
	  this.defines = {};
	  this.uniforms = {};
	  this.vertexShader = default_vertex;
	  this.fragmentShader = default_fragment;
	  this.linewidth = 1;
	  this.wireframe = false;
	  this.wireframeLinewidth = 1;
	  this.fog = false;
	  this.lights = false;
	  this.clipping = false;
	  this.skinning = false;
	  this.morphTargets = false;
	  this.morphNormals = false;
	  this.extensions = {
	    derivatives: false,
	    fragDepth: false,
	    drawBuffers: false,
	    shaderTextureLOD: false
	  };
	  this.defaultAttributeValues = {
	    "color": [1, 1, 1],
	    "uv": [0, 0],
	    "uv2": [0, 0]
	  };
	  this.index0AttributeName = undefined;
	  this.uniformsNeedUpdate = false;
	  if (parameters !== undefined) {
	    if (parameters.attributes !== undefined) {
	      console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.");
	    }
	    this.setValues(parameters);
	  }
	}
	ShaderMaterial.prototype = Object.create(Material.prototype);
	ShaderMaterial.prototype.constructor = ShaderMaterial;
	ShaderMaterial.prototype.isShaderMaterial = true;
	ShaderMaterial.prototype.copy = function (source) {
	  Material.prototype.copy.call(this, source);
	  this.fragmentShader = source.fragmentShader;
	  this.vertexShader = source.vertexShader;
	  this.uniforms = cloneUniforms(source.uniforms);
	  this.defines = Object.assign({}, source.defines);
	  this.wireframe = source.wireframe;
	  this.wireframeLinewidth = source.wireframeLinewidth;
	  this.lights = source.lights;
	  this.clipping = source.clipping;
	  this.skinning = source.skinning;
	  this.morphTargets = source.morphTargets;
	  this.morphNormals = source.morphNormals;
	  this.extensions = source.extensions;
	  return this;
	};
	ShaderMaterial.prototype.toJSON = function (meta) {
	  var data = Material.prototype.toJSON.call(this, meta);
	  data.uniforms = {};
	  for (var name in this.uniforms) {
	    var uniform = this.uniforms[name];
	    var value = uniform.value;
	    if (value && value.isTexture) {
	      data.uniforms[name] = {
	        type: "t",
	        value: value.toJSON(meta).uuid
	      };
	    } else if (value && value.isColor) {
	      data.uniforms[name] = {
	        type: "c",
	        value: value.getHex()
	      };
	    } else if (value && value.isVector2) {
	      data.uniforms[name] = {
	        type: "v2",
	        value: value.toArray()
	      };
	    } else if (value && value.isVector3) {
	      data.uniforms[name] = {
	        type: "v3",
	        value: value.toArray()
	      };
	    } else if (value && value.isVector4) {
	      data.uniforms[name] = {
	        type: "v4",
	        value: value.toArray()
	      };
	    } else if (value && value.isMatrix3) {
	      data.uniforms[name] = {
	        type: "m3",
	        value: value.toArray()
	      };
	    } else if (value && value.isMatrix4) {
	      data.uniforms[name] = {
	        type: "m4",
	        value: value.toArray()
	      };
	    } else {
	      data.uniforms[name] = {
	        value: value
	      };
	    }
	  }
	  if (Object.keys(this.defines).length > 0) data.defines = this.defines;
	  data.vertexShader = this.vertexShader;
	  data.fragmentShader = this.fragmentShader;
	  var extensions = {};
	  for (var key in this.extensions) {
	    if (this.extensions[key] === true) extensions[key] = true;
	  }
	  if (Object.keys(extensions).length > 0) data.extensions = extensions;
	  return data;
	};
	function Camera() {
	  Object3D.call(this);
	  this.type = "Camera";
	  this.matrixWorldInverse = new Matrix4();
	  this.projectionMatrix = new Matrix4();
	  this.projectionMatrixInverse = new Matrix4();
	}
	Camera.prototype = Object.assign(Object.create(Object3D.prototype), {
	  constructor: Camera,
	  isCamera: true,
	  copy: function (source, recursive) {
	    Object3D.prototype.copy.call(this, source, recursive);
	    this.matrixWorldInverse.copy(source.matrixWorldInverse);
	    this.projectionMatrix.copy(source.projectionMatrix);
	    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
	    return this;
	  },
	  getWorldDirection: function (target) {
	    if (target === undefined) {
	      console.warn("THREE.Camera: .getWorldDirection() target is now required");
	      target = new Vector3();
	    }
	    this.updateMatrixWorld(true);
	    var e = this.matrixWorld.elements;
	    return target.set(-e[8], -e[9], -e[10]).normalize();
	  },
	  updateMatrixWorld: function (force) {
	    Object3D.prototype.updateMatrixWorld.call(this, force);
	    this.matrixWorldInverse.getInverse(this.matrixWorld);
	  },
	  updateWorldMatrix: function (updateParents, updateChildren) {
	    Object3D.prototype.updateWorldMatrix.call(this, updateParents, updateChildren);
	    this.matrixWorldInverse.getInverse(this.matrixWorld);
	  },
	  clone: function () {
	    return new this.constructor().copy(this);
	  }
	});
	function PerspectiveCamera(fov, aspect, near, far) {
	  Camera.call(this);
	  this.type = "PerspectiveCamera";
	  this.fov = fov !== undefined ? fov : 50;
	  this.zoom = 1;
	  this.near = near !== undefined ? near : 0.1;
	  this.far = far !== undefined ? far : 2000;
	  this.focus = 10;
	  this.aspect = aspect !== undefined ? aspect : 1;
	  this.view = null;
	  this.filmGauge = 35;
	  this.filmOffset = 0;
	  this.updateProjectionMatrix();
	}
	PerspectiveCamera.prototype = Object.assign(Object.create(Camera.prototype), {
	  constructor: PerspectiveCamera,
	  isPerspectiveCamera: true,
	  copy: function (source, recursive) {
	    Camera.prototype.copy.call(this, source, recursive);
	    this.fov = source.fov;
	    this.zoom = source.zoom;
	    this.near = source.near;
	    this.far = source.far;
	    this.focus = source.focus;
	    this.aspect = source.aspect;
	    this.view = source.view === null ? null : Object.assign({}, source.view);
	    this.filmGauge = source.filmGauge;
	    this.filmOffset = source.filmOffset;
	    return this;
	  },
	  setFocalLength: function (focalLength) {
	    var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
	    this.fov = MathUtils.RAD2DEG * 2 * Math.atan(vExtentSlope);
	    this.updateProjectionMatrix();
	  },
	  getFocalLength: function () {
	    var vExtentSlope = Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov);
	    return 0.5 * this.getFilmHeight() / vExtentSlope;
	  },
	  getEffectiveFOV: function () {
	    return MathUtils.RAD2DEG * 2 * Math.atan(Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom);
	  },
	  getFilmWidth: function () {
	    return this.filmGauge * Math.min(this.aspect, 1);
	  },
	  getFilmHeight: function () {
	    return this.filmGauge / Math.max(this.aspect, 1);
	  },
	  setViewOffset: function (fullWidth, fullHeight, x, y, width, height) {
	    this.aspect = fullWidth / fullHeight;
	    if (this.view === null) {
	      this.view = {
	        enabled: true,
	        fullWidth: 1,
	        fullHeight: 1,
	        offsetX: 0,
	        offsetY: 0,
	        width: 1,
	        height: 1
	      };
	    }
	    this.view.enabled = true;
	    this.view.fullWidth = fullWidth;
	    this.view.fullHeight = fullHeight;
	    this.view.offsetX = x;
	    this.view.offsetY = y;
	    this.view.width = width;
	    this.view.height = height;
	    this.updateProjectionMatrix();
	  },
	  clearViewOffset: function () {
	    if (this.view !== null) {
	      this.view.enabled = false;
	    }
	    this.updateProjectionMatrix();
	  },
	  updateProjectionMatrix: function () {
	    var near = this.near, top = near * Math.tan(MathUtils.DEG2RAD * 0.5 * this.fov) / this.zoom, height = 2 * top, width = this.aspect * height, left = -0.5 * width, view = this.view;
	    if (this.view !== null && this.view.enabled) {
	      var fullWidth = view.fullWidth, fullHeight = view.fullHeight;
	      left += view.offsetX * width / fullWidth;
	      top -= view.offsetY * height / fullHeight;
	      width *= view.width / fullWidth;
	      height *= view.height / fullHeight;
	    }
	    var skew = this.filmOffset;
	    if (skew !== 0) left += near * skew / this.getFilmWidth();
	    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);
	    this.projectionMatrixInverse.getInverse(this.projectionMatrix);
	  },
	  toJSON: function (meta) {
	    var data = Object3D.prototype.toJSON.call(this, meta);
	    data.object.fov = this.fov;
	    data.object.zoom = this.zoom;
	    data.object.near = this.near;
	    data.object.far = this.far;
	    data.object.focus = this.focus;
	    data.object.aspect = this.aspect;
	    if (this.view !== null) data.object.view = Object.assign({}, this.view);
	    data.object.filmGauge = this.filmGauge;
	    data.object.filmOffset = this.filmOffset;
	    return data;
	  }
	});
	var fov = 90, aspect = 1;
	function CubeCamera(near, far, cubeResolution, options) {
	  Object3D.call(this);
	  this.type = "CubeCamera";
	  var cameraPX = new PerspectiveCamera(fov, aspect, near, far);
	  cameraPX.up.set(0, -1, 0);
	  cameraPX.lookAt(new Vector3(1, 0, 0));
	  this.add(cameraPX);
	  var cameraNX = new PerspectiveCamera(fov, aspect, near, far);
	  cameraNX.up.set(0, -1, 0);
	  cameraNX.lookAt(new Vector3(-1, 0, 0));
	  this.add(cameraNX);
	  var cameraPY = new PerspectiveCamera(fov, aspect, near, far);
	  cameraPY.up.set(0, 0, 1);
	  cameraPY.lookAt(new Vector3(0, 1, 0));
	  this.add(cameraPY);
	  var cameraNY = new PerspectiveCamera(fov, aspect, near, far);
	  cameraNY.up.set(0, 0, -1);
	  cameraNY.lookAt(new Vector3(0, -1, 0));
	  this.add(cameraNY);
	  var cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
	  cameraPZ.up.set(0, -1, 0);
	  cameraPZ.lookAt(new Vector3(0, 0, 1));
	  this.add(cameraPZ);
	  var cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
	  cameraNZ.up.set(0, -1, 0);
	  cameraNZ.lookAt(new Vector3(0, 0, -1));
	  this.add(cameraNZ);
	  options = options || ({
	    format: RGBFormat,
	    magFilter: LinearFilter,
	    minFilter: LinearFilter
	  });
	  this.renderTarget = new WebGLCubeRenderTarget(cubeResolution, options);
	  this.renderTarget.texture.name = "CubeCamera";
	  this.update = function (renderer, scene) {
	    if (this.parent === null) this.updateMatrixWorld();
	    var currentRenderTarget = renderer.getRenderTarget();
	    var renderTarget = this.renderTarget;
	    var generateMipmaps = renderTarget.texture.generateMipmaps;
	    renderTarget.texture.generateMipmaps = false;
	    renderer.setRenderTarget(renderTarget, 0);
	    renderer.render(scene, cameraPX);
	    renderer.setRenderTarget(renderTarget, 1);
	    renderer.render(scene, cameraNX);
	    renderer.setRenderTarget(renderTarget, 2);
	    renderer.render(scene, cameraPY);
	    renderer.setRenderTarget(renderTarget, 3);
	    renderer.render(scene, cameraNY);
	    renderer.setRenderTarget(renderTarget, 4);
	    renderer.render(scene, cameraPZ);
	    renderTarget.texture.generateMipmaps = generateMipmaps;
	    renderer.setRenderTarget(renderTarget, 5);
	    renderer.render(scene, cameraNZ);
	    renderer.setRenderTarget(currentRenderTarget);
	  };
	  this.clear = function (renderer, color, depth, stencil) {
	    var currentRenderTarget = renderer.getRenderTarget();
	    var renderTarget = this.renderTarget;
	    for (var i = 0; i < 6; i++) {
	      renderer.setRenderTarget(renderTarget, i);
	      renderer.clear(color, depth, stencil);
	    }
	    renderer.setRenderTarget(currentRenderTarget);
	  };
	}
	CubeCamera.prototype = Object.create(Object3D.prototype);
	CubeCamera.prototype.constructor = CubeCamera;
	function WebGLCubeRenderTarget(size, options, dummy) {
	  if (Number.isInteger(options)) {
	    console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )");
	    options = dummy;
	  }
	  WebGLRenderTarget.call(this, size, size, options);
	}
	WebGLCubeRenderTarget.prototype = Object.create(WebGLRenderTarget.prototype);
	WebGLCubeRenderTarget.prototype.constructor = WebGLCubeRenderTarget;
	WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;
	WebGLCubeRenderTarget.prototype.fromEquirectangularTexture = function (renderer, texture) {
	  this.texture.type = texture.type;
	  this.texture.format = texture.format;
	  this.texture.encoding = texture.encoding;
	  var scene = new Scene();
	  var shader = {
	    uniforms: {
	      tEquirect: {
	        value: null
	      }
	    },
	    vertexShader: ["varying vec3 vWorldDirection;", "vec3 transformDirection( in vec3 dir, in mat4 matrix ) {", "\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );", "}", "void main() {", "\tvWorldDirection = transformDirection( position, modelMatrix );", "\t#include <begin_vertex>", "\t#include <project_vertex>", "}"].join("\n"),
	    fragmentShader: ["uniform sampler2D tEquirect;", "varying vec3 vWorldDirection;", "#define RECIPROCAL_PI 0.31830988618", "#define RECIPROCAL_PI2 0.15915494", "void main() {", "\tvec3 direction = normalize( vWorldDirection );", "\tvec2 sampleUV;", "\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;", "\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;", "\tgl_FragColor = texture2D( tEquirect, sampleUV );", "}"].join("\n")
	  };
	  var material = new ShaderMaterial({
	    type: "CubemapFromEquirect",
	    uniforms: cloneUniforms(shader.uniforms),
	    vertexShader: shader.vertexShader,
	    fragmentShader: shader.fragmentShader,
	    side: BackSide,
	    blending: NoBlending
	  });
	  material.uniforms.tEquirect.value = texture;
	  var mesh = new Mesh(new BoxBufferGeometry(5, 5, 5), material);
	  scene.add(mesh);
	  var camera = new CubeCamera(1, 10, 1);
	  camera.renderTarget = this;
	  camera.renderTarget.texture.name = "CubeCameraTexture";
	  camera.update(renderer, scene);
	  mesh.geometry.dispose();
	  mesh.material.dispose();
	  return this;
	};
	function DataTexture(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
	  Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
	  this.image = {
	    data: data || null,
	    width: width || 1,
	    height: height || 1
	  };
	  this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
	  this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
	  this.generateMipmaps = false;
	  this.flipY = false;
	  this.unpackAlignment = 1;
	  this.needsUpdate = true;
	}
	DataTexture.prototype = Object.create(Texture.prototype);
	DataTexture.prototype.constructor = DataTexture;
	DataTexture.prototype.isDataTexture = true;
	var _sphere$1 = new Sphere();
	var _vector$5 = new Vector3();
	function Frustum(p0, p1, p2, p3, p4, p5) {
	  this.planes = [p0 !== undefined ? p0 : new Plane(), p1 !== undefined ? p1 : new Plane(), p2 !== undefined ? p2 : new Plane(), p3 !== undefined ? p3 : new Plane(), p4 !== undefined ? p4 : new Plane(), p5 !== undefined ? p5 : new Plane()];
	}
	Object.assign(Frustum.prototype, {
	  set: function (p0, p1, p2, p3, p4, p5) {
	    var planes = this.planes;
	    planes[0].copy(p0);
	    planes[1].copy(p1);
	    planes[2].copy(p2);
	    planes[3].copy(p3);
	    planes[4].copy(p4);
	    planes[5].copy(p5);
	    return this;
	  },
	  clone: function () {
	    return new this.constructor().copy(this);
	  },
	  copy: function (frustum) {
	    var planes = this.planes;
	    for (var i = 0; i < 6; i++) {
	      planes[i].copy(frustum.planes[i]);
	    }
	    return this;
	  },
	  setFromProjectionMatrix: function (m) {
	    var planes = this.planes;
	    var me = m.elements;
	    var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
	    var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
	    var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
	    var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];
	    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
	    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
	    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
	    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
	    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
	    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
	    return this;
	  },
	  intersectsObject: function (object) {
	    var geometry = object.geometry;
	    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
	    _sphere$1.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
	    return this.intersectsSphere(_sphere$1);
	  },
	  intersectsSprite: function (sprite) {
	    _sphere$1.center.set(0, 0, 0);
	    _sphere$1.radius = 0.7071067811865476;
	    _sphere$1.applyMatrix4(sprite.matrixWorld);
	    return this.intersectsSphere(_sphere$1);
	  },
	  intersectsSphere: function (sphere) {
	    var planes = this.planes;
	    var center = sphere.center;
	    var negRadius = -sphere.radius;
	    for (var i = 0; i < 6; i++) {
	      var distance = planes[i].distanceToPoint(center);
	      if (distance < negRadius) {
	        return false;
	      }
	    }
	    return true;
	  },
	  intersectsBox: function (box) {
	    var planes = this.planes;
	    for (var i = 0; i < 6; i++) {
	      var plane = planes[i];
	      _vector$5.x = plane.normal.x > 0 ? box.max.x : box.min.x;
	      _vector$5.y = plane.normal.y > 0 ? box.max.y : box.min.y;
	      _vector$5.z = plane.normal.z > 0 ? box.max.z : box.min.z;
	      if (plane.distanceToPoint(_vector$5) < 0) {
	        return false;
	      }
	    }
	    return true;
	  },
	  containsPoint: function (point) {
	    var planes = this.planes;
	    for (var i = 0; i < 6; i++) {
	      if (planes[i].distanceToPoint(point) < 0) {
	        return false;
	      }
	    }
	    return true;
	  }
	});
	var UniformsLib = {
	  common: {
	    diffuse: {
	      value: new Color(15658734)
	    },
	    opacity: {
	      value: 1
	    },
	    map: {
	      value: null
	    },
	    uvTransform: {
	      value: new Matrix3()
	    },
	    uv2Transform: {
	      value: new Matrix3()
	    },
	    alphaMap: {
	      value: null
	    }
	  },
	  specularmap: {
	    specularMap: {
	      value: null
	    }
	  },
	  envmap: {
	    envMap: {
	      value: null
	    },
	    flipEnvMap: {
	      value: -1
	    },
	    reflectivity: {
	      value: 1
	    },
	    refractionRatio: {
	      value: 0.98
	    },
	    maxMipLevel: {
	      value: 0
	    }
	  },
	  aomap: {
	    aoMap: {
	      value: null
	    },
	    aoMapIntensity: {
	      value: 1
	    }
	  },
	  lightmap: {
	    lightMap: {
	      value: null
	    },
	    lightMapIntensity: {
	      value: 1
	    }
	  },
	  emissivemap: {
	    emissiveMap: {
	      value: null
	    }
	  },
	  bumpmap: {
	    bumpMap: {
	      value: null
	    },
	    bumpScale: {
	      value: 1
	    }
	  },
	  normalmap: {
	    normalMap: {
	      value: null
	    },
	    normalScale: {
	      value: new Vector2(1, 1)
	    }
	  },
	  displacementmap: {
	    displacementMap: {
	      value: null
	    },
	    displacementScale: {
	      value: 1
	    },
	    displacementBias: {
	      value: 0
	    }
	  },
	  roughnessmap: {
	    roughnessMap: {
	      value: null
	    }
	  },
	  metalnessmap: {
	    metalnessMap: {
	      value: null
	    }
	  },
	  gradientmap: {
	    gradientMap: {
	      value: null
	    }
	  },
	  fog: {
	    fogDensity: {
	      value: 0.00025
	    },
	    fogNear: {
	      value: 1
	    },
	    fogFar: {
	      value: 2000
	    },
	    fogColor: {
	      value: new Color(16777215)
	    }
	  },
	  lights: {
	    ambientLightColor: {
	      value: []
	    },
	    lightProbe: {
	      value: []
	    },
	    directionalLights: {
	      value: [],
	      properties: {
	        direction: {},
	        color: {}
	      }
	    },
	    directionalLightShadows: {
	      value: [],
	      properties: {
	        shadowBias: {},
	        shadowRadius: {},
	        shadowMapSize: {}
	      }
	    },
	    directionalShadowMap: {
	      value: []
	    },
	    directionalShadowMatrix: {
	      value: []
	    },
	    spotLights: {
	      value: [],
	      properties: {
	        color: {},
	        position: {},
	        direction: {},
	        distance: {},
	        coneCos: {},
	        penumbraCos: {},
	        decay: {}
	      }
	    },
	    spotLightShadows: {
	      value: [],
	      properties: {
	        shadowBias: {},
	        shadowRadius: {},
	        shadowMapSize: {}
	      }
	    },
	    spotShadowMap: {
	      value: []
	    },
	    spotShadowMatrix: {
	      value: []
	    },
	    pointLights: {
	      value: [],
	      properties: {
	        color: {},
	        position: {},
	        decay: {},
	        distance: {}
	      }
	    },
	    pointLightShadows: {
	      value: [],
	      properties: {
	        shadowBias: {},
	        shadowRadius: {},
	        shadowMapSize: {},
	        shadowCameraNear: {},
	        shadowCameraFar: {}
	      }
	    },
	    pointShadowMap: {
	      value: []
	    },
	    pointShadowMatrix: {
	      value: []
	    },
	    hemisphereLights: {
	      value: [],
	      properties: {
	        direction: {},
	        skyColor: {},
	        groundColor: {}
	      }
	    },
	    rectAreaLights: {
	      value: [],
	      properties: {
	        color: {},
	        position: {},
	        width: {},
	        height: {}
	      }
	    }
	  },
	  points: {
	    diffuse: {
	      value: new Color(15658734)
	    },
	    opacity: {
	      value: 1
	    },
	    size: {
	      value: 1
	    },
	    scale: {
	      value: 1
	    },
	    map: {
	      value: null
	    },
	    alphaMap: {
	      value: null
	    },
	    uvTransform: {
	      value: new Matrix3()
	    }
	  },
	  sprite: {
	    diffuse: {
	      value: new Color(15658734)
	    },
	    opacity: {
	      value: 1
	    },
	    center: {
	      value: new Vector2(0.5, 0.5)
	    },
	    rotation: {
	      value: 0
	    },
	    map: {
	      value: null
	    },
	    alphaMap: {
	      value: null
	    },
	    uvTransform: {
	      value: new Matrix3()
	    }
	  }
	};
	function WebGLAnimation() {
	  var context = null;
	  var isAnimating = false;
	  var animationLoop = null;
	  function onAnimationFrame(time, frame) {
	    if (isAnimating === false) return;
	    animationLoop(time, frame);
	    context.requestAnimationFrame(onAnimationFrame);
	  }
	  return {
	    start: function () {
	      if (isAnimating === true) return;
	      if (animationLoop === null) return;
	      context.requestAnimationFrame(onAnimationFrame);
	      isAnimating = true;
	    },
	    stop: function () {
	      isAnimating = false;
	    },
	    setAnimationLoop: function (callback) {
	      animationLoop = callback;
	    },
	    setContext: function (value) {
	      context = value;
	    }
	  };
	}
	function WebGLAttributes(gl, capabilities) {
	  var isWebGL2 = capabilities.isWebGL2;
	  var buffers = new WeakMap();
	  function createBuffer(attribute, bufferType) {
	    var array = attribute.array;
	    var usage = attribute.usage;
	    var buffer = gl.createBuffer();
	    gl.bindBuffer(bufferType, buffer);
	    gl.bufferData(bufferType, array, usage);
	    attribute.onUploadCallback();
	    var type = 5126;
	    if (array instanceof Float32Array) {
	      type = 5126;
	    } else if (array instanceof Float64Array) {
	      console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.");
	    } else if (array instanceof Uint16Array) {
	      type = 5123;
	    } else if (array instanceof Int16Array) {
	      type = 5122;
	    } else if (array instanceof Uint32Array) {
	      type = 5125;
	    } else if (array instanceof Int32Array) {
	      type = 5124;
	    } else if (array instanceof Int8Array) {
	      type = 5120;
	    } else if (array instanceof Uint8Array) {
	      type = 5121;
	    }
	    return {
	      buffer: buffer,
	      type: type,
	      bytesPerElement: array.BYTES_PER_ELEMENT,
	      version: attribute.version
	    };
	  }
	  function updateBuffer(buffer, attribute, bufferType) {
	    var array = attribute.array;
	    var updateRange = attribute.updateRange;
	    gl.bindBuffer(bufferType, buffer);
	    if (updateRange.count === -1) {
	      gl.bufferSubData(bufferType, 0, array);
	    } else {
	      if (isWebGL2) {
	        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);
	      } else {
	        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));
	      }
	      updateRange.count = -1;
	    }
	  }
	  function get(attribute) {
	    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
	    return buffers.get(attribute);
	  }
	  function remove(attribute) {
	    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
	    var data = buffers.get(attribute);
	    if (data) {
	      gl.deleteBuffer(data.buffer);
	      buffers.delete(attribute);
	    }
	  }
	  function update(attribute, bufferType) {
	    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
	    var data = buffers.get(attribute);
	    if (data === undefined) {
	      buffers.set(attribute, createBuffer(attribute, bufferType));
	    } else if (data.version < attribute.version) {
	      updateBuffer(data.buffer, attribute, bufferType);
	      data.version = attribute.version;
	    }
	  }
	  return {
	    get: get,
	    remove: remove,
	    update: update
	  };
	}
	function PlaneGeometry(width, height, widthSegments, heightSegments) {
	  Geometry.call(this);
	  this.type = "PlaneGeometry";
	  this.parameters = {
	    width: width,
	    height: height,
	    widthSegments: widthSegments,
	    heightSegments: heightSegments
	  };
	  this.fromBufferGeometry(new PlaneBufferGeometry(width, height, widthSegments, heightSegments));
	  this.mergeVertices();
	}
	PlaneGeometry.prototype = Object.create(Geometry.prototype);
	PlaneGeometry.prototype.constructor = PlaneGeometry;
	function PlaneBufferGeometry(width, height, widthSegments, heightSegments) {
	  BufferGeometry.call(this);
	  this.type = "PlaneBufferGeometry";
	  this.parameters = {
	    width: width,
	    height: height,
	    widthSegments: widthSegments,
	    heightSegments: heightSegments
	  };
	  width = width || 1;
	  height = height || 1;
	  var width_half = width / 2;
	  var height_half = height / 2;
	  var gridX = Math.floor(widthSegments) || 1;
	  var gridY = Math.floor(heightSegments) || 1;
	  var gridX1 = gridX + 1;
	  var gridY1 = gridY + 1;
	  var segment_width = width / gridX;
	  var segment_height = height / gridY;
	  var ix, iy;
	  var indices = [];
	  var vertices = [];
	  var normals = [];
	  var uvs = [];
	  for (iy = 0; iy < gridY1; iy++) {
	    var y = iy * segment_height - height_half;
	    for (ix = 0; ix < gridX1; ix++) {
	      var x = ix * segment_width - width_half;
	      vertices.push(x, -y, 0);
	      normals.push(0, 0, 1);
	      uvs.push(ix / gridX);
	      uvs.push(1 - iy / gridY);
	    }
	  }
	  for (iy = 0; iy < gridY; iy++) {
	    for (ix = 0; ix < gridX; ix++) {
	      var a = ix + gridX1 * iy;
	      var b = ix + gridX1 * (iy + 1);
	      var c = ix + 1 + gridX1 * (iy + 1);
	      var d = ix + 1 + gridX1 * iy;
	      indices.push(a, b, d);
	      indices.push(b, c, d);
	    }
	  }
	  this.setIndex(indices);
	  this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
	  this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
	  this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
	}
	PlaneBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
	PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;
	var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
	var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
	var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";
	var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";
	var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
	var begin_vertex = "vec3 transformed = vec3( position );";
	var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";
	var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha  = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";
	var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";
	var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";
	var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP ) && ! defined( TOON )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
	var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP ) && ! defined( TOON )\n\tvarying vec3 vViewPosition;\n#endif";
	var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( STANDARD ) && ! defined( PHONG ) && ! defined( MATCAP ) && ! defined( TOON )\n\tvViewPosition = - mvPosition.xyz;\n#endif";
	var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";
	var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
	var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
	var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";
	var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n  return m[ 2 ][ 3 ] == - 1.0;\n}";
	var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_maxMipLevel 8.0\n#define cubeUV_minMipLevel 4.0\n#define cubeUV_maxTileSize 256.0\n#define cubeUV_minTileSize 16.0\nfloat getFace(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    float face = -1.0;\n    if (absDirection.x > absDirection.z) {\n      if (absDirection.x > absDirection.y)\n        face = direction.x > 0.0 ? 0.0 : 3.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    } else {\n      if (absDirection.z > absDirection.y)\n        face = direction.z > 0.0 ? 2.0 : 5.0;\n      else\n        face = direction.y > 0.0 ? 1.0 : 4.0;\n    }\n    return face;\n}\nvec2 getUV(vec3 direction, float face) {\n    vec2 uv;\n    if (face == 0.0) {\n      uv = vec2(-direction.z, direction.y) / abs(direction.x);\n    } else if (face == 1.0) {\n      uv = vec2(direction.x, -direction.z) / abs(direction.y);\n    } else if (face == 2.0) {\n      uv = direction.xy / abs(direction.z);\n    } else if (face == 3.0) {\n      uv = vec2(direction.z, direction.y) / abs(direction.x);\n    } else if (face == 4.0) {\n      uv = direction.xz / abs(direction.y);\n    } else {\n      uv = vec2(-direction.x, direction.y) / abs(direction.z);\n    }\n    return 0.5 * (uv + 1.0);\n}\nvec3 bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {\n  float face = getFace(direction);\n  float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);\n  mipInt = max(mipInt, cubeUV_minMipLevel);\n  float faceSize = exp2(mipInt);\n  float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);\n  vec2 uv = getUV(direction, face) * (faceSize - 1.0);\n  vec2 f = fract(uv);\n  uv += 0.5 - f;\n  if (face > 2.0) {\n    uv.y += faceSize;\n    face -= 3.0;\n  }\n  uv.x += face * faceSize;\n  if(mipInt < cubeUV_maxMipLevel){\n    uv.y += 2.0 * cubeUV_maxTileSize;\n  }\n  uv.y += filterInt * 2.0 * cubeUV_minTileSize;\n  uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);\n  uv *= texelSize;\n  vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x += texelSize;\n  vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.y += texelSize;\n  vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  uv.x -= texelSize;\n  vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;\n  vec3 tm = mix(tl, tr, f.x);\n  vec3 bm = mix(bl, br, f.x);\n  return mix(tm, bm, f.y);\n}\n#define r0 1.0\n#define v0 0.339\n#define m0 -2.0\n#define r1 0.8\n#define v1 0.276\n#define m1 -1.0\n#define r4 0.4\n#define v4 0.046\n#define m4 2.0\n#define r5 0.305\n#define v5 0.016\n#define m5 3.0\n#define r6 0.21\n#define v6 0.0038\n#define m6 4.0\nfloat roughnessToMip(float roughness) {\n  float mip = 0.0;\n  if (roughness >= r1) {\n    mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;\n  } else if (roughness >= r4) {\n    mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;\n  } else if (roughness >= r5) {\n    mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;\n  } else if (roughness >= r6) {\n    mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;\n  } else {\n    mip = -2.0 * log2(1.16 * roughness);  }\n  return mip;\n}\nvec4 textureCubeUV(sampler2D envMap, vec3 sampleDir, float roughness) {\n  float mip = clamp(roughnessToMip(roughness), m0, cubeUV_maxMipLevel);\n  float mipF = fract(mip);\n  float mipInt = floor(mip);\n  vec3 color0 = bilinearCubeUV(envMap, sampleDir, mipInt);\n  if (mipF == 0.0) {\n    return vec4(color0, 1.0);\n  } else {\n    vec3 color1 = bilinearCubeUV(envMap, sampleDir, mipInt + 1.0);\n    return vec4(mix(color0, color1, mipF), 1.0);\n  }\n}\n#endif";
	var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";
	var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";
	var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";
	var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
	var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";
	var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
	var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";
	var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\t\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t}  else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";
	var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";
	var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";
	var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";
	var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) { \n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";
	var fog_vertex = "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif";
	var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";
	var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
	var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";
	var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";
	var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";
	var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
	var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif";
	var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";
	var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t  vec3 reflectVec = reflect( -viewDir, normal );\n\t\t  reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t  vec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";
	var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
	var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";
	var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
	var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";
	var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = saturate( clearcoat );\tmaterial.clearcoatRoughness = max( clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";
	var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
	var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
	var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";
	var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";
	var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
	var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";
	var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";
	var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";
	var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";
	var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";
	var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
	var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
	var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";
	var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
	var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";
	var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";
	var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";
	var normal_fragment_begin = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";
	var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif";
	var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\tvec3 N = normalize( surf_norm );\n\t\tmat3 tsn = mat3( S, T, N );\n\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif";
	var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";
	var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN );\n\t#endif\n#endif";
	var clearcoat_normalmap_pars_fragment = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";
	var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
	var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";
	var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
	var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
	var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";
	var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";
	var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
	var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";
	var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";
	var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif";
	var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}";
	var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
	var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";
	var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
	var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";
	var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
	var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
	var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
	var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}";
	var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";
	var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";
	var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
	var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
	var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";
	var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";
	var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";
	var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
	var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
	var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
	var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
	var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";
	var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";
	var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";
	var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";
	var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
	var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";
	var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
	var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
	var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
	var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";
	var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
	var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
	var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
	var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";
	var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
	var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
	var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
	var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
	var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSPARENCY\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSPARENCY\n\tuniform float transparency;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSPARENCY\n\t\tdiffuseColor.a *= saturate( 1. - transparency + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
	var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
	var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
	var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";
	var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";
	var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";
	var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
	var shadow_vert = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
	var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
	var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
	var ShaderChunk = {
	  alphamap_fragment: alphamap_fragment,
	  alphamap_pars_fragment: alphamap_pars_fragment,
	  alphatest_fragment: alphatest_fragment,
	  aomap_fragment: aomap_fragment,
	  aomap_pars_fragment: aomap_pars_fragment,
	  begin_vertex: begin_vertex,
	  beginnormal_vertex: beginnormal_vertex,
	  bsdfs: bsdfs,
	  bumpmap_pars_fragment: bumpmap_pars_fragment,
	  clipping_planes_fragment: clipping_planes_fragment,
	  clipping_planes_pars_fragment: clipping_planes_pars_fragment,
	  clipping_planes_pars_vertex: clipping_planes_pars_vertex,
	  clipping_planes_vertex: clipping_planes_vertex,
	  color_fragment: color_fragment,
	  color_pars_fragment: color_pars_fragment,
	  color_pars_vertex: color_pars_vertex,
	  color_vertex: color_vertex,
	  common: common,
	  cube_uv_reflection_fragment: cube_uv_reflection_fragment,
	  defaultnormal_vertex: defaultnormal_vertex,
	  displacementmap_pars_vertex: displacementmap_pars_vertex,
	  displacementmap_vertex: displacementmap_vertex,
	  emissivemap_fragment: emissivemap_fragment,
	  emissivemap_pars_fragment: emissivemap_pars_fragment,
	  encodings_fragment: encodings_fragment,
	  encodings_pars_fragment: encodings_pars_fragment,
	  envmap_fragment: envmap_fragment,
	  envmap_common_pars_fragment: envmap_common_pars_fragment,
	  envmap_pars_fragment: envmap_pars_fragment,
	  envmap_pars_vertex: envmap_pars_vertex,
	  envmap_physical_pars_fragment: envmap_physical_pars_fragment,
	  envmap_vertex: envmap_vertex,
	  fog_vertex: fog_vertex,
	  fog_pars_vertex: fog_pars_vertex,
	  fog_fragment: fog_fragment,
	  fog_pars_fragment: fog_pars_fragment,
	  gradientmap_pars_fragment: gradientmap_pars_fragment,
	  lightmap_fragment: lightmap_fragment,
	  lightmap_pars_fragment: lightmap_pars_fragment,
	  lights_lambert_vertex: lights_lambert_vertex,
	  lights_pars_begin: lights_pars_begin,
	  lights_toon_fragment: lights_toon_fragment,
	  lights_toon_pars_fragment: lights_toon_pars_fragment,
	  lights_phong_fragment: lights_phong_fragment,
	  lights_phong_pars_fragment: lights_phong_pars_fragment,
	  lights_physical_fragment: lights_physical_fragment,
	  lights_physical_pars_fragment: lights_physical_pars_fragment,
	  lights_fragment_begin: lights_fragment_begin,
	  lights_fragment_maps: lights_fragment_maps,
	  lights_fragment_end: lights_fragment_end,
	  logdepthbuf_fragment: logdepthbuf_fragment,
	  logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
	  logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
	  logdepthbuf_vertex: logdepthbuf_vertex,
	  map_fragment: map_fragment,
	  map_pars_fragment: map_pars_fragment,
	  map_particle_fragment: map_particle_fragment,
	  map_particle_pars_fragment: map_particle_pars_fragment,
	  metalnessmap_fragment: metalnessmap_fragment,
	  metalnessmap_pars_fragment: metalnessmap_pars_fragment,
	  morphnormal_vertex: morphnormal_vertex,
	  morphtarget_pars_vertex: morphtarget_pars_vertex,
	  morphtarget_vertex: morphtarget_vertex,
	  normal_fragment_begin: normal_fragment_begin,
	  normal_fragment_maps: normal_fragment_maps,
	  normalmap_pars_fragment: normalmap_pars_fragment,
	  clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
	  clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
	  clearcoat_normalmap_pars_fragment: clearcoat_normalmap_pars_fragment,
	  packing: packing,
	  premultiplied_alpha_fragment: premultiplied_alpha_fragment,
	  project_vertex: project_vertex,
	  dithering_fragment: dithering_fragment,
	  dithering_pars_fragment: dithering_pars_fragment,
	  roughnessmap_fragment: roughnessmap_fragment,
	  roughnessmap_pars_fragment: roughnessmap_pars_fragment,
	  shadowmap_pars_fragment: shadowmap_pars_fragment,
	  shadowmap_pars_vertex: shadowmap_pars_vertex,
	  shadowmap_vertex: shadowmap_vertex,
	  shadowmask_pars_fragment: shadowmask_pars_fragment,
	  skinbase_vertex: skinbase_vertex,
	  skinning_pars_vertex: skinning_pars_vertex,
	  skinning_vertex: skinning_vertex,
	  skinnormal_vertex: skinnormal_vertex,
	  specularmap_fragment: specularmap_fragment,
	  specularmap_pars_fragment: specularmap_pars_fragment,
	  tonemapping_fragment: tonemapping_fragment,
	  tonemapping_pars_fragment: tonemapping_pars_fragment,
	  uv_pars_fragment: uv_pars_fragment,
	  uv_pars_vertex: uv_pars_vertex,
	  uv_vertex: uv_vertex,
	  uv2_pars_fragment: uv2_pars_fragment,
	  uv2_pars_vertex: uv2_pars_vertex,
	  uv2_vertex: uv2_vertex,
	  worldpos_vertex: worldpos_vertex,
	  background_frag: background_frag,
	  background_vert: background_vert,
	  cube_frag: cube_frag,
	  cube_vert: cube_vert,
	  depth_frag: depth_frag,
	  depth_vert: depth_vert,
	  distanceRGBA_frag: distanceRGBA_frag,
	  distanceRGBA_vert: distanceRGBA_vert,
	  equirect_frag: equirect_frag,
	  equirect_vert: equirect_vert,
	  linedashed_frag: linedashed_frag,
	  linedashed_vert: linedashed_vert,
	  meshbasic_frag: meshbasic_frag,
	  meshbasic_vert: meshbasic_vert,
	  meshlambert_frag: meshlambert_frag,
	  meshlambert_vert: meshlambert_vert,
	  meshmatcap_frag: meshmatcap_frag,
	  meshmatcap_vert: meshmatcap_vert,
	  meshtoon_frag: meshtoon_frag,
	  meshtoon_vert: meshtoon_vert,
	  meshphong_frag: meshphong_frag,
	  meshphong_vert: meshphong_vert,
	  meshphysical_frag: meshphysical_frag,
	  meshphysical_vert: meshphysical_vert,
	  normal_frag: normal_frag,
	  normal_vert: normal_vert,
	  points_frag: points_frag,
	  points_vert: points_vert,
	  shadow_frag: shadow_frag,
	  shadow_vert: shadow_vert,
	  sprite_frag: sprite_frag,
	  sprite_vert: sprite_vert
	};
	var ShaderLib = {
	  basic: {
	    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.fog]),
	    vertexShader: ShaderChunk.meshbasic_vert,
	    fragmentShader: ShaderChunk.meshbasic_frag
	  },
	  lambert: {
	    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.fog, UniformsLib.lights, {
	      emissive: {
	        value: new Color(0)
	      }
	    }]),
	    vertexShader: ShaderChunk.meshlambert_vert,
	    fragmentShader: ShaderChunk.meshlambert_frag
	  },
	  phong: {
	    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, UniformsLib.lights, {
	      emissive: {
	        value: new Color(0)
	      },
	      specular: {
	        value: new Color(1118481)
	      },
	      shininess: {
	        value: 30
	      }
	    }]),
	    vertexShader: ShaderChunk.meshphong_vert,
	    fragmentShader: ShaderChunk.meshphong_frag
	  },
	  standard: {
	    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.envmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.roughnessmap, UniformsLib.metalnessmap, UniformsLib.fog, UniformsLib.lights, {
	      emissive: {
	        value: new Color(0)
	      },
	      roughness: {
	        value: 0.5
	      },
	      metalness: {
	        value: 0.5
	      },
	      envMapIntensity: {
	        value: 1
	      }
	    }]),
	    vertexShader: ShaderChunk.meshphysical_vert,
	    fragmentShader: ShaderChunk.meshphysical_frag
	  },
	  toon: {
	    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.specularmap, UniformsLib.aomap, UniformsLib.lightmap, UniformsLib.emissivemap, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.gradientmap, UniformsLib.fog, UniformsLib.lights, {
	      emissive: {
	        value: new Color(0)
	      },
	      specular: {
	        value: new Color(1118481)
	      },
	      shininess: {
	        value: 30
	      }
	    }]),
	    vertexShader: ShaderChunk.meshtoon_vert,
	    fragmentShader: ShaderChunk.meshtoon_frag
	  },
	  matcap: {
	    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, UniformsLib.fog, {
	      matcap: {
	        value: null
	      }
	    }]),
	    vertexShader: ShaderChunk.meshmatcap_vert,
	    fragmentShader: ShaderChunk.meshmatcap_frag
	  },
	  points: {
	    uniforms: mergeUniforms([UniformsLib.points, UniformsLib.fog]),
	    vertexShader: ShaderChunk.points_vert,
	    fragmentShader: ShaderChunk.points_frag
	  },
	  dashed: {
	    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.fog, {
	      scale: {
	        value: 1
	      },
	      dashSize: {
	        value: 1
	      },
	      totalSize: {
	        value: 2
	      }
	    }]),
	    vertexShader: ShaderChunk.linedashed_vert,
	    fragmentShader: ShaderChunk.linedashed_frag
	  },
	  depth: {
	    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap]),
	    vertexShader: ShaderChunk.depth_vert,
	    fragmentShader: ShaderChunk.depth_frag
	  },
	  normal: {
	    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.bumpmap, UniformsLib.normalmap, UniformsLib.displacementmap, {
	      opacity: {
	        value: 1
	      }
	    }]),
	    vertexShader: ShaderChunk.normal_vert,
	    fragmentShader: ShaderChunk.normal_frag
	  },
	  sprite: {
	    uniforms: mergeUniforms([UniformsLib.sprite, UniformsLib.fog]),
	    vertexShader: ShaderChunk.sprite_vert,
	    fragmentShader: ShaderChunk.sprite_frag
	  },
	  background: {
	    uniforms: {
	      uvTransform: {
	        value: new Matrix3()
	      },
	      t2D: {
	        value: null
	      }
	    },
	    vertexShader: ShaderChunk.background_vert,
	    fragmentShader: ShaderChunk.background_frag
	  },
	  cube: {
	    uniforms: mergeUniforms([UniformsLib.envmap, {
	      opacity: {
	        value: 1
	      }
	    }]),
	    vertexShader: ShaderChunk.cube_vert,
	    fragmentShader: ShaderChunk.cube_frag
	  },
	  equirect: {
	    uniforms: {
	      tEquirect: {
	        value: null
	      }
	    },
	    vertexShader: ShaderChunk.equirect_vert,
	    fragmentShader: ShaderChunk.equirect_frag
	  },
	  distanceRGBA: {
	    uniforms: mergeUniforms([UniformsLib.common, UniformsLib.displacementmap, {
	      referencePosition: {
	        value: new Vector3()
	      },
	      nearDistance: {
	        value: 1
	      },
	      farDistance: {
	        value: 1000
	      }
	    }]),
	    vertexShader: ShaderChunk.distanceRGBA_vert,
	    fragmentShader: ShaderChunk.distanceRGBA_frag
	  },
	  shadow: {
	    uniforms: mergeUniforms([UniformsLib.lights, UniformsLib.fog, {
	      color: {
	        value: new Color(0)
	      },
	      opacity: {
	        value: 1
	      }
	    }]),
	    vertexShader: ShaderChunk.shadow_vert,
	    fragmentShader: ShaderChunk.shadow_frag
	  }
	};
	ShaderLib.physical = {
	  uniforms: mergeUniforms([ShaderLib.standard.uniforms, {
	    transparency: {
	      value: 0
	    },
	    clearcoat: {
	      value: 0
	    },
	    clearcoatRoughness: {
	      value: 0
	    },
	    sheen: {
	      value: new Color(0)
	    },
	    clearcoatNormalScale: {
	      value: new Vector2(1, 1)
	    },
	    clearcoatNormalMap: {
	      value: null
	    }
	  }]),
	  vertexShader: ShaderChunk.meshphysical_vert,
	  fragmentShader: ShaderChunk.meshphysical_frag
	};
	function WebGLBackground(renderer, state, objects, premultipliedAlpha) {
	  var clearColor = new Color(0);
	  var clearAlpha = 0;
	  var planeMesh;
	  var boxMesh;
	  var currentBackground = null;
	  var currentBackgroundVersion = 0;
	  var currentTonemapping = null;
	  function render(renderList, scene, camera, forceClear) {
	    var background = scene.background;
	    var xr = renderer.xr;
	    var session = xr.getSession && xr.getSession();
	    if (session && session.environmentBlendMode === "additive") {
	      background = null;
	    }
	    if (background === null) {
	      setClear(clearColor, clearAlpha);
	    } else if (background && background.isColor) {
	      setClear(background, 1);
	      forceClear = true;
	    }
	    if (renderer.autoClear || forceClear) {
	      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
	    }
	    if (background && (background.isCubeTexture || background.isWebGLCubeRenderTarget || background.mapping === CubeUVReflectionMapping)) {
	      if (boxMesh === undefined) {
	        boxMesh = new Mesh(new BoxBufferGeometry(1, 1, 1), new ShaderMaterial({
	          type: "BackgroundCubeMaterial",
	          uniforms: cloneUniforms(ShaderLib.cube.uniforms),
	          vertexShader: ShaderLib.cube.vertexShader,
	          fragmentShader: ShaderLib.cube.fragmentShader,
	          side: BackSide,
	          depthTest: false,
	          depthWrite: false,
	          fog: false
	        }));
	        boxMesh.geometry.deleteAttribute("normal");
	        boxMesh.geometry.deleteAttribute("uv");
	        boxMesh.onBeforeRender = function (renderer, scene, camera) {
	          this.matrixWorld.copyPosition(camera.matrixWorld);
	        };
	        Object.defineProperty(boxMesh.material, "envMap", {
	          get: function () {
	            return this.uniforms.envMap.value;
	          }
	        });
	        objects.update(boxMesh);
	      }
	      var texture = background.isWebGLCubeRenderTarget ? background.texture : background;
	      boxMesh.material.uniforms.envMap.value = texture;
	      boxMesh.material.uniforms.flipEnvMap.value = texture.isCubeTexture ? -1 : 1;
	      if (currentBackground !== background || currentBackgroundVersion !== texture.version || currentTonemapping !== renderer.toneMapping) {
	        boxMesh.material.needsUpdate = true;
	        currentBackground = background;
	        currentBackgroundVersion = texture.version;
	        currentTonemapping = renderer.toneMapping;
	      }
	      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
	    } else if (background && background.isTexture) {
	      if (planeMesh === undefined) {
	        planeMesh = new Mesh(new PlaneBufferGeometry(2, 2), new ShaderMaterial({
	          type: "BackgroundMaterial",
	          uniforms: cloneUniforms(ShaderLib.background.uniforms),
	          vertexShader: ShaderLib.background.vertexShader,
	          fragmentShader: ShaderLib.background.fragmentShader,
	          side: FrontSide,
	          depthTest: false,
	          depthWrite: false,
	          fog: false
	        }));
	        planeMesh.geometry.deleteAttribute("normal");
	        Object.defineProperty(planeMesh.material, "map", {
	          get: function () {
	            return this.uniforms.t2D.value;
	          }
	        });
	        objects.update(planeMesh);
	      }
	      planeMesh.material.uniforms.t2D.value = background;
	      if (background.matrixAutoUpdate === true) {
	        background.updateMatrix();
	      }
	      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
	      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
	        planeMesh.material.needsUpdate = true;
	        currentBackground = background;
	        currentBackgroundVersion = background.version;
	        currentTonemapping = renderer.toneMapping;
	      }
	      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
	    }
	  }
	  function setClear(color, alpha) {
	    state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);
	  }
	  return {
	    getClearColor: function () {
	      return clearColor;
	    },
	    setClearColor: function (color, alpha) {
	      clearColor.set(color);
	      clearAlpha = alpha !== undefined ? alpha : 1;
	      setClear(clearColor, clearAlpha);
	    },
	    getClearAlpha: function () {
	      return clearAlpha;
	    },
	    setClearAlpha: function (alpha) {
	      clearAlpha = alpha;
	      setClear(clearColor, clearAlpha);
	    },
	    render: render
	  };
	}
	function WebGLBufferRenderer(gl, extensions, info, capabilities) {
	  var isWebGL2 = capabilities.isWebGL2;
	  var mode;
	  function setMode(value) {
	    mode = value;
	  }
	  function render(start, count) {
	    gl.drawArrays(mode, start, count);
	    info.update(count, mode);
	  }
	  function renderInstances(geometry, start, count, primcount) {
	    if (primcount === 0) return;
	    var extension, methodName;
	    if (isWebGL2) {
	      extension = gl;
	      methodName = "drawArraysInstanced";
	    } else {
	      extension = extensions.get("ANGLE_instanced_arrays");
	      methodName = "drawArraysInstancedANGLE";
	      if (extension === null) {
	        console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
	        return;
	      }
	    }
	    extension[methodName](mode, start, count, primcount);
	    info.update(count, mode, primcount);
	  }
	  this.setMode = setMode;
	  this.render = render;
	  this.renderInstances = renderInstances;
	}
	function WebGLCapabilities(gl, extensions, parameters) {
	  var maxAnisotropy;
	  function getMaxAnisotropy() {
	    if (maxAnisotropy !== undefined) return maxAnisotropy;
	    var extension = extensions.get("EXT_texture_filter_anisotropic");
	    if (extension !== null) {
	      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
	    } else {
	      maxAnisotropy = 0;
	    }
	    return maxAnisotropy;
	  }
	  function getMaxPrecision(precision) {
	    if (precision === "highp") {
	      if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {
	        return "highp";
	      }
	      precision = "mediump";
	    }
	    if (precision === "mediump") {
	      if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {
	        return "mediump";
	      }
	    }
	    return "lowp";
	  }
	  var isWebGL2 = typeof WebGL2RenderingContext !== "undefined" && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== "undefined" && gl instanceof WebGL2ComputeRenderingContext;
	  var precision = parameters.precision !== undefined ? parameters.precision : "highp";
	  var maxPrecision = getMaxPrecision(precision);
	  if (maxPrecision !== precision) {
	    console.warn("THREE.WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
	    precision = maxPrecision;
	  }
	  var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
	  var maxTextures = gl.getParameter(34930);
	  var maxVertexTextures = gl.getParameter(35660);
	  var maxTextureSize = gl.getParameter(3379);
	  var maxCubemapSize = gl.getParameter(34076);
	  var maxAttributes = gl.getParameter(34921);
	  var maxVertexUniforms = gl.getParameter(36347);
	  var maxVaryings = gl.getParameter(36348);
	  var maxFragmentUniforms = gl.getParameter(36349);
	  var vertexTextures = maxVertexTextures > 0;
	  var floatFragmentTextures = isWebGL2 || !!extensions.get("OES_texture_float");
	  var floatVertexTextures = vertexTextures && floatFragmentTextures;
	  var maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;
	  return {
	    isWebGL2: isWebGL2,
	    getMaxAnisotropy: getMaxAnisotropy,
	    getMaxPrecision: getMaxPrecision,
	    precision: precision,
	    logarithmicDepthBuffer: logarithmicDepthBuffer,
	    maxTextures: maxTextures,
	    maxVertexTextures: maxVertexTextures,
	    maxTextureSize: maxTextureSize,
	    maxCubemapSize: maxCubemapSize,
	    maxAttributes: maxAttributes,
	    maxVertexUniforms: maxVertexUniforms,
	    maxVaryings: maxVaryings,
	    maxFragmentUniforms: maxFragmentUniforms,
	    vertexTextures: vertexTextures,
	    floatFragmentTextures: floatFragmentTextures,
	    floatVertexTextures: floatVertexTextures,
	    maxSamples: maxSamples
	  };
	}
	function WebGLClipping() {
	  var scope = this, globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false, plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = {
	    value: null,
	    needsUpdate: false
	  };
	  this.uniform = uniform;
	  this.numPlanes = 0;
	  this.numIntersection = 0;
	  this.init = function (planes, enableLocalClipping, camera) {
	    var enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;
	    localClippingEnabled = enableLocalClipping;
	    globalState = projectPlanes(planes, camera, 0);
	    numGlobalPlanes = planes.length;
	    return enabled;
	  };
	  this.beginShadows = function () {
	    renderingShadows = true;
	    projectPlanes(null);
	  };
	  this.endShadows = function () {
	    renderingShadows = false;
	    resetGlobalState();
	  };
	  this.setState = function (planes, clipIntersection, clipShadows, camera, cache, fromCache) {
	    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
	      if (renderingShadows) {
	        projectPlanes(null);
	      } else {
	        resetGlobalState();
	      }
	    } else {
	      var nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4, dstArray = cache.clippingState || null;
	      uniform.value = dstArray;
	      dstArray = projectPlanes(planes, camera, lGlobal, fromCache);
	      for (var i = 0; i !== lGlobal; ++i) {
	        dstArray[i] = globalState[i];
	      }
	      cache.clippingState = dstArray;
	      this.numIntersection = clipIntersection ? this.numPlanes : 0;
	      this.numPlanes += nGlobal;
	    }
	  };
	  function resetGlobalState() {
	    if (uniform.value !== globalState) {
	      uniform.value = globalState;
	      uniform.needsUpdate = numGlobalPlanes > 0;
	    }
	    scope.numPlanes = numGlobalPlanes;
	    scope.numIntersection = 0;
	  }
	  function projectPlanes(planes, camera, dstOffset, skipTransform) {
	    var nPlanes = planes !== null ? planes.length : 0, dstArray = null;
	    if (nPlanes !== 0) {
	      dstArray = uniform.value;
	      if (skipTransform !== true || dstArray === null) {
	        var flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
	        viewNormalMatrix.getNormalMatrix(viewMatrix);
	        if (dstArray === null || dstArray.length < flatSize) {
	          dstArray = new Float32Array(flatSize);
	        }
	        for (var i = 0, i4 = dstOffset; i !== nPlanes; (++i, i4 += 4)) {
	          plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);
	          plane.normal.toArray(dstArray, i4);
	          dstArray[i4 + 3] = plane.constant;
	        }
	      }
	      uniform.value = dstArray;
	      uniform.needsUpdate = true;
	    }
	    scope.numPlanes = nPlanes;
	    scope.numIntersection = 0;
	    return dstArray;
	  }
	}
	function WebGLExtensions(gl) {
	  var extensions = {};
	  return {
	    get: function (name) {
	      if (extensions[name] !== undefined) {
	        return extensions[name];
	      }
	      var extension;
	      switch (name) {
	        case "WEBGL_depth_texture":
	          extension = gl.getExtension("WEBGL_depth_texture") || gl.getExtension("MOZ_WEBGL_depth_texture") || gl.getExtension("WEBKIT_WEBGL_depth_texture");
	          break;
	        case "EXT_texture_filter_anisotropic":
	          extension = gl.getExtension("EXT_texture_filter_anisotropic") || gl.getExtension("MOZ_EXT_texture_filter_anisotropic") || gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
	          break;
	        case "WEBGL_compressed_texture_s3tc":
	          extension = gl.getExtension("WEBGL_compressed_texture_s3tc") || gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
	          break;
	        case "WEBGL_compressed_texture_pvrtc":
	          extension = gl.getExtension("WEBGL_compressed_texture_pvrtc") || gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
	          break;
	        default:
	          extension = gl.getExtension(name);
	      }
	      if (extension === null) {
	        console.warn("THREE.WebGLRenderer: " + name + " extension not supported.");
	      }
	      extensions[name] = extension;
	      return extension;
	    }
	  };
	}
	function WebGLGeometries(gl, attributes, info) {
	  var geometries = new WeakMap();
	  var wireframeAttributes = new WeakMap();
	  function onGeometryDispose(event) {
	    var geometry = event.target;
	    var buffergeometry = geometries.get(geometry);
	    if (buffergeometry.index !== null) {
	      attributes.remove(buffergeometry.index);
	    }
	    for (var name in buffergeometry.attributes) {
	      attributes.remove(buffergeometry.attributes[name]);
	    }
	    geometry.removeEventListener("dispose", onGeometryDispose);
	    geometries.delete(geometry);
	    var attribute = wireframeAttributes.get(buffergeometry);
	    if (attribute) {
	      attributes.remove(attribute);
	      wireframeAttributes.delete(buffergeometry);
	    }
	    info.memory.geometries--;
	  }
	  function get(object, geometry) {
	    var buffergeometry = geometries.get(geometry);
	    if (buffergeometry) return buffergeometry;
	    geometry.addEventListener("dispose", onGeometryDispose);
	    if (geometry.isBufferGeometry) {
	      buffergeometry = geometry;
	    } else if (geometry.isGeometry) {
	      if (geometry._bufferGeometry === undefined) {
	        geometry._bufferGeometry = new BufferGeometry().setFromObject(object);
	      }
	      buffergeometry = geometry._bufferGeometry;
	    }
	    geometries.set(geometry, buffergeometry);
	    info.memory.geometries++;
	    return buffergeometry;
	  }
	  function update(geometry) {
	    var index = geometry.index;
	    var geometryAttributes = geometry.attributes;
	    if (index !== null) {
	      attributes.update(index, 34963);
	    }
	    for (var name in geometryAttributes) {
	      attributes.update(geometryAttributes[name], 34962);
	    }
	    var morphAttributes = geometry.morphAttributes;
	    for (var name in morphAttributes) {
	      var array = morphAttributes[name];
	      for (var i = 0, l = array.length; i < l; i++) {
	        attributes.update(array[i], 34962);
	      }
	    }
	  }
	  function updateWireframeAttribute(geometry) {
	    var indices = [];
	    var geometryIndex = geometry.index;
	    var geometryPosition = geometry.attributes.position;
	    var version = 0;
	    if (geometryIndex !== null) {
	      var array = geometryIndex.array;
	      version = geometryIndex.version;
	      for (var i = 0, l = array.length; i < l; i += 3) {
	        var a = array[i + 0];
	        var b = array[i + 1];
	        var c = array[i + 2];
	        indices.push(a, b, b, c, c, a);
	      }
	    } else {
	      var array = geometryPosition.array;
	      version = geometryPosition.version;
	      for (var i = 0, l = array.length / 3 - 1; i < l; i += 3) {
	        var a = i + 0;
	        var b = i + 1;
	        var c = i + 2;
	        indices.push(a, b, b, c, c, a);
	      }
	    }
	    var attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
	    attribute.version = version;
	    attributes.update(attribute, 34963);
	    var previousAttribute = wireframeAttributes.get(geometry);
	    if (previousAttribute) attributes.remove(previousAttribute);
	    wireframeAttributes.set(geometry, attribute);
	  }
	  function getWireframeAttribute(geometry) {
	    var currentAttribute = wireframeAttributes.get(geometry);
	    if (currentAttribute) {
	      var geometryIndex = geometry.index;
	      if (geometryIndex !== null) {
	        if (currentAttribute.version < geometryIndex.version) {
	          updateWireframeAttribute(geometry);
	        }
	      }
	    } else {
	      updateWireframeAttribute(geometry);
	    }
	    return wireframeAttributes.get(geometry);
	  }
	  return {
	    get: get,
	    update: update,
	    getWireframeAttribute: getWireframeAttribute
	  };
	}
	function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
	  var isWebGL2 = capabilities.isWebGL2;
	  var mode;
	  function setMode(value) {
	    mode = value;
	  }
	  var type, bytesPerElement;
	  function setIndex(value) {
	    type = value.type;
	    bytesPerElement = value.bytesPerElement;
	  }
	  function render(start, count) {
	    gl.drawElements(mode, count, type, start * bytesPerElement);
	    info.update(count, mode);
	  }
	  function renderInstances(geometry, start, count, primcount) {
	    if (primcount === 0) return;
	    var extension, methodName;
	    if (isWebGL2) {
	      extension = gl;
	      methodName = "drawElementsInstanced";
	    } else {
	      extension = extensions.get("ANGLE_instanced_arrays");
	      methodName = "drawElementsInstancedANGLE";
	      if (extension === null) {
	        console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
	        return;
	      }
	    }
	    extension[methodName](mode, count, type, start * bytesPerElement, primcount);
	    info.update(count, mode, primcount);
	  }
	  this.setMode = setMode;
	  this.setIndex = setIndex;
	  this.render = render;
	  this.renderInstances = renderInstances;
	}
	function WebGLInfo(gl) {
	  var memory = {
	    geometries: 0,
	    textures: 0
	  };
	  var render = {
	    frame: 0,
	    calls: 0,
	    triangles: 0,
	    points: 0,
	    lines: 0
	  };
	  function update(count, mode, instanceCount) {
	    instanceCount = instanceCount || 1;
	    render.calls++;
	    switch (mode) {
	      case 4:
	        render.triangles += instanceCount * (count / 3);
	        break;
	      case 1:
	        render.lines += instanceCount * (count / 2);
	        break;
	      case 3:
	        render.lines += instanceCount * (count - 1);
	        break;
	      case 2:
	        render.lines += instanceCount * count;
	        break;
	      case 0:
	        render.points += instanceCount * count;
	        break;
	      default:
	        console.error("THREE.WebGLInfo: Unknown draw mode:", mode);
	        break;
	    }
	  }
	  function reset() {
	    render.frame++;
	    render.calls = 0;
	    render.triangles = 0;
	    render.points = 0;
	    render.lines = 0;
	  }
	  return {
	    memory: memory,
	    render: render,
	    programs: null,
	    autoReset: true,
	    reset: reset,
	    update: update
	  };
	}
	function absNumericalSort(a, b) {
	  return Math.abs(b[1]) - Math.abs(a[1]);
	}
	function WebGLMorphtargets(gl) {
	  var influencesList = {};
	  var morphInfluences = new Float32Array(8);
	  function update(object, geometry, material, program) {
	    var objectInfluences = object.morphTargetInfluences;
	    var length = objectInfluences === undefined ? 0 : objectInfluences.length;
	    var influences = influencesList[geometry.id];
	    if (influences === undefined) {
	      influences = [];
	      for (var i = 0; i < length; i++) {
	        influences[i] = [i, 0];
	      }
	      influencesList[geometry.id] = influences;
	    }
	    var morphTargets = material.morphTargets && geometry.morphAttributes.position;
	    var morphNormals = material.morphNormals && geometry.morphAttributes.normal;
	    for (var i = 0; i < length; i++) {
	      var influence = influences[i];
	      if (influence[1] !== 0) {
	        if (morphTargets) geometry.deleteAttribute("morphTarget" + i);
	        if (morphNormals) geometry.deleteAttribute("morphNormal" + i);
	      }
	    }
	    for (var i = 0; i < length; i++) {
	      var influence = influences[i];
	      influence[0] = i;
	      influence[1] = objectInfluences[i];
	    }
	    influences.sort(absNumericalSort);
	    var morphInfluencesSum = 0;
	    for (var i = 0; i < 8; i++) {
	      var influence = influences[i];
	      if (influence) {
	        var index = influence[0];
	        var value = influence[1];
	        if (value) {
	          if (morphTargets) geometry.setAttribute("morphTarget" + i, morphTargets[index]);
	          if (morphNormals) geometry.setAttribute("morphNormal" + i, morphNormals[index]);
	          morphInfluences[i] = value;
	          morphInfluencesSum += value;
	          continue;
	        }
	      }
	      morphInfluences[i] = 0;
	    }
	    var morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
	    program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
	    program.getUniforms().setValue(gl, "morphTargetInfluences", morphInfluences);
	  }
	  return {
	    update: update
	  };
	}
	function WebGLObjects(gl, geometries, attributes, info) {
	  var updateMap = new WeakMap();
	  function update(object) {
	    var frame = info.render.frame;
	    var geometry = object.geometry;
	    var buffergeometry = geometries.get(object, geometry);
	    if (updateMap.get(buffergeometry) !== frame) {
	      if (geometry.isGeometry) {
	        buffergeometry.updateFromObject(object);
	      }
	      geometries.update(buffergeometry);
	      updateMap.set(buffergeometry, frame);
	    }
	    if (object.isInstancedMesh) {
	      attributes.update(object.instanceMatrix, 34962);
	    }
	    return buffergeometry;
	  }
	  function dispose() {
	    updateMap = new WeakMap();
	  }
	  return {
	    update: update,
	    dispose: dispose
	  };
	}
	function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {
	  images = images !== undefined ? images : [];
	  mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
	  format = format !== undefined ? format : RGBFormat;
	  Texture.call(this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
	  this.flipY = false;
	}
	CubeTexture.prototype = Object.create(Texture.prototype);
	CubeTexture.prototype.constructor = CubeTexture;
	CubeTexture.prototype.isCubeTexture = true;
	Object.defineProperty(CubeTexture.prototype, "images", {
	  get: function () {
	    return this.image;
	  },
	  set: function (value) {
	    this.image = value;
	  }
	});
	function DataTexture2DArray(data, width, height, depth) {
	  Texture.call(this, null);
	  this.image = {
	    data: data || null,
	    width: width || 1,
	    height: height || 1,
	    depth: depth || 1
	  };
	  this.magFilter = NearestFilter;
	  this.minFilter = NearestFilter;
	  this.wrapR = ClampToEdgeWrapping;
	  this.generateMipmaps = false;
	  this.flipY = false;
	  this.needsUpdate = true;
	}
	DataTexture2DArray.prototype = Object.create(Texture.prototype);
	DataTexture2DArray.prototype.constructor = DataTexture2DArray;
	DataTexture2DArray.prototype.isDataTexture2DArray = true;
	function DataTexture3D(data, width, height, depth) {
	  Texture.call(this, null);
	  this.image = {
	    data: data || null,
	    width: width || 1,
	    height: height || 1,
	    depth: depth || 1
	  };
	  this.magFilter = NearestFilter;
	  this.minFilter = NearestFilter;
	  this.wrapR = ClampToEdgeWrapping;
	  this.generateMipmaps = false;
	  this.flipY = false;
	  this.needsUpdate = true;
	}
	DataTexture3D.prototype = Object.create(Texture.prototype);
	DataTexture3D.prototype.constructor = DataTexture3D;
	DataTexture3D.prototype.isDataTexture3D = true;
	var emptyTexture = new Texture();
	var emptyTexture2dArray = new DataTexture2DArray();
	var emptyTexture3d = new DataTexture3D();
	var emptyCubeTexture = new CubeTexture();
	var arrayCacheF32 = [];
	var arrayCacheI32 = [];
	var mat4array = new Float32Array(16);
	var mat3array = new Float32Array(9);
	var mat2array = new Float32Array(4);
	function flatten(array, nBlocks, blockSize) {
	  var firstElem = array[0];
	  if (firstElem <= 0 || firstElem > 0) return array;
	  var n = nBlocks * blockSize, r = arrayCacheF32[n];
	  if (r === undefined) {
	    r = new Float32Array(n);
	    arrayCacheF32[n] = r;
	  }
	  if (nBlocks !== 0) {
	    firstElem.toArray(r, 0);
	    for (var i = 1, offset = 0; i !== nBlocks; ++i) {
	      offset += blockSize;
	      array[i].toArray(r, offset);
	    }
	  }
	  return r;
	}
	function arraysEqual(a, b) {
	  if (a.length !== b.length) return false;
	  for (var i = 0, l = a.length; i < l; i++) {
	    if (a[i] !== b[i]) return false;
	  }
	  return true;
	}
	function copyArray(a, b) {
	  for (var i = 0, l = b.length; i < l; i++) {
	    a[i] = b[i];
	  }
	}
	function allocTexUnits(textures, n) {
	  var r = arrayCacheI32[n];
	  if (r === undefined) {
	    r = new Int32Array(n);
	    arrayCacheI32[n] = r;
	  }
	  for (var i = 0; i !== n; ++i) r[i] = textures.allocateTextureUnit();
	  return r;
	}
	function setValueV1f(gl, v) {
	  var cache = this.cache;
	  if (cache[0] === v) return;
	  gl.uniform1f(this.addr, v);
	  cache[0] = v;
	}
	function setValueV2f(gl, v) {
	  var cache = this.cache;
	  if (v.x !== undefined) {
	    if (cache[0] !== v.x || cache[1] !== v.y) {
	      gl.uniform2f(this.addr, v.x, v.y);
	      cache[0] = v.x;
	      cache[1] = v.y;
	    }
	  } else {
	    if (arraysEqual(cache, v)) return;
	    gl.uniform2fv(this.addr, v);
	    copyArray(cache, v);
	  }
	}
	function setValueV3f(gl, v) {
	  var cache = this.cache;
	  if (v.x !== undefined) {
	    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
	      gl.uniform3f(this.addr, v.x, v.y, v.z);
	      cache[0] = v.x;
	      cache[1] = v.y;
	      cache[2] = v.z;
	    }
	  } else if (v.r !== undefined) {
	    if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
	      gl.uniform3f(this.addr, v.r, v.g, v.b);
	      cache[0] = v.r;
	      cache[1] = v.g;
	      cache[2] = v.b;
	    }
	  } else {
	    if (arraysEqual(cache, v)) return;
	    gl.uniform3fv(this.addr, v);
	    copyArray(cache, v);
	  }
	}
	function setValueV4f(gl, v) {
	  var cache = this.cache;
	  if (v.x !== undefined) {
	    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {
	      gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);
	      cache[0] = v.x;
	      cache[1] = v.y;
	      cache[2] = v.z;
	      cache[3] = v.w;
	    }
	  } else {
	    if (arraysEqual(cache, v)) return;
	    gl.uniform4fv(this.addr, v);
	    copyArray(cache, v);
	  }
	}
	function setValueM2(gl, v) {
	  var cache = this.cache;
	  var elements = v.elements;
	  if (elements === undefined) {
	    if (arraysEqual(cache, v)) return;
	    gl.uniformMatrix2fv(this.addr, false, v);
	    copyArray(cache, v);
	  } else {
	    if (arraysEqual(cache, elements)) return;
	    mat2array.set(elements);
	    gl.uniformMatrix2fv(this.addr, false, mat2array);
	    copyArray(cache, elements);
	  }
	}
	function setValueM3(gl, v) {
	  var cache = this.cache;
	  var elements = v.elements;
	  if (elements === undefined) {
	    if (arraysEqual(cache, v)) return;
	    gl.uniformMatrix3fv(this.addr, false, v);
	    copyArray(cache, v);
	  } else {
	    if (arraysEqual(cache, elements)) return;
	    mat3array.set(elements);
	    gl.uniformMatrix3fv(this.addr, false, mat3array);
	    copyArray(cache, elements);
	  }
	}
	function setValueM4(gl, v) {
	  var cache = this.cache;
	  var elements = v.elements;
	  if (elements === undefined) {
	    if (arraysEqual(cache, v)) return;
	    gl.uniformMatrix4fv(this.addr, false, v);
	    copyArray(cache, v);
	  } else {
	    if (arraysEqual(cache, elements)) return;
	    mat4array.set(elements);
	    gl.uniformMatrix4fv(this.addr, false, mat4array);
	    copyArray(cache, elements);
	  }
	}
	function setValueT1(gl, v, textures) {
	  var cache = this.cache;
	  var unit = textures.allocateTextureUnit();
	  if (cache[0] !== unit) {
	    gl.uniform1i(this.addr, unit);
	    cache[0] = unit;
	  }
	  textures.safeSetTexture2D(v || emptyTexture, unit);
	}
	function setValueT2DArray1(gl, v, textures) {
	  var cache = this.cache;
	  var unit = textures.allocateTextureUnit();
	  if (cache[0] !== unit) {
	    gl.uniform1i(this.addr, unit);
	    cache[0] = unit;
	  }
	  textures.setTexture2DArray(v || emptyTexture2dArray, unit);
	}
	function setValueT3D1(gl, v, textures) {
	  var cache = this.cache;
	  var unit = textures.allocateTextureUnit();
	  if (cache[0] !== unit) {
	    gl.uniform1i(this.addr, unit);
	    cache[0] = unit;
	  }
	  textures.setTexture3D(v || emptyTexture3d, unit);
	}
	function setValueT6(gl, v, textures) {
	  var cache = this.cache;
	  var unit = textures.allocateTextureUnit();
	  if (cache[0] !== unit) {
	    gl.uniform1i(this.addr, unit);
	    cache[0] = unit;
	  }
	  textures.safeSetTextureCube(v || emptyCubeTexture, unit);
	}
	function setValueV1i(gl, v) {
	  var cache = this.cache;
	  if (cache[0] === v) return;
	  gl.uniform1i(this.addr, v);
	  cache[0] = v;
	}
	function setValueV2i(gl, v) {
	  var cache = this.cache;
	  if (arraysEqual(cache, v)) return;
	  gl.uniform2iv(this.addr, v);
	  copyArray(cache, v);
	}
	function setValueV3i(gl, v) {
	  var cache = this.cache;
	  if (arraysEqual(cache, v)) return;
	  gl.uniform3iv(this.addr, v);
	  copyArray(cache, v);
	}
	function setValueV4i(gl, v) {
	  var cache = this.cache;
	  if (arraysEqual(cache, v)) return;
	  gl.uniform4iv(this.addr, v);
	  copyArray(cache, v);
	}
	function setValueV1ui(gl, v) {
	  var cache = this.cache;
	  if (cache[0] === v) return;
	  gl.uniform1ui(this.addr, v);
	  cache[0] = v;
	}
	function getSingularSetter(type) {
	  switch (type) {
	    case 5126:
	      return setValueV1f;
	    case 35664:
	      return setValueV2f;
	    case 35665:
	      return setValueV3f;
	    case 35666:
	      return setValueV4f;
	    case 35674:
	      return setValueM2;
	    case 35675:
	      return setValueM3;
	    case 35676:
	      return setValueM4;
	    case 5124:
	    case 35670:
	      return setValueV1i;
	    case 35667:
	    case 35671:
	      return setValueV2i;
	    case 35668:
	    case 35672:
	      return setValueV3i;
	    case 35669:
	    case 35673:
	      return setValueV4i;
	    case 5125:
	      return setValueV1ui;
	    case 35678:
	    case 36198:
	    case 36298:
	    case 36306:
	    case 35682:
	      return setValueT1;
	    case 35679:
	    case 36299:
	    case 36307:
	      return setValueT3D1;
	    case 35680:
	    case 36300:
	    case 36308:
	    case 36293:
	      return setValueT6;
	    case 36289:
	    case 36303:
	    case 36311:
	    case 36292:
	      return setValueT2DArray1;
	  }
	}
	function setValueV1fArray(gl, v) {
	  gl.uniform1fv(this.addr, v);
	}
	function setValueV1iArray(gl, v) {
	  gl.uniform1iv(this.addr, v);
	}
	function setValueV2iArray(gl, v) {
	  gl.uniform2iv(this.addr, v);
	}
	function setValueV3iArray(gl, v) {
	  gl.uniform3iv(this.addr, v);
	}
	function setValueV4iArray(gl, v) {
	  gl.uniform4iv(this.addr, v);
	}
	function setValueV2fArray(gl, v) {
	  var data = flatten(v, this.size, 2);
	  gl.uniform2fv(this.addr, data);
	}
	function setValueV3fArray(gl, v) {
	  var data = flatten(v, this.size, 3);
	  gl.uniform3fv(this.addr, data);
	}
	function setValueV4fArray(gl, v) {
	  var data = flatten(v, this.size, 4);
	  gl.uniform4fv(this.addr, data);
	}
	function setValueM2Array(gl, v) {
	  var data = flatten(v, this.size, 4);
	  gl.uniformMatrix2fv(this.addr, false, data);
	}
	function setValueM3Array(gl, v) {
	  var data = flatten(v, this.size, 9);
	  gl.uniformMatrix3fv(this.addr, false, data);
	}
	function setValueM4Array(gl, v) {
	  var data = flatten(v, this.size, 16);
	  gl.uniformMatrix4fv(this.addr, false, data);
	}
	function setValueT1Array(gl, v, textures) {
	  var n = v.length;
	  var units = allocTexUnits(textures, n);
	  gl.uniform1iv(this.addr, units);
	  for (var i = 0; i !== n; ++i) {
	    textures.safeSetTexture2D(v[i] || emptyTexture, units[i]);
	  }
	}
	function setValueT6Array(gl, v, textures) {
	  var n = v.length;
	  var units = allocTexUnits(textures, n);
	  gl.uniform1iv(this.addr, units);
	  for (var i = 0; i !== n; ++i) {
	    textures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i]);
	  }
	}
	function getPureArraySetter(type) {
	  switch (type) {
	    case 5126:
	      return setValueV1fArray;
	    case 35664:
	      return setValueV2fArray;
	    case 35665:
	      return setValueV3fArray;
	    case 35666:
	      return setValueV4fArray;
	    case 35674:
	      return setValueM2Array;
	    case 35675:
	      return setValueM3Array;
	    case 35676:
	      return setValueM4Array;
	    case 5124:
	    case 35670:
	      return setValueV1iArray;
	    case 35667:
	    case 35671:
	      return setValueV2iArray;
	    case 35668:
	    case 35672:
	      return setValueV3iArray;
	    case 35669:
	    case 35673:
	      return setValueV4iArray;
	    case 35678:
	    case 36198:
	    case 36298:
	    case 36306:
	    case 35682:
	      return setValueT1Array;
	    case 35680:
	    case 36300:
	    case 36308:
	    case 36293:
	      return setValueT6Array;
	  }
	}
	function SingleUniform(id, activeInfo, addr) {
	  this.id = id;
	  this.addr = addr;
	  this.cache = [];
	  this.setValue = getSingularSetter(activeInfo.type);
	}
	function PureArrayUniform(id, activeInfo, addr) {
	  this.id = id;
	  this.addr = addr;
	  this.cache = [];
	  this.size = activeInfo.size;
	  this.setValue = getPureArraySetter(activeInfo.type);
	}
	PureArrayUniform.prototype.updateCache = function (data) {
	  var cache = this.cache;
	  if (data instanceof Float32Array && cache.length !== data.length) {
	    this.cache = new Float32Array(data.length);
	  }
	  copyArray(cache, data);
	};
	function StructuredUniform(id) {
	  this.id = id;
	  this.seq = [];
	  this.map = {};
	}
	StructuredUniform.prototype.setValue = function (gl, value, textures) {
	  var seq = this.seq;
	  for (var i = 0, n = seq.length; i !== n; ++i) {
	    var u = seq[i];
	    u.setValue(gl, value[u.id], textures);
	  }
	};
	var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
	function addUniform(container, uniformObject) {
	  container.seq.push(uniformObject);
	  container.map[uniformObject.id] = uniformObject;
	}
	function parseUniform(activeInfo, addr, container) {
	  var path = activeInfo.name, pathLength = path.length;
	  RePathPart.lastIndex = 0;
	  while (true) {
	    var match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex, id = match[1], idIsIndex = match[2] === "]", subscript = match[3];
	    if (idIsIndex) id = id | 0;
	    if (subscript === undefined || subscript === "[" && matchEnd + 2 === pathLength) {
	      addUniform(container, subscript === undefined ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
	      break;
	    } else {
	      var map = container.map, next = map[id];
	      if (next === undefined) {
	        next = new StructuredUniform(id);
	        addUniform(container, next);
	      }
	      container = next;
	    }
	  }
	}
	function WebGLUniforms(gl, program) {
	  this.seq = [];
	  this.map = {};
	  var n = gl.getProgramParameter(program, 35718);
	  for (var i = 0; i < n; ++i) {
	    var info = gl.getActiveUniform(program, i), addr = gl.getUniformLocation(program, info.name);
	    parseUniform(info, addr, this);
	  }
	}
	WebGLUniforms.prototype.setValue = function (gl, name, value, textures) {
	  var u = this.map[name];
	  if (u !== undefined) u.setValue(gl, value, textures);
	};
	WebGLUniforms.prototype.setOptional = function (gl, object, name) {
	  var v = object[name];
	  if (v !== undefined) this.setValue(gl, name, v);
	};
	WebGLUniforms.upload = function (gl, seq, values, textures) {
	  for (var i = 0, n = seq.length; i !== n; ++i) {
	    var u = seq[i], v = values[u.id];
	    if (v.needsUpdate !== false) {
	      u.setValue(gl, v.value, textures);
	    }
	  }
	};
	WebGLUniforms.seqWithValue = function (seq, values) {
	  var r = [];
	  for (var i = 0, n = seq.length; i !== n; ++i) {
	    var u = seq[i];
	    if ((u.id in values)) r.push(u);
	  }
	  return r;
	};
	function WebGLShader(gl, type, string) {
	  var shader = gl.createShader(type);
	  gl.shaderSource(shader, string);
	  gl.compileShader(shader);
	  return shader;
	}
	var programIdCount = 0;
	function addLineNumbers(string) {
	  var lines = string.split("\n");
	  for (var i = 0; i < lines.length; i++) {
	    lines[i] = i + 1 + ": " + lines[i];
	  }
	  return lines.join("\n");
	}
	function getEncodingComponents(encoding) {
	  switch (encoding) {
	    case LinearEncoding:
	      return ["Linear", "( value )"];
	    case sRGBEncoding:
	      return ["sRGB", "( value )"];
	    case RGBEEncoding:
	      return ["RGBE", "( value )"];
	    case RGBM7Encoding:
	      return ["RGBM", "( value, 7.0 )"];
	    case RGBM16Encoding:
	      return ["RGBM", "( value, 16.0 )"];
	    case RGBDEncoding:
	      return ["RGBD", "( value, 256.0 )"];
	    case GammaEncoding:
	      return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
	    case LogLuvEncoding:
	      return ["LogLuv", "( value )"];
	    default:
	      throw new Error("unsupported encoding: " + encoding);
	  }
	}
	function getShaderErrors(gl, shader, type) {
	  var status = gl.getShaderParameter(shader, 35713);
	  var log = gl.getShaderInfoLog(shader).trim();
	  if (status && log === "") return "";
	  var source = gl.getShaderSource(shader);
	  return "THREE.WebGLShader: gl.getShaderInfoLog() " + type + "\n" + log + addLineNumbers(source);
	}
	function getTexelDecodingFunction(functionName, encoding) {
	  var components = getEncodingComponents(encoding);
	  return "vec4 " + functionName + "( vec4 value ) { return " + components[0] + "ToLinear" + components[1] + "; }";
	}
	function getTexelEncodingFunction(functionName, encoding) {
	  var components = getEncodingComponents(encoding);
	  return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[0] + components[1] + "; }";
	}
	function getToneMappingFunction(functionName, toneMapping) {
	  var toneMappingName;
	  switch (toneMapping) {
	    case LinearToneMapping:
	      toneMappingName = "Linear";
	      break;
	    case ReinhardToneMapping:
	      toneMappingName = "Reinhard";
	      break;
	    case Uncharted2ToneMapping:
	      toneMappingName = "Uncharted2";
	      break;
	    case CineonToneMapping:
	      toneMappingName = "OptimizedCineon";
	      break;
	    case ACESFilmicToneMapping:
	      toneMappingName = "ACESFilmic";
	      break;
	    default:
	      throw new Error("unsupported toneMapping: " + toneMapping);
	  }
	  return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
	}
	function generateExtensions(parameters) {
	  var chunks = [parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""];
	  return chunks.filter(filterEmptyLine).join("\n");
	}
	function generateDefines(defines) {
	  var chunks = [];
	  for (var name in defines) {
	    var value = defines[name];
	    if (value === false) continue;
	    chunks.push("#define " + name + " " + value);
	  }
	  return chunks.join("\n");
	}
	function fetchAttributeLocations(gl, program) {
	  var attributes = {};
	  var n = gl.getProgramParameter(program, 35721);
	  for (var i = 0; i < n; i++) {
	    var info = gl.getActiveAttrib(program, i);
	    var name = info.name;
	    attributes[name] = gl.getAttribLocation(program, name);
	  }
	  return attributes;
	}
	function filterEmptyLine(string) {
	  return string !== "";
	}
	function replaceLightNums(string, parameters) {
	  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
	}
	function replaceClippingPlaneNums(string, parameters) {
	  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
	}
	var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
	function resolveIncludes(string) {
	  return string.replace(includePattern, includeReplacer);
	}
	function includeReplacer(match, include) {
	  var string = ShaderChunk[include];
	  if (string === undefined) {
	    throw new Error("Can not resolve #include <" + include + ">");
	  }
	  return resolveIncludes(string);
	}
	var loopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
	function unrollLoops(string) {
	  return string.replace(loopPattern, loopReplacer);
	}
	function loopReplacer(match, start, end, snippet) {
	  var string = "";
	  for (var i = parseInt(start); i < parseInt(end); i++) {
	    string += snippet.replace(/\[ i \]/g, "[ " + i + " ]").replace(/UNROLLED_LOOP_INDEX/g, i);
	  }
	  return string;
	}
	function generatePrecision(parameters) {
	  var precisionstring = "precision " + parameters.precision + " float;\nprecision " + parameters.precision + " int;";
	  if (parameters.precision === "highp") {
	    precisionstring += "\n#define HIGH_PRECISION";
	  } else if (parameters.precision === "mediump") {
	    precisionstring += "\n#define MEDIUM_PRECISION";
	  } else if (parameters.precision === "lowp") {
	    precisionstring += "\n#define LOW_PRECISION";
	  }
	  return precisionstring;
	}
	function generateShadowMapTypeDefine(parameters) {
	  var shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";
	  if (parameters.shadowMapType === PCFShadowMap) {
	    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";
	  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
	    shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";
	  } else if (parameters.shadowMapType === VSMShadowMap) {
	    shadowMapTypeDefine = "SHADOWMAP_TYPE_VSM";
	  }
	  return shadowMapTypeDefine;
	}
	function generateEnvMapTypeDefine(parameters) {
	  var envMapTypeDefine = "ENVMAP_TYPE_CUBE";
	  if (parameters.envMap) {
	    switch (parameters.envMapMode) {
	      case CubeReflectionMapping:
	      case CubeRefractionMapping:
	        envMapTypeDefine = "ENVMAP_TYPE_CUBE";
	        break;
	      case CubeUVReflectionMapping:
	      case CubeUVRefractionMapping:
	        envMapTypeDefine = "ENVMAP_TYPE_CUBE_UV";
	        break;
	      case EquirectangularReflectionMapping:
	      case EquirectangularRefractionMapping:
	        envMapTypeDefine = "ENVMAP_TYPE_EQUIREC";
	        break;
	      case SphericalReflectionMapping:
	        envMapTypeDefine = "ENVMAP_TYPE_SPHERE";
	        break;
	    }
	  }
	  return envMapTypeDefine;
	}
	function generateEnvMapModeDefine(parameters) {
	  var envMapModeDefine = "ENVMAP_MODE_REFLECTION";
	  if (parameters.envMap) {
	    switch (parameters.envMapMode) {
	      case CubeRefractionMapping:
	      case EquirectangularRefractionMapping:
	        envMapModeDefine = "ENVMAP_MODE_REFRACTION";
	        break;
	    }
	  }
	  return envMapModeDefine;
	}
	function generateEnvMapBlendingDefine(parameters) {
	  var envMapBlendingDefine = "ENVMAP_BLENDING_NONE";
	  if (parameters.envMap) {
	    switch (parameters.combine) {
	      case MultiplyOperation:
	        envMapBlendingDefine = "ENVMAP_BLENDING_MULTIPLY";
	        break;
	      case MixOperation:
	        envMapBlendingDefine = "ENVMAP_BLENDING_MIX";
	        break;
	      case AddOperation:
	        envMapBlendingDefine = "ENVMAP_BLENDING_ADD";
	        break;
	    }
	  }
	  return envMapBlendingDefine;
	}
	function WebGLProgram(renderer, cacheKey, parameters) {
	  var gl = renderer.getContext();
	  var defines = parameters.defines;
	  var vertexShader = parameters.vertexShader;
	  var fragmentShader = parameters.fragmentShader;
	  var shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
	  var envMapTypeDefine = generateEnvMapTypeDefine(parameters);
	  var envMapModeDefine = generateEnvMapModeDefine(parameters);
	  var envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
	  var gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;
	  var customExtensions = parameters.isWebGL2 ? "" : generateExtensions(parameters);
	  var customDefines = generateDefines(defines);
	  var program = gl.createProgram();
	  var prefixVertex, prefixFragment;
	  if (parameters.isRawShaderMaterial) {
	    prefixVertex = [customDefines].filter(filterEmptyLine).join("\n");
	    if (prefixVertex.length > 0) {
	      prefixVertex += "\n";
	    }
	    prefixFragment = [customExtensions, customDefines].filter(filterEmptyLine).join("\n");
	    if (prefixFragment.length > 0) {
	      prefixFragment += "\n";
	    }
	  } else {
	    prefixVertex = [generatePrecision(parameters), "#define SHADER_NAME " + parameters.shaderName, customDefines, parameters.instancing ? "#define USE_INSTANCING" : "", parameters.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + gammaFactorDefine, "#define MAX_BONES " + parameters.maxBones, parameters.useFog && parameters.fog ? "#define USE_FOG" : "", parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "", parameters.map ? "#define USE_MAP" : "", parameters.envMap ? "#define USE_ENVMAP" : "", parameters.envMap ? "#define " + envMapModeDefine : "", parameters.lightMap ? "#define USE_LIGHTMAP" : "", parameters.aoMap ? "#define USE_AOMAP" : "", parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "", parameters.bumpMap ? "#define USE_BUMPMAP" : "", parameters.normalMap ? "#define USE_NORMALMAP" : "", parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", parameters.displacementMap && parameters.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", parameters.specularMap ? "#define USE_SPECULARMAP" : "", parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", parameters.metalnessMap ? "#define USE_METALNESSMAP" : "", parameters.alphaMap ? "#define USE_ALPHAMAP" : "", parameters.vertexTangents ? "#define USE_TANGENT" : "", parameters.vertexColors ? "#define USE_COLOR" : "", parameters.vertexUvs ? "#define USE_UV" : "", parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", parameters.flatShading ? "#define FLAT_SHADED" : "", parameters.skinning ? "#define USE_SKINNING" : "", parameters.useVertexTexture ? "#define BONE_TEXTURE" : "", parameters.morphTargets ? "#define USE_MORPHTARGETS" : "", parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "", parameters.doubleSided ? "#define DOUBLE_SIDED" : "", parameters.flipSided ? "#define FLIP_SIDED" : "", parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "", parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", " attribute mat4 instanceMatrix;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(filterEmptyLine).join("\n");
	    prefixFragment = [customExtensions, generatePrecision(parameters), "#define SHADER_NAME " + parameters.shaderName, customDefines, parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest + (parameters.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + gammaFactorDefine, parameters.useFog && parameters.fog ? "#define USE_FOG" : "", parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "", parameters.map ? "#define USE_MAP" : "", parameters.matcap ? "#define USE_MATCAP" : "", parameters.envMap ? "#define USE_ENVMAP" : "", parameters.envMap ? "#define " + envMapTypeDefine : "", parameters.envMap ? "#define " + envMapModeDefine : "", parameters.envMap ? "#define " + envMapBlendingDefine : "", parameters.lightMap ? "#define USE_LIGHTMAP" : "", parameters.aoMap ? "#define USE_AOMAP" : "", parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "", parameters.bumpMap ? "#define USE_BUMPMAP" : "", parameters.normalMap ? "#define USE_NORMALMAP" : "", parameters.normalMap && parameters.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", parameters.normalMap && parameters.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", parameters.specularMap ? "#define USE_SPECULARMAP" : "", parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", parameters.metalnessMap ? "#define USE_METALNESSMAP" : "", parameters.alphaMap ? "#define USE_ALPHAMAP" : "", parameters.sheen ? "#define USE_SHEEN" : "", parameters.vertexTangents ? "#define USE_TANGENT" : "", parameters.vertexColors ? "#define USE_COLOR" : "", parameters.vertexUvs ? "#define USE_UV" : "", parameters.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", parameters.gradientMap ? "#define USE_GRADIENTMAP" : "", parameters.flatShading ? "#define FLAT_SHADED" : "", parameters.doubleSided ? "#define DOUBLE_SIDED" : "", parameters.flipSided ? "#define FLIP_SIDED" : "", parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "", parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", parameters.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "", parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "", parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "", parameters.dithering ? "#define DITHERING" : "", parameters.outputEncoding || parameters.mapEncoding || parameters.matcapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding || parameters.lightMapEncoding ? ShaderChunk["encodings_pars_fragment"] : "", parameters.mapEncoding ? getTexelDecodingFunction("mapTexelToLinear", parameters.mapEncoding) : "", parameters.matcapEncoding ? getTexelDecodingFunction("matcapTexelToLinear", parameters.matcapEncoding) : "", parameters.envMapEncoding ? getTexelDecodingFunction("envMapTexelToLinear", parameters.envMapEncoding) : "", parameters.emissiveMapEncoding ? getTexelDecodingFunction("emissiveMapTexelToLinear", parameters.emissiveMapEncoding) : "", parameters.lightMapEncoding ? getTexelDecodingFunction("lightMapTexelToLinear", parameters.lightMapEncoding) : "", parameters.outputEncoding ? getTexelEncodingFunction("linearToOutputTexel", parameters.outputEncoding) : "", parameters.depthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "", "\n"].filter(filterEmptyLine).join("\n");
	  }
	  vertexShader = resolveIncludes(vertexShader);
	  vertexShader = replaceLightNums(vertexShader, parameters);
	  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
	  fragmentShader = resolveIncludes(fragmentShader);
	  fragmentShader = replaceLightNums(fragmentShader, parameters);
	  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
	  vertexShader = unrollLoops(vertexShader);
	  fragmentShader = unrollLoops(fragmentShader);
	  if (parameters.isWebGL2 && !parameters.isRawShaderMaterial) {
	    var isGLSL3ShaderMaterial = false;
	    var versionRegex = /^\s*#version\s+300\s+es\s*\n/;
	    if (parameters.isShaderMaterial && vertexShader.match(versionRegex) !== null && fragmentShader.match(versionRegex) !== null) {
	      isGLSL3ShaderMaterial = true;
	      vertexShader = vertexShader.replace(versionRegex, "");
	      fragmentShader = fragmentShader.replace(versionRegex, "");
	    }
	    prefixVertex = ["#version 300 es\n", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + prefixVertex;
	    prefixFragment = ["#version 300 es\n", "#define varying in", isGLSL3ShaderMaterial ? "" : "out highp vec4 pc_fragColor;", isGLSL3ShaderMaterial ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + prefixFragment;
	  }
	  var vertexGlsl = prefixVertex + vertexShader;
	  var fragmentGlsl = prefixFragment + fragmentShader;
	  var glVertexShader = WebGLShader(gl, 35633, vertexGlsl);
	  var glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);
	  gl.attachShader(program, glVertexShader);
	  gl.attachShader(program, glFragmentShader);
	  if (parameters.index0AttributeName !== undefined) {
	    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
	  } else if (parameters.morphTargets === true) {
	    gl.bindAttribLocation(program, 0, "position");
	  }
	  gl.linkProgram(program);
	  if (renderer.debug.checkShaderErrors) {
	    var programLog = gl.getProgramInfoLog(program).trim();
	    var vertexLog = gl.getShaderInfoLog(glVertexShader).trim();
	    var fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();
	    var runnable = true;
	    var haveDiagnostics = true;
	    if (gl.getProgramParameter(program, 35714) === false) {
	      runnable = false;
	      var vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
	      var fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
	      console.error("THREE.WebGLProgram: shader error: ", gl.getError(), "35715", gl.getProgramParameter(program, 35715), "gl.getProgramInfoLog", programLog, vertexErrors, fragmentErrors);
	    } else if (programLog !== "") {
	      console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", programLog);
	    } else if (vertexLog === "" || fragmentLog === "") {
	      haveDiagnostics = false;
	    }
	    if (haveDiagnostics) {
	      this.diagnostics = {
	        runnable: runnable,
	        programLog: programLog,
	        vertexShader: {
	          log: vertexLog,
	          prefix: prefixVertex
	        },
	        fragmentShader: {
	          log: fragmentLog,
	          prefix: prefixFragment
	        }
	      };
	    }
	  }
	  gl.detachShader(program, glVertexShader);
	  gl.detachShader(program, glFragmentShader);
	  gl.deleteShader(glVertexShader);
	  gl.deleteShader(glFragmentShader);
	  var cachedUniforms;
	  this.getUniforms = function () {
	    if (cachedUniforms === undefined) {
	      cachedUniforms = new WebGLUniforms(gl, program);
	    }
	    return cachedUniforms;
	  };
	  var cachedAttributes;
	  this.getAttributes = function () {
	    if (cachedAttributes === undefined) {
	      cachedAttributes = fetchAttributeLocations(gl, program);
	    }
	    return cachedAttributes;
	  };
	  this.destroy = function () {
	    gl.deleteProgram(program);
	    this.program = undefined;
	  };
	  this.name = parameters.shaderName;
	  this.id = programIdCount++;
	  this.cacheKey = cacheKey;
	  this.usedTimes = 1;
	  this.program = program;
	  this.vertexShader = glVertexShader;
	  this.fragmentShader = glFragmentShader;
	  return this;
	}
	function WebGLPrograms(renderer, extensions, capabilities) {
	  var programs = [];
	  var isWebGL2 = capabilities.isWebGL2;
	  var logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
	  var floatVertexTextures = capabilities.floatVertexTextures;
	  var precision = capabilities.precision;
	  var maxVertexUniforms = capabilities.maxVertexUniforms;
	  var vertexTextures = capabilities.vertexTextures;
	  var shaderIDs = {
	    MeshDepthMaterial: "depth",
	    MeshDistanceMaterial: "distanceRGBA",
	    MeshNormalMaterial: "normal",
	    MeshBasicMaterial: "basic",
	    MeshLambertMaterial: "lambert",
	    MeshPhongMaterial: "phong",
	    MeshToonMaterial: "toon",
	    MeshStandardMaterial: "physical",
	    MeshPhysicalMaterial: "physical",
	    MeshMatcapMaterial: "matcap",
	    LineBasicMaterial: "basic",
	    LineDashedMaterial: "dashed",
	    PointsMaterial: "points",
	    ShadowMaterial: "shadow",
	    SpriteMaterial: "sprite"
	  };
	  var parameterNames = ["precision", "isWebGL2", "supportsVertexTextures", "outputEncoding", "instancing", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding", "envMapCubeUV", "lightMap", "lightMapEncoding", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "tangentSpaceNormalMap", "clearcoatNormalMap", "displacementMap", "specularMap", "roughnessMap", "metalnessMap", "gradientMap", "alphaMap", "combine", "vertexColors", "vertexTangents", "vertexUvs", "uvsVertexOnly", "fog", "useFog", "fogExp2", "flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning", "maxBones", "useVertexTexture", "morphTargets", "morphNormals", "maxMorphTargets", "maxMorphNormals", "premultipliedAlpha", "numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights", "numDirLightShadows", "numPointLightShadows", "numSpotLightShadows", "shadowMapEnabled", "shadowMapType", "toneMapping", "physicallyCorrectLights", "alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering", "sheen"];
	  function getShaderObject(material, shaderID) {
	    var shaderobject;
	    if (shaderID) {
	      var shader = ShaderLib[shaderID];
	      shaderobject = {
	        name: material.type,
	        uniforms: UniformsUtils.clone(shader.uniforms),
	        vertexShader: shader.vertexShader,
	        fragmentShader: shader.fragmentShader
	      };
	    } else {
	      shaderobject = {
	        name: material.type,
	        uniforms: material.uniforms,
	        vertexShader: material.vertexShader,
	        fragmentShader: material.fragmentShader
	      };
	    }
	    return shaderobject;
	  }
	  function allocateBones(object) {
	    var skeleton = object.skeleton;
	    var bones = skeleton.bones;
	    if (floatVertexTextures) {
	      return 1024;
	    } else {
	      var nVertexUniforms = maxVertexUniforms;
	      var nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);
	      var maxBones = Math.min(nVertexMatrices, bones.length);
	      if (maxBones < bones.length) {
	        console.warn("THREE.WebGLRenderer: Skeleton has " + bones.length + " bones. This GPU supports " + maxBones + ".");
	        return 0;
	      }
	      return maxBones;
	    }
	  }
	  function getTextureEncodingFromMap(map) {
	    var encoding;
	    if (!map) {
	      encoding = LinearEncoding;
	    } else if (map.isTexture) {
	      encoding = map.encoding;
	    } else if (map.isWebGLRenderTarget) {
	      console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.");
	      encoding = map.texture.encoding;
	    }
	    return encoding;
	  }
	  this.getParameters = function (material, lights, shadows, scene, nClipPlanes, nClipIntersection, object) {
	    var fog = scene.fog;
	    var environment = material.isMeshStandardMaterial ? scene.environment : null;
	    var envMap = material.envMap || environment;
	    var shaderID = shaderIDs[material.type];
	    var maxBones = object.isSkinnedMesh ? allocateBones(object) : 0;
	    if (material.precision !== null) {
	      precision = capabilities.getMaxPrecision(material.precision);
	      if (precision !== material.precision) {
	        console.warn("THREE.WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
	      }
	    }
	    var shaderobject = getShaderObject(material, shaderID);
	    material.onBeforeCompile(shaderobject, renderer);
	    var currentRenderTarget = renderer.getRenderTarget();
	    var parameters = {
	      isWebGL2: isWebGL2,
	      shaderID: shaderID,
	      shaderName: shaderobject.name,
	      uniforms: shaderobject.uniforms,
	      vertexShader: shaderobject.vertexShader,
	      fragmentShader: shaderobject.fragmentShader,
	      defines: material.defines,
	      isRawShaderMaterial: material.isRawShaderMaterial,
	      isShaderMaterial: material.isShaderMaterial,
	      precision: precision,
	      instancing: object.isInstancedMesh === true,
	      supportsVertexTextures: vertexTextures,
	      outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,
	      map: !!material.map,
	      mapEncoding: getTextureEncodingFromMap(material.map),
	      matcap: !!material.matcap,
	      matcapEncoding: getTextureEncodingFromMap(material.matcap),
	      envMap: !!envMap,
	      envMapMode: envMap && envMap.mapping,
	      envMapEncoding: getTextureEncodingFromMap(envMap),
	      envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),
	      lightMap: !!material.lightMap,
	      lightMapEncoding: getTextureEncodingFromMap(material.lightMap),
	      aoMap: !!material.aoMap,
	      emissiveMap: !!material.emissiveMap,
	      emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),
	      bumpMap: !!material.bumpMap,
	      normalMap: !!material.normalMap,
	      objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
	      tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
	      clearcoatNormalMap: !!material.clearcoatNormalMap,
	      displacementMap: !!material.displacementMap,
	      roughnessMap: !!material.roughnessMap,
	      metalnessMap: !!material.metalnessMap,
	      specularMap: !!material.specularMap,
	      alphaMap: !!material.alphaMap,
	      gradientMap: !!material.gradientMap,
	      sheen: !!material.sheen,
	      combine: material.combine,
	      vertexTangents: material.normalMap && material.vertexTangents,
	      vertexColors: material.vertexColors,
	      vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.displacementMap,
	      uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap) && !!material.displacementMap,
	      fog: !!fog,
	      useFog: material.fog,
	      fogExp2: fog && fog.isFogExp2,
	      flatShading: material.flatShading,
	      sizeAttenuation: material.sizeAttenuation,
	      logarithmicDepthBuffer: logarithmicDepthBuffer,
	      skinning: material.skinning && maxBones > 0,
	      maxBones: maxBones,
	      useVertexTexture: floatVertexTextures,
	      morphTargets: material.morphTargets,
	      morphNormals: material.morphNormals,
	      maxMorphTargets: renderer.maxMorphTargets,
	      maxMorphNormals: renderer.maxMorphNormals,
	      numDirLights: lights.directional.length,
	      numPointLights: lights.point.length,
	      numSpotLights: lights.spot.length,
	      numRectAreaLights: lights.rectArea.length,
	      numHemiLights: lights.hemi.length,
	      numDirLightShadows: lights.directionalShadowMap.length,
	      numPointLightShadows: lights.pointShadowMap.length,
	      numSpotLightShadows: lights.spotShadowMap.length,
	      numClippingPlanes: nClipPlanes,
	      numClipIntersection: nClipIntersection,
	      dithering: material.dithering,
	      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
	      shadowMapType: renderer.shadowMap.type,
	      toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
	      physicallyCorrectLights: renderer.physicallyCorrectLights,
	      premultipliedAlpha: material.premultipliedAlpha,
	      alphaTest: material.alphaTest,
	      doubleSided: material.side === DoubleSide,
	      flipSided: material.side === BackSide,
	      depthPacking: material.depthPacking !== undefined ? material.depthPacking : false,
	      index0AttributeName: material.index0AttributeName,
	      extensionDerivatives: material.extensions && material.extensions.derivatives,
	      extensionFragDepth: material.extensions && material.extensions.fragDepth,
	      extensionDrawbuffers: material.extensions && material.extensions.drawBuffers,
	      extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,
	      rendererExtensionFragDepth: isWebGL2 || extensions.get("EXT_frag_depth") !== null,
	      rendererExtensionDrawBuffers: isWebGL2 || extensions.get("WEBGL_draw_buffers") !== null,
	      rendererExtensionShaderTextureLod: isWebGL2 || extensions.get("EXT_shader_texture_lod") !== null,
	      onBeforeCompile: material.onBeforeCompile
	    };
	    return parameters;
	  };
	  this.getProgramCacheKey = function (parameters) {
	    var array = [];
	    if (parameters.shaderID) {
	      array.push(parameters.shaderID);
	    } else {
	      array.push(parameters.fragmentShader);
	      array.push(parameters.vertexShader);
	    }
	    if (parameters.defines !== undefined) {
	      for (var name in parameters.defines) {
	        array.push(name);
	        array.push(parameters.defines[name]);
	      }
	    }
	    if (parameters.isRawShaderMaterial === undefined) {
	      for (var i = 0; i < parameterNames.length; i++) {
	        array.push(parameters[parameterNames[i]]);
	      }
	      array.push(renderer.outputEncoding);
	      array.push(renderer.gammaFactor);
	    }
	    array.push(parameters.onBeforeCompile.toString());
	    return array.join();
	  };
	  this.acquireProgram = function (parameters, cacheKey) {
	    var program;
	    for (var p = 0, pl = programs.length; p < pl; p++) {
	      var preexistingProgram = programs[p];
	      if (preexistingProgram.cacheKey === cacheKey) {
	        program = preexistingProgram;
	        ++program.usedTimes;
	        break;
	      }
	    }
	    if (program === undefined) {
	      program = new WebGLProgram(renderer, cacheKey, parameters);
	      programs.push(program);
	    }
	    return program;
	  };
	  this.releaseProgram = function (program) {
	    if (--program.usedTimes === 0) {
	      var i = programs.indexOf(program);
	      programs[i] = programs[programs.length - 1];
	      programs.pop();
	      program.destroy();
	    }
	  };
	  this.programs = programs;
	}
	function WebGLProperties() {
	  var properties = new WeakMap();
	  function get(object) {
	    var map = properties.get(object);
	    if (map === undefined) {
	      map = {};
	      properties.set(object, map);
	    }
	    return map;
	  }
	  function remove(object) {
	    properties.delete(object);
	  }
	  function update(object, key, value) {
	    properties.get(object)[key] = value;
	  }
	  function dispose() {
	    properties = new WeakMap();
	  }
	  return {
	    get: get,
	    remove: remove,
	    update: update,
	    dispose: dispose
	  };
	}
	function painterSortStable(a, b) {
	  if (a.groupOrder !== b.groupOrder) {
	    return a.groupOrder - b.groupOrder;
	  } else if (a.renderOrder !== b.renderOrder) {
	    return a.renderOrder - b.renderOrder;
	  } else if (a.program !== b.program) {
	    return a.program.id - b.program.id;
	  } else if (a.material.id !== b.material.id) {
	    return a.material.id - b.material.id;
	  } else if (a.z !== b.z) {
	    return a.z - b.z;
	  } else {
	    return a.id - b.id;
	  }
	}
	function reversePainterSortStable(a, b) {
	  if (a.groupOrder !== b.groupOrder) {
	    return a.groupOrder - b.groupOrder;
	  } else if (a.renderOrder !== b.renderOrder) {
	    return a.renderOrder - b.renderOrder;
	  } else if (a.z !== b.z) {
	    return b.z - a.z;
	  } else {
	    return a.id - b.id;
	  }
	}
	function WebGLRenderList() {
	  var renderItems = [];
	  var renderItemsIndex = 0;
	  var opaque = [];
	  var transparent = [];
	  var defaultProgram = {
	    id: -1
	  };
	  function init() {
	    renderItemsIndex = 0;
	    opaque.length = 0;
	    transparent.length = 0;
	  }
	  function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
	    var renderItem = renderItems[renderItemsIndex];
	    if (renderItem === undefined) {
	      renderItem = {
	        id: object.id,
	        object: object,
	        geometry: geometry,
	        material: material,
	        program: material.program || defaultProgram,
	        groupOrder: groupOrder,
	        renderOrder: object.renderOrder,
	        z: z,
	        group: group
	      };
	      renderItems[renderItemsIndex] = renderItem;
	    } else {
	      renderItem.id = object.id;
	      renderItem.object = object;
	      renderItem.geometry = geometry;
	      renderItem.material = material;
	      renderItem.program = material.program || defaultProgram;
	      renderItem.groupOrder = groupOrder;
	      renderItem.renderOrder = object.renderOrder;
	      renderItem.z = z;
	      renderItem.group = group;
	    }
	    renderItemsIndex++;
	    return renderItem;
	  }
	  function push(object, geometry, material, groupOrder, z, group) {
	    var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
	    (material.transparent === true ? transparent : opaque).push(renderItem);
	  }
	  function unshift(object, geometry, material, groupOrder, z, group) {
	    var renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);
	    (material.transparent === true ? transparent : opaque).unshift(renderItem);
	  }
	  function sort(customOpaqueSort, customTransparentSort) {
	    if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
	    if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
	  }
	  function finish() {
	    for (var i = renderItemsIndex, il = renderItems.length; i < il; i++) {
	      var renderItem = renderItems[i];
	      if (renderItem.id === null) break;
	      renderItem.id = null;
	      renderItem.object = null;
	      renderItem.geometry = null;
	      renderItem.material = null;
	      renderItem.program = null;
	      renderItem.group = null;
	    }
	  }
	  return {
	    opaque: opaque,
	    transparent: transparent,
	    init: init,
	    push: push,
	    unshift: unshift,
	    finish: finish,
	    sort: sort
	  };
	}
	function WebGLRenderLists() {
	  var lists = new WeakMap();
	  function onSceneDispose(event) {
	    var scene = event.target;
	    scene.removeEventListener("dispose", onSceneDispose);
	    lists.delete(scene);
	  }
	  function get(scene, camera) {
	    var cameras = lists.get(scene);
	    var list;
	    if (cameras === undefined) {
	      list = new WebGLRenderList();
	      lists.set(scene, new WeakMap());
	      lists.get(scene).set(camera, list);
	      scene.addEventListener("dispose", onSceneDispose);
	    } else {
	      list = cameras.get(camera);
	      if (list === undefined) {
	        list = new WebGLRenderList();
	        cameras.set(camera, list);
	      }
	    }
	    return list;
	  }
	  function dispose() {
	    lists = new WeakMap();
	  }
	  return {
	    get: get,
	    dispose: dispose
	  };
	}
	function UniformsCache() {
	  var lights = {};
	  return {
	    get: function (light) {
	      if (lights[light.id] !== undefined) {
	        return lights[light.id];
	      }
	      var uniforms;
	      switch (light.type) {
	        case "DirectionalLight":
	          uniforms = {
	            direction: new Vector3(),
	            color: new Color()
	          };
	          break;
	        case "SpotLight":
	          uniforms = {
	            position: new Vector3(),
	            direction: new Vector3(),
	            color: new Color(),
	            distance: 0,
	            coneCos: 0,
	            penumbraCos: 0,
	            decay: 0
	          };
	          break;
	        case "PointLight":
	          uniforms = {
	            position: new Vector3(),
	            color: new Color(),
	            distance: 0,
	            decay: 0
	          };
	          break;
	        case "HemisphereLight":
	          uniforms = {
	            direction: new Vector3(),
	            skyColor: new Color(),
	            groundColor: new Color()
	          };
	          break;
	        case "RectAreaLight":
	          uniforms = {
	            color: new Color(),
	            position: new Vector3(),
	            halfWidth: new Vector3(),
	            halfHeight: new Vector3()
	          };
	          break;
	      }
	      lights[light.id] = uniforms;
	      return uniforms;
	    }
	  };
	}
	function ShadowUniformsCache() {
	  var lights = {};
	  return {
	    get: function (light) {
	      if (lights[light.id] !== undefined) {
	        return lights[light.id];
	      }
	      var uniforms;
	      switch (light.type) {
	        case "DirectionalLight":
	          uniforms = {
	            shadowBias: 0,
	            shadowRadius: 1,
	            shadowMapSize: new Vector2()
	          };
	          break;
	        case "SpotLight":
	          uniforms = {
	            shadowBias: 0,
	            shadowRadius: 1,
	            shadowMapSize: new Vector2()
	          };
	          break;
	        case "PointLight":
	          uniforms = {
	            shadowBias: 0,
	            shadowRadius: 1,
	            shadowMapSize: new Vector2(),
	            shadowCameraNear: 1,
	            shadowCameraFar: 1000
	          };
	          break;
	      }
	      lights[light.id] = uniforms;
	      return uniforms;
	    }
	  };
	}
	var nextVersion = 0;
	function shadowCastingLightsFirst(lightA, lightB) {
	  return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);
	}
	function WebGLLights() {
	  var cache = new UniformsCache();
	  var shadowCache = ShadowUniformsCache();
	  var state = {
	    version: 0,
	    hash: {
	      directionalLength: -1,
	      pointLength: -1,
	      spotLength: -1,
	      rectAreaLength: -1,
	      hemiLength: -1,
	      numDirectionalShadows: -1,
	      numPointShadows: -1,
	      numSpotShadows: -1
	    },
	    ambient: [0, 0, 0],
	    probe: [],
	    directional: [],
	    directionalShadow: [],
	    directionalShadowMap: [],
	    directionalShadowMatrix: [],
	    spot: [],
	    spotShadow: [],
	    spotShadowMap: [],
	    spotShadowMatrix: [],
	    rectArea: [],
	    point: [],
	    pointShadow: [],
	    pointShadowMap: [],
	    pointShadowMatrix: [],
	    hemi: []
	  };
	  for (var i = 0; i < 9; i++) state.probe.push(new Vector3());
	  var vector3 = new Vector3();
	  var matrix4 = new Matrix4();
	  var matrix42 = new Matrix4();
	  function setup(lights, shadows, camera) {
	    var r = 0, g = 0, b = 0;
	    for (var i = 0; i < 9; i++) state.probe[i].set(0, 0, 0);
	    var directionalLength = 0;
	    var pointLength = 0;
	    var spotLength = 0;
	    var rectAreaLength = 0;
	    var hemiLength = 0;
	    var numDirectionalShadows = 0;
	    var numPointShadows = 0;
	    var numSpotShadows = 0;
	    var viewMatrix = camera.matrixWorldInverse;
	    lights.sort(shadowCastingLightsFirst);
	    for (var i = 0, l = lights.length; i < l; i++) {
	      var light = lights[i];
	      var color = light.color;
	      var intensity = light.intensity;
	      var distance = light.distance;
	      var shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;
	      if (light.isAmbientLight) {
	        r += color.r * intensity;
	        g += color.g * intensity;
	        b += color.b * intensity;
	      } else if (light.isLightProbe) {
	        for (var j = 0; j < 9; j++) {
	          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);
	        }
	      } else if (light.isDirectionalLight) {
	        var uniforms = cache.get(light);
	        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
	        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
	        vector3.setFromMatrixPosition(light.target.matrixWorld);
	        uniforms.direction.sub(vector3);
	        uniforms.direction.transformDirection(viewMatrix);
	        if (light.castShadow) {
	          var shadow = light.shadow;
	          var shadowUniforms = shadowCache.get(light);
	          shadowUniforms.shadowBias = shadow.bias;
	          shadowUniforms.shadowRadius = shadow.radius;
	          shadowUniforms.shadowMapSize = shadow.mapSize;
	          state.directionalShadow[directionalLength] = shadowUniforms;
	          state.directionalShadowMap[directionalLength] = shadowMap;
	          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
	          numDirectionalShadows++;
	        }
	        state.directional[directionalLength] = uniforms;
	        directionalLength++;
	      } else if (light.isSpotLight) {
	        var uniforms = cache.get(light);
	        uniforms.position.setFromMatrixPosition(light.matrixWorld);
	        uniforms.position.applyMatrix4(viewMatrix);
	        uniforms.color.copy(color).multiplyScalar(intensity);
	        uniforms.distance = distance;
	        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
	        vector3.setFromMatrixPosition(light.target.matrixWorld);
	        uniforms.direction.sub(vector3);
	        uniforms.direction.transformDirection(viewMatrix);
	        uniforms.coneCos = Math.cos(light.angle);
	        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
	        uniforms.decay = light.decay;
	        if (light.castShadow) {
	          var shadow = light.shadow;
	          var shadowUniforms = shadowCache.get(light);
	          shadowUniforms.shadowBias = shadow.bias;
	          shadowUniforms.shadowRadius = shadow.radius;
	          shadowUniforms.shadowMapSize = shadow.mapSize;
	          state.spotShadow[spotLength] = shadowUniforms;
	          state.spotShadowMap[spotLength] = shadowMap;
	          state.spotShadowMatrix[spotLength] = light.shadow.matrix;
	          numSpotShadows++;
	        }
	        state.spot[spotLength] = uniforms;
	        spotLength++;
	      } else if (light.isRectAreaLight) {
	        var uniforms = cache.get(light);
	        uniforms.color.copy(color).multiplyScalar(intensity);
	        uniforms.position.setFromMatrixPosition(light.matrixWorld);
	        uniforms.position.applyMatrix4(viewMatrix);
	        matrix42.identity();
	        matrix4.copy(light.matrixWorld);
	        matrix4.premultiply(viewMatrix);
	        matrix42.extractRotation(matrix4);
	        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
	        uniforms.halfHeight.set(0, light.height * 0.5, 0);
	        uniforms.halfWidth.applyMatrix4(matrix42);
	        uniforms.halfHeight.applyMatrix4(matrix42);
	        state.rectArea[rectAreaLength] = uniforms;
	        rectAreaLength++;
	      } else if (light.isPointLight) {
	        var uniforms = cache.get(light);
	        uniforms.position.setFromMatrixPosition(light.matrixWorld);
	        uniforms.position.applyMatrix4(viewMatrix);
	        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
	        uniforms.distance = light.distance;
	        uniforms.decay = light.decay;
	        if (light.castShadow) {
	          var shadow = light.shadow;
	          var shadowUniforms = shadowCache.get(light);
	          shadowUniforms.shadowBias = shadow.bias;
	          shadowUniforms.shadowRadius = shadow.radius;
	          shadowUniforms.shadowMapSize = shadow.mapSize;
	          shadowUniforms.shadowCameraNear = shadow.camera.near;
	          shadowUniforms.shadowCameraFar = shadow.camera.far;
	          state.pointShadow[pointLength] = shadowUniforms;
	          state.pointShadowMap[pointLength] = shadowMap;
	          state.pointShadowMatrix[pointLength] = light.shadow.matrix;
	          numPointShadows++;
	        }
	        state.point[pointLength] = uniforms;
	        pointLength++;
	      } else if (light.isHemisphereLight) {
	        var uniforms = cache.get(light);
	        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
	        uniforms.direction.transformDirection(viewMatrix);
	        uniforms.direction.normalize();
	        uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
	        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
	        state.hemi[hemiLength] = uniforms;
	        hemiLength++;
	      }
	    }
	    state.ambient[0] = r;
	    state.ambient[1] = g;
	    state.ambient[2] = b;
	    var hash = state.hash;
	    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {
	      state.directional.length = directionalLength;
	      state.spot.length = spotLength;
	      state.rectArea.length = rectAreaLength;
	      state.point.length = pointLength;
	      state.hemi.length = hemiLength;
	      state.directionalShadow.length = numDirectionalShadows;
	      state.directionalShadowMap.length = numDirectionalShadows;
	      state.pointShadow.length = numPointShadows;
	      state.pointShadowMap.length = numPointShadows;
	      state.spotShadow.length = numSpotShadows;
	      state.spotShadowMap.length = numSpotShadows;
	      state.directionalShadowMatrix.length = numDirectionalShadows;
	      state.pointShadowMatrix.length = numPointShadows;
	      state.spotShadowMatrix.length = numSpotShadows;
	      hash.directionalLength = directionalLength;
	      hash.pointLength = pointLength;
	      hash.spotLength = spotLength;
	      hash.rectAreaLength = rectAreaLength;
	      hash.hemiLength = hemiLength;
	      hash.numDirectionalShadows = numDirectionalShadows;
	      hash.numPointShadows = numPointShadows;
	      hash.numSpotShadows = numSpotShadows;
	      state.version = nextVersion++;
	    }
	  }
	  return {
	    setup: setup,
	    state: state
	  };
	}
	function WebGLRenderState() {
	  var lights = new WebGLLights();
	  var lightsArray = [];
	  var shadowsArray = [];
	  function init() {
	    lightsArray.length = 0;
	    shadowsArray.length = 0;
	  }
	  function pushLight(light) {
	    lightsArray.push(light);
	  }
	  function pushShadow(shadowLight) {
	    shadowsArray.push(shadowLight);
	  }
	  function setupLights(camera) {
	    lights.setup(lightsArray, shadowsArray, camera);
	  }
	  var state = {
	    lightsArray: lightsArray,
	    shadowsArray: shadowsArray,
	    lights: lights
	  };
	  return {
	    init: init,
	    state: state,
	    setupLights: setupLights,
	    pushLight: pushLight,
	    pushShadow: pushShadow
	  };
	}
	function WebGLRenderStates() {
	  var renderStates = new WeakMap();
	  function onSceneDispose(event) {
	    var scene = event.target;
	    scene.removeEventListener("dispose", onSceneDispose);
	    renderStates.delete(scene);
	  }
	  function get(scene, camera) {
	    var renderState;
	    if (renderStates.has(scene) === false) {
	      renderState = new WebGLRenderState();
	      renderStates.set(scene, new WeakMap());
	      renderStates.get(scene).set(camera, renderState);
	      scene.addEventListener("dispose", onSceneDispose);
	    } else {
	      if (renderStates.get(scene).has(camera) === false) {
	        renderState = new WebGLRenderState();
	        renderStates.get(scene).set(camera, renderState);
	      } else {
	        renderState = renderStates.get(scene).get(camera);
	      }
	    }
	    return renderState;
	  }
	  function dispose() {
	    renderStates = new WeakMap();
	  }
	  return {
	    get: get,
	    dispose: dispose
	  };
	}
	function MeshDepthMaterial(parameters) {
	  Material.call(this);
	  this.type = "MeshDepthMaterial";
	  this.depthPacking = BasicDepthPacking;
	  this.skinning = false;
	  this.morphTargets = false;
	  this.map = null;
	  this.alphaMap = null;
	  this.displacementMap = null;
	  this.displacementScale = 1;
	  this.displacementBias = 0;
	  this.wireframe = false;
	  this.wireframeLinewidth = 1;
	  this.fog = false;
	  this.setValues(parameters);
	}
	MeshDepthMaterial.prototype = Object.create(Material.prototype);
	MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
	MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
	MeshDepthMaterial.prototype.copy = function (source) {
	  Material.prototype.copy.call(this, source);
	  this.depthPacking = source.depthPacking;
	  this.skinning = source.skinning;
	  this.morphTargets = source.morphTargets;
	  this.map = source.map;
	  this.alphaMap = source.alphaMap;
	  this.displacementMap = source.displacementMap;
	  this.displacementScale = source.displacementScale;
	  this.displacementBias = source.displacementBias;
	  this.wireframe = source.wireframe;
	  this.wireframeLinewidth = source.wireframeLinewidth;
	  return this;
	};
	function MeshDistanceMaterial(parameters) {
	  Material.call(this);
	  this.type = "MeshDistanceMaterial";
	  this.referencePosition = new Vector3();
	  this.nearDistance = 1;
	  this.farDistance = 1000;
	  this.skinning = false;
	  this.morphTargets = false;
	  this.map = null;
	  this.alphaMap = null;
	  this.displacementMap = null;
	  this.displacementScale = 1;
	  this.displacementBias = 0;
	  this.fog = false;
	  this.setValues(parameters);
	}
	MeshDistanceMaterial.prototype = Object.create(Material.prototype);
	MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;
	MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
	MeshDistanceMaterial.prototype.copy = function (source) {
	  Material.prototype.copy.call(this, source);
	  this.referencePosition.copy(source.referencePosition);
	  this.nearDistance = source.nearDistance;
	  this.farDistance = source.farDistance;
	  this.skinning = source.skinning;
	  this.morphTargets = source.morphTargets;
	  this.map = source.map;
	  this.alphaMap = source.alphaMap;
	  this.displacementMap = source.displacementMap;
	  this.displacementScale = source.displacementScale;
	  this.displacementBias = source.displacementBias;
	  return this;
	};
	var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n  float mean = 0.0;\n  float squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy  ) / resolution ) );\n  for ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n    #ifdef HORIZONAL_PASS\n      vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n      mean += distribution.x;\n      squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n    #else\n      float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0,  i )  * radius ) / resolution ) );\n      mean += depth;\n      squared_mean += depth * depth;\n    #endif\n  }\n  mean = mean * HALF_SAMPLE_RATE;\n  squared_mean = squared_mean * HALF_SAMPLE_RATE;\n  float std_dev = sqrt( squared_mean - mean * mean );\n  gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";
	var vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";
	function WebGLShadowMap(_renderer, _objects, maxTextureSize) {
	  var _frustum = new Frustum(), _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterials = [], _distanceMaterials = [], _materialCache = {};
	  var shadowSide = {
	    0: BackSide,
	    1: FrontSide,
	    2: DoubleSide
	  };
	  var shadowMaterialVertical = new ShaderMaterial({
	    defines: {
	      SAMPLE_RATE: 2 / 8,
	      HALF_SAMPLE_RATE: 1 / 8
	    },
	    uniforms: {
	      shadow_pass: {
	        value: null
	      },
	      resolution: {
	        value: new Vector2()
	      },
	      radius: {
	        value: 4
	      }
	    },
	    vertexShader: vsm_vert,
	    fragmentShader: vsm_frag
	  });
	  var shadowMaterialHorizonal = shadowMaterialVertical.clone();
	  shadowMaterialHorizonal.defines.HORIZONAL_PASS = 1;
	  var fullScreenTri = new BufferGeometry();
	  fullScreenTri.setAttribute("position", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));
	  var fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
	  var scope = this;
	  this.enabled = false;
	  this.autoUpdate = true;
	  this.needsUpdate = false;
	  this.type = PCFShadowMap;
	  this.render = function (lights, scene, camera) {
	    if (scope.enabled === false) return;
	    if (scope.autoUpdate === false && scope.needsUpdate === false) return;
	    if (lights.length === 0) return;
	    var currentRenderTarget = _renderer.getRenderTarget();
	    var activeCubeFace = _renderer.getActiveCubeFace();
	    var activeMipmapLevel = _renderer.getActiveMipmapLevel();
	    var _state = _renderer.state;
	    _state.setBlending(NoBlending);
	    _state.buffers.color.setClear(1, 1, 1, 1);
	    _state.buffers.depth.setTest(true);
	    _state.setScissorTest(false);
	    for (var i = 0, il = lights.length; i < il; i++) {
	      var light = lights[i];
	      var shadow = light.shadow;
	      if (shadow === undefined) {
	        console.warn("THREE.WebGLShadowMap:", light, "has no shadow.");
	        continue;
	      }
	      _shadowMapSize.copy(shadow.mapSize);
	      var shadowFrameExtents = shadow.getFrameExtents();
	      _shadowMapSize.multiply(shadowFrameExtents);
	      _viewportSize.copy(shadow.mapSize);
	      if (_shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize) {
	        console.warn("THREE.WebGLShadowMap:", light, "has shadow exceeding max texture size, reducing");
	        if (_shadowMapSize.x > maxTextureSize) {
	          _viewportSize.x = Math.floor(maxTextureSize / shadowFrameExtents.x);
	          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
	          shadow.mapSize.x = _viewportSize.x;
	        }
	        if (_shadowMapSize.y > maxTextureSize) {
	          _viewportSize.y = Math.floor(maxTextureSize / shadowFrameExtents.y);
	          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
	          shadow.mapSize.y = _viewportSize.y;
	        }
	      }
	      if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {
	        var pars = {
	          minFilter: LinearFilter,
	          magFilter: LinearFilter,
	          format: RGBAFormat
	        };
	        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
	        shadow.map.texture.name = light.name + ".shadowMap";
	        shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
	        shadow.camera.updateProjectionMatrix();
	      }
	      if (shadow.map === null) {
	        var pars = {
	          minFilter: NearestFilter,
	          magFilter: NearestFilter,
	          format: RGBAFormat
	        };
	        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);
	        shadow.map.texture.name = light.name + ".shadowMap";
	        shadow.camera.updateProjectionMatrix();
	      }
	      _renderer.setRenderTarget(shadow.map);
	      _renderer.clear();
	      var viewportCount = shadow.getViewportCount();
	      for (var vp = 0; vp < viewportCount; vp++) {
	        var viewport = shadow.getViewport(vp);
	        _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);
	        _state.viewport(_viewport);
	        shadow.updateMatrices(light, vp);
	        _frustum = shadow.getFrustum();
	        renderObject(scene, camera, shadow.camera, light, this.type);
	      }
	      if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {
	        VSMPass(shadow, camera);
	      }
	    }
	    scope.needsUpdate = false;
	    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
	  };
	  function VSMPass(shadow, camera) {
	    var geometry = _objects.update(fullScreenMesh);
	    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
	    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
	    shadowMaterialVertical.uniforms.radius.value = shadow.radius;
	    _renderer.setRenderTarget(shadow.mapPass);
	    _renderer.clear();
	    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
	    shadowMaterialHorizonal.uniforms.shadow_pass.value = shadow.mapPass.texture;
	    shadowMaterialHorizonal.uniforms.resolution.value = shadow.mapSize;
	    shadowMaterialHorizonal.uniforms.radius.value = shadow.radius;
	    _renderer.setRenderTarget(shadow.map);
	    _renderer.clear();
	    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizonal, fullScreenMesh, null);
	  }
	  function getDepthMaterialVariant(useMorphing, useSkinning, useInstancing) {
	    var index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
	    var material = _depthMaterials[index];
	    if (material === undefined) {
	      material = new MeshDepthMaterial({
	        depthPacking: RGBADepthPacking,
	        morphTargets: useMorphing,
	        skinning: useSkinning
	      });
	      _depthMaterials[index] = material;
	    }
	    return material;
	  }
	  function getDistanceMaterialVariant(useMorphing, useSkinning, useInstancing) {
	    var index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;
	    var material = _distanceMaterials[index];
	    if (material === undefined) {
	      material = new MeshDistanceMaterial({
	        morphTargets: useMorphing,
	        skinning: useSkinning
	      });
	      _distanceMaterials[index] = material;
	    }
	    return material;
	  }
	  function getDepthMaterial(object, material, light, shadowCameraNear, shadowCameraFar, type) {
	    var geometry = object.geometry;
	    var result = null;
	    var getMaterialVariant = getDepthMaterialVariant;
	    var customMaterial = object.customDepthMaterial;
	    if (light.isPointLight === true) {
	      getMaterialVariant = getDistanceMaterialVariant;
	      customMaterial = object.customDistanceMaterial;
	    }
	    if (customMaterial === undefined) {
	      var useMorphing = false;
	      if (material.morphTargets === true) {
	        if (geometry.isBufferGeometry === true) {
	          useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
	        } else if (geometry.isGeometry === true) {
	          useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;
	        }
	      }
	      var useSkinning = false;
	      if (object.isSkinnedMesh === true) {
	        if (material.skinning === true) {
	          useSkinning = true;
	        } else {
	          console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", object);
	        }
	      }
	      var useInstancing = object.isInstancedMesh === true;
	      result = getMaterialVariant(useMorphing, useSkinning, useInstancing);
	    } else {
	      result = customMaterial;
	    }
	    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {
	      var keyA = result.uuid, keyB = material.uuid;
	      var materialsForVariant = _materialCache[keyA];
	      if (materialsForVariant === undefined) {
	        materialsForVariant = {};
	        _materialCache[keyA] = materialsForVariant;
	      }
	      var cachedMaterial = materialsForVariant[keyB];
	      if (cachedMaterial === undefined) {
	        cachedMaterial = result.clone();
	        materialsForVariant[keyB] = cachedMaterial;
	      }
	      result = cachedMaterial;
	    }
	    result.visible = material.visible;
	    result.wireframe = material.wireframe;
	    if (type === VSMShadowMap) {
	      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
	    } else {
	      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
	    }
	    result.clipShadows = material.clipShadows;
	    result.clippingPlanes = material.clippingPlanes;
	    result.clipIntersection = material.clipIntersection;
	    result.wireframeLinewidth = material.wireframeLinewidth;
	    result.linewidth = material.linewidth;
	    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
	      result.referencePosition.setFromMatrixPosition(light.matrixWorld);
	      result.nearDistance = shadowCameraNear;
	      result.farDistance = shadowCameraFar;
	    }
	    return result;
	  }
	  function renderObject(object, camera, shadowCamera, light, type) {
	    if (object.visible === false) return;
	    var visible = object.layers.test(camera.layers);
	    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
	      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
	        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
	        var geometry = _objects.update(object);
	        var material = object.material;
	        if (Array.isArray(material)) {
	          var groups = geometry.groups;
	          for (var k = 0, kl = groups.length; k < kl; k++) {
	            var group = groups[k];
	            var groupMaterial = material[group.materialIndex];
	            if (groupMaterial && groupMaterial.visible) {
	              var depthMaterial = getDepthMaterial(object, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);
	              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
	            }
	          }
	        } else if (material.visible) {
	          var depthMaterial = getDepthMaterial(object, material, light, shadowCamera.near, shadowCamera.far, type);
	          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
	        }
	      }
	    }
	    var children = object.children;
	    for (var i = 0, l = children.length; i < l; i++) {
	      renderObject(children[i], camera, shadowCamera, light, type);
	    }
	  }
	}
	function WebGLState(gl, extensions, capabilities) {
	  var isWebGL2 = capabilities.isWebGL2;
	  function ColorBuffer() {
	    var locked = false;
	    var color = new Vector4();
	    var currentColorMask = null;
	    var currentColorClear = new Vector4(0, 0, 0, 0);
	    return {
	      setMask: function (colorMask) {
	        if (currentColorMask !== colorMask && !locked) {
	          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
	          currentColorMask = colorMask;
	        }
	      },
	      setLocked: function (lock) {
	        locked = lock;
	      },
	      setClear: function (r, g, b, a, premultipliedAlpha) {
	        if (premultipliedAlpha === true) {
	          r *= a;
	          g *= a;
	          b *= a;
	        }
	        color.set(r, g, b, a);
	        if (currentColorClear.equals(color) === false) {
	          gl.clearColor(r, g, b, a);
	          currentColorClear.copy(color);
	        }
	      },
	      reset: function () {
	        locked = false;
	        currentColorMask = null;
	        currentColorClear.set(-1, 0, 0, 0);
	      }
	    };
	  }
	  function DepthBuffer() {
	    var locked = false;
	    var currentDepthMask = null;
	    var currentDepthFunc = null;
	    var currentDepthClear = null;
	    return {
	      setTest: function (depthTest) {
	        if (depthTest) {
	          enable(2929);
	        } else {
	          disable(2929);
	        }
	      },
	      setMask: function (depthMask) {
	        if (currentDepthMask !== depthMask && !locked) {
	          gl.depthMask(depthMask);
	          currentDepthMask = depthMask;
	        }
	      },
	      setFunc: function (depthFunc) {
	        if (currentDepthFunc !== depthFunc) {
	          if (depthFunc) {
	            switch (depthFunc) {
	              case NeverDepth:
	                gl.depthFunc(512);
	                break;
	              case AlwaysDepth:
	                gl.depthFunc(519);
	                break;
	              case LessDepth:
	                gl.depthFunc(513);
	                break;
	              case LessEqualDepth:
	                gl.depthFunc(515);
	                break;
	              case EqualDepth:
	                gl.depthFunc(514);
	                break;
	              case GreaterEqualDepth:
	                gl.depthFunc(518);
	                break;
	              case GreaterDepth:
	                gl.depthFunc(516);
	                break;
	              case NotEqualDepth:
	                gl.depthFunc(517);
	                break;
	              default:
	                gl.depthFunc(515);
	            }
	          } else {
	            gl.depthFunc(515);
	          }
	          currentDepthFunc = depthFunc;
	        }
	      },
	      setLocked: function (lock) {
	        locked = lock;
	      },
	      setClear: function (depth) {
	        if (currentDepthClear !== depth) {
	          gl.clearDepth(depth);
	          currentDepthClear = depth;
	        }
	      },
	      reset: function () {
	        locked = false;
	        currentDepthMask = null;
	        currentDepthFunc = null;
	        currentDepthClear = null;
	      }
	    };
	  }
	  function StencilBuffer() {
	    var locked = false;
	    var currentStencilMask = null;
	    var currentStencilFunc = null;
	    var currentStencilRef = null;
	    var currentStencilFuncMask = null;
	    var currentStencilFail = null;
	    var currentStencilZFail = null;
	    var currentStencilZPass = null;
	    var currentStencilClear = null;
	    return {
	      setTest: function (stencilTest) {
	        if (!locked) {
	          if (stencilTest) {
	            enable(2960);
	          } else {
	            disable(2960);
	          }
	        }
	      },
	      setMask: function (stencilMask) {
	        if (currentStencilMask !== stencilMask && !locked) {
	          gl.stencilMask(stencilMask);
	          currentStencilMask = stencilMask;
	        }
	      },
	      setFunc: function (stencilFunc, stencilRef, stencilMask) {
	        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
	          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
	          currentStencilFunc = stencilFunc;
	          currentStencilRef = stencilRef;
	          currentStencilFuncMask = stencilMask;
	        }
	      },
	      setOp: function (stencilFail, stencilZFail, stencilZPass) {
	        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
	          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
	          currentStencilFail = stencilFail;
	          currentStencilZFail = stencilZFail;
	          currentStencilZPass = stencilZPass;
	        }
	      },
	      setLocked: function (lock) {
	        locked = lock;
	      },
	      setClear: function (stencil) {
	        if (currentStencilClear !== stencil) {
	          gl.clearStencil(stencil);
	          currentStencilClear = stencil;
	        }
	      },
	      reset: function () {
	        locked = false;
	        currentStencilMask = null;
	        currentStencilFunc = null;
	        currentStencilRef = null;
	        currentStencilFuncMask = null;
	        currentStencilFail = null;
	        currentStencilZFail = null;
	        currentStencilZPass = null;
	        currentStencilClear = null;
	      }
	    };
	  }
	  var colorBuffer = new ColorBuffer();
	  var depthBuffer = new DepthBuffer();
	  var stencilBuffer = new StencilBuffer();
	  var maxVertexAttributes = gl.getParameter(34921);
	  var newAttributes = new Uint8Array(maxVertexAttributes);
	  var enabledAttributes = new Uint8Array(maxVertexAttributes);
	  var attributeDivisors = new Uint8Array(maxVertexAttributes);
	  var enabledCapabilities = {};
	  var currentProgram = null;
	  var currentBlendingEnabled = null;
	  var currentBlending = null;
	  var currentBlendEquation = null;
	  var currentBlendSrc = null;
	  var currentBlendDst = null;
	  var currentBlendEquationAlpha = null;
	  var currentBlendSrcAlpha = null;
	  var currentBlendDstAlpha = null;
	  var currentPremultipledAlpha = false;
	  var currentFlipSided = null;
	  var currentCullFace = null;
	  var currentLineWidth = null;
	  var currentPolygonOffsetFactor = null;
	  var currentPolygonOffsetUnits = null;
	  var maxTextures = gl.getParameter(35661);
	  var lineWidthAvailable = false;
	  var version = 0;
	  var glVersion = gl.getParameter(7938);
	  if (glVersion.indexOf("WebGL") !== -1) {
	    version = parseFloat((/^WebGL\ ([0-9])/).exec(glVersion)[1]);
	    lineWidthAvailable = version >= 1;
	  } else if (glVersion.indexOf("OpenGL ES") !== -1) {
	    version = parseFloat((/^OpenGL\ ES\ ([0-9])/).exec(glVersion)[1]);
	    lineWidthAvailable = version >= 2;
	  }
	  var currentTextureSlot = null;
	  var currentBoundTextures = {};
	  var currentScissor = new Vector4();
	  var currentViewport = new Vector4();
	  function createTexture(type, target, count) {
	    var data = new Uint8Array(4);
	    var texture = gl.createTexture();
	    gl.bindTexture(type, texture);
	    gl.texParameteri(type, 10241, 9728);
	    gl.texParameteri(type, 10240, 9728);
	    for (var i = 0; i < count; i++) {
	      gl.texImage2D(target + i, 0, 6408, 1, 1, 0, 6408, 5121, data);
	    }
	    return texture;
	  }
	  var emptyTextures = {};
	  emptyTextures[3553] = createTexture(3553, 3553, 1);
	  emptyTextures[34067] = createTexture(34067, 34069, 6);
	  colorBuffer.setClear(0, 0, 0, 1);
	  depthBuffer.setClear(1);
	  stencilBuffer.setClear(0);
	  enable(2929);
	  depthBuffer.setFunc(LessEqualDepth);
	  setFlipSided(false);
	  setCullFace(CullFaceBack);
	  enable(2884);
	  setBlending(NoBlending);
	  function initAttributes() {
	    for (var i = 0, l = newAttributes.length; i < l; i++) {
	      newAttributes[i] = 0;
	    }
	  }
	  function enableAttribute(attribute) {
	    enableAttributeAndDivisor(attribute, 0);
	  }
	  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
	    newAttributes[attribute] = 1;
	    if (enabledAttributes[attribute] === 0) {
	      gl.enableVertexAttribArray(attribute);
	      enabledAttributes[attribute] = 1;
	    }
	    if (attributeDivisors[attribute] !== meshPerAttribute) {
	      var extension = isWebGL2 ? gl : extensions.get("ANGLE_instanced_arrays");
	      extension[isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](attribute, meshPerAttribute);
	      attributeDivisors[attribute] = meshPerAttribute;
	    }
	  }
	  function disableUnusedAttributes() {
	    for (var i = 0, l = enabledAttributes.length; i !== l; ++i) {
	      if (enabledAttributes[i] !== newAttributes[i]) {
	        gl.disableVertexAttribArray(i);
	        enabledAttributes[i] = 0;
	      }
	    }
	  }
	  function enable(id) {
	    if (enabledCapabilities[id] !== true) {
	      gl.enable(id);
	      enabledCapabilities[id] = true;
	    }
	  }
	  function disable(id) {
	    if (enabledCapabilities[id] !== false) {
	      gl.disable(id);
	      enabledCapabilities[id] = false;
	    }
	  }
	  function useProgram(program) {
	    if (currentProgram !== program) {
	      gl.useProgram(program);
	      currentProgram = program;
	      return true;
	    }
	    return false;
	  }
	  var equationToGL = {
	    [AddEquation]: 32774,
	    [SubtractEquation]: 32778,
	    [ReverseSubtractEquation]: 32779
	  };
	  if (isWebGL2) {
	    equationToGL[MinEquation] = 32775;
	    equationToGL[MaxEquation] = 32776;
	  } else {
	    var extension = extensions.get("EXT_blend_minmax");
	    if (extension !== null) {
	      equationToGL[MinEquation] = extension.MIN_EXT;
	      equationToGL[MaxEquation] = extension.MAX_EXT;
	    }
	  }
	  var factorToGL = {
	    [ZeroFactor]: 0,
	    [OneFactor]: 1,
	    [SrcColorFactor]: 768,
	    [SrcAlphaFactor]: 770,
	    [SrcAlphaSaturateFactor]: 776,
	    [DstColorFactor]: 774,
	    [DstAlphaFactor]: 772,
	    [OneMinusSrcColorFactor]: 769,
	    [OneMinusSrcAlphaFactor]: 771,
	    [OneMinusDstColorFactor]: 775,
	    [OneMinusDstAlphaFactor]: 773
	  };
	  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
	    if (blending === NoBlending) {
	      if (currentBlendingEnabled) {
	        disable(3042);
	        currentBlendingEnabled = false;
	      }
	      return;
	    }
	    if (!currentBlendingEnabled) {
	      enable(3042);
	      currentBlendingEnabled = true;
	    }
	    if (blending !== CustomBlending) {
	      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
	        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
	          gl.blendEquation(32774);
	          currentBlendEquation = AddEquation;
	          currentBlendEquationAlpha = AddEquation;
	        }
	        if (premultipliedAlpha) {
	          switch (blending) {
	            case NormalBlending:
	              gl.blendFuncSeparate(1, 771, 1, 771);
	              break;
	            case AdditiveBlending:
	              gl.blendFunc(1, 1);
	              break;
	            case SubtractiveBlending:
	              gl.blendFuncSeparate(0, 0, 769, 771);
	              break;
	            case MultiplyBlending:
	              gl.blendFuncSeparate(0, 768, 0, 770);
	              break;
	            default:
	              console.error("THREE.WebGLState: Invalid blending: ", blending);
	              break;
	          }
	        } else {
	          switch (blending) {
	            case NormalBlending:
	              gl.blendFuncSeparate(770, 771, 1, 771);
	              break;
	            case AdditiveBlending:
	              gl.blendFunc(770, 1);
	              break;
	            case SubtractiveBlending:
	              gl.blendFunc(0, 769);
	              break;
	            case MultiplyBlending:
	              gl.blendFunc(0, 768);
	              break;
	            default:
	              console.error("THREE.WebGLState: Invalid blending: ", blending);
	              break;
	          }
	        }
	        currentBlendSrc = null;
	        currentBlendDst = null;
	        currentBlendSrcAlpha = null;
	        currentBlendDstAlpha = null;
	        currentBlending = blending;
	        currentPremultipledAlpha = premultipliedAlpha;
	      }
	      return;
	    }
	    blendEquationAlpha = blendEquationAlpha || blendEquation;
	    blendSrcAlpha = blendSrcAlpha || blendSrc;
	    blendDstAlpha = blendDstAlpha || blendDst;
	    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
	      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
	      currentBlendEquation = blendEquation;
	      currentBlendEquationAlpha = blendEquationAlpha;
	    }
	    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
	      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
	      currentBlendSrc = blendSrc;
	      currentBlendDst = blendDst;
	      currentBlendSrcAlpha = blendSrcAlpha;
	      currentBlendDstAlpha = blendDstAlpha;
	    }
	    currentBlending = blending;
	    currentPremultipledAlpha = null;
	  }
	  function setMaterial(material, frontFaceCW) {
	    material.side === DoubleSide ? disable(2884) : enable(2884);
	    var flipSided = material.side === BackSide;
	    if (frontFaceCW) flipSided = !flipSided;
	    setFlipSided(flipSided);
	    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
	    depthBuffer.setFunc(material.depthFunc);
	    depthBuffer.setTest(material.depthTest);
	    depthBuffer.setMask(material.depthWrite);
	    colorBuffer.setMask(material.colorWrite);
	    var stencilWrite = material.stencilWrite;
	    stencilBuffer.setTest(stencilWrite);
	    if (stencilWrite) {
	      stencilBuffer.setMask(material.stencilWriteMask);
	      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
	      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
	    }
	    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
	  }
	  function setFlipSided(flipSided) {
	    if (currentFlipSided !== flipSided) {
	      if (flipSided) {
	        gl.frontFace(2304);
	      } else {
	        gl.frontFace(2305);
	      }
	      currentFlipSided = flipSided;
	    }
	  }
	  function setCullFace(cullFace) {
	    if (cullFace !== CullFaceNone) {
	      enable(2884);
	      if (cullFace !== currentCullFace) {
	        if (cullFace === CullFaceBack) {
	          gl.cullFace(1029);
	        } else if (cullFace === CullFaceFront) {
	          gl.cullFace(1028);
	        } else {
	          gl.cullFace(1032);
	        }
	      }
	    } else {
	      disable(2884);
	    }
	    currentCullFace = cullFace;
	  }
	  function setLineWidth(width) {
	    if (width !== currentLineWidth) {
	      if (lineWidthAvailable) gl.lineWidth(width);
	      currentLineWidth = width;
	    }
	  }
	  function setPolygonOffset(polygonOffset, factor, units) {
	    if (polygonOffset) {
	      enable(32823);
	      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
	        gl.polygonOffset(factor, units);
	        currentPolygonOffsetFactor = factor;
	        currentPolygonOffsetUnits = units;
	      }
	    } else {
	      disable(32823);
	    }
	  }
	  function setScissorTest(scissorTest) {
	    if (scissorTest) {
	      enable(3089);
	    } else {
	      disable(3089);
	    }
	  }
	  function activeTexture(webglSlot) {
	    if (webglSlot === undefined) webglSlot = 33984 + maxTextures - 1;
	    if (currentTextureSlot !== webglSlot) {
	      gl.activeTexture(webglSlot);
	      currentTextureSlot = webglSlot;
	    }
	  }
	  function bindTexture(webglType, webglTexture) {
	    if (currentTextureSlot === null) {
	      activeTexture();
	    }
	    var boundTexture = currentBoundTextures[currentTextureSlot];
	    if (boundTexture === undefined) {
	      boundTexture = {
	        type: undefined,
	        texture: undefined
	      };
	      currentBoundTextures[currentTextureSlot] = boundTexture;
	    }
	    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
	      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
	      boundTexture.type = webglType;
	      boundTexture.texture = webglTexture;
	    }
	  }
	  function unbindTexture() {
	    var boundTexture = currentBoundTextures[currentTextureSlot];
	    if (boundTexture !== undefined && boundTexture.type !== undefined) {
	      gl.bindTexture(boundTexture.type, null);
	      boundTexture.type = undefined;
	      boundTexture.texture = undefined;
	    }
	  }
	  function compressedTexImage2D() {
	    try {
	      gl.compressedTexImage2D.apply(gl, arguments);
	    } catch (error) {
	      console.error("THREE.WebGLState:", error);
	    }
	  }
	  function texImage2D() {
	    try {
	      gl.texImage2D.apply(gl, arguments);
	    } catch (error) {
	      console.error("THREE.WebGLState:", error);
	    }
	  }
	  function texImage3D() {
	    try {
	      gl.texImage3D.apply(gl, arguments);
	    } catch (error) {
	      console.error("THREE.WebGLState:", error);
	    }
	  }
	  function scissor(scissor) {
	    if (currentScissor.equals(scissor) === false) {
	      gl.scissor(scissor.x, scissor.y, scissor.z, scissor.w);
	      currentScissor.copy(scissor);
	    }
	  }
	  function viewport(viewport) {
	    if (currentViewport.equals(viewport) === false) {
	      gl.viewport(viewport.x, viewport.y, viewport.z, viewport.w);
	      currentViewport.copy(viewport);
	    }
	  }
	  function reset() {
	    for (var i = 0; i < enabledAttributes.length; i++) {
	      if (enabledAttributes[i] === 1) {
	        gl.disableVertexAttribArray(i);
	        enabledAttributes[i] = 0;
	      }
	    }
	    enabledCapabilities = {};
	    currentTextureSlot = null;
	    currentBoundTextures = {};
	    currentProgram = null;
	    currentBlending = null;
	    currentFlipSided = null;
	    currentCullFace = null;
	    colorBuffer.reset();
	    depthBuffer.reset();
	    stencilBuffer.reset();
	  }
	  return {
	    buffers: {
	      color: colorBuffer,
	      depth: depthBuffer,
	      stencil: stencilBuffer
	    },
	    initAttributes: initAttributes,
	    enableAttribute: enableAttribute,
	    enableAttributeAndDivisor: enableAttributeAndDivisor,
	    disableUnusedAttributes: disableUnusedAttributes,
	    enable: enable,
	    disable: disable,
	    useProgram: useProgram,
	    setBlending: setBlending,
	    setMaterial: setMaterial,
	    setFlipSided: setFlipSided,
	    setCullFace: setCullFace,
	    setLineWidth: setLineWidth,
	    setPolygonOffset: setPolygonOffset,
	    setScissorTest: setScissorTest,
	    activeTexture: activeTexture,
	    bindTexture: bindTexture,
	    unbindTexture: unbindTexture,
	    compressedTexImage2D: compressedTexImage2D,
	    texImage2D: texImage2D,
	    texImage3D: texImage3D,
	    scissor: scissor,
	    viewport: viewport,
	    reset: reset
	  };
	}
	function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
	  var isWebGL2 = capabilities.isWebGL2;
	  var maxTextures = capabilities.maxTextures;
	  var maxCubemapSize = capabilities.maxCubemapSize;
	  var maxTextureSize = capabilities.maxTextureSize;
	  var maxSamples = capabilities.maxSamples;
	  var _videoTextures = new WeakMap();
	  var _canvas;
	  var useOffscreenCanvas = false;
	  try {
	    useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
	  } catch (err) {}
	  function createCanvas(width, height) {
	    return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas");
	  }
	  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
	    var scale = 1;
	    if (image.width > maxSize || image.height > maxSize) {
	      scale = maxSize / Math.max(image.width, image.height);
	    }
	    if (scale < 1 || needsPowerOfTwo === true) {
	      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
	        var floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;
	        var width = floor(scale * image.width);
	        var height = floor(scale * image.height);
	        if (_canvas === undefined) _canvas = createCanvas(width, height);
	        var canvas = needsNewCanvas ? createCanvas(width, height) : _canvas;
	        canvas.width = width;
	        canvas.height = height;
	        var context = canvas.getContext("2d");
	        context.drawImage(image, 0, 0, width, height);
	        console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + width + "x" + height + ").");
	        return canvas;
	      } else {
	        if (("data" in image)) {
	          console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ").");
	        }
	        return image;
	      }
	    }
	    return image;
	  }
	  function isPowerOfTwo(image) {
	    return MathUtils.isPowerOfTwo(image.width) && MathUtils.isPowerOfTwo(image.height);
	  }
	  function textureNeedsPowerOfTwo(texture) {
	    if (isWebGL2) return false;
	    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
	  }
	  function textureNeedsGenerateMipmaps(texture, supportsMips) {
	    return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
	  }
	  function generateMipmap(target, texture, width, height) {
	    _gl.generateMipmap(target);
	    var textureProperties = properties.get(texture);
	    textureProperties.__maxMipLevel = Math.log(Math.max(width, height)) * Math.LOG2E;
	  }
	  function getInternalFormat(internalFormatName, glFormat, glType) {
	    if (isWebGL2 === false) return glFormat;
	    if (internalFormatName !== null) {
	      if (_gl[internalFormatName] !== undefined) return _gl[internalFormatName];
	      console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
	    }
	    var internalFormat = glFormat;
	    if (glFormat === 6403) {
	      if (glType === 5126) internalFormat = 33326;
	      if (glType === 5131) internalFormat = 33325;
	      if (glType === 5121) internalFormat = 33321;
	    }
	    if (glFormat === 6407) {
	      if (glType === 5126) internalFormat = 34837;
	      if (glType === 5131) internalFormat = 34843;
	      if (glType === 5121) internalFormat = 32849;
	    }
	    if (glFormat === 6408) {
	      if (glType === 5126) internalFormat = 34836;
	      if (glType === 5131) internalFormat = 34842;
	      if (glType === 5121) internalFormat = 32856;
	    }
	    if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) {
	      extensions.get("EXT_color_buffer_float");
	    } else if (internalFormat === 34843 || internalFormat === 34837) {
	      console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.");
	    }
	    return internalFormat;
	  }
	  function filterFallback(f) {
	    if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {
	      return 9728;
	    }
	    return 9729;
	  }
	  function onTextureDispose(event) {
	    var texture = event.target;
	    texture.removeEventListener("dispose", onTextureDispose);
	    deallocateTexture(texture);
	    if (texture.isVideoTexture) {
	      _videoTextures.delete(texture);
	    }
	    info.memory.textures--;
	  }
	  function onRenderTargetDispose(event) {
	    var renderTarget = event.target;
	    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
	    deallocateRenderTarget(renderTarget);
	    info.memory.textures--;
	  }
	  function deallocateTexture(texture) {
	    var textureProperties = properties.get(texture);
	    if (textureProperties.__webglInit === undefined) return;
	    _gl.deleteTexture(textureProperties.__webglTexture);
	    properties.remove(texture);
	  }
	  function deallocateRenderTarget(renderTarget) {
	    var renderTargetProperties = properties.get(renderTarget);
	    var textureProperties = properties.get(renderTarget.texture);
	    if (!renderTarget) return;
	    if (textureProperties.__webglTexture !== undefined) {
	      _gl.deleteTexture(textureProperties.__webglTexture);
	    }
	    if (renderTarget.depthTexture) {
	      renderTarget.depthTexture.dispose();
	    }
	    if (renderTarget.isWebGLCubeRenderTarget) {
	      for (var i = 0; i < 6; i++) {
	        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);
	        if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);
	      }
	    } else {
	      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
	      if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
	    }
	    properties.remove(renderTarget.texture);
	    properties.remove(renderTarget);
	  }
	  var textureUnits = 0;
	  function resetTextureUnits() {
	    textureUnits = 0;
	  }
	  function allocateTextureUnit() {
	    var textureUnit = textureUnits;
	    if (textureUnit >= maxTextures) {
	      console.warn("THREE.WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + maxTextures);
	    }
	    textureUnits += 1;
	    return textureUnit;
	  }
	  function setTexture2D(texture, slot) {
	    var textureProperties = properties.get(texture);
	    if (texture.isVideoTexture) updateVideoTexture(texture);
	    if (texture.version > 0 && textureProperties.__version !== texture.version) {
	      var image = texture.image;
	      if (image === undefined) {
	        console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
	      } else if (image.complete === false) {
	        console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
	      } else {
	        uploadTexture(textureProperties, texture, slot);
	        return;
	      }
	    }
	    state.activeTexture(33984 + slot);
	    state.bindTexture(3553, textureProperties.__webglTexture);
	  }
	  function setTexture2DArray(texture, slot) {
	    var textureProperties = properties.get(texture);
	    if (texture.version > 0 && textureProperties.__version !== texture.version) {
	      uploadTexture(textureProperties, texture, slot);
	      return;
	    }
	    state.activeTexture(33984 + slot);
	    state.bindTexture(35866, textureProperties.__webglTexture);
	  }
	  function setTexture3D(texture, slot) {
	    var textureProperties = properties.get(texture);
	    if (texture.version > 0 && textureProperties.__version !== texture.version) {
	      uploadTexture(textureProperties, texture, slot);
	      return;
	    }
	    state.activeTexture(33984 + slot);
	    state.bindTexture(32879, textureProperties.__webglTexture);
	  }
	  function setTextureCube(texture, slot) {
	    if (texture.image.length !== 6) return;
	    var textureProperties = properties.get(texture);
	    if (texture.version > 0 && textureProperties.__version !== texture.version) {
	      initTexture(textureProperties, texture);
	      state.activeTexture(33984 + slot);
	      state.bindTexture(34067, textureProperties.__webglTexture);
	      _gl.pixelStorei(37440, texture.flipY);
	      var isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);
	      var isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
	      var cubeImage = [];
	      for (var i = 0; i < 6; i++) {
	        if (!isCompressed && !isDataTexture) {
	          cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);
	        } else {
	          cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];
	        }
	      }
	      var image = cubeImage[0], supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
	      setTextureParameters(34067, texture, supportsMips);
	      var mipmaps;
	      if (isCompressed) {
	        for (var i = 0; i < 6; i++) {
	          mipmaps = cubeImage[i].mipmaps;
	          for (var j = 0; j < mipmaps.length; j++) {
	            var mipmap = mipmaps[j];
	            if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
	              if (glFormat !== null) {
	                state.compressedTexImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
	              } else {
	                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
	              }
	            } else {
	              state.texImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
	            }
	          }
	        }
	        textureProperties.__maxMipLevel = mipmaps.length - 1;
	      } else {
	        mipmaps = texture.mipmaps;
	        for (var i = 0; i < 6; i++) {
	          if (isDataTexture) {
	            state.texImage2D(34069 + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);
	            for (var j = 0; j < mipmaps.length; j++) {
	              var mipmap = mipmaps[j];
	              var mipmapImage = mipmap.image[i].image;
	              state.texImage2D(34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
	            }
	          } else {
	            state.texImage2D(34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);
	            for (var j = 0; j < mipmaps.length; j++) {
	              var mipmap = mipmaps[j];
	              state.texImage2D(34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);
	            }
	          }
	        }
	        textureProperties.__maxMipLevel = mipmaps.length;
	      }
	      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
	        generateMipmap(34067, texture, image.width, image.height);
	      }
	      textureProperties.__version = texture.version;
	      if (texture.onUpdate) texture.onUpdate(texture);
	    } else {
	      state.activeTexture(33984 + slot);
	      state.bindTexture(34067, textureProperties.__webglTexture);
	    }
	  }
	  function setTextureCubeDynamic(texture, slot) {
	    state.activeTexture(33984 + slot);
	    state.bindTexture(34067, properties.get(texture).__webglTexture);
	  }
	  var wrappingToGL = {
	    [RepeatWrapping]: 10497,
	    [ClampToEdgeWrapping]: 33071,
	    [MirroredRepeatWrapping]: 33648
	  };
	  var filterToGL = {
	    [NearestFilter]: 9728,
	    [NearestMipmapNearestFilter]: 9984,
	    [NearestMipmapLinearFilter]: 9986,
	    [LinearFilter]: 9729,
	    [LinearMipmapNearestFilter]: 9985,
	    [LinearMipmapLinearFilter]: 9987
	  };
	  function setTextureParameters(textureType, texture, supportsMips) {
	    if (supportsMips) {
	      _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);
	      _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);
	      if (textureType === 32879 || textureType === 35866) {
	        _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);
	      }
	      _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);
	      _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);
	    } else {
	      _gl.texParameteri(textureType, 10242, 33071);
	      _gl.texParameteri(textureType, 10243, 33071);
	      if (textureType === 32879 || textureType === 35866) {
	        _gl.texParameteri(textureType, 32882, 33071);
	      }
	      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {
	        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.");
	      }
	      _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));
	      _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));
	      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
	        console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.");
	      }
	    }
	    var extension = extensions.get("EXT_texture_filter_anisotropic");
	    if (extension) {
	      if (texture.type === FloatType && extensions.get("OES_texture_float_linear") === null) return;
	      if (texture.type === HalfFloatType && (isWebGL2 || extensions.get("OES_texture_half_float_linear")) === null) return;
	      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
	        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
	        properties.get(texture).__currentAnisotropy = texture.anisotropy;
	      }
	    }
	  }
	  function initTexture(textureProperties, texture) {
	    if (textureProperties.__webglInit === undefined) {
	      textureProperties.__webglInit = true;
	      texture.addEventListener("dispose", onTextureDispose);
	      textureProperties.__webglTexture = _gl.createTexture();
	      info.memory.textures++;
	    }
	  }
	  function uploadTexture(textureProperties, texture, slot) {
	    var textureType = 3553;
	    if (texture.isDataTexture2DArray) textureType = 35866;
	    if (texture.isDataTexture3D) textureType = 32879;
	    initTexture(textureProperties, texture);
	    state.activeTexture(33984 + slot);
	    state.bindTexture(textureType, textureProperties.__webglTexture);
	    _gl.pixelStorei(37440, texture.flipY);
	    _gl.pixelStorei(37441, texture.premultiplyAlpha);
	    _gl.pixelStorei(3317, texture.unpackAlignment);
	    var needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo(texture.image) === false;
	    var image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);
	    var supportsMips = isPowerOfTwo(image) || isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);
	    setTextureParameters(textureType, texture, supportsMips);
	    var mipmap, mipmaps = texture.mipmaps;
	    if (texture.isDepthTexture) {
	      glInternalFormat = 6402;
	      if (texture.type === FloatType) {
	        if (isWebGL2 === false) throw new Error("Float Depth Texture only supported in WebGL2.0");
	        glInternalFormat = 36012;
	      } else if (isWebGL2) {
	        glInternalFormat = 33189;
	      }
	      if (texture.format === DepthFormat && glInternalFormat === 6402) {
	        if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {
	          console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.");
	          texture.type = UnsignedShortType;
	          glType = utils.convert(texture.type);
	        }
	      }
	      if (texture.format === DepthStencilFormat) {
	        glInternalFormat = 34041;
	        if (texture.type !== UnsignedInt248Type) {
	          console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.");
	          texture.type = UnsignedInt248Type;
	          glType = utils.convert(texture.type);
	        }
	      }
	      state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
	    } else if (texture.isDataTexture) {
	      if (mipmaps.length > 0 && supportsMips) {
	        for (var i = 0, il = mipmaps.length; i < il; i++) {
	          mipmap = mipmaps[i];
	          state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
	        }
	        texture.generateMipmaps = false;
	        textureProperties.__maxMipLevel = mipmaps.length - 1;
	      } else {
	        state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
	        textureProperties.__maxMipLevel = 0;
	      }
	    } else if (texture.isCompressedTexture) {
	      for (var i = 0, il = mipmaps.length; i < il; i++) {
	        mipmap = mipmaps[i];
	        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {
	          if (glFormat !== null) {
	            state.compressedTexImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
	          } else {
	            console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
	          }
	        } else {
	          state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
	        }
	      }
	      textureProperties.__maxMipLevel = mipmaps.length - 1;
	    } else if (texture.isDataTexture2DArray) {
	      state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
	      textureProperties.__maxMipLevel = 0;
	    } else if (texture.isDataTexture3D) {
	      state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
	      textureProperties.__maxMipLevel = 0;
	    } else {
	      if (mipmaps.length > 0 && supportsMips) {
	        for (var i = 0, il = mipmaps.length; i < il; i++) {
	          mipmap = mipmaps[i];
	          state.texImage2D(3553, i, glInternalFormat, glFormat, glType, mipmap);
	        }
	        texture.generateMipmaps = false;
	        textureProperties.__maxMipLevel = mipmaps.length - 1;
	      } else {
	        state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);
	        textureProperties.__maxMipLevel = 0;
	      }
	    }
	    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
	      generateMipmap(textureType, texture, image.width, image.height);
	    }
	    textureProperties.__version = texture.version;
	    if (texture.onUpdate) texture.onUpdate(texture);
	  }
	  function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {
	    var glFormat = utils.convert(renderTarget.texture.format);
	    var glType = utils.convert(renderTarget.texture.type);
	    var glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
	    state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
	    _gl.bindFramebuffer(36160, framebuffer);
	    _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(renderTarget.texture).__webglTexture, 0);
	    _gl.bindFramebuffer(36160, null);
	  }
	  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
	    _gl.bindRenderbuffer(36161, renderbuffer);
	    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
	      if (isMultisample) {
	        var samples = getRenderTargetSamples(renderTarget);
	        _gl.renderbufferStorageMultisample(36161, samples, 33189, renderTarget.width, renderTarget.height);
	      } else {
	        _gl.renderbufferStorage(36161, 33189, renderTarget.width, renderTarget.height);
	      }
	      _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);
	    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
	      if (isMultisample) {
	        var samples = getRenderTargetSamples(renderTarget);
	        _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);
	      } else {
	        _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);
	      }
	      _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);
	    } else {
	      var glFormat = utils.convert(renderTarget.texture.format);
	      var glType = utils.convert(renderTarget.texture.type);
	      var glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
	      if (isMultisample) {
	        var samples = getRenderTargetSamples(renderTarget);
	        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
	      } else {
	        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);
	      }
	    }
	    _gl.bindRenderbuffer(36161, null);
	  }
	  function setupDepthTexture(framebuffer, renderTarget) {
	    var isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;
	    if (isCube) throw new Error("Depth Texture with cube render targets is not supported");
	    _gl.bindFramebuffer(36160, framebuffer);
	    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
	      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
	    }
	    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
	      renderTarget.depthTexture.image.width = renderTarget.width;
	      renderTarget.depthTexture.image.height = renderTarget.height;
	      renderTarget.depthTexture.needsUpdate = true;
	    }
	    setTexture2D(renderTarget.depthTexture, 0);
	    var webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;
	    if (renderTarget.depthTexture.format === DepthFormat) {
	      _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);
	    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
	      _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);
	    } else {
	      throw new Error("Unknown depthTexture format");
	    }
	  }
	  function setupDepthRenderbuffer(renderTarget) {
	    var renderTargetProperties = properties.get(renderTarget);
	    var isCube = renderTarget.isWebGLCubeRenderTarget === true;
	    if (renderTarget.depthTexture) {
	      if (isCube) throw new Error("target.depthTexture not supported in Cube render targets");
	      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);
	    } else {
	      if (isCube) {
	        renderTargetProperties.__webglDepthbuffer = [];
	        for (var i = 0; i < 6; i++) {
	          _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i]);
	          renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();
	          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget);
	        }
	      } else {
	        _gl.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);
	        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
	        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget);
	      }
	    }
	    _gl.bindFramebuffer(36160, null);
	  }
	  function setupRenderTarget(renderTarget) {
	    var renderTargetProperties = properties.get(renderTarget);
	    var textureProperties = properties.get(renderTarget.texture);
	    renderTarget.addEventListener("dispose", onRenderTargetDispose);
	    textureProperties.__webglTexture = _gl.createTexture();
	    info.memory.textures++;
	    var isCube = renderTarget.isWebGLCubeRenderTarget === true;
	    var isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;
	    var supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
	    if (isCube) {
	      renderTargetProperties.__webglFramebuffer = [];
	      for (var i = 0; i < 6; i++) {
	        renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();
	      }
	    } else {
	      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
	      if (isMultisample) {
	        if (isWebGL2) {
	          renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
	          renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
	          _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);
	          var glFormat = utils.convert(renderTarget.texture.format);
	          var glType = utils.convert(renderTarget.texture.type);
	          var glInternalFormat = getInternalFormat(renderTarget.texture.internalFormat, glFormat, glType);
	          var samples = getRenderTargetSamples(renderTarget);
	          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);
	          _gl.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);
	          _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);
	          _gl.bindRenderbuffer(36161, null);
	          if (renderTarget.depthBuffer) {
	            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
	            setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
	          }
	          _gl.bindFramebuffer(36160, null);
	        } else {
	          console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
	        }
	      }
	    }
	    if (isCube) {
	      state.bindTexture(34067, textureProperties.__webglTexture);
	      setTextureParameters(34067, renderTarget.texture, supportsMips);
	      for (var i = 0; i < 6; i++) {
	        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, 36064, 34069 + i);
	      }
	      if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {
	        generateMipmap(34067, renderTarget.texture, renderTarget.width, renderTarget.height);
	      }
	      state.bindTexture(34067, null);
	    } else {
	      state.bindTexture(3553, textureProperties.__webglTexture);
	      setTextureParameters(3553, renderTarget.texture, supportsMips);
	      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553);
	      if (textureNeedsGenerateMipmaps(renderTarget.texture, supportsMips)) {
	        generateMipmap(3553, renderTarget.texture, renderTarget.width, renderTarget.height);
	      }
	      state.bindTexture(3553, null);
	    }
	    if (renderTarget.depthBuffer) {
	      setupDepthRenderbuffer(renderTarget);
	    }
	  }
	  function updateRenderTargetMipmap(renderTarget) {
	    var texture = renderTarget.texture;
	    var supportsMips = isPowerOfTwo(renderTarget) || isWebGL2;
	    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
	      var target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
	      var webglTexture = properties.get(texture).__webglTexture;
	      state.bindTexture(target, webglTexture);
	      generateMipmap(target, texture, renderTarget.width, renderTarget.height);
	      state.bindTexture(target, null);
	    }
	  }
	  function updateMultisampleRenderTarget(renderTarget) {
	    if (renderTarget.isWebGLMultisampleRenderTarget) {
	      if (isWebGL2) {
	        var renderTargetProperties = properties.get(renderTarget);
	        _gl.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);
	        _gl.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);
	        var width = renderTarget.width;
	        var height = renderTarget.height;
	        var mask = 16384;
	        if (renderTarget.depthBuffer) mask |= 256;
	        if (renderTarget.stencilBuffer) mask |= 1024;
	        _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);
	      } else {
	        console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
	      }
	    }
	  }
	  function getRenderTargetSamples(renderTarget) {
	    return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;
	  }
	  function updateVideoTexture(texture) {
	    var frame = info.render.frame;
	    if (_videoTextures.get(texture) !== frame) {
	      _videoTextures.set(texture, frame);
	      texture.update();
	    }
	  }
	  var warnedTexture2D = false;
	  var warnedTextureCube = false;
	  function safeSetTexture2D(texture, slot) {
	    if (texture && texture.isWebGLRenderTarget) {
	      if (warnedTexture2D === false) {
	        console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.");
	        warnedTexture2D = true;
	      }
	      texture = texture.texture;
	    }
	    setTexture2D(texture, slot);
	  }
	  function safeSetTextureCube(texture, slot) {
	    if (texture && texture.isWebGLCubeRenderTarget) {
	      if (warnedTextureCube === false) {
	        console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.");
	        warnedTextureCube = true;
	      }
	      texture = texture.texture;
	    }
	    if (texture && texture.isCubeTexture || Array.isArray(texture.image) && texture.image.length === 6) {
	      setTextureCube(texture, slot);
	    } else {
	      setTextureCubeDynamic(texture, slot);
	    }
	  }
	  this.allocateTextureUnit = allocateTextureUnit;
	  this.resetTextureUnits = resetTextureUnits;
	  this.setTexture2D = setTexture2D;
	  this.setTexture2DArray = setTexture2DArray;
	  this.setTexture3D = setTexture3D;
	  this.setTextureCube = setTextureCube;
	  this.setTextureCubeDynamic = setTextureCubeDynamic;
	  this.setupRenderTarget = setupRenderTarget;
	  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
	  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
	  this.safeSetTexture2D = safeSetTexture2D;
	  this.safeSetTextureCube = safeSetTextureCube;
	}
	function WebGLUtils(gl, extensions, capabilities) {
	  var isWebGL2 = capabilities.isWebGL2;
	  function convert(p) {
	    var extension;
	    if (p === UnsignedByteType) return 5121;
	    if (p === UnsignedShort4444Type) return 32819;
	    if (p === UnsignedShort5551Type) return 32820;
	    if (p === UnsignedShort565Type) return 33635;
	    if (p === ByteType) return 5120;
	    if (p === ShortType) return 5122;
	    if (p === UnsignedShortType) return 5123;
	    if (p === IntType) return 5124;
	    if (p === UnsignedIntType) return 5125;
	    if (p === FloatType) return 5126;
	    if (p === HalfFloatType) {
	      if (isWebGL2) return 5131;
	      extension = extensions.get("OES_texture_half_float");
	      if (extension !== null) {
	        return extension.HALF_FLOAT_OES;
	      } else {
	        return null;
	      }
	    }
	    if (p === AlphaFormat) return 6406;
	    if (p === RGBFormat) return 6407;
	    if (p === RGBAFormat) return 6408;
	    if (p === LuminanceFormat) return 6409;
	    if (p === LuminanceAlphaFormat) return 6410;
	    if (p === DepthFormat) return 6402;
	    if (p === DepthStencilFormat) return 34041;
	    if (p === RedFormat) return 6403;
	    if (p === RedIntegerFormat) return 36244;
	    if (p === RGFormat) return 33319;
	    if (p === RGIntegerFormat) return 33320;
	    if (p === RGBIntegerFormat) return 36248;
	    if (p === RGBAIntegerFormat) return 36249;
	    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {
	      extension = extensions.get("WEBGL_compressed_texture_s3tc");
	      if (extension !== null) {
	        if (p === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
	        if (p === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
	        if (p === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
	        if (p === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
	      } else {
	        return null;
	      }
	    }
	    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {
	      extension = extensions.get("WEBGL_compressed_texture_pvrtc");
	      if (extension !== null) {
	        if (p === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
	        if (p === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
	        if (p === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
	        if (p === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
	      } else {
	        return null;
	      }
	    }
	    if (p === RGB_ETC1_Format) {
	      extension = extensions.get("WEBGL_compressed_texture_etc1");
	      if (extension !== null) {
	        return extension.COMPRESSED_RGB_ETC1_WEBGL;
	      } else {
	        return null;
	      }
	    }
	    if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {
	      extension = extensions.get("WEBGL_compressed_texture_etc");
	      if (extension !== null) {
	        if (p === RGB_ETC2_Format) return extension.COMPRESSED_RGB8_ETC2;
	        if (p === RGBA_ETC2_EAC_Format) return extension.COMPRESSED_RGBA8_ETC2_EAC;
	      }
	    }
	    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {
	      extension = extensions.get("WEBGL_compressed_texture_astc");
	      if (extension !== null) {
	        return p;
	      } else {
	        return null;
	      }
	    }
	    if (p === UnsignedInt248Type) {
	      if (isWebGL2) return 34042;
	      extension = extensions.get("WEBGL_depth_texture");
	      if (extension !== null) {
	        return extension.UNSIGNED_INT_24_8_WEBGL;
	      } else {
	        return null;
	      }
	    }
	  }
	  return {
	    convert: convert
	  };
	}
	function ArrayCamera(array) {
	  PerspectiveCamera.call(this);
	  this.cameras = array || [];
	}
	ArrayCamera.prototype = Object.assign(Object.create(PerspectiveCamera.prototype), {
	  constructor: ArrayCamera,
	  isArrayCamera: true
	});
	function Group() {
	  Object3D.call(this);
	  this.type = "Group";
	}
	Group.prototype = Object.assign(Object.create(Object3D.prototype), {
	  constructor: Group,
	  isGroup: true
	});
	function WebXRManager(renderer, gl) {
	  var scope = this;
	  var session = null;
	  var framebufferScaleFactor = 1;
	  var referenceSpace = null;
	  var referenceSpaceType = "local-floor";
	  var pose = null;
	  var controllers = [];
	  var inputSourcesMap = new Map();
	  var cameraL = new PerspectiveCamera();
	  cameraL.layers.enable(1);
	  cameraL.viewport = new Vector4();
	  var cameraR = new PerspectiveCamera();
	  cameraR.layers.enable(2);
	  cameraR.viewport = new Vector4();
	  var cameraVR = new ArrayCamera([cameraL, cameraR]);
	  cameraVR.layers.enable(1);
	  cameraVR.layers.enable(2);
	  var _currentDepthNear = null;
	  var _currentDepthFar = null;
	  this.enabled = false;
	  this.isPresenting = false;
	  this.getController = function (id) {
	    var controller = controllers[id];
	    if (controller === undefined) {
	      controller = {};
	      controllers[id] = controller;
	    }
	    if (controller.targetRay === undefined) {
	      controller.targetRay = new Group();
	      controller.targetRay.matrixAutoUpdate = false;
	      controller.targetRay.visible = false;
	    }
	    return controller.targetRay;
	  };
	  this.getControllerGrip = function (id) {
	    var controller = controllers[id];
	    if (controller === undefined) {
	      controller = {};
	      controllers[id] = controller;
	    }
	    if (controller.grip === undefined) {
	      controller.grip = new Group();
	      controller.grip.matrixAutoUpdate = false;
	      controller.grip.visible = false;
	    }
	    return controller.grip;
	  };
	  function onSessionEvent(event) {
	    var controller = inputSourcesMap.get(event.inputSource);
	    if (controller) {
	      if (controller.targetRay) {
	        controller.targetRay.dispatchEvent({
	          type: event.type
	        });
	      }
	      if (controller.grip) {
	        controller.grip.dispatchEvent({
	          type: event.type
	        });
	      }
	    }
	  }
	  function onSessionEnd() {
	    inputSourcesMap.forEach(function (controller, inputSource) {
	      if (controller.targetRay) {
	        controller.targetRay.dispatchEvent({
	          type: "disconnected",
	          data: inputSource
	        });
	        controller.targetRay.visible = false;
	      }
	      if (controller.grip) {
	        controller.grip.dispatchEvent({
	          type: "disconnected",
	          data: inputSource
	        });
	        controller.grip.visible = false;
	      }
	    });
	    inputSourcesMap.clear();
	    renderer.setFramebuffer(null);
	    renderer.setRenderTarget(renderer.getRenderTarget());
	    animation.stop();
	    scope.isPresenting = false;
	    scope.dispatchEvent({
	      type: "sessionend"
	    });
	  }
	  function onRequestReferenceSpace(value) {
	    referenceSpace = value;
	    animation.setContext(session);
	    animation.start();
	    scope.isPresenting = true;
	    scope.dispatchEvent({
	      type: "sessionstart"
	    });
	  }
	  this.setFramebufferScaleFactor = function (value) {
	    framebufferScaleFactor = value;
	    if (scope.isPresenting == true) {
	      console.warn("WebXRManager: Cannot change framebuffer scale while presenting VR content");
	    }
	  };
	  this.setReferenceSpaceType = function (value) {
	    referenceSpaceType = value;
	  };
	  this.getReferenceSpace = function () {
	    return referenceSpace;
	  };
	  this.getSession = function () {
	    return session;
	  };
	  this.setSession = function (value) {
	    session = value;
	    if (session !== null) {
	      session.addEventListener("select", onSessionEvent);
	      session.addEventListener("selectstart", onSessionEvent);
	      session.addEventListener("selectend", onSessionEvent);
	      session.addEventListener("squeeze", onSessionEvent);
	      session.addEventListener("squeezestart", onSessionEvent);
	      session.addEventListener("squeezeend", onSessionEvent);
	      session.addEventListener("end", onSessionEnd);
	      var attributes = gl.getContextAttributes();
	      var layerInit = {
	        antialias: attributes.antialias,
	        alpha: attributes.alpha,
	        depth: attributes.depth,
	        stencil: attributes.stencil,
	        framebufferScaleFactor: framebufferScaleFactor
	      };
	      var baseLayer = new XRWebGLLayer(session, gl, layerInit);
	      session.updateRenderState({
	        baseLayer: baseLayer
	      });
	      session.requestReferenceSpace(referenceSpaceType).then(onRequestReferenceSpace);
	      session.addEventListener("inputsourceschange", updateInputSources);
	    }
	  };
	  function updateInputSources(event) {
	    var inputSources = session.inputSources;
	    for (var i = 0; i < controllers.length; i++) {
	      inputSourcesMap.set(inputSources[i], controllers[i]);
	    }
	    for (var i = 0; i < event.removed.length; i++) {
	      var inputSource = event.removed[i];
	      var controller = inputSourcesMap.get(inputSource);
	      if (controller) {
	        if (controller.targetRay) {
	          controller.targetRay.dispatchEvent({
	            type: "disconnected",
	            data: inputSource
	          });
	        }
	        if (controller.grip) {
	          controller.grip.dispatchEvent({
	            type: "disconnected",
	            data: inputSource
	          });
	        }
	        inputSourcesMap.delete(inputSource);
	      }
	    }
	    for (var i = 0; i < event.added.length; i++) {
	      var inputSource = event.added[i];
	      var controller = inputSourcesMap.get(inputSource);
	      if (controller) {
	        if (controller.targetRay) {
	          controller.targetRay.dispatchEvent({
	            type: "connected",
	            data: inputSource
	          });
	        }
	        if (controller.grip) {
	          controller.grip.dispatchEvent({
	            type: "connected",
	            data: inputSource
	          });
	        }
	      }
	    }
	  }
	  var cameraLPos = new Vector3();
	  var cameraRPos = new Vector3();
	  function setProjectionFromUnion(camera, cameraL, cameraR) {
	    cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);
	    cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);
	    var ipd = cameraLPos.distanceTo(cameraRPos);
	    var projL = cameraL.projectionMatrix.elements;
	    var projR = cameraR.projectionMatrix.elements;
	    var near = projL[14] / (projL[10] - 1);
	    var far = projL[14] / (projL[10] + 1);
	    var topFov = (projL[9] + 1) / projL[5];
	    var bottomFov = (projL[9] - 1) / projL[5];
	    var leftFov = (projL[8] - 1) / projL[0];
	    var rightFov = (projR[8] + 1) / projR[0];
	    var left = near * leftFov;
	    var right = near * rightFov;
	    var zOffset = ipd / (-leftFov + rightFov);
	    var xOffset = zOffset * -leftFov;
	    cameraL.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
	    camera.translateX(xOffset);
	    camera.translateZ(zOffset);
	    camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
	    camera.matrixWorldInverse.getInverse(camera.matrixWorld);
	    var near2 = near + zOffset;
	    var far2 = far + zOffset;
	    var left2 = left - xOffset;
	    var right2 = right + (ipd - xOffset);
	    var top2 = topFov * far / far2 * near2;
	    var bottom2 = bottomFov * far / far2 * near2;
	    camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
	  }
	  function updateCamera(camera, parent) {
	    if (parent === null) {
	      camera.matrixWorld.copy(camera.matrix);
	    } else {
	      camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
	    }
	    camera.matrixWorldInverse.getInverse(camera.matrixWorld);
	  }
	  this.getCamera = function (camera) {
	    cameraVR.near = cameraR.near = cameraL.near = camera.near;
	    cameraVR.far = cameraR.far = cameraL.far = camera.far;
	    if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {
	      session.updateRenderState({
	        depthNear: cameraVR.near,
	        depthFar: cameraVR.far
	      });
	      _currentDepthNear = cameraVR.near;
	      _currentDepthFar = cameraVR.far;
	    }
	    var parent = camera.parent;
	    var cameras = cameraVR.cameras;
	    updateCamera(cameraVR, parent);
	    for (var i = 0; i < cameras.length; i++) {
	      updateCamera(cameras[i], parent);
	    }
	    camera.matrixWorld.copy(cameraVR.matrixWorld);
	    var children = camera.children;
	    for (var i = 0, l = children.length; i < l; i++) {
	      children[i].updateMatrixWorld(true);
	    }
	    setProjectionFromUnion(cameraVR, cameraL, cameraR);
	    return cameraVR;
	  };
	  var onAnimationFrameCallback = null;
	  function onAnimationFrame(time, frame) {
	    pose = frame.getViewerPose(referenceSpace);
	    if (pose !== null) {
	      var views = pose.views;
	      var baseLayer = session.renderState.baseLayer;
	      renderer.setFramebuffer(baseLayer.framebuffer);
	      for (var i = 0; i < views.length; i++) {
	        var view = views[i];
	        var viewport = baseLayer.getViewport(view);
	        var camera = cameraVR.cameras[i];
	        camera.matrix.fromArray(view.transform.matrix);
	        camera.projectionMatrix.fromArray(view.projectionMatrix);
	        camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
	        if (i === 0) {
	          cameraVR.matrix.copy(camera.matrix);
	        }
	      }
	    }
	    var inputSources = session.inputSources;
	    for (var i = 0; i < controllers.length; i++) {
	      var controller = controllers[i];
	      var inputSource = inputSources[i];
	      var inputPose = null;
	      var gripPose = null;
	      if (inputSource) {
	        if (controller.targetRay) {
	          inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
	          if (inputPose !== null) {
	            controller.targetRay.matrix.fromArray(inputPose.transform.matrix);
	            controller.targetRay.matrix.decompose(controller.targetRay.position, controller.targetRay.rotation, controller.targetRay.scale);
	          }
	        }
	        if (controller.grip && inputSource.gripSpace) {
	          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
	          if (gripPose !== null) {
	            controller.grip.matrix.fromArray(gripPose.transform.matrix);
	            controller.grip.matrix.decompose(controller.grip.position, controller.grip.rotation, controller.grip.scale);
	          }
	        }
	      }
	      if (controller.targetRay) {
	        controller.targetRay.visible = inputPose !== null;
	      }
	      if (controller.grip) {
	        controller.grip.visible = gripPose !== null;
	      }
	    }
	    if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
	  }
	  var animation = new WebGLAnimation();
	  animation.setAnimationLoop(onAnimationFrame);
	  this.setAnimationLoop = function (callback) {
	    onAnimationFrameCallback = callback;
	  };
	  this.dispose = function () {};
	}
	Object.assign(WebXRManager.prototype, EventDispatcher.prototype);
	function WebGLRenderer(parameters) {
	  parameters = parameters || ({});
	  var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), _context = parameters.context !== undefined ? parameters.context : null, _alpha = parameters.alpha !== undefined ? parameters.alpha : false, _depth = parameters.depth !== undefined ? parameters.depth : true, _stencil = parameters.stencil !== undefined ? parameters.stencil : true, _antialias = parameters.antialias !== undefined ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : "default", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;
	  var currentRenderList = null;
	  var currentRenderState = null;
	  this.domElement = _canvas;
	  this.debug = {
	    checkShaderErrors: true
	  };
	  this.autoClear = true;
	  this.autoClearColor = true;
	  this.autoClearDepth = true;
	  this.autoClearStencil = true;
	  this.sortObjects = true;
	  this.clippingPlanes = [];
	  this.localClippingEnabled = false;
	  this.gammaFactor = 2;
	  this.outputEncoding = LinearEncoding;
	  this.physicallyCorrectLights = false;
	  this.toneMapping = LinearToneMapping;
	  this.toneMappingExposure = 1;
	  this.toneMappingWhitePoint = 1;
	  this.maxMorphTargets = 8;
	  this.maxMorphNormals = 4;
	  var _this = this, _isContextLost = false, _framebuffer = null, _currentActiveCubeFace = 0, _currentActiveMipmapLevel = 0, _currentRenderTarget = null, _currentFramebuffer = null, _currentMaterialId = -1, _currentGeometryProgram = {
	    geometry: null,
	    program: null,
	    wireframe: false
	  }, _currentCamera = null, _currentArrayCamera = null, _currentViewport = new Vector4(), _currentScissor = new Vector4(), _currentScissorTest = null, _width = _canvas.width, _height = _canvas.height, _pixelRatio = 1, _opaqueSort = null, _transparentSort = null, _viewport = new Vector4(0, 0, _width, _height), _scissor = new Vector4(0, 0, _width, _height), _scissorTest = false, _frustum = new Frustum(), _clipping = new WebGLClipping(), _clippingEnabled = false, _localClippingEnabled = false, _projScreenMatrix = new Matrix4(), _vector3 = new Vector3();
	  function getTargetPixelRatio() {
	    return _currentRenderTarget === null ? _pixelRatio : 1;
	  }
	  var _gl;
	  try {
	    var contextAttributes = {
	      alpha: _alpha,
	      depth: _depth,
	      stencil: _stencil,
	      antialias: _antialias,
	      premultipliedAlpha: _premultipliedAlpha,
	      preserveDrawingBuffer: _preserveDrawingBuffer,
	      powerPreference: _powerPreference,
	      failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat,
	      xrCompatible: true
	    };
	    _canvas.addEventListener("webglcontextlost", onContextLost, false);
	    _canvas.addEventListener("webglcontextrestored", onContextRestore, false);
	    _gl = _context || _canvas.getContext("webgl", contextAttributes) || _canvas.getContext("experimental-webgl", contextAttributes);
	    if (_gl === null) {
	      if (_canvas.getContext("webgl") !== null) {
	        throw new Error("Error creating WebGL context with your selected attributes.");
	      } else {
	        throw new Error("Error creating WebGL context.");
	      }
	    }
	    if (_gl.getShaderPrecisionFormat === undefined) {
	      _gl.getShaderPrecisionFormat = function () {
	        return {
	          "rangeMin": 1,
	          "rangeMax": 1,
	          "precision": 1
	        };
	      };
	    }
	  } catch (error) {
	    console.error("THREE.WebGLRenderer: " + error.message);
	    throw error;
	  }
	  var extensions, capabilities, state, info;
	  var properties, textures, attributes, geometries, objects;
	  var programCache, renderLists, renderStates;
	  var background, morphtargets, bufferRenderer, indexedBufferRenderer;
	  var utils;
	  function initGLContext() {
	    extensions = new WebGLExtensions(_gl);
	    capabilities = new WebGLCapabilities(_gl, extensions, parameters);
	    if (capabilities.isWebGL2 === false) {
	      extensions.get("WEBGL_depth_texture");
	      extensions.get("OES_texture_float");
	      extensions.get("OES_texture_half_float");
	      extensions.get("OES_texture_half_float_linear");
	      extensions.get("OES_standard_derivatives");
	      extensions.get("OES_element_index_uint");
	      extensions.get("ANGLE_instanced_arrays");
	    }
	    extensions.get("OES_texture_float_linear");
	    utils = new WebGLUtils(_gl, extensions, capabilities);
	    state = new WebGLState(_gl, extensions, capabilities);
	    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
	    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
	    info = new WebGLInfo(_gl);
	    properties = new WebGLProperties();
	    textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
	    attributes = new WebGLAttributes(_gl, capabilities);
	    geometries = new WebGLGeometries(_gl, attributes, info);
	    objects = new WebGLObjects(_gl, geometries, attributes, info);
	    morphtargets = new WebGLMorphtargets(_gl);
	    programCache = new WebGLPrograms(_this, extensions, capabilities);
	    renderLists = new WebGLRenderLists();
	    renderStates = new WebGLRenderStates();
	    background = new WebGLBackground(_this, state, objects, _premultipliedAlpha);
	    bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);
	    indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);
	    info.programs = programCache.programs;
	    _this.capabilities = capabilities;
	    _this.extensions = extensions;
	    _this.properties = properties;
	    _this.renderLists = renderLists;
	    _this.state = state;
	    _this.info = info;
	  }
	  initGLContext();
	  var xr = new WebXRManager(_this, _gl);
	  this.xr = xr;
	  var shadowMap = new WebGLShadowMap(_this, objects, capabilities.maxTextureSize);
	  this.shadowMap = shadowMap;
	  this.getContext = function () {
	    return _gl;
	  };
	  this.getContextAttributes = function () {
	    return _gl.getContextAttributes();
	  };
	  this.forceContextLoss = function () {
	    var extension = extensions.get("WEBGL_lose_context");
	    if (extension) extension.loseContext();
	  };
	  this.forceContextRestore = function () {
	    var extension = extensions.get("WEBGL_lose_context");
	    if (extension) extension.restoreContext();
	  };
	  this.getPixelRatio = function () {
	    return _pixelRatio;
	  };
	  this.setPixelRatio = function (value) {
	    if (value === undefined) return;
	    _pixelRatio = value;
	    this.setSize(_width, _height, false);
	  };
	  this.getSize = function (target) {
	    if (target === undefined) {
	      console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument");
	      target = new Vector2();
	    }
	    return target.set(_width, _height);
	  };
	  this.setSize = function (width, height, updateStyle) {
	    if (xr.isPresenting) {
	      console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
	      return;
	    }
	    _width = width;
	    _height = height;
	    _canvas.width = Math.floor(width * _pixelRatio);
	    _canvas.height = Math.floor(height * _pixelRatio);
	    if (updateStyle !== false) {
	      _canvas.style.width = width + "px";
	      _canvas.style.height = height + "px";
	    }
	    this.setViewport(0, 0, width, height);
	  };
	  this.getDrawingBufferSize = function (target) {
	    if (target === undefined) {
	      console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument");
	      target = new Vector2();
	    }
	    return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
	  };
	  this.setDrawingBufferSize = function (width, height, pixelRatio) {
	    _width = width;
	    _height = height;
	    _pixelRatio = pixelRatio;
	    _canvas.width = Math.floor(width * pixelRatio);
	    _canvas.height = Math.floor(height * pixelRatio);
	    this.setViewport(0, 0, width, height);
	  };
	  this.getCurrentViewport = function (target) {
	    if (target === undefined) {
	      console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument");
	      target = new Vector4();
	    }
	    return target.copy(_currentViewport);
	  };
	  this.getViewport = function (target) {
	    return target.copy(_viewport);
	  };
	  this.setViewport = function (x, y, width, height) {
	    if (x.isVector4) {
	      _viewport.set(x.x, x.y, x.z, x.w);
	    } else {
	      _viewport.set(x, y, width, height);
	    }
	    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());
	  };
	  this.getScissor = function (target) {
	    return target.copy(_scissor);
	  };
	  this.setScissor = function (x, y, width, height) {
	    if (x.isVector4) {
	      _scissor.set(x.x, x.y, x.z, x.w);
	    } else {
	      _scissor.set(x, y, width, height);
	    }
	    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());
	  };
	  this.getScissorTest = function () {
	    return _scissorTest;
	  };
	  this.setScissorTest = function (boolean) {
	    state.setScissorTest(_scissorTest = boolean);
	  };
	  this.setOpaqueSort = function (method) {
	    _opaqueSort = method;
	  };
	  this.setTransparentSort = function (method) {
	    _transparentSort = method;
	  };
	  this.getClearColor = function () {
	    return background.getClearColor();
	  };
	  this.setClearColor = function () {
	    background.setClearColor.apply(background, arguments);
	  };
	  this.getClearAlpha = function () {
	    return background.getClearAlpha();
	  };
	  this.setClearAlpha = function () {
	    background.setClearAlpha.apply(background, arguments);
	  };
	  this.clear = function (color, depth, stencil) {
	    var bits = 0;
	    if (color === undefined || color) bits |= 16384;
	    if (depth === undefined || depth) bits |= 256;
	    if (stencil === undefined || stencil) bits |= 1024;
	    _gl.clear(bits);
	  };
	  this.clearColor = function () {
	    this.clear(true, false, false);
	  };
	  this.clearDepth = function () {
	    this.clear(false, true, false);
	  };
	  this.clearStencil = function () {
	    this.clear(false, false, true);
	  };
	  this.dispose = function () {
	    _canvas.removeEventListener("webglcontextlost", onContextLost, false);
	    _canvas.removeEventListener("webglcontextrestored", onContextRestore, false);
	    renderLists.dispose();
	    renderStates.dispose();
	    properties.dispose();
	    objects.dispose();
	    xr.dispose();
	    animation.stop();
	  };
	  function onContextLost(event) {
	    event.preventDefault();
	    console.log("THREE.WebGLRenderer: Context Lost.");
	    _isContextLost = true;
	  }
	  function onContextRestore() {
	    console.log("THREE.WebGLRenderer: Context Restored.");
	    _isContextLost = false;
	    initGLContext();
	  }
	  function onMaterialDispose(event) {
	    var material = event.target;
	    material.removeEventListener("dispose", onMaterialDispose);
	    deallocateMaterial(material);
	  }
	  function deallocateMaterial(material) {
	    releaseMaterialProgramReference(material);
	    properties.remove(material);
	  }
	  function releaseMaterialProgramReference(material) {
	    var programInfo = properties.get(material).program;
	    material.program = undefined;
	    if (programInfo !== undefined) {
	      programCache.releaseProgram(programInfo);
	    }
	  }
	  function renderObjectImmediate(object, program) {
	    object.render(function (object) {
	      _this.renderBufferImmediate(object, program);
	    });
	  }
	  this.renderBufferImmediate = function (object, program) {
	    state.initAttributes();
	    var buffers = properties.get(object);
	    if (object.hasPositions && !buffers.position) buffers.position = _gl.createBuffer();
	    if (object.hasNormals && !buffers.normal) buffers.normal = _gl.createBuffer();
	    if (object.hasUvs && !buffers.uv) buffers.uv = _gl.createBuffer();
	    if (object.hasColors && !buffers.color) buffers.color = _gl.createBuffer();
	    var programAttributes = program.getAttributes();
	    if (object.hasPositions) {
	      _gl.bindBuffer(34962, buffers.position);
	      _gl.bufferData(34962, object.positionArray, 35048);
	      state.enableAttribute(programAttributes.position);
	      _gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);
	    }
	    if (object.hasNormals) {
	      _gl.bindBuffer(34962, buffers.normal);
	      _gl.bufferData(34962, object.normalArray, 35048);
	      state.enableAttribute(programAttributes.normal);
	      _gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);
	    }
	    if (object.hasUvs) {
	      _gl.bindBuffer(34962, buffers.uv);
	      _gl.bufferData(34962, object.uvArray, 35048);
	      state.enableAttribute(programAttributes.uv);
	      _gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);
	    }
	    if (object.hasColors) {
	      _gl.bindBuffer(34962, buffers.color);
	      _gl.bufferData(34962, object.colorArray, 35048);
	      state.enableAttribute(programAttributes.color);
	      _gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);
	    }
	    state.disableUnusedAttributes();
	    _gl.drawArrays(4, 0, object.count);
	    object.count = 0;
	  };
	  var tempScene = new Scene();
	  this.renderBufferDirect = function (camera, scene, geometry, material, object, group) {
	    if (scene === null) scene = tempScene;
	    var frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
	    var program = setProgram(camera, scene, material, object);
	    state.setMaterial(material, frontFaceCW);
	    var updateBuffers = false;
	    if (_currentGeometryProgram.geometry !== geometry.id || _currentGeometryProgram.program !== program.id || _currentGeometryProgram.wireframe !== (material.wireframe === true)) {
	      _currentGeometryProgram.geometry = geometry.id;
	      _currentGeometryProgram.program = program.id;
	      _currentGeometryProgram.wireframe = material.wireframe === true;
	      updateBuffers = true;
	    }
	    if (material.morphTargets || material.morphNormals) {
	      morphtargets.update(object, geometry, material, program);
	      updateBuffers = true;
	    }
	    var index = geometry.index;
	    var position = geometry.attributes.position;
	    if (index === null) {
	      if (position === undefined || position.count === 0) return;
	    } else if (index.count === 0) {
	      return;
	    }
	    var rangeFactor = 1;
	    if (material.wireframe === true) {
	      index = geometries.getWireframeAttribute(geometry);
	      rangeFactor = 2;
	    }
	    var attribute;
	    var renderer = bufferRenderer;
	    if (index !== null) {
	      attribute = attributes.get(index);
	      renderer = indexedBufferRenderer;
	      renderer.setIndex(attribute);
	    }
	    if (updateBuffers) {
	      setupVertexAttributes(object, geometry, material, program);
	      if (index !== null) {
	        _gl.bindBuffer(34963, attribute.buffer);
	      }
	    }
	    var dataCount = index !== null ? index.count : position.count;
	    var rangeStart = geometry.drawRange.start * rangeFactor;
	    var rangeCount = geometry.drawRange.count * rangeFactor;
	    var groupStart = group !== null ? group.start * rangeFactor : 0;
	    var groupCount = group !== null ? group.count * rangeFactor : Infinity;
	    var drawStart = Math.max(rangeStart, groupStart);
	    var drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;
	    var drawCount = Math.max(0, drawEnd - drawStart + 1);
	    if (drawCount === 0) return;
	    if (object.isMesh) {
	      if (material.wireframe === true) {
	        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
	        renderer.setMode(1);
	      } else {
	        renderer.setMode(4);
	      }
	    } else if (object.isLine) {
	      var lineWidth = material.linewidth;
	      if (lineWidth === undefined) lineWidth = 1;
	      state.setLineWidth(lineWidth * getTargetPixelRatio());
	      if (object.isLineSegments) {
	        renderer.setMode(1);
	      } else if (object.isLineLoop) {
	        renderer.setMode(2);
	      } else {
	        renderer.setMode(3);
	      }
	    } else if (object.isPoints) {
	      renderer.setMode(0);
	    } else if (object.isSprite) {
	      renderer.setMode(4);
	    }
	    if (object.isInstancedMesh) {
	      renderer.renderInstances(geometry, drawStart, drawCount, object.count);
	    } else if (geometry.isInstancedBufferGeometry) {
	      renderer.renderInstances(geometry, drawStart, drawCount, geometry.maxInstancedCount);
	    } else {
	      renderer.render(drawStart, drawCount);
	    }
	  };
	  function setupVertexAttributes(object, geometry, material, program) {
	    if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {
	      if (extensions.get("ANGLE_instanced_arrays") === null) return;
	    }
	    state.initAttributes();
	    var geometryAttributes = geometry.attributes;
	    var programAttributes = program.getAttributes();
	    var materialDefaultAttributeValues = material.defaultAttributeValues;
	    for (var name in programAttributes) {
	      var programAttribute = programAttributes[name];
	      if (programAttribute >= 0) {
	        var geometryAttribute = geometryAttributes[name];
	        if (geometryAttribute !== undefined) {
	          var normalized = geometryAttribute.normalized;
	          var size = geometryAttribute.itemSize;
	          var attribute = attributes.get(geometryAttribute);
	          if (attribute === undefined) continue;
	          var buffer = attribute.buffer;
	          var type = attribute.type;
	          var bytesPerElement = attribute.bytesPerElement;
	          if (geometryAttribute.isInterleavedBufferAttribute) {
	            var data = geometryAttribute.data;
	            var stride = data.stride;
	            var offset = geometryAttribute.offset;
	            if (data && data.isInstancedInterleavedBuffer) {
	              state.enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);
	              if (geometry.maxInstancedCount === undefined) {
	                geometry.maxInstancedCount = data.meshPerAttribute * data.count;
	              }
	            } else {
	              state.enableAttribute(programAttribute);
	            }
	            _gl.bindBuffer(34962, buffer);
	            _gl.vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);
	          } else {
	            if (geometryAttribute.isInstancedBufferAttribute) {
	              state.enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);
	              if (geometry.maxInstancedCount === undefined) {
	                geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
	              }
	            } else {
	              state.enableAttribute(programAttribute);
	            }
	            _gl.bindBuffer(34962, buffer);
	            _gl.vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);
	          }
	        } else if (name === "instanceMatrix") {
	          var attribute = attributes.get(object.instanceMatrix);
	          if (attribute === undefined) continue;
	          var buffer = attribute.buffer;
	          var type = attribute.type;
	          state.enableAttributeAndDivisor(programAttribute + 0, 1);
	          state.enableAttributeAndDivisor(programAttribute + 1, 1);
	          state.enableAttributeAndDivisor(programAttribute + 2, 1);
	          state.enableAttributeAndDivisor(programAttribute + 3, 1);
	          _gl.bindBuffer(34962, buffer);
	          _gl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);
	          _gl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);
	          _gl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);
	          _gl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);
	        } else if (materialDefaultAttributeValues !== undefined) {
	          var value = materialDefaultAttributeValues[name];
	          if (value !== undefined) {
	            switch (value.length) {
	              case 2:
	                _gl.vertexAttrib2fv(programAttribute, value);
	                break;
	              case 3:
	                _gl.vertexAttrib3fv(programAttribute, value);
	                break;
	              case 4:
	                _gl.vertexAttrib4fv(programAttribute, value);
	                break;
	              default:
	                _gl.vertexAttrib1fv(programAttribute, value);
	            }
	          }
	        }
	      }
	    }
	    state.disableUnusedAttributes();
	  }
	  this.compile = function (scene, camera) {
	    currentRenderState = renderStates.get(scene, camera);
	    currentRenderState.init();
	    scene.traverse(function (object) {
	      if (object.isLight) {
	        currentRenderState.pushLight(object);
	        if (object.castShadow) {
	          currentRenderState.pushShadow(object);
	        }
	      }
	    });
	    currentRenderState.setupLights(camera);
	    var compiled = {};
	    scene.traverse(function (object) {
	      if (object.material) {
	        if (Array.isArray(object.material)) {
	          for (var i = 0; i < object.material.length; i++) {
	            if ((object.material[i].uuid in compiled) === false) {
	              initMaterial(object.material[i], scene, object);
	              compiled[object.material[i].uuid] = true;
	            }
	          }
	        } else if ((object.material.uuid in compiled) === false) {
	          initMaterial(object.material, scene, object);
	          compiled[object.material.uuid] = true;
	        }
	      }
	    });
	  };
	  var onAnimationFrameCallback = null;
	  function onAnimationFrame(time) {
	    if (xr.isPresenting) return;
	    if (onAnimationFrameCallback) onAnimationFrameCallback(time);
	  }
	  var animation = new WebGLAnimation();
	  animation.setAnimationLoop(onAnimationFrame);
	  if (typeof window !== "undefined") animation.setContext(window);
	  this.setAnimationLoop = function (callback) {
	    onAnimationFrameCallback = callback;
	    xr.setAnimationLoop(callback);
	    animation.start();
	  };
	  this.render = function (scene, camera) {
	    var renderTarget, forceClear;
	    if (arguments[2] !== undefined) {
	      console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.");
	      renderTarget = arguments[2];
	    }
	    if (arguments[3] !== undefined) {
	      console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.");
	      forceClear = arguments[3];
	    }
	    if (!(camera && camera.isCamera)) {
	      console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
	      return;
	    }
	    if (_isContextLost) return;
	    _currentGeometryProgram.geometry = null;
	    _currentGeometryProgram.program = null;
	    _currentGeometryProgram.wireframe = false;
	    _currentMaterialId = -1;
	    _currentCamera = null;
	    if (scene.autoUpdate === true) scene.updateMatrixWorld();
	    if (camera.parent === null) camera.updateMatrixWorld();
	    if (xr.enabled && xr.isPresenting) {
	      camera = xr.getCamera(camera);
	    }
	    currentRenderState = renderStates.get(scene, camera);
	    currentRenderState.init();
	    scene.onBeforeRender(_this, scene, camera, renderTarget || _currentRenderTarget);
	    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
	    _frustum.setFromProjectionMatrix(_projScreenMatrix);
	    _localClippingEnabled = this.localClippingEnabled;
	    _clippingEnabled = _clipping.init(this.clippingPlanes, _localClippingEnabled, camera);
	    currentRenderList = renderLists.get(scene, camera);
	    currentRenderList.init();
	    projectObject(scene, camera, 0, _this.sortObjects);
	    currentRenderList.finish();
	    if (_this.sortObjects === true) {
	      currentRenderList.sort(_opaqueSort, _transparentSort);
	    }
	    if (_clippingEnabled) _clipping.beginShadows();
	    var shadowsArray = currentRenderState.state.shadowsArray;
	    shadowMap.render(shadowsArray, scene, camera);
	    currentRenderState.setupLights(camera);
	    if (_clippingEnabled) _clipping.endShadows();
	    if (this.info.autoReset) this.info.reset();
	    if (renderTarget !== undefined) {
	      this.setRenderTarget(renderTarget);
	    }
	    background.render(currentRenderList, scene, camera, forceClear);
	    var opaqueObjects = currentRenderList.opaque;
	    var transparentObjects = currentRenderList.transparent;
	    if (scene.overrideMaterial) {
	      var overrideMaterial = scene.overrideMaterial;
	      if (opaqueObjects.length) renderObjects(opaqueObjects, scene, camera, overrideMaterial);
	      if (transparentObjects.length) renderObjects(transparentObjects, scene, camera, overrideMaterial);
	    } else {
	      if (opaqueObjects.length) renderObjects(opaqueObjects, scene, camera);
	      if (transparentObjects.length) renderObjects(transparentObjects, scene, camera);
	    }
	    scene.onAfterRender(_this, scene, camera);
	    if (_currentRenderTarget !== null) {
	      textures.updateRenderTargetMipmap(_currentRenderTarget);
	      textures.updateMultisampleRenderTarget(_currentRenderTarget);
	    }
	    state.buffers.depth.setTest(true);
	    state.buffers.depth.setMask(true);
	    state.buffers.color.setMask(true);
	    state.setPolygonOffset(false);
	    currentRenderList = null;
	    currentRenderState = null;
	  };
	  function projectObject(object, camera, groupOrder, sortObjects) {
	    if (object.visible === false) return;
	    var visible = object.layers.test(camera.layers);
	    if (visible) {
	      if (object.isGroup) {
	        groupOrder = object.renderOrder;
	      } else if (object.isLOD) {
	        if (object.autoUpdate === true) object.update(camera);
	      } else if (object.isLight) {
	        currentRenderState.pushLight(object);
	        if (object.castShadow) {
	          currentRenderState.pushShadow(object);
	        }
	      } else if (object.isSprite) {
	        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
	          if (sortObjects) {
	            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
	          }
	          var geometry = objects.update(object);
	          var material = object.material;
	          if (material.visible) {
	            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
	          }
	        }
	      } else if (object.isImmediateRenderObject) {
	        if (sortObjects) {
	          _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
	        }
	        currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);
	      } else if (object.isMesh || object.isLine || object.isPoints) {
	        if (object.isSkinnedMesh) {
	          if (object.skeleton.frame !== info.render.frame) {
	            object.skeleton.update();
	            object.skeleton.frame = info.render.frame;
	          }
	        }
	        if (!object.frustumCulled || _frustum.intersectsObject(object)) {
	          if (sortObjects) {
	            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
	          }
	          var geometry = objects.update(object);
	          var material = object.material;
	          if (Array.isArray(material)) {
	            var groups = geometry.groups;
	            for (var i = 0, l = groups.length; i < l; i++) {
	              var group = groups[i];
	              var groupMaterial = material[group.materialIndex];
	              if (groupMaterial && groupMaterial.visible) {
	                currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);
	              }
	            }
	          } else if (material.visible) {
	            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);
	          }
	        }
	      }
	    }
	    var children = object.children;
	    for (var i = 0, l = children.length; i < l; i++) {
	      projectObject(children[i], camera, groupOrder, sortObjects);
	    }
	  }
	  function renderObjects(renderList, scene, camera, overrideMaterial) {
	    for (var i = 0, l = renderList.length; i < l; i++) {
	      var renderItem = renderList[i];
	      var object = renderItem.object;
	      var geometry = renderItem.geometry;
	      var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
	      var group = renderItem.group;
	      if (camera.isArrayCamera) {
	        _currentArrayCamera = camera;
	        var cameras = camera.cameras;
	        for (var j = 0, jl = cameras.length; j < jl; j++) {
	          var camera2 = cameras[j];
	          if (object.layers.test(camera2.layers)) {
	            state.viewport(_currentViewport.copy(camera2.viewport));
	            currentRenderState.setupLights(camera2);
	            renderObject(object, scene, camera2, geometry, material, group);
	          }
	        }
	      } else {
	        _currentArrayCamera = null;
	        renderObject(object, scene, camera, geometry, material, group);
	      }
	    }
	  }
	  function renderObject(object, scene, camera, geometry, material, group) {
	    object.onBeforeRender(_this, scene, camera, geometry, material, group);
	    currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
	    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
	    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
	    if (object.isImmediateRenderObject) {
	      var program = setProgram(camera, scene, material, object);
	      state.setMaterial(material);
	      _currentGeometryProgram.geometry = null;
	      _currentGeometryProgram.program = null;
	      _currentGeometryProgram.wireframe = false;
	      renderObjectImmediate(object, program);
	    } else {
	      _this.renderBufferDirect(camera, scene, geometry, material, object, group);
	    }
	    object.onAfterRender(_this, scene, camera, geometry, material, group);
	    currentRenderState = renderStates.get(scene, _currentArrayCamera || camera);
	  }
	  function initMaterial(material, scene, object) {
	    var materialProperties = properties.get(material);
	    var lights = currentRenderState.state.lights;
	    var shadowsArray = currentRenderState.state.shadowsArray;
	    var lightsStateVersion = lights.state.version;
	    var parameters = programCache.getParameters(material, lights.state, shadowsArray, scene, _clipping.numPlanes, _clipping.numIntersection, object);
	    var programCacheKey = programCache.getProgramCacheKey(parameters);
	    var program = materialProperties.program;
	    var programChange = true;
	    if (program === undefined) {
	      material.addEventListener("dispose", onMaterialDispose);
	    } else if (program.cacheKey !== programCacheKey) {
	      releaseMaterialProgramReference(material);
	    } else if (materialProperties.lightsStateVersion !== lightsStateVersion) {
	      materialProperties.lightsStateVersion = lightsStateVersion;
	      programChange = false;
	    } else if (parameters.shaderID !== undefined) {
	      return;
	    } else {
	      programChange = false;
	    }
	    if (programChange) {
	      program = programCache.acquireProgram(parameters, programCacheKey);
	      materialProperties.program = program;
	      materialProperties.uniforms = parameters.uniforms;
	      materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
	      materialProperties.outputEncoding = _this.outputEncoding;
	      material.program = program;
	    }
	    var programAttributes = program.getAttributes();
	    if (material.morphTargets) {
	      material.numSupportedMorphTargets = 0;
	      for (var i = 0; i < _this.maxMorphTargets; i++) {
	        if (programAttributes["morphTarget" + i] >= 0) {
	          material.numSupportedMorphTargets++;
	        }
	      }
	    }
	    if (material.morphNormals) {
	      material.numSupportedMorphNormals = 0;
	      for (var i = 0; i < _this.maxMorphNormals; i++) {
	        if (programAttributes["morphNormal" + i] >= 0) {
	          material.numSupportedMorphNormals++;
	        }
	      }
	    }
	    var uniforms = materialProperties.uniforms;
	    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
	      materialProperties.numClippingPlanes = _clipping.numPlanes;
	      materialProperties.numIntersection = _clipping.numIntersection;
	      uniforms.clippingPlanes = _clipping.uniform;
	    }
	    materialProperties.fog = scene.fog;
	    materialProperties.needsLights = materialNeedsLights(material);
	    materialProperties.lightsStateVersion = lightsStateVersion;
	    if (materialProperties.needsLights) {
	      uniforms.ambientLightColor.value = lights.state.ambient;
	      uniforms.lightProbe.value = lights.state.probe;
	      uniforms.directionalLights.value = lights.state.directional;
	      uniforms.directionalLightShadows.value = lights.state.directionalShadow;
	      uniforms.spotLights.value = lights.state.spot;
	      uniforms.spotLightShadows.value = lights.state.spotShadow;
	      uniforms.rectAreaLights.value = lights.state.rectArea;
	      uniforms.pointLights.value = lights.state.point;
	      uniforms.pointLightShadows.value = lights.state.pointShadow;
	      uniforms.hemisphereLights.value = lights.state.hemi;
	      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
	      uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
	      uniforms.spotShadowMap.value = lights.state.spotShadowMap;
	      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
	      uniforms.pointShadowMap.value = lights.state.pointShadowMap;
	      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
	    }
	    var progUniforms = materialProperties.program.getUniforms(), uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);
	    materialProperties.uniformsList = uniformsList;
	  }
	  function setProgram(camera, scene, material, object) {
	    textures.resetTextureUnits();
	    var fog = scene.fog;
	    var environment = material.isMeshStandardMaterial ? scene.environment : null;
	    var materialProperties = properties.get(material);
	    var lights = currentRenderState.state.lights;
	    if (_clippingEnabled) {
	      if (_localClippingEnabled || camera !== _currentCamera) {
	        var useCache = camera === _currentCamera && material.id === _currentMaterialId;
	        _clipping.setState(material.clippingPlanes, material.clipIntersection, material.clipShadows, camera, materialProperties, useCache);
	      }
	    }
	    if (material.version === materialProperties.__version) {
	      if (materialProperties.program === undefined) {
	        initMaterial(material, scene, object);
	      } else if (material.fog && materialProperties.fog !== fog) {
	        initMaterial(material, scene, object);
	      } else if (materialProperties.environment !== environment) {
	        initMaterial(material, scene, object);
	      } else if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
	        initMaterial(material, scene, object);
	      } else if (materialProperties.numClippingPlanes !== undefined && (materialProperties.numClippingPlanes !== _clipping.numPlanes || materialProperties.numIntersection !== _clipping.numIntersection)) {
	        initMaterial(material, scene, object);
	      } else if (materialProperties.outputEncoding !== _this.outputEncoding) {
	        initMaterial(material, scene, object);
	      }
	    } else {
	      initMaterial(material, scene, object);
	      materialProperties.__version = material.version;
	    }
	    var refreshProgram = false;
	    var refreshMaterial = false;
	    var refreshLights = false;
	    var program = materialProperties.program, p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
	    if (state.useProgram(program.program)) {
	      refreshProgram = true;
	      refreshMaterial = true;
	      refreshLights = true;
	    }
	    if (material.id !== _currentMaterialId) {
	      _currentMaterialId = material.id;
	      refreshMaterial = true;
	    }
	    if (refreshProgram || _currentCamera !== camera) {
	      p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
	      if (capabilities.logarithmicDepthBuffer) {
	        p_uniforms.setValue(_gl, "logDepthBufFC", 2 / (Math.log(camera.far + 1) / Math.LN2));
	      }
	      if (_currentCamera !== camera) {
	        _currentCamera = camera;
	        refreshMaterial = true;
	        refreshLights = true;
	      }
	      if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {
	        var uCamPos = p_uniforms.map.cameraPosition;
	        if (uCamPos !== undefined) {
	          uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));
	        }
	      }
	      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
	        p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
	      }
	      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.skinning) {
	        p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
	      }
	    }
	    if (material.skinning) {
	      p_uniforms.setOptional(_gl, object, "bindMatrix");
	      p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
	      var skeleton = object.skeleton;
	      if (skeleton) {
	        var bones = skeleton.bones;
	        if (capabilities.floatVertexTextures) {
	          if (skeleton.boneTexture === undefined) {
	            var size = Math.sqrt(bones.length * 4);
	            size = MathUtils.ceilPowerOfTwo(size);
	            size = Math.max(size, 4);
	            var boneMatrices = new Float32Array(size * size * 4);
	            boneMatrices.set(skeleton.boneMatrices);
	            var boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
	            skeleton.boneMatrices = boneMatrices;
	            skeleton.boneTexture = boneTexture;
	            skeleton.boneTextureSize = size;
	          }
	          p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
	          p_uniforms.setValue(_gl, "boneTextureSize", skeleton.boneTextureSize);
	        } else {
	          p_uniforms.setOptional(_gl, skeleton, "boneMatrices");
	        }
	      }
	    }
	    if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
	      materialProperties.receiveShadow = object.receiveShadow;
	      p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
	    }
	    if (refreshMaterial) {
	      p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
	      p_uniforms.setValue(_gl, "toneMappingWhitePoint", _this.toneMappingWhitePoint);
	      if (materialProperties.needsLights) {
	        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
	      }
	      if (fog && material.fog) {
	        refreshUniformsFog(m_uniforms, fog);
	      }
	      if (material.isMeshBasicMaterial) {
	        refreshUniformsCommon(m_uniforms, material);
	      } else if (material.isMeshLambertMaterial) {
	        refreshUniformsCommon(m_uniforms, material);
	        refreshUniformsLambert(m_uniforms, material);
	      } else if (material.isMeshToonMaterial) {
	        refreshUniformsCommon(m_uniforms, material);
	        refreshUniformsToon(m_uniforms, material);
	      } else if (material.isMeshPhongMaterial) {
	        refreshUniformsCommon(m_uniforms, material);
	        refreshUniformsPhong(m_uniforms, material);
	      } else if (material.isMeshStandardMaterial) {
	        refreshUniformsCommon(m_uniforms, material, environment);
	        if (material.isMeshPhysicalMaterial) {
	          refreshUniformsPhysical(m_uniforms, material, environment);
	        } else {
	          refreshUniformsStandard(m_uniforms, material, environment);
	        }
	      } else if (material.isMeshMatcapMaterial) {
	        refreshUniformsCommon(m_uniforms, material);
	        refreshUniformsMatcap(m_uniforms, material);
	      } else if (material.isMeshDepthMaterial) {
	        refreshUniformsCommon(m_uniforms, material);
	        refreshUniformsDepth(m_uniforms, material);
	      } else if (material.isMeshDistanceMaterial) {
	        refreshUniformsCommon(m_uniforms, material);
	        refreshUniformsDistance(m_uniforms, material);
	      } else if (material.isMeshNormalMaterial) {
	        refreshUniformsCommon(m_uniforms, material);
	        refreshUniformsNormal(m_uniforms, material);
	      } else if (material.isLineBasicMaterial) {
	        refreshUniformsLine(m_uniforms, material);
	        if (material.isLineDashedMaterial) {
	          refreshUniformsDash(m_uniforms, material);
	        }
	      } else if (material.isPointsMaterial) {
	        refreshUniformsPoints(m_uniforms, material);
	      } else if (material.isSpriteMaterial) {
	        refreshUniformsSprites(m_uniforms, material);
	      } else if (material.isShadowMaterial) {
	        m_uniforms.color.value.copy(material.color);
	        m_uniforms.opacity.value = material.opacity;
	      }
	      if (m_uniforms.ltc_1 !== undefined) m_uniforms.ltc_1.value = UniformsLib.LTC_1;
	      if (m_uniforms.ltc_2 !== undefined) m_uniforms.ltc_2.value = UniformsLib.LTC_2;
	      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
	      if (material.isShaderMaterial) {
	        material.uniformsNeedUpdate = false;
	      }
	    }
	    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
	      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);
	      material.uniformsNeedUpdate = false;
	    }
	    if (material.isSpriteMaterial) {
	      p_uniforms.setValue(_gl, "center", object.center);
	    }
	    p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
	    p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
	    p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
	    return program;
	  }
	  function refreshUniformsCommon(uniforms, material, environment) {
	    uniforms.opacity.value = material.opacity;
	    if (material.color) {
	      uniforms.diffuse.value.copy(material.color);
	    }
	    if (material.emissive) {
	      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
	    }
	    if (material.map) {
	      uniforms.map.value = material.map;
	    }
	    if (material.alphaMap) {
	      uniforms.alphaMap.value = material.alphaMap;
	    }
	    if (material.specularMap) {
	      uniforms.specularMap.value = material.specularMap;
	    }
	    var envMap = material.envMap || environment;
	    if (envMap) {
	      uniforms.envMap.value = envMap;
	      uniforms.flipEnvMap.value = envMap.isCubeTexture ? -1 : 1;
	      uniforms.reflectivity.value = material.reflectivity;
	      uniforms.refractionRatio.value = material.refractionRatio;
	      uniforms.maxMipLevel.value = properties.get(envMap).__maxMipLevel;
	    }
	    if (material.lightMap) {
	      uniforms.lightMap.value = material.lightMap;
	      uniforms.lightMapIntensity.value = material.lightMapIntensity;
	    }
	    if (material.aoMap) {
	      uniforms.aoMap.value = material.aoMap;
	      uniforms.aoMapIntensity.value = material.aoMapIntensity;
	    }
	    var uvScaleMap;
	    if (material.map) {
	      uvScaleMap = material.map;
	    } else if (material.specularMap) {
	      uvScaleMap = material.specularMap;
	    } else if (material.displacementMap) {
	      uvScaleMap = material.displacementMap;
	    } else if (material.normalMap) {
	      uvScaleMap = material.normalMap;
	    } else if (material.bumpMap) {
	      uvScaleMap = material.bumpMap;
	    } else if (material.roughnessMap) {
	      uvScaleMap = material.roughnessMap;
	    } else if (material.metalnessMap) {
	      uvScaleMap = material.metalnessMap;
	    } else if (material.alphaMap) {
	      uvScaleMap = material.alphaMap;
	    } else if (material.emissiveMap) {
	      uvScaleMap = material.emissiveMap;
	    }
	    if (uvScaleMap !== undefined) {
	      if (uvScaleMap.isWebGLRenderTarget) {
	        uvScaleMap = uvScaleMap.texture;
	      }
	      if (uvScaleMap.matrixAutoUpdate === true) {
	        uvScaleMap.updateMatrix();
	      }
	      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
	    }
	    var uv2ScaleMap;
	    if (material.aoMap) {
	      uv2ScaleMap = material.aoMap;
	    } else if (material.lightMap) {
	      uv2ScaleMap = material.lightMap;
	    }
	    if (uv2ScaleMap !== undefined) {
	      if (uv2ScaleMap.isWebGLRenderTarget) {
	        uv2ScaleMap = uv2ScaleMap.texture;
	      }
	      if (uv2ScaleMap.matrixAutoUpdate === true) {
	        uv2ScaleMap.updateMatrix();
	      }
	      uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);
	    }
	  }
	  function refreshUniformsLine(uniforms, material) {
	    uniforms.diffuse.value.copy(material.color);
	    uniforms.opacity.value = material.opacity;
	  }
	  function refreshUniformsDash(uniforms, material) {
	    uniforms.dashSize.value = material.dashSize;
	    uniforms.totalSize.value = material.dashSize + material.gapSize;
	    uniforms.scale.value = material.scale;
	  }
	  function refreshUniformsPoints(uniforms, material) {
	    uniforms.diffuse.value.copy(material.color);
	    uniforms.opacity.value = material.opacity;
	    uniforms.size.value = material.size * _pixelRatio;
	    uniforms.scale.value = _height * 0.5;
	    if (material.map) {
	      uniforms.map.value = material.map;
	    }
	    if (material.alphaMap) {
	      uniforms.alphaMap.value = material.alphaMap;
	    }
	    var uvScaleMap;
	    if (material.map) {
	      uvScaleMap = material.map;
	    } else if (material.alphaMap) {
	      uvScaleMap = material.alphaMap;
	    }
	    if (uvScaleMap !== undefined) {
	      if (uvScaleMap.matrixAutoUpdate === true) {
	        uvScaleMap.updateMatrix();
	      }
	      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
	    }
	  }
	  function refreshUniformsSprites(uniforms, material) {
	    uniforms.diffuse.value.copy(material.color);
	    uniforms.opacity.value = material.opacity;
	    uniforms.rotation.value = material.rotation;
	    if (material.map) {
	      uniforms.map.value = material.map;
	    }
	    if (material.alphaMap) {
	      uniforms.alphaMap.value = material.alphaMap;
	    }
	    var uvScaleMap;
	    if (material.map) {
	      uvScaleMap = material.map;
	    } else if (material.alphaMap) {
	      uvScaleMap = material.alphaMap;
	    }
	    if (uvScaleMap !== undefined) {
	      if (uvScaleMap.matrixAutoUpdate === true) {
	        uvScaleMap.updateMatrix();
	      }
	      uniforms.uvTransform.value.copy(uvScaleMap.matrix);
	    }
	  }
	  function refreshUniformsFog(uniforms, fog) {
	    uniforms.fogColor.value.copy(fog.color);
	    if (fog.isFog) {
	      uniforms.fogNear.value = fog.near;
	      uniforms.fogFar.value = fog.far;
	    } else if (fog.isFogExp2) {
	      uniforms.fogDensity.value = fog.density;
	    }
	  }
	  function refreshUniformsLambert(uniforms, material) {
	    if (material.emissiveMap) {
	      uniforms.emissiveMap.value = material.emissiveMap;
	    }
	  }
	  function refreshUniformsPhong(uniforms, material) {
	    uniforms.specular.value.copy(material.specular);
	    uniforms.shininess.value = Math.max(material.shininess, 0.0001);
	    if (material.emissiveMap) {
	      uniforms.emissiveMap.value = material.emissiveMap;
	    }
	    if (material.bumpMap) {
	      uniforms.bumpMap.value = material.bumpMap;
	      uniforms.bumpScale.value = material.bumpScale;
	      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
	    }
	    if (material.normalMap) {
	      uniforms.normalMap.value = material.normalMap;
	      uniforms.normalScale.value.copy(material.normalScale);
	      if (material.side === BackSide) uniforms.normalScale.value.negate();
	    }
	    if (material.displacementMap) {
	      uniforms.displacementMap.value = material.displacementMap;
	      uniforms.displacementScale.value = material.displacementScale;
	      uniforms.displacementBias.value = material.displacementBias;
	    }
	  }
	  function refreshUniformsToon(uniforms, material) {
	    uniforms.specular.value.copy(material.specular);
	    uniforms.shininess.value = Math.max(material.shininess, 0.0001);
	    if (material.gradientMap) {
	      uniforms.gradientMap.value = material.gradientMap;
	    }
	    if (material.emissiveMap) {
	      uniforms.emissiveMap.value = material.emissiveMap;
	    }
	    if (material.bumpMap) {
	      uniforms.bumpMap.value = material.bumpMap;
	      uniforms.bumpScale.value = material.bumpScale;
	      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
	    }
	    if (material.normalMap) {
	      uniforms.normalMap.value = material.normalMap;
	      uniforms.normalScale.value.copy(material.normalScale);
	      if (material.side === BackSide) uniforms.normalScale.value.negate();
	    }
	    if (material.displacementMap) {
	      uniforms.displacementMap.value = material.displacementMap;
	      uniforms.displacementScale.value = material.displacementScale;
	      uniforms.displacementBias.value = material.displacementBias;
	    }
	  }
	  function refreshUniformsStandard(uniforms, material, environment) {
	    uniforms.roughness.value = material.roughness;
	    uniforms.metalness.value = material.metalness;
	    if (material.roughnessMap) {
	      uniforms.roughnessMap.value = material.roughnessMap;
	    }
	    if (material.metalnessMap) {
	      uniforms.metalnessMap.value = material.metalnessMap;
	    }
	    if (material.emissiveMap) {
	      uniforms.emissiveMap.value = material.emissiveMap;
	    }
	    if (material.bumpMap) {
	      uniforms.bumpMap.value = material.bumpMap;
	      uniforms.bumpScale.value = material.bumpScale;
	      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
	    }
	    if (material.normalMap) {
	      uniforms.normalMap.value = material.normalMap;
	      uniforms.normalScale.value.copy(material.normalScale);
	      if (material.side === BackSide) uniforms.normalScale.value.negate();
	    }
	    if (material.displacementMap) {
	      uniforms.displacementMap.value = material.displacementMap;
	      uniforms.displacementScale.value = material.displacementScale;
	      uniforms.displacementBias.value = material.displacementBias;
	    }
	    if (material.envMap || environment) {
	      uniforms.envMapIntensity.value = material.envMapIntensity;
	    }
	  }
	  function refreshUniformsPhysical(uniforms, material, environment) {
	    refreshUniformsStandard(uniforms, material, environment);
	    uniforms.reflectivity.value = material.reflectivity;
	    uniforms.clearcoat.value = material.clearcoat;
	    uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
	    if (material.sheen) uniforms.sheen.value.copy(material.sheen);
	    if (material.clearcoatNormalMap) {
	      uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
	      uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
	      if (material.side === BackSide) {
	        uniforms.clearcoatNormalScale.value.negate();
	      }
	    }
	    uniforms.transparency.value = material.transparency;
	  }
	  function refreshUniformsMatcap(uniforms, material) {
	    if (material.matcap) {
	      uniforms.matcap.value = material.matcap;
	    }
	    if (material.bumpMap) {
	      uniforms.bumpMap.value = material.bumpMap;
	      uniforms.bumpScale.value = material.bumpScale;
	      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
	    }
	    if (material.normalMap) {
	      uniforms.normalMap.value = material.normalMap;
	      uniforms.normalScale.value.copy(material.normalScale);
	      if (material.side === BackSide) uniforms.normalScale.value.negate();
	    }
	    if (material.displacementMap) {
	      uniforms.displacementMap.value = material.displacementMap;
	      uniforms.displacementScale.value = material.displacementScale;
	      uniforms.displacementBias.value = material.displacementBias;
	    }
	  }
	  function refreshUniformsDepth(uniforms, material) {
	    if (material.displacementMap) {
	      uniforms.displacementMap.value = material.displacementMap;
	      uniforms.displacementScale.value = material.displacementScale;
	      uniforms.displacementBias.value = material.displacementBias;
	    }
	  }
	  function refreshUniformsDistance(uniforms, material) {
	    if (material.displacementMap) {
	      uniforms.displacementMap.value = material.displacementMap;
	      uniforms.displacementScale.value = material.displacementScale;
	      uniforms.displacementBias.value = material.displacementBias;
	    }
	    uniforms.referencePosition.value.copy(material.referencePosition);
	    uniforms.nearDistance.value = material.nearDistance;
	    uniforms.farDistance.value = material.farDistance;
	  }
	  function refreshUniformsNormal(uniforms, material) {
	    if (material.bumpMap) {
	      uniforms.bumpMap.value = material.bumpMap;
	      uniforms.bumpScale.value = material.bumpScale;
	      if (material.side === BackSide) uniforms.bumpScale.value *= -1;
	    }
	    if (material.normalMap) {
	      uniforms.normalMap.value = material.normalMap;
	      uniforms.normalScale.value.copy(material.normalScale);
	      if (material.side === BackSide) uniforms.normalScale.value.negate();
	    }
	    if (material.displacementMap) {
	      uniforms.displacementMap.value = material.displacementMap;
	      uniforms.displacementScale.value = material.displacementScale;
	      uniforms.displacementBias.value = material.displacementBias;
	    }
	  }
	  function markUniformsLightsNeedsUpdate(uniforms, value) {
	    uniforms.ambientLightColor.needsUpdate = value;
	    uniforms.lightProbe.needsUpdate = value;
	    uniforms.directionalLights.needsUpdate = value;
	    uniforms.directionalLightShadows.needsUpdate = value;
	    uniforms.pointLights.needsUpdate = value;
	    uniforms.pointLightShadows.needsUpdate = value;
	    uniforms.spotLights.needsUpdate = value;
	    uniforms.spotLightShadows.needsUpdate = value;
	    uniforms.rectAreaLights.needsUpdate = value;
	    uniforms.hemisphereLights.needsUpdate = value;
	  }
	  function materialNeedsLights(material) {
	    return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
	  }
	  this.setFramebuffer = function (value) {
	    if (_framebuffer !== value && _currentRenderTarget === null) _gl.bindFramebuffer(36160, value);
	    _framebuffer = value;
	  };
	  this.getActiveCubeFace = function () {
	    return _currentActiveCubeFace;
	  };
	  this.getActiveMipmapLevel = function () {
	    return _currentActiveMipmapLevel;
	  };
	  this.getRenderTarget = function () {
	    return _currentRenderTarget;
	  };
	  this.setRenderTarget = function (renderTarget, activeCubeFace, activeMipmapLevel) {
	    _currentRenderTarget = renderTarget;
	    _currentActiveCubeFace = activeCubeFace;
	    _currentActiveMipmapLevel = activeMipmapLevel;
	    if (renderTarget && properties.get(renderTarget).__webglFramebuffer === undefined) {
	      textures.setupRenderTarget(renderTarget);
	    }
	    var framebuffer = _framebuffer;
	    var isCube = false;
	    if (renderTarget) {
	      var __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
	      if (renderTarget.isWebGLCubeRenderTarget) {
	        framebuffer = __webglFramebuffer[activeCubeFace || 0];
	        isCube = true;
	      } else if (renderTarget.isWebGLMultisampleRenderTarget) {
	        framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
	      } else {
	        framebuffer = __webglFramebuffer;
	      }
	      _currentViewport.copy(renderTarget.viewport);
	      _currentScissor.copy(renderTarget.scissor);
	      _currentScissorTest = renderTarget.scissorTest;
	    } else {
	      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
	      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
	      _currentScissorTest = _scissorTest;
	    }
	    if (_currentFramebuffer !== framebuffer) {
	      _gl.bindFramebuffer(36160, framebuffer);
	      _currentFramebuffer = framebuffer;
	    }
	    state.viewport(_currentViewport);
	    state.scissor(_currentScissor);
	    state.setScissorTest(_currentScissorTest);
	    if (isCube) {
	      var textureProperties = properties.get(renderTarget.texture);
	      _gl.framebufferTexture2D(36160, 36064, 34069 + (activeCubeFace || 0), textureProperties.__webglTexture, activeMipmapLevel || 0);
	    }
	  };
	  this.readRenderTargetPixels = function (renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {
	    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
	      console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
	      return;
	    }
	    var framebuffer = properties.get(renderTarget).__webglFramebuffer;
	    if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined) {
	      framebuffer = framebuffer[activeCubeFaceIndex];
	    }
	    if (framebuffer) {
	      var restore = false;
	      if (framebuffer !== _currentFramebuffer) {
	        _gl.bindFramebuffer(36160, framebuffer);
	        restore = true;
	      }
	      try {
	        var texture = renderTarget.texture;
	        var textureFormat = texture.format;
	        var textureType = texture.type;
	        if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {
	          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
	          return;
	        }
	        if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.get("OES_texture_float") || extensions.get("WEBGL_color_buffer_float"))) && !(textureType === HalfFloatType && (capabilities.isWebGL2 ? extensions.get("EXT_color_buffer_float") : extensions.get("EXT_color_buffer_half_float")))) {
	          console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
	          return;
	        }
	        if (_gl.checkFramebufferStatus(36160) === 36053) {
	          if (x >= 0 && x <= renderTarget.width - width && (y >= 0 && y <= renderTarget.height - height)) {
	            _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
	          }
	        } else {
	          console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.");
	        }
	      } finally {
	        if (restore) {
	          _gl.bindFramebuffer(36160, _currentFramebuffer);
	        }
	      }
	    }
	  };
	  this.copyFramebufferToTexture = function (position, texture, level) {
	    if (level === undefined) level = 0;
	    var levelScale = Math.pow(2, -level);
	    var width = Math.floor(texture.image.width * levelScale);
	    var height = Math.floor(texture.image.height * levelScale);
	    var glFormat = utils.convert(texture.format);
	    textures.setTexture2D(texture, 0);
	    _gl.copyTexImage2D(3553, level, glFormat, position.x, position.y, width, height, 0);
	    state.unbindTexture();
	  };
	  this.copyTextureToTexture = function (position, srcTexture, dstTexture, level) {
	    var width = srcTexture.image.width;
	    var height = srcTexture.image.height;
	    var glFormat = utils.convert(dstTexture.format);
	    var glType = utils.convert(dstTexture.type);
	    textures.setTexture2D(dstTexture, 0);
	    if (srcTexture.isDataTexture) {
	      _gl.texSubImage2D(3553, level || 0, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);
	    } else {
	      _gl.texSubImage2D(3553, level || 0, position.x, position.y, glFormat, glType, srcTexture.image);
	    }
	    state.unbindTexture();
	  };
	  this.initTexture = function (texture) {
	    textures.setTexture2D(texture, 0);
	    state.unbindTexture();
	  };
	  if (typeof __THREE_DEVTOOLS__ !== "undefined") {
	    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
	      detail: this
	    }));
	  }
	}
	function FogExp2(color, density) {
	  this.name = "";
	  this.color = new Color(color);
	  this.density = density !== undefined ? density : 0.00025;
	}
	Object.assign(FogExp2.prototype, {
	  isFogExp2: true,
	  clone: function () {
	    return new FogExp2(this.color, this.density);
	  },
	  toJSON: function () {
	    return {
	      type: "FogExp2",
	      color: this.color.getHex(),
	      density: this.density
	    };
	  }
	});
	function Fog(color, near, far) {
	  this.name = "";
	  this.color = new Color(color);
	  this.near = near !== undefined ? near : 1;
	  this.far = far !== undefined ? far : 1000;
	}
	Object.assign(Fog.prototype, {
	  isFog: true,
	  clone: function () {
	    return new Fog(this.color, this.near, this.far);
	  },
	  toJSON: function () {
	    return {
	      type: "Fog",
	      color: this.color.getHex(),
	      near: this.near,
	      far: this.far
	    };
	  }
	});
	function InterleavedBuffer(array, stride) {
	  this.array = array;
	  this.stride = stride;
	  this.count = array !== undefined ? array.length / stride : 0;
	  this.usage = StaticDrawUsage;
	  this.updateRange = {
	    offset: 0,
	    count: -1
	  };
	  this.version = 0;
	}
	Object.defineProperty(InterleavedBuffer.prototype, "needsUpdate", {
	  set: function (value) {
	    if (value === true) this.version++;
	  }
	});
	Object.assign(InterleavedBuffer.prototype, {
	  isInterleavedBuffer: true,
	  onUploadCallback: function () {},
	  setUsage: function (value) {
	    this.usage = value;
	    return this;
	  },
	  copy: function (source) {
	    this.array = new source.array.constructor(source.array);
	    this.count = source.count;
	    this.stride = source.stride;
	    this.usage = source.usage;
	    return this;
	  },
	  copyAt: function (index1, attribute, index2) {
	    index1 *= this.stride;
	    index2 *= attribute.stride;
	    for (var i = 0, l = this.stride; i < l; i++) {
	      this.array[index1 + i] = attribute.array[index2 + i];
	    }
	    return this;
	  },
	  set: function (value, offset) {
	    if (offset === undefined) offset = 0;
	    this.array.set(value, offset);
	    return this;
	  },
	  clone: function () {
	    return new this.constructor().copy(this);
	  },
	  onUpload: function (callback) {
	    this.onUploadCallback = callback;
	    return this;
	  }
	});
	var _vector$6 = new Vector3();
	function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, normalized) {
	  this.data = interleavedBuffer;
	  this.itemSize = itemSize;
	  this.offset = offset;
	  this.normalized = normalized === true;
	}
	Object.defineProperties(InterleavedBufferAttribute.prototype, {
	  count: {
	    get: function () {
	      return this.data.count;
	    }
	  },
	  array: {
	    get: function () {
	      return this.data.array;
	    }
	  }
	});
	Object.assign(InterleavedBufferAttribute.prototype, {
	  isInterleavedBufferAttribute: true,
	  applyMatrix4: function (m) {
	    for (var i = 0, l = this.data.count; i < l; i++) {
	      _vector$6.x = this.getX(i);
	      _vector$6.y = this.getY(i);
	      _vector$6.z = this.getZ(i);
	      _vector$6.applyMatrix4(m);
	      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);
	    }
	    return this;
	  },
	  setX: function (index, x) {
	    this.data.array[index * this.data.stride + this.offset] = x;
	    return this;
	  },
	  setY: function (index, y) {
	    this.data.array[index * this.data.stride + this.offset + 1] = y;
	    return this;
	  },
	  setZ: function (index, z) {
	    this.data.array[index * this.data.stride + this.offset + 2] = z;
	    return this;
	  },
	  setW: function (index, w) {
	    this.data.array[index * this.data.stride + this.offset + 3] = w;
	    return this;
	  },
	  getX: function (index) {
	    return this.data.array[index * this.data.stride + this.offset];
	  },
	  getY: function (index) {
	    return this.data.array[index * this.data.stride + this.offset + 1];
	  },
	  getZ: function (index) {
	    return this.data.array[index * this.data.stride + this.offset + 2];
	  },
	  getW: function (index) {
	    return this.data.array[index * this.data.stride + this.offset + 3];
	  },
	  setXY: function (index, x, y) {
	    index = index * this.data.stride + this.offset;
	    this.data.array[index + 0] = x;
	    this.data.array[index + 1] = y;
	    return this;
	  },
	  setXYZ: function (index, x, y, z) {
	    index = index * this.data.stride + this.offset;
	    this.data.array[index + 0] = x;
	    this.data.array[index + 1] = y;
	    this.data.array[index + 2] = z;
	    return this;
	  },
	  setXYZW: function (index, x, y, z, w) {
	    index = index * this.data.stride + this.offset;
	    this.data.array[index + 0] = x;
	    this.data.array[index + 1] = y;
	    this.data.array[index + 2] = z;
	    this.data.array[index + 3] = w;
	    return this;
	  }
	});
	function SpriteMaterial(parameters) {
	  Material.call(this);
	  this.type = "SpriteMaterial";
	  this.color = new Color(16777215);
	  this.map = null;
	  this.alphaMap = null;
	  this.rotation = 0;
	  this.sizeAttenuation = true;
	  this.transparent = true;
	  this.setValues(parameters);
	}
	SpriteMaterial.prototype = Object.create(Material.prototype);
	SpriteMaterial.prototype.constructor = SpriteMaterial;
	SpriteMaterial.prototype.isSpriteMaterial = true;
	SpriteMaterial.prototype.copy = function (source) {
	  Material.prototype.copy.call(this, source);
	  this.color.copy(source.color);
	  this.map = source.map;
	  this.alphaMap = source.alphaMap;
	  this.rotation = source.rotation;
	  this.sizeAttenuation = source.sizeAttenuation;
	  return this;
	};
	var _geometry;
	var _intersectPoint = new Vector3();
	var _worldScale = new Vector3();
	var _mvPosition = new Vector3();
	var _alignedPosition = new Vector2();
	var _rotatedPosition = new Vector2();
	var _viewWorldMatrix = new Matrix4();
	var _vA$1 = new Vector3();
	var _vB$1 = new Vector3();
	var _vC$1 = new Vector3();
	var _uvA$1 = new Vector2();
	var _uvB$1 = new Vector2();
	var _uvC$1 = new Vector2();
	function Sprite(material) {
	  Object3D.call(this);
	  this.type = "Sprite";
	  if (_geometry === undefined) {
	    _geometry = new BufferGeometry();
	    var float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);
	    var interleavedBuffer = new InterleavedBuffer(float32Array, 5);
	    _geometry.setIndex([0, 1, 2, 0, 2, 3]);
	    _geometry.setAttribute("position", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
	    _geometry.setAttribute("uv", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
	  }
	  this.geometry = _geometry;
	  this.material = material !== undefined ? material : new SpriteMaterial();
	  this.center = new Vector2(0.5, 0.5);
	}
	Sprite.prototype = Object.assign(Object.create(Object3D.prototype), {
	  constructor: Sprite,
	  isSprite: true,
	  raycast: function (raycaster, intersects) {
	    if (raycaster.camera === null) {
	      console.error("THREE.Sprite: \"Raycaster.camera\" needs to be set in order to raycast against sprites.");
	    }
	    _worldScale.setFromMatrixScale(this.matrixWorld);
	    _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
	    this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
	    _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
	    if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
	      _worldScale.multiplyScalar(-_mvPosition.z);
	    }
	    var rotation = this.material.rotation;
	    var sin, cos;
	    if (rotation !== 0) {
	      cos = Math.cos(rotation);
	      sin = Math.sin(rotation);
	    }
	    var center = this.center;
	    transformVertex(_vA$1.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
	    transformVertex(_vB$1.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
	    transformVertex(_vC$1.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
	    _uvA$1.set(0, 0);
	    _uvB$1.set(1, 0);
	    _uvC$1.set(1, 1);
	    var intersect = raycaster.ray.intersectTriangle(_vA$1, _vB$1, _vC$1, false, _intersectPoint);
	    if (intersect === null) {
	      transformVertex(_vB$1.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
	      _uvB$1.set(0, 1);
	      intersect = raycaster.ray.intersectTriangle(_vA$1, _vC$1, _vB$1, false, _intersectPoint);
	      if (intersect === null) {
	        return;
	      }
	    }
	    var distance = raycaster.ray.origin.distanceTo(_intersectPoint);
	    if (distance < raycaster.near || distance > raycaster.far) return;
	    intersects.push({
	      distance: distance,
	      point: _intersectPoint.clone(),
	      uv: Triangle.getUV(_intersectPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2()),
	      face: null,
	      object: this
	    });
	  },
	  clone: function () {
	    return new this.constructor(this.material).copy(this);
	  },
	  copy: function (source) {
	    Object3D.prototype.copy.call(this, source);
	    if (source.center !== undefined) this.center.copy(source.center);
	    return this;
	  }
	});
	function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
	  _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);
	  if (sin !== undefined) {
	    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
	    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
	  } else {
	    _rotatedPosition.copy(_alignedPosition);
	  }
	  vertexPosition.copy(mvPosition);
	  vertexPosition.x += _rotatedPosition.x;
	  vertexPosition.y += _rotatedPosition.y;
	  vertexPosition.applyMatrix4(_viewWorldMatrix);
	}
	var _v1$4 = new Vector3();
	var _v2$2 = new Vector3();
	function LOD() {
	  Object3D.call(this);
	  this._currentLevel = 0;
	  this.type = "LOD";
	  Object.defineProperties(this, {
	    levels: {
	      enumerable: true,
	      value: []
	    }
	  });
	  this.autoUpdate = true;
	}
	LOD.prototype = Object.assign(Object.create(Object3D.prototype), {
	  constructor: LOD,
	  isLOD: true,
	  copy: function (source) {
	    Object3D.prototype.copy.call(this, source, false);
	    var levels = source.levels;
	    for (var i = 0, l = levels.length; i < l; i++) {
	      var level = levels[i];
	      this.addLevel(level.object.clone(), level.distance);
	    }
	    this.autoUpdate = source.autoUpdate;
	    return this;
	  },
	  addLevel: function (object, distance) {
	    if (distance === undefined) distance = 0;
	    distance = Math.abs(distance);
	    var levels = this.levels;
	    for (var l = 0; l < levels.length; l++) {
	      if (distance < levels[l].distance) {
	        break;
	      }
	    }
	    levels.splice(l, 0, {
	      distance: distance,
	      object: object
	    });
	    this.add(object);
	    return this;
	  },
	  getCurrentLevel: function () {
	    return this._currentLevel;
	  },
	  getObjectForDistance: function (distance) {
	    var levels = this.levels;
	    if (levels.length > 0) {
	      for (var i = 1, l = levels.length; i < l; i++) {
	        if (distance < levels[i].distance) {
	          break;
	        }
	      }
	      return levels[i - 1].object;
	    }
	    return null;
	  },
	  raycast: function (raycaster, intersects) {
	    var levels = this.levels;
	    if (levels.length > 0) {
	      _v1$4.setFromMatrixPosition(this.matrixWorld);
	      var distance = raycaster.ray.origin.distanceTo(_v1$4);
	      this.getObjectForDistance(distance).raycast(raycaster, intersects);
	    }
	  },
	  update: function (camera) {
	    var levels = this.levels;
	    if (levels.length > 1) {
	      _v1$4.setFromMatrixPosition(camera.matrixWorld);
	      _v2$2.setFromMatrixPosition(this.matrixWorld);
	      var distance = _v1$4.distanceTo(_v2$2) / camera.zoom;
	      levels[0].object.visible = true;
	      for (var i = 1, l = levels.length; i < l; i++) {
	        if (distance >= levels[i].distance) {
	          levels[i - 1].object.visible = false;
	          levels[i].object.visible = true;
	        } else {
	          break;
	        }
	      }
	      this._currentLevel = i - 1;
	      for (; i < l; i++) {
	        levels[i].object.visible = false;
	      }
	    }
	  },
	  toJSON: function (meta) {
	    var data = Object3D.prototype.toJSON.call(this, meta);
	    if (this.autoUpdate === false) data.object.autoUpdate = false;
	    data.object.levels = [];
	    var levels = this.levels;
	    for (var i = 0, l = levels.length; i < l; i++) {
	      var level = levels[i];
	      data.object.levels.push({
	        object: level.object.uuid,
	        distance: level.distance
	      });
	    }
	    return data;
	  }
	});
	function SkinnedMesh(geometry, material) {
	  if (geometry && geometry.isGeometry) {
	    console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
	  }
	  Mesh.call(this, geometry, material);
	  this.type = "SkinnedMesh";
	  this.bindMode = "attached";
	  this.bindMatrix = new Matrix4();
	  this.bindMatrixInverse = new Matrix4();
	}
	SkinnedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
	  constructor: SkinnedMesh,
	  isSkinnedMesh: true,
	  bind: function (skeleton, bindMatrix) {
	    this.skeleton = skeleton;
	    if (bindMatrix === undefined) {
	      this.updateMatrixWorld(true);
	      this.skeleton.calculateInverses();
	      bindMatrix = this.matrixWorld;
	    }
	    this.bindMatrix.copy(bindMatrix);
	    this.bindMatrixInverse.getInverse(bindMatrix);
	  },
	  pose: function () {
	    this.skeleton.pose();
	  },
	  normalizeSkinWeights: function () {
	    var vector = new Vector4();
	    var skinWeight = this.geometry.attributes.skinWeight;
	    for (var i = 0, l = skinWeight.count; i < l; i++) {
	      vector.x = skinWeight.getX(i);
	      vector.y = skinWeight.getY(i);
	      vector.z = skinWeight.getZ(i);
	      vector.w = skinWeight.getW(i);
	      var scale = 1 / vector.manhattanLength();
	      if (scale !== Infinity) {
	        vector.multiplyScalar(scale);
	      } else {
	        vector.set(1, 0, 0, 0);
	      }
	      skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
	    }
	  },
	  updateMatrixWorld: function (force) {
	    Mesh.prototype.updateMatrixWorld.call(this, force);
	    if (this.bindMode === "attached") {
	      this.bindMatrixInverse.getInverse(this.matrixWorld);
	    } else if (this.bindMode === "detached") {
	      this.bindMatrixInverse.getInverse(this.bindMatrix);
	    } else {
	      console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
	    }
	  },
	  clone: function () {
	    return new this.constructor(this.geometry, this.material).copy(this);
	  }
	});
	var _offsetMatrix = new Matrix4();
	var _identityMatrix = new Matrix4();
	function Skeleton(bones, boneInverses) {
	  bones = bones || [];
	  this.bones = bones.slice(0);
	  this.boneMatrices = new Float32Array(this.bones.length * 16);
	  this.frame = -1;
	  if (boneInverses === undefined) {
	    this.calculateInverses();
	  } else {
	    if (this.bones.length === boneInverses.length) {
	      this.boneInverses = boneInverses.slice(0);
	    } else {
	      console.warn("THREE.Skeleton boneInverses is the wrong length.");
	      this.boneInverses = [];
	      for (var i = 0, il = this.bones.length; i < il; i++) {
	        this.boneInverses.push(new Matrix4());
	      }
	    }
	  }
	}
	Object.assign(Skeleton.prototype, {
	  calculateInverses: function () {
	    this.boneInverses = [];
	    for (var i = 0, il = this.bones.length; i < il; i++) {
	      var inverse = new Matrix4();
	      if (this.bones[i]) {
	        inverse.getInverse(this.bones[i].matrixWorld);
	      }
	      this.boneInverses.push(inverse);
	    }
	  },
	  pose: function () {
	    var bone, i, il;
	    for ((i = 0, il = this.bones.length); i < il; i++) {
	      bone = this.bones[i];
	      if (bone) {
	        bone.matrixWorld.getInverse(this.boneInverses[i]);
	      }
	    }
	    for ((i = 0, il = this.bones.length); i < il; i++) {
	      bone = this.bones[i];
	      if (bone) {
	        if (bone.parent && bone.parent.isBone) {
	          bone.matrix.getInverse(bone.parent.matrixWorld);
	          bone.matrix.multiply(bone.matrixWorld);
	        } else {
	          bone.matrix.copy(bone.matrixWorld);
	        }
	        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
	      }
	    }
	  },
	  update: function () {
	    var bones = this.bones;
	    var boneInverses = this.boneInverses;
	    var boneMatrices = this.boneMatrices;
	    var boneTexture = this.boneTexture;
	    for (var i = 0, il = bones.length; i < il; i++) {
	      var matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;
	      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
	      _offsetMatrix.toArray(boneMatrices, i * 16);
	    }
	    if (boneTexture !== undefined) {
	      boneTexture.needsUpdate = true;
	    }
	  },
	  clone: function () {
	    return new Skeleton(this.bones, this.boneInverses);
	  },
	  getBoneByName: function (name) {
	    for (var i = 0, il = this.bones.length; i < il; i++) {
	      var bone = this.bones[i];
	      if (bone.name === name) {
	        return bone;
	      }
	    }
	    return undefined;
	  }
	});
	function Bone() {
	  Object3D.call(this);
	  this.type = "Bone";
	}
	Bone.prototype = Object.assign(Object.create(Object3D.prototype), {
	  constructor: Bone,
	  isBone: true
	});
	var _instanceLocalMatrix = new Matrix4();
	var _instanceWorldMatrix = new Matrix4();
	var _instanceIntersects = [];
	var _mesh = new Mesh();
	function InstancedMesh(geometry, material, count) {
	  Mesh.call(this, geometry, material);
	  this.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);
	  this.count = count;
	  this.frustumCulled = false;
	}
	InstancedMesh.prototype = Object.assign(Object.create(Mesh.prototype), {
	  constructor: InstancedMesh,
	  isInstancedMesh: true,
	  getMatrixAt: function (index, matrix) {
	    matrix.fromArray(this.instanceMatrix.array, index * 16);
	  },
	  raycast: function (raycaster, intersects) {
	    var matrixWorld = this.matrixWorld;
	    var raycastTimes = this.count;
	    _mesh.geometry = this.geometry;
	    _mesh.material = this.material;
	    if (_mesh.material === undefined) return;
	    for (var instanceId = 0; instanceId < raycastTimes; instanceId++) {
	      this.getMatrixAt(instanceId, _instanceLocalMatrix);
	      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
	      _mesh.matrixWorld = _instanceWorldMatrix;
	      _mesh.raycast(raycaster, _instanceIntersects);
	      if (_instanceIntersects.length > 0) {
	        _instanceIntersects[0].instanceId = instanceId;
	        _instanceIntersects[0].object = this;
	        intersects.push(_instanceIntersects[0]);
	        _instanceIntersects.length = 0;
	      }
	    }
	  },
	  setMatrixAt: function (index, matrix) {
	    matrix.toArray(this.instanceMatrix.array, index * 16);
	  },
	  updateMorphTargets: function () {}
	});
	function LineBasicMaterial(parameters) {
	  Material.call(this);
	  this.type = "LineBasicMaterial";
	  this.color = new Color(16777215);
	  this.linewidth = 1;
	  this.linecap = "round";
	  this.linejoin = "round";
	  this.setValues(parameters);
	}
	LineBasicMaterial.prototype = Object.create(Material.prototype);
	LineBasicMaterial.prototype.constructor = LineBasicMaterial;
	LineBasicMaterial.prototype.isLineBasicMaterial = true;
	LineBasicMaterial.prototype.copy = function (source) {
	  Material.prototype.copy.call(this, source);
	  this.color.copy(source.color);
	  this.linewidth = source.linewidth;
	  this.linecap = source.linecap;
	  this.linejoin = source.linejoin;
	  return this;
	};
	var _start = new Vector3();
	var _end = new Vector3();
	var _inverseMatrix$1 = new Matrix4();
	var _ray$1 = new Ray();
	var _sphere$2 = new Sphere();
	function Line(geometry, material, mode) {
	  if (mode === 1) {
	    console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.");
	  }
	  Object3D.call(this);
	  this.type = "Line";
	  this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
	  this.material = material !== undefined ? material : new LineBasicMaterial();
	}
	Line.prototype = Object.assign(Object.create(Object3D.prototype), {
	  constructor: Line,
	  isLine: true,
	  computeLineDistances: function () {
	    var geometry = this.geometry;
	    if (geometry.isBufferGeometry) {
	      if (geometry.index === null) {
	        var positionAttribute = geometry.attributes.position;
	        var lineDistances = [0];
	        for (var i = 1, l = positionAttribute.count; i < l; i++) {
	          _start.fromBufferAttribute(positionAttribute, i - 1);
	          _end.fromBufferAttribute(positionAttribute, i);
	          lineDistances[i] = lineDistances[i - 1];
	          lineDistances[i] += _start.distanceTo(_end);
	        }
	        geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
	      } else {
	        console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
	      }
	    } else if (geometry.isGeometry) {
	      var vertices = geometry.vertices;
	      var lineDistances = geometry.lineDistances;
	      lineDistances[0] = 0;
	      for (var i = 1, l = vertices.length; i < l; i++) {
	        lineDistances[i] = lineDistances[i - 1];
	        lineDistances[i] += vertices[i - 1].distanceTo(vertices[i]);
	      }
	    }
	    return this;
	  },
	  raycast: function (raycaster, intersects) {
	    var geometry = this.geometry;
	    var matrixWorld = this.matrixWorld;
	    var threshold = raycaster.params.Line.threshold;
	    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
	    _sphere$2.copy(geometry.boundingSphere);
	    _sphere$2.applyMatrix4(matrixWorld);
	    _sphere$2.radius += threshold;
	    if (raycaster.ray.intersectsSphere(_sphere$2) === false) return;
	    _inverseMatrix$1.getInverse(matrixWorld);
	    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
	    var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
	    var localThresholdSq = localThreshold * localThreshold;
	    var vStart = new Vector3();
	    var vEnd = new Vector3();
	    var interSegment = new Vector3();
	    var interRay = new Vector3();
	    var step = this && this.isLineSegments ? 2 : 1;
	    if (geometry.isBufferGeometry) {
	      var index = geometry.index;
	      var attributes = geometry.attributes;
	      var positions = attributes.position.array;
	      if (index !== null) {
	        var indices = index.array;
	        for (var i = 0, l = indices.length - 1; i < l; i += step) {
	          var a = indices[i];
	          var b = indices[i + 1];
	          vStart.fromArray(positions, a * 3);
	          vEnd.fromArray(positions, b * 3);
	          var distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
	          if (distSq > localThresholdSq) continue;
	          interRay.applyMatrix4(this.matrixWorld);
	          var distance = raycaster.ray.origin.distanceTo(interRay);
	          if (distance < raycaster.near || distance > raycaster.far) continue;
	          intersects.push({
	            distance: distance,
	            point: interSegment.clone().applyMatrix4(this.matrixWorld),
	            index: i,
	            face: null,
	            faceIndex: null,
	            object: this
	          });
	        }
	      } else {
	        for (var i = 0, l = positions.length / 3 - 1; i < l; i += step) {
	          vStart.fromArray(positions, 3 * i);
	          vEnd.fromArray(positions, 3 * i + 3);
	          var distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);
	          if (distSq > localThresholdSq) continue;
	          interRay.applyMatrix4(this.matrixWorld);
	          var distance = raycaster.ray.origin.distanceTo(interRay);
	          if (distance < raycaster.near || distance > raycaster.far) continue;
	          intersects.push({
	            distance: distance,
	            point: interSegment.clone().applyMatrix4(this.matrixWorld),
	            index: i,
	            face: null,
	            faceIndex: null,
	            object: this
	          });
	        }
	      }
	    } else if (geometry.isGeometry) {
	      var vertices = geometry.vertices;
	      var nbVertices = vertices.length;
	      for (var i = 0; i < nbVertices - 1; i += step) {
	        var distSq = _ray$1.distanceSqToSegment(vertices[i], vertices[i + 1], interRay, interSegment);
	        if (distSq > localThresholdSq) continue;
	        interRay.applyMatrix4(this.matrixWorld);
	        var distance = raycaster.ray.origin.distanceTo(interRay);
	        if (distance < raycaster.near || distance > raycaster.far) continue;
	        intersects.push({
	          distance: distance,
	          point: interSegment.clone().applyMatrix4(this.matrixWorld),
	          index: i,
	          face: null,
	          faceIndex: null,
	          object: this
	        });
	      }
	    }
	  },
	  clone: function () {
	    return new this.constructor(this.geometry, this.material).copy(this);
	  }
	});
	var _start$1 = new Vector3();
	var _end$1 = new Vector3();
	function LineSegments(geometry, material) {
	  Line.call(this, geometry, material);
	  this.type = "LineSegments";
	}
	LineSegments.prototype = Object.assign(Object.create(Line.prototype), {
	  constructor: LineSegments,
	  isLineSegments: true,
	  computeLineDistances: function () {
	    var geometry = this.geometry;
	    if (geometry.isBufferGeometry) {
	      if (geometry.index === null) {
	        var positionAttribute = geometry.attributes.position;
	        var lineDistances = [];
	        for (var i = 0, l = positionAttribute.count; i < l; i += 2) {
	          _start$1.fromBufferAttribute(positionAttribute, i);
	          _end$1.fromBufferAttribute(positionAttribute, i + 1);
	          lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
	          lineDistances[i + 1] = lineDistances[i] + _start$1.distanceTo(_end$1);
	        }
	        geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
	      } else {
	        console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
	      }
	    } else if (geometry.isGeometry) {
	      var vertices = geometry.vertices;
	      var lineDistances = geometry.lineDistances;
	      for (var i = 0, l = vertices.length; i < l; i += 2) {
	        _start$1.copy(vertices[i]);
	        _end$1.copy(vertices[i + 1]);
	        lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
	        lineDistances[i + 1] = lineDistances[i] + _start$1.distanceTo(_end$1);
	      }
	    }
	    return this;
	  }
	});
	function LineLoop(geometry, material) {
	  Line.call(this, geometry, material);
	  this.type = "LineLoop";
	}
	LineLoop.prototype = Object.assign(Object.create(Line.prototype), {
	  constructor: LineLoop,
	  isLineLoop: true
	});
	function PointsMaterial(parameters) {
	  Material.call(this);
	  this.type = "PointsMaterial";
	  this.color = new Color(16777215);
	  this.map = null;
	  this.alphaMap = null;
	  this.size = 1;
	  this.sizeAttenuation = true;
	  this.morphTargets = false;
	  this.setValues(parameters);
	}
	PointsMaterial.prototype = Object.create(Material.prototype);
	PointsMaterial.prototype.constructor = PointsMaterial;
	PointsMaterial.prototype.isPointsMaterial = true;
	PointsMaterial.prototype.copy = function (source) {
	  Material.prototype.copy.call(this, source);
	  this.color.copy(source.color);
	  this.map = source.map;
	  this.alphaMap = source.alphaMap;
	  this.size = source.size;
	  this.sizeAttenuation = source.sizeAttenuation;
	  this.morphTargets = source.morphTargets;
	  return this;
	};
	var _inverseMatrix$2 = new Matrix4();
	var _ray$2 = new Ray();
	var _sphere$3 = new Sphere();
	var _position$1 = new Vector3();
	function Points(geometry, material) {
	  Object3D.call(this);
	  this.type = "Points";
	  this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
	  this.material = material !== undefined ? material : new PointsMaterial();
	  this.updateMorphTargets();
	}
	Points.prototype = Object.assign(Object.create(Object3D.prototype), {
	  constructor: Points,
	  isPoints: true,
	  raycast: function (raycaster, intersects) {
	    var geometry = this.geometry;
	    var matrixWorld = this.matrixWorld;
	    var threshold = raycaster.params.Points.threshold;
	    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
	    _sphere$3.copy(geometry.boundingSphere);
	    _sphere$3.applyMatrix4(matrixWorld);
	    _sphere$3.radius += threshold;
	    if (raycaster.ray.intersectsSphere(_sphere$3) === false) return;
	    _inverseMatrix$2.getInverse(matrixWorld);
	    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
	    var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
	    var localThresholdSq = localThreshold * localThreshold;
	    if (geometry.isBufferGeometry) {
	      var index = geometry.index;
	      var attributes = geometry.attributes;
	      var positions = attributes.position.array;
	      if (index !== null) {
	        var indices = index.array;
	        for (var i = 0, il = indices.length; i < il; i++) {
	          var a = indices[i];
	          _position$1.fromArray(positions, a * 3);
	          testPoint(_position$1, a, localThresholdSq, matrixWorld, raycaster, intersects, this);
	        }
	      } else {
	        for (var i = 0, l = positions.length / 3; i < l; i++) {
	          _position$1.fromArray(positions, i * 3);
	          testPoint(_position$1, i, localThresholdSq, matrixWorld, raycaster, intersects, this);
	        }
	      }
	    } else {
	      var vertices = geometry.vertices;
	      for (var i = 0, l = vertices.length; i < l; i++) {
	        testPoint(vertices[i], i, localThresholdSq, matrixWorld, raycaster, intersects, this);
	      }
	    }
	  },
	  updateMorphTargets: function () {
	    var geometry = this.geometry;
	    var m, ml, name;
	    if (geometry.isBufferGeometry) {
	      var morphAttributes = geometry.morphAttributes;
	      var keys = Object.keys(morphAttributes);
	      if (keys.length > 0) {
	        var morphAttribute = morphAttributes[keys[0]];
	        if (morphAttribute !== undefined) {
	          this.morphTargetInfluences = [];
	          this.morphTargetDictionary = {};
	          for ((m = 0, ml = morphAttribute.length); m < ml; m++) {
	            name = morphAttribute[m].name || String(m);
	            this.morphTargetInfluences.push(0);
	            this.morphTargetDictionary[name] = m;
	          }
	        }
	      }
	    } else {
	      var morphTargets = geometry.morphTargets;
	      if (morphTargets !== undefined && morphTargets.length > 0) {
	        console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.");
	      }
	    }
	  },
	  clone: function () {
	    return new this.constructor(this.geometry, this.material).copy(this);
	  }
	});
	function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
	  var rayPointDistanceSq = _ray$2.distanceSqToPoint(point);
	  if (rayPointDistanceSq < localThresholdSq) {
	    var intersectPoint = new Vector3();
	    _ray$2.closestPointToPoint(point, intersectPoint);
	    intersectPoint.applyMatrix4(matrixWorld);
	    var distance = raycaster.ray.origin.distanceTo(intersectPoint);
	    if (distance < raycaster.near || distance > raycaster.far) return;
	    intersects.push({
	      distance: distance,
	      distanceToRay: Math.sqrt(rayPointDistanceSq),
	      point: intersectPoint,
	      index: index,
	      face: null,
	      object: object
	    });
	  }
	}
	function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
	  Texture.call(this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
	  this.format = format !== undefined ? format : RGBFormat;
	  this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
	  this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
	  this.generateMipmaps = false;
	}
	VideoTexture.prototype = Object.assign(Object.create(Texture.prototype), {
	  constructor: VideoTexture,
	  isVideoTexture: true,
	  update: function () {
	    var video = this.image;
	    if (video.readyState >= video.HAVE_CURRENT_DATA) {
	      this.needsUpdate = true;
	    }
	  }
	});
	function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
	  Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);
	  this.image = {
	    width: width,
	    height: height
	  };
	  this.mipmaps = mipmaps;
	  this.flipY = false;
	  this.generateMipmaps = false;
	}
	CompressedTexture.prototype = Object.create(Texture.prototype);
	CompressedTexture.prototype.constructor = CompressedTexture;
	CompressedTexture.prototype.isCompressedTexture = true;
	function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
	  Texture.call(this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
	  this.needsUpdate = true;
	}
	CanvasTexture.prototype = Object.create(Texture.prototype);
	CanvasTexture.prototype.constructor = CanvasTexture;
	CanvasTexture.prototype.isCanvasTexture = true;
	function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {
	  format = format !== undefined ? format : DepthFormat;
	  if (format !== DepthFormat && format !== DepthStencilFormat) {
	    throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
	  }
	  if (type === undefined && format === DepthFormat) type = UnsignedShortType;
	  if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;
	  Texture.call(this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
	  this.image = {
	    width: width,
	    height: height
	  };
	  this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
	  this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
	  this.flipY = false;
	  this.generateMipmaps = false;
	}
	DepthTexture.prototype = Object.create(Texture.prototype);
	DepthTexture.prototype.constructor = DepthTexture;
	DepthTexture.prototype.isDepthTexture = true;
	function WireframeGeometry(geometry) {
	  BufferGeometry.call(this);
	  this.type = "WireframeGeometry";
	  var vertices = [];
	  var i, j, l, o, ol;
	  var edge = [0, 0], edges = {}, e, edge1, edge2;
	  var key, keys = ["a", "b", "c"];
	  var vertex;
	  if (geometry && geometry.isGeometry) {
	    var faces = geometry.faces;
	    for ((i = 0, l = faces.length); i < l; i++) {
	      var face = faces[i];
	      for (j = 0; j < 3; j++) {
	        edge1 = face[keys[j]];
	        edge2 = face[keys[(j + 1) % 3]];
	        edge[0] = Math.min(edge1, edge2);
	        edge[1] = Math.max(edge1, edge2);
	        key = edge[0] + "," + edge[1];
	        if (edges[key] === undefined) {
	          edges[key] = {
	            index1: edge[0],
	            index2: edge[1]
	          };
	        }
	      }
	    }
	    for (key in edges) {
	      e = edges[key];
	      vertex = geometry.vertices[e.index1];
	      vertices.push(vertex.x, vertex.y, vertex.z);
	      vertex = geometry.vertices[e.index2];
	      vertices.push(vertex.x, vertex.y, vertex.z);
	    }
	  } else if (geometry && geometry.isBufferGeometry) {
	    var position, indices, groups;
	    var group, start, count;
	    var index1, index2;
	    vertex = new Vector3();
	    if (geometry.index !== null) {
	      position = geometry.attributes.position;
	      indices = geometry.index;
	      groups = geometry.groups;
	      if (groups.length === 0) {
	        groups = [{
	          start: 0,
	          count: indices.count,
	          materialIndex: 0
	        }];
	      }
	      for ((o = 0, ol = groups.length); o < ol; ++o) {
	        group = groups[o];
	        start = group.start;
	        count = group.count;
	        for ((i = start, l = start + count); i < l; i += 3) {
	          for (j = 0; j < 3; j++) {
	            edge1 = indices.getX(i + j);
	            edge2 = indices.getX(i + (j + 1) % 3);
	            edge[0] = Math.min(edge1, edge2);
	            edge[1] = Math.max(edge1, edge2);
	            key = edge[0] + "," + edge[1];
	            if (edges[key] === undefined) {
	              edges[key] = {
	                index1: edge[0],
	                index2: edge[1]
	              };
	            }
	          }
	        }
	      }
	      for (key in edges) {
	        e = edges[key];
	        vertex.fromBufferAttribute(position, e.index1);
	        vertices.push(vertex.x, vertex.y, vertex.z);
	        vertex.fromBufferAttribute(position, e.index2);
	        vertices.push(vertex.x, vertex.y, vertex.z);
	      }
	    } else {
	      position = geometry.attributes.position;
	      for ((i = 0, l = position.count / 3); i < l; i++) {
	        for (j = 0; j < 3; j++) {
	          index1 = 3 * i + j;
	          vertex.fromBufferAttribute(position, index1);
	          vertices.push(vertex.x, vertex.y, vertex.z);
	          index2 = 3 * i + (j + 1) % 3;
	          vertex.fromBufferAttribute(position, index2);
	          vertices.push(vertex.x, vertex.y, vertex.z);
	        }
	      }
	    }
	  }
	  this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
	}
	WireframeGeometry.prototype = Object.create(BufferGeometry.prototype);
	WireframeGeometry.prototype.constructor = WireframeGeometry;
	function ParametricGeometry(func, slices, stacks) {
	  Geometry.call(this);
	  this.type = "ParametricGeometry";
	  this.parameters = {
	    func: func,
	    slices: slices,
	    stacks: stacks
	  };
	  this.fromBufferGeometry(new ParametricBufferGeometry(func, slices, stacks));
	  this.mergeVertices();
	}
	ParametricGeometry.prototype = Object.create(Geometry.prototype);
	ParametricGeometry.prototype.constructor = ParametricGeometry;
	function ParametricBufferGeometry(func, slices, stacks) {
	  BufferGeometry.call(this);
	  this.type = "ParametricBufferGeometry";
	  this.parameters = {
	    func: func,
	    slices: slices,
	    stacks: stacks
	  };
	  var indices = [];
	  var vertices = [];
	  var normals = [];
	  var uvs = [];
	  var EPS = 0.00001;
	  var normal = new Vector3();
	  var p0 = new Vector3(), p1 = new Vector3();
	  var pu = new Vector3(), pv = new Vector3();
	  var i, j;
	  if (func.length < 3) {
	    console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
	  }
	  var sliceCount = slices + 1;
	  for (i = 0; i <= stacks; i++) {
	    var v = i / stacks;
	    for (j = 0; j <= slices; j++) {
	      var u = j / slices;
	      func(u, v, p0);
	      vertices.push(p0.x, p0.y, p0.z);
	      if (u - EPS >= 0) {
	        func(u - EPS, v, p1);
	        pu.subVectors(p0, p1);
	      } else {
	        func(u + EPS, v, p1);
	        pu.subVectors(p1, p0);
	      }
	      if (v - EPS >= 0) {
	        func(u, v - EPS, p1);
	        pv.subVectors(p0, p1);
	      } else {
	        func(u, v + EPS, p1);
	        pv.subVectors(p1, p0);
	      }
	      normal.crossVectors(pu, pv).normalize();
	      normals.push(normal.x, normal.y, normal.z);
	      uvs.push(u, v);
	    }
	  }
	  for (i = 0; i < stacks; i++) {
	    for (j = 0; j < slices; j++) {
	      var a = i * sliceCount + j;
	      var b = i * sliceCount + j + 1;
	      var c = (i + 1) * sliceCount + j + 1;
	      var d = (i + 1) * sliceCount + j;
	      indices.push(a, b, d);
	      indices.push(b, c, d);
	    }
	  }
	  this.setIndex(indices);
	  this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
	  this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
	  this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
	}
	ParametricBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
	ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;
	function PolyhedronGeometry(vertices, indices, radius, detail) {
	  Geometry.call(this);
	  this.type = "PolyhedronGeometry";
	  this.parameters = {
	    vertices: vertices,
	    indices: indices,
	    radius: radius,
	    detail: detail
	  };
	  this.fromBufferGeometry(new PolyhedronBufferGeometry(vertices, indices, radius, detail));
	  this.mergeVertices();
	}
	PolyhedronGeometry.prototype = Object.create(Geometry.prototype);
	PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;
	function PolyhedronBufferGeometry(vertices, indices, radius, detail) {
	  BufferGeometry.call(this);
	  this.type = "PolyhedronBufferGeometry";
	  this.parameters = {
	    vertices: vertices,
	    indices: indices,
	    radius: radius,
	    detail: detail
	  };
	  radius = radius || 1;
	  detail = detail || 0;
	  var vertexBuffer = [];
	  var uvBuffer = [];
	  subdivide(detail);
	  applyRadius(radius);
	  generateUVs();
	  this.setAttribute("position", new Float32BufferAttribute(vertexBuffer, 3));
	  this.setAttribute("normal", new Float32BufferAttribute(vertexBuffer.slice(), 3));
	  this.setAttribute("uv", new Float32BufferAttribute(uvBuffer, 2));
	  if (detail === 0) {
	    this.computeVertexNormals();
	  } else {
	    this.normalizeNormals();
	  }
	  function subdivide(detail) {
	    var a = new Vector3();
	    var b = new Vector3();
	    var c = new Vector3();
	    for (var i = 0; i < indices.length; i += 3) {
	      getVertexByIndex(indices[i + 0], a);
	      getVertexByIndex(indices[i + 1], b);
	      getVertexByIndex(indices[i + 2], c);
	      subdivideFace(a, b, c, detail);
	    }
	  }
	  function subdivideFace(a, b, c, detail) {
	    var cols = Math.pow(2, detail);
	    var v = [];
	    var i, j;
	    for (i = 0; i <= cols; i++) {
	      v[i] = [];
	      var aj = a.clone().lerp(c, i / cols);
	      var bj = b.clone().lerp(c, i / cols);
	      var rows = cols - i;
	      for (j = 0; j <= rows; j++) {
	        if (j === 0 && i === cols) {
	          v[i][j] = aj;
	        } else {
	          v[i][j] = aj.clone().lerp(bj, j / rows);
	        }
	      }
	    }
	    for (i = 0; i < cols; i++) {
	      for (j = 0; j < 2 * (cols - i) - 1; j++) {
	        var k = Math.floor(j / 2);
	        if (j % 2 === 0) {
	          pushVertex(v[i][k + 1]);
	          pushVertex(v[i + 1][k]);
	          pushVertex(v[i][k]);
	        } else {
	          pushVertex(v[i][k + 1]);
	          pushVertex(v[i + 1][k + 1]);
	          pushVertex(v[i + 1][k]);
	        }
	      }
	    }
	  }
	  function applyRadius(radius) {
	    var vertex = new Vector3();
	    for (var i = 0; i < vertexBuffer.length; i += 3) {
	      vertex.x = vertexBuffer[i + 0];
	      vertex.y = vertexBuffer[i + 1];
	      vertex.z = vertexBuffer[i + 2];
	      vertex.normalize().multiplyScalar(radius);
	      vertexBuffer[i + 0] = vertex.x;
	      vertexBuffer[i + 1] = vertex.y;
	      vertexBuffer[i + 2] = vertex.z;
	    }
	  }
	  function generateUVs() {
	    var vertex = new Vector3();
	    for (var i = 0; i < vertexBuffer.length; i += 3) {
	      vertex.x = vertexBuffer[i + 0];
	      vertex.y = vertexBuffer[i + 1];
	      vertex.z = vertexBuffer[i + 2];
	      var u = azimuth(vertex) / 2 / Math.PI + 0.5;
	      var v = inclination(vertex) / Math.PI + 0.5;
	      uvBuffer.push(u, 1 - v);
	    }
	    correctUVs();
	    correctSeam();
	  }
	  function correctSeam() {
	    for (var i = 0; i < uvBuffer.length; i += 6) {
	      var x0 = uvBuffer[i + 0];
	      var x1 = uvBuffer[i + 2];
	      var x2 = uvBuffer[i + 4];
	      var max = Math.max(x0, x1, x2);
	      var min = Math.min(x0, x1, x2);
	      if (max > 0.9 && min < 0.1) {
	        if (x0 < 0.2) uvBuffer[i + 0] += 1;
	        if (x1 < 0.2) uvBuffer[i + 2] += 1;
	        if (x2 < 0.2) uvBuffer[i + 4] += 1;
	      }
	    }
	  }
	  function pushVertex(vertex) {
	    vertexBuffer.push(vertex.x, vertex.y, vertex.z);
	  }
	  function getVertexByIndex(index, vertex) {
	    var stride = index * 3;
	    vertex.x = vertices[stride + 0];
	    vertex.y = vertices[stride + 1];
	    vertex.z = vertices[stride + 2];
	  }
	  function correctUVs() {
	    var a = new Vector3();
	    var b = new Vector3();
	    var c = new Vector3();
	    var centroid = new Vector3();
	    var uvA = new Vector2();
	    var uvB = new Vector2();
	    var uvC = new Vector2();
	    for (var i = 0, j = 0; i < vertexBuffer.length; (i += 9, j += 6)) {
	      a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
	      b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
	      c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
	      uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
	      uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
	      uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
	      centroid.copy(a).add(b).add(c).divideScalar(3);
	      var azi = azimuth(centroid);
	      correctUV(uvA, j + 0, a, azi);
	      correctUV(uvB, j + 2, b, azi);
	      correctUV(uvC, j + 4, c, azi);
	    }
	  }
	  function correctUV(uv, stride, vector, azimuth) {
	    if (azimuth < 0 && uv.x === 1) {
	      uvBuffer[stride] = uv.x - 1;
	    }
	    if (vector.x === 0 && vector.z === 0) {
	      uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
	    }
	  }
	  function azimuth(vector) {
	    return Math.atan2(vector.z, -vector.x);
	  }
	  function inclination(vector) {
	    return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
	  }
	}
	PolyhedronBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
	PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;
	function TetrahedronGeometry(radius, detail) {
	  Geometry.call(this);
	  this.type = "TetrahedronGeometry";
	  this.parameters = {
	    radius: radius,
	    detail: detail
	  };
	  this.fromBufferGeometry(new TetrahedronBufferGeometry(radius, detail));
	  this.mergeVertices();
	}
	TetrahedronGeometry.prototype = Object.create(Geometry.prototype);
	TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;
	function TetrahedronBufferGeometry(radius, detail) {
	  var vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
	  var indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
	  PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
	  this.type = "TetrahedronBufferGeometry";
	  this.parameters = {
	    radius: radius,
	    detail: detail
	  };
	}
	TetrahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
	TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;
	function OctahedronGeometry(radius, detail) {
	  Geometry.call(this);
	  this.type = "OctahedronGeometry";
	  this.parameters = {
	    radius: radius,
	    detail: detail
	  };
	  this.fromBufferGeometry(new OctahedronBufferGeometry(radius, detail));
	  this.mergeVertices();
	}
	OctahedronGeometry.prototype = Object.create(Geometry.prototype);
	OctahedronGeometry.prototype.constructor = OctahedronGeometry;
	function OctahedronBufferGeometry(radius, detail) {
	  var vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
	  var indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
	  PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
	  this.type = "OctahedronBufferGeometry";
	  this.parameters = {
	    radius: radius,
	    detail: detail
	  };
	}
	OctahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
	OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;
	function IcosahedronGeometry(radius, detail) {
	  Geometry.call(this);
	  this.type = "IcosahedronGeometry";
	  this.parameters = {
	    radius: radius,
	    detail: detail
	  };
	  this.fromBufferGeometry(new IcosahedronBufferGeometry(radius, detail));
	  this.mergeVertices();
	}
	IcosahedronGeometry.prototype = Object.create(Geometry.prototype);
	IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;
	function IcosahedronBufferGeometry(radius, detail) {
	  var t = (1 + Math.sqrt(5)) / 2;
	  var vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
	  var indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
	  PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
	  this.type = "IcosahedronBufferGeometry";
	  this.parameters = {
	    radius: radius,
	    detail: detail
	  };
	}
	IcosahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
	IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;
	function DodecahedronGeometry(radius, detail) {
	  Geometry.call(this);
	  this.type = "DodecahedronGeometry";
	  this.parameters = {
	    radius: radius,
	    detail: detail
	  };
	  this.fromBufferGeometry(new DodecahedronBufferGeometry(radius, detail));
	  this.mergeVertices();
	}
	DodecahedronGeometry.prototype = Object.create(Geometry.prototype);
	DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;
	function DodecahedronBufferGeometry(radius, detail) {
	  var t = (1 + Math.sqrt(5)) / 2;
	  var r = 1 / t;
	  var vertices = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0, -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];
	  var indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
	  PolyhedronBufferGeometry.call(this, vertices, indices, radius, detail);
	  this.type = "DodecahedronBufferGeometry";
	  this.parameters = {
	    radius: radius,
	    detail: detail
	  };
	}
	DodecahedronBufferGeometry.prototype = Object.create(PolyhedronBufferGeometry.prototype);
	DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;
	function TubeGeometry(path, tubularSegments, radius, radialSegments, closed, taper) {
	  Geometry.call(this);
	  this.type = "TubeGeometry";
	  this.parameters = {
	    path: path,
	    tubularSegments: tubularSegments,
	    radius: radius,
	    radialSegments: radialSegments,
	    closed: closed
	  };
	  if (taper !== undefined) console.warn("THREE.TubeGeometry: taper has been removed.");
	  var bufferGeometry = new TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed);
	  this.tangents = bufferGeometry.tangents;
	  this.normals = bufferGeometry.normals;
	  this.binormals = bufferGeometry.binormals;
	  this.fromBufferGeometry(bufferGeometry);
	  this.mergeVertices();
	}
	TubeGeometry.prototype = Object.create(Geometry.prototype);
	TubeGeometry.prototype.constructor = TubeGeometry;
	function TubeBufferGeometry(path, tubularSegments, radius, radialSegments, closed) {
	  BufferGeometry.call(this);
	  this.type = "TubeBufferGeometry";
	  this.parameters = {
	    path: path,
	    tubularSegments: tubularSegments,
	    radius: radius,
	    radialSegments: radialSegments,
	    closed: closed
	  };
	  tubularSegments = tubularSegments || 64;
	  radius = radius || 1;
	  radialSegments = radialSegments || 8;
	  closed = closed || false;
	  var frames = path.computeFrenetFrames(tubularSegments, closed);
	  this.tangents = frames.tangents;
	  this.normals = frames.normals;
	  this.binormals = frames.binormals;
	  var vertex = new Vector3();
	  var normal = new Vector3();
	  var uv = new Vector2();
	  var P = new Vector3();
	  var i, j;
	  var vertices = [];
	  var normals = [];
	  var uvs = [];
	  var indices = [];
	  generateBufferData();
	  this.setIndex(indices);
	  this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
	  this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
	  this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
	  function generateBufferData() {
	    for (i = 0; i < tubularSegments; i++) {
	      generateSegment(i);
	    }
	    generateSegment(closed === false ? tubularSegments : 0);
	    generateUVs();
	    generateIndices();
	  }
	  function generateSegment(i) {
	    P = path.getPointAt(i / tubularSegments, P);
	    var N = frames.normals[i];
	    var B = frames.binormals[i];
	    for (j = 0; j <= radialSegments; j++) {
	      var v = j / radialSegments * Math.PI * 2;
	      var sin = Math.sin(v);
	      var cos = -Math.cos(v);
	      normal.x = cos * N.x + sin * B.x;
	      normal.y = cos * N.y + sin * B.y;
	      normal.z = cos * N.z + sin * B.z;
	      normal.normalize();
	      normals.push(normal.x, normal.y, normal.z);
	      vertex.x = P.x + radius * normal.x;
	      vertex.y = P.y + radius * normal.y;
	      vertex.z = P.z + radius * normal.z;
	      vertices.push(vertex.x, vertex.y, vertex.z);
	    }
	  }
	  function generateIndices() {
	    for (j = 1; j <= tubularSegments; j++) {
	      for (i = 1; i <= radialSegments; i++) {
	        var a = (radialSegments + 1) * (j - 1) + (i - 1);
	        var b = (radialSegments + 1) * j + (i - 1);
	        var c = (radialSegments + 1) * j + i;
	        var d = (radialSegments + 1) * (j - 1) + i;
	        indices.push(a, b, d);
	        indices.push(b, c, d);
	      }
	    }
	  }
	  function generateUVs() {
	    for (i = 0; i <= tubularSegments; i++) {
	      for (j = 0; j <= radialSegments; j++) {
	        uv.x = i / tubularSegments;
	        uv.y = j / radialSegments;
	        uvs.push(uv.x, uv.y);
	      }
	    }
	  }
	}
	TubeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
	TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;
	TubeBufferGeometry.prototype.toJSON = function () {
	  var data = BufferGeometry.prototype.toJSON.call(this);
	  data.path = this.parameters.path.toJSON();
	  return data;
	};
	function TorusKnotGeometry(radius, tube, tubularSegments, radialSegments, p, q, heightScale) {
	  Geometry.call(this);
	  this.type = "TorusKnotGeometry";
	  this.parameters = {
	    radius: radius,
	    tube: tube,
	    tubularSegments: tubularSegments,
	    radialSegments: radialSegments,
	    p: p,
	    q: q
	  };
	  if (heightScale !== undefined) console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.");
	  this.fromBufferGeometry(new TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q));
	  this.mergeVertices();
	}
	TorusKnotGeometry.prototype = Object.create(Geometry.prototype);
	TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;
	function TorusKnotBufferGeometry(radius, tube, tubularSegments, radialSegments, p, q) {
	  BufferGeometry.call(this);
	  this.type = "TorusKnotBufferGeometry";
	  this.parameters = {
	    radius: radius,
	    tube: tube,
	    tubularSegments: tubularSegments,
	    radialSegments: radialSegments,
	    p: p,
	    q: q
	  };
	  radius = radius || 1;
	  tube = tube || 0.4;
	  tubularSegments = Math.floor(tubularSegments) || 64;
	  radialSegments = Math.floor(radialSegments) || 8;
	  p = p || 2;
	  q = q || 3;
	  var indices = [];
	  var vertices = [];
	  var normals = [];
	  var uvs = [];
	  var i, j;
	  var vertex = new Vector3();
	  var normal = new Vector3();
	  var P1 = new Vector3();
	  var P2 = new Vector3();
	  var B = new Vector3();
	  var T = new Vector3();
	  var N = new Vector3();
	  for (i = 0; i <= tubularSegments; ++i) {
	    var u = i / tubularSegments * p * Math.PI * 2;
	    calculatePositionOnCurve(u, p, q, radius, P1);
	    calculatePositionOnCurve(u + 0.01, p, q, radius, P2);
	    T.subVectors(P2, P1);
	    N.addVectors(P2, P1);
	    B.crossVectors(T, N);
	    N.crossVectors(B, T);
	    B.normalize();
	    N.normalize();
	    for (j = 0; j <= radialSegments; ++j) {
	      var v = j / radialSegments * Math.PI * 2;
	      var cx = -tube * Math.cos(v);
	      var cy = tube * Math.sin(v);
	      vertex.x = P1.x + (cx * N.x + cy * B.x);
	      vertex.y = P1.y + (cx * N.y + cy * B.y);
	      vertex.z = P1.z + (cx * N.z + cy * B.z);
	      vertices.push(vertex.x, vertex.y, vertex.z);
	      normal.subVectors(vertex, P1).normalize();
	      normals.push(normal.x, normal.y, normal.z);
	      uvs.push(i / tubularSegments);
	      uvs.push(j / radialSegments);
	    }
	  }
	  for (j = 1; j <= tubularSegments; j++) {
	    for (i = 1; i <= radialSegments; i++) {
	      var a = (radialSegments + 1) * (j - 1) + (i - 1);
	      var b = (radialSegments + 1) * j + (i - 1);
	      var c = (radialSegments + 1) * j + i;
	      var d = (radialSegments + 1) * (j - 1) + i;
	      indices.push(a, b, d);
	      indices.push(b, c, d);
	    }
	  }
	  this.setIndex(indices);
	  this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
	  this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
	  this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
	  function calculatePositionOnCurve(u, p, q, radius, position) {
	    var cu = Math.cos(u);
	    var su = Math.sin(u);
	    var quOverP = q / p * u;
	    var cs = Math.cos(quOverP);
	    position.x = radius * (2 + cs) * 0.5 * cu;
	    position.y = radius * (2 + cs) * su * 0.5;
	    position.z = radius * Math.sin(quOverP) * 0.5;
	  }
	}
	TorusKnotBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
	TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;
	function TorusGeometry(radius, tube, radialSegments, tubularSegments, arc) {
	  Geometry.call(this);
	  this.type = "TorusGeometry";
	  this.parameters = {
	    radius: radius,
	    tube: tube,
	    radialSegments: radialSegments,
	    tubularSegments: tubularSegments,
	    arc: arc
	  };
	  this.fromBufferGeometry(new TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc));
	  this.mergeVertices();
	}
	TorusGeometry.prototype = Object.create(Geometry.prototype);
	TorusGeometry.prototype.constructor = TorusGeometry;
	function TorusBufferGeometry(radius, tube, radialSegments, tubularSegments, arc) {
	  BufferGeometry.call(this);
	  this.type = "TorusBufferGeometry";
	  this.parameters = {
	    radius: radius,
	    tube: tube,
	    radialSegments: radialSegments,
	    tubularSegments: tubularSegments,
	    arc: arc
	  };
	  radius = radius || 1;
	  tube = tube || 0.4;
	  radialSegments = Math.floor(radialSegments) || 8;
	  tubularSegments = Math.floor(tubularSegments) || 6;
	  arc = arc || Math.PI * 2;
	  var indices = [];
	  var vertices = [];
	  var normals = [];
	  var uvs = [];
	  var center = new Vector3();
	  var vertex = new Vector3();
	  var normal = new Vector3();
	  var j, i;
	  for (j = 0; j <= radialSegments; j++) {
	    for (i = 0; i <= tubularSegments; i++) {
	      var u = i / tubularSegments * arc;
	      var v = j / radialSegments * Math.PI * 2;
	      vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
	      vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
	      vertex.z = tube * Math.sin(v);
	      vertices.push(vertex.x, vertex.y, vertex.z);
	      center.x = radius * Math.cos(u);
	      center.y = radius * Math.sin(u);
	      normal.subVectors(vertex, center).normalize();
	      normals.push(normal.x, normal.y, normal.z);
	      uvs.push(i / tubularSegments);
	      uvs.push(j / radialSegments);
	    }
	  }
	  for (j = 1; j <= radialSegments; j++) {
	    for (i = 1; i <= tubularSegments; i++) {
	      var a = (tubularSegments + 1) * j + i - 1;
	      var b = (tubularSegments + 1) * (j - 1) + i - 1;
	      var c = (tubularSegments + 1) * (j - 1) + i;
	      var d = (tubularSegments + 1) * j + i;
	      indices.push(a, b, d);
	      indices.push(b, c, d);
	    }
	  }
	  this.setIndex(indices);
	  this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
	  this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
	  this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
	}
	TorusBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
	TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;
	var Earcut = {
	  triangulate: function (data, holeIndices, dim) {
	    dim = dim || 2;
	    var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
	    if (!outerNode || outerNode.next === outerNode.prev) return triangles;
	    var minX, minY, maxX, maxY, x, y, invSize;
	    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
	    if (data.length > 80 * dim) {
	      minX = maxX = data[0];
	      minY = maxY = data[1];
	      for (var i = dim; i < outerLen; i += dim) {
	        x = data[i];
	        y = data[i + 1];
	        if (x < minX) minX = x;
	        if (y < minY) minY = y;
	        if (x > maxX) maxX = x;
	        if (y > maxY) maxY = y;
	      }
	      invSize = Math.max(maxX - minX, maxY - minY);
	      invSize = invSize !== 0 ? 1 / invSize : 0;
	    }
	    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
	    return triangles;
	  }
	};
	function linkedList(data, start, end, dim, clockwise) {
	  var i, last;
	  if (clockwise === signedArea(data, start, end, dim) > 0) {
	    for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
	  } else {
	    for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
	  }
	  if (last && equals(last, last.next)) {
	    removeNode(last);
	    last = last.next;
	  }
	  return last;
	}
	function filterPoints(start, end) {
	  if (!start) return start;
	  if (!end) end = start;
	  var p = start, again;
	  do {
	    again = false;
	    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
	      removeNode(p);
	      p = end = p.prev;
	      if (p === p.next) break;
	      again = true;
	    } else {
	      p = p.next;
	    }
	  } while (again || p !== end);
	  return end;
	}
	function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
	  if (!ear) return;
	  if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
	  var stop = ear, prev, next;
	  while (ear.prev !== ear.next) {
	    prev = ear.prev;
	    next = ear.next;
	    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
	      triangles.push(prev.i / dim);
	      triangles.push(ear.i / dim);
	      triangles.push(next.i / dim);
	      removeNode(ear);
	      ear = next.next;
	      stop = next.next;
	      continue;
	    }
	    ear = next;
	    if (ear === stop) {
	      if (!pass) {
	        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
	      } else if (pass === 1) {
	        ear = cureLocalIntersections(ear, triangles, dim);
	        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
	      } else if (pass === 2) {
	        splitEarcut(ear, triangles, dim, minX, minY, invSize);
	      }
	      break;
	    }
	  }
	}
	function isEar(ear) {
	  var a = ear.prev, b = ear, c = ear.next;
	  if (area(a, b, c) >= 0) return false;
	  var p = ear.next.next;
	  while (p !== ear.prev) {
	    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
	    p = p.next;
	  }
	  return true;
	}
	function isEarHashed(ear, minX, minY, invSize) {
	  var a = ear.prev, b = ear, c = ear.next;
	  if (area(a, b, c) >= 0) return false;
	  var minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;
	  var minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);
	  var p = ear.prevZ, n = ear.nextZ;
	  while (p && p.z >= minZ && n && n.z <= maxZ) {
	    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
	    p = p.prevZ;
	    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
	    n = n.nextZ;
	  }
	  while (p && p.z >= minZ) {
	    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
	    p = p.prevZ;
	  }
	  while (n && n.z <= maxZ) {
	    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
	    n = n.nextZ;
	  }
	  return true;
	}
	function cureLocalIntersections(start, triangles, dim) {
	  var p = start;
	  do {
	    var a = p.prev, b = p.next.next;
	    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
	      triangles.push(a.i / dim);
	      triangles.push(p.i / dim);
	      triangles.push(b.i / dim);
	      removeNode(p);
	      removeNode(p.next);
	      p = start = b;
	    }
	    p = p.next;
	  } while (p !== start);
	  return p;
	}
	function splitEarcut(start, triangles, dim, minX, minY, invSize) {
	  var a = start;
	  do {
	    var b = a.next.next;
	    while (b !== a.prev) {
	      if (a.i !== b.i && isValidDiagonal(a, b)) {
	        var c = splitPolygon(a, b);
	        a = filterPoints(a, a.next);
	        c = filterPoints(c, c.next);
	        earcutLinked(a, triangles, dim, minX, minY, invSize);
	        earcutLinked(c, triangles, dim, minX, minY, invSize);
	        return;
	      }
	      b = b.next;
	    }
	    a = a.next;
	  } while (a !== start);
	}
	function eliminateHoles(data, holeIndices, outerNode, dim) {
	  var queue = [], i, len, start, end, list;
	  for ((i = 0, len = holeIndices.length); i < len; i++) {
	    start = holeIndices[i] * dim;
	    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
	    list = linkedList(data, start, end, dim, false);
	    if (list === list.next) list.steiner = true;
	    queue.push(getLeftmost(list));
	  }
	  queue.sort(compareX);
	  for (i = 0; i < queue.length; i++) {
	    eliminateHole(queue[i], outerNode);
	    outerNode = filterPoints(outerNode, outerNode.next);
	  }
	  return outerNode;
	}
	function compareX(a, b) {
	  return a.x - b.x;
	}
	function eliminateHole(hole, outerNode) {
	  outerNode = findHoleBridge(hole, outerNode);
	  if (outerNode) {
	    var b = splitPolygon(outerNode, hole);
	    filterPoints(b, b.next);
	  }
	}
	function findHoleBridge(hole, outerNode) {
	  var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
	  do {
	    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
	      var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
	      if (x <= hx && x > qx) {
	        qx = x;
	        if (x === hx) {
	          if (hy === p.y) return p;
	          if (hy === p.next.y) return p.next;
	        }
	        m = p.x < p.next.x ? p : p.next;
	      }
	    }
	    p = p.next;
	  } while (p !== outerNode);
	  if (!m) return null;
	  if (hx === qx) return m.prev;
	  var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
	  p = m.next;
	  while (p !== stop) {
	    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
	      tan = Math.abs(hy - p.y) / (hx - p.x);
	      if ((tan < tanMin || tan === tanMin && p.x > m.x) && locallyInside(p, hole)) {
	        m = p;
	        tanMin = tan;
	      }
	    }
	    p = p.next;
	  }
	  return m;
	}
	function indexCurve(start, minX, minY, invSize) {
	  var p = start;
	  do {
	    if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
	    p.prevZ = p.prev;
	    p.nextZ = p.next;
	    p = p.next;
	  } while (p !== start);
	  p.prevZ.nextZ = null;
	  p.prevZ = null;
	  sortLinked(p);
	}
	function sortLinked(list) {
	  var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
	  do {
	    p = list;
	    list = null;
	    tail = null;
	    numMerges = 0;
	    while (p) {
	      numMerges++;
	      q = p;
	      pSize = 0;
	      for (i = 0; i < inSize; i++) {
	        pSize++;
	        q = q.nextZ;
	        if (!q) break;
	      }
	      qSize = inSize;
	      while (pSize > 0 || qSize > 0 && q) {
	        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
	          e = p;
	          p = p.nextZ;
	          pSize--;
	        } else {
	          e = q;
	          q = q.nextZ;
	          qSize--;
	        }
	        if (tail) tail.nextZ = e; else list = e;
	        e.prevZ = tail;
	        tail = e;
	      }
	      p = q;
	    }
	    tail.nextZ = null;
	    inSize *= 2;
	  } while (numMerges > 1);
	  return list;
	}
	function zOrder(x, y, minX, minY, invSize) {
	  x = 32767 * (x - minX) * invSize;
	  y = 32767 * (y - minY) * invSize;
	  x = (x | x << 8) & 16711935;
	  x = (x | x << 4) & 252645135;
	  x = (x | x << 2) & 858993459;
	  x = (x | x << 1) & 1431655765;
	  y = (y | y << 8) & 16711935;
	  y = (y | y << 4) & 252645135;
	  y = (y | y << 2) & 858993459;
	  y = (y | y << 1) & 1431655765;
	  return x | y << 1;
	}
	function getLeftmost(start) {
	  var p = start, leftmost = start;
	  do {
	    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
	    p = p.next;
	  } while (p !== start);
	  return leftmost;
	}
	function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
	  return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
	}
	function isValidDiagonal(a, b) {
	  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
	}
	function area(p, q, r) {
	  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
	}
	function equals(p1, p2) {
	  return p1.x === p2.x && p1.y === p2.y;
	}
	function intersects(p1, q1, p2, q2) {
	  if (equals(p1, p2) && equals(q1, q2) || equals(p1, q2) && equals(p2, q1)) return true;
	  return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 && area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
	}
	function intersectsPolygon(a, b) {
	  var p = a;
	  do {
	    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
	    p = p.next;
	  } while (p !== a);
	  return false;
	}
	function locallyInside(a, b) {
	  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
	}
	function middleInside(a, b) {
	  var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
	  do {
	    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
	    p = p.next;
	  } while (p !== a);
	  return inside;
	}
	function splitPolygon(a, b) {
	  var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
	  a.next = b;
	  b.prev = a;
	  a2.next = an;
	  an.prev = a2;
	  b2.next = a2;
	  a2.prev = b2;
	  bp.next = b2;
	  b2.prev = bp;
	  return b2;
	}
	function insertNode(i, x, y, last) {
	  var p = new Node(i, x, y);
	  if (!last) {
	    p.prev = p;
	    p.next = p;
	  } else {
	    p.next = last.next;
	    p.prev = last;
	    last.next.prev = p;
	    last.next = p;
	  }
	  return p;
	}
	function removeNode(p) {
	  p.next.prev = p.prev;
	  p.prev.next = p.next;
	  if (p.prevZ) p.prevZ.nextZ = p.nextZ;
	  if (p.nextZ) p.nextZ.prevZ = p.prevZ;
	}
	function Node(i, x, y) {
	  this.i = i;
	  this.x = x;
	  this.y = y;
	  this.prev = null;
	  this.next = null;
	  this.z = null;
	  this.prevZ = null;
	  this.nextZ = null;
	  this.steiner = false;
	}
	function signedArea(data, start, end, dim) {
	  var sum = 0;
	  for (var i = start, j = end - dim; i < end; i += dim) {
	    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
	    j = i;
	  }
	  return sum;
	}
	var ShapeUtils = {
	  area: function (contour) {
	    var n = contour.length;
	    var a = 0;
	    for (var p = n - 1, q = 0; q < n; p = q++) {
	      a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
	    }
	    return a * 0.5;
	  },
	  isClockWise: function (pts) {
	    return ShapeUtils.area(pts) < 0;
	  },
	  triangulateShape: function (contour, holes) {
	    var vertices = [];
	    var holeIndices = [];
	    var faces = [];
	    removeDupEndPts(contour);
	    addContour(vertices, contour);
	    var holeIndex = contour.length;
	    holes.forEach(removeDupEndPts);
	    for (var i = 0; i < holes.length; i++) {
	      holeIndices.push(holeIndex);
	      holeIndex += holes[i].length;
	      addContour(vertices, holes[i]);
	    }
	    var triangles = Earcut.triangulate(vertices, holeIndices);
	    for (var i = 0; i < triangles.length; i += 3) {
	      faces.push(triangles.slice(i, i + 3));
	    }
	    return faces;
	  }
	};
	function removeDupEndPts(points) {
	  var l = points.length;
	  if (l > 2 && points[l - 1].equals(points[0])) {
	    points.pop();
	  }
	}
	function addContour(vertices, contour) {
	  for (var i = 0; i < contour.length; i++) {
	    vertices.push(contour[i].x);
	    vertices.push(contour[i].y);
	  }
	}
	function ExtrudeGeometry(shapes, options) {
	  Geometry.call(this);
	  this.type = "ExtrudeGeometry";
	  this.parameters = {
	    shapes: shapes,
	    options: options
	  };
	  this.fromBufferGeometry(new ExtrudeBufferGeometry(shapes, options));
	  this.mergeVertices();
	}
	ExtrudeGeometry.prototype = Object.create(Geometry.prototype);
	ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;
	ExtrudeGeometry.prototype.toJSON = function () {
	  var data = Geometry.prototype.toJSON.call(this);
	  var shapes = this.parameters.shapes;
	  var options = this.parameters.options;
	  return toJSON(shapes, options, data);
	};
	function ExtrudeBufferGeometry(shapes, options) {
	  BufferGeometry.call(this);
	  this.type = "ExtrudeBufferGeometry";
	  this.parameters = {
	    shapes: shapes,
	    options: options
	  };
	  shapes = Array.isArray(shapes) ? shapes : [shapes];
	  var scope = this;
	  var verticesArray = [];
	  var uvArray = [];
	  for (var i = 0, l = shapes.length; i < l; i++) {
	    var shape = shapes[i];
	    addShape(shape);
	  }
	  this.setAttribute("position", new Float32BufferAttribute(verticesArray, 3));
	  this.setAttribute("uv", new Float32BufferAttribute(uvArray, 2));
	  this.computeVertexNormals();
	  function addShape(shape) {
	    var placeholder = [];
	    var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
	    var steps = options.steps !== undefined ? options.steps : 1;
	    var depth = options.depth !== undefined ? options.depth : 100;
	    var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
	    var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
	    var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
	    var bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
	    var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
	    var extrudePath = options.extrudePath;
	    var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;
	    if (options.amount !== undefined) {
	      console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth.");
	      depth = options.amount;
	    }
	    var extrudePts, extrudeByPath = false;
	    var splineTube, binormal, normal, position2;
	    if (extrudePath) {
	      extrudePts = extrudePath.getSpacedPoints(steps);
	      extrudeByPath = true;
	      bevelEnabled = false;
	      splineTube = extrudePath.computeFrenetFrames(steps, false);
	      binormal = new Vector3();
	      normal = new Vector3();
	      position2 = new Vector3();
	    }
	    if (!bevelEnabled) {
	      bevelSegments = 0;
	      bevelThickness = 0;
	      bevelSize = 0;
	      bevelOffset = 0;
	    }
	    var ahole, h, hl;
	    var shapePoints = shape.extractPoints(curveSegments);
	    var vertices = shapePoints.shape;
	    var holes = shapePoints.holes;
	    var reverse = !ShapeUtils.isClockWise(vertices);
	    if (reverse) {
	      vertices = vertices.reverse();
	      for ((h = 0, hl = holes.length); h < hl; h++) {
	        ahole = holes[h];
	        if (ShapeUtils.isClockWise(ahole)) {
	          holes[h] = ahole.reverse();
	        }
	      }
	    }
	    var faces = ShapeUtils.triangulateShape(vertices, holes);
	    var contour = vertices;
	    for ((h = 0, hl = holes.length); h < hl; h++) {
	      ahole = holes[h];
	      vertices = vertices.concat(ahole);
	    }
	    function scalePt2(pt, vec, size) {
	      if (!vec) console.error("THREE.ExtrudeGeometry: vec does not exist");
	      return vec.clone().multiplyScalar(size).add(pt);
	    }
	    var b, bs, t, z, vert, vlen = vertices.length, face, flen = faces.length;
	    function getBevelVec(inPt, inPrev, inNext) {
	      var v_trans_x, v_trans_y, shrink_by;
	      var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
	      var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
	      var v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;
	      var collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
	      if (Math.abs(collinear0) > Number.EPSILON) {
	        var v_prev_len = Math.sqrt(v_prev_lensq);
	        var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);
	        var ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
	        var ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
	        var ptNextShift_x = inNext.x - v_next_y / v_next_len;
	        var ptNextShift_y = inNext.y + v_next_x / v_next_len;
	        var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);
	        v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
	        v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;
	        var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
	        if (v_trans_lensq <= 2) {
	          return new Vector2(v_trans_x, v_trans_y);
	        } else {
	          shrink_by = Math.sqrt(v_trans_lensq / 2);
	        }
	      } else {
	        var direction_eq = false;
	        if (v_prev_x > Number.EPSILON) {
	          if (v_next_x > Number.EPSILON) {
	            direction_eq = true;
	          }
	        } else {
	          if (v_prev_x < -Number.EPSILON) {
	            if (v_next_x < -Number.EPSILON) {
	              direction_eq = true;
	            }
	          } else {
	            if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
	              direction_eq = true;
	            }
	          }
	        }
	        if (direction_eq) {
	          v_trans_x = -v_prev_y;
	          v_trans_y = v_prev_x;
	          shrink_by = Math.sqrt(v_prev_lensq);
	        } else {
	          v_trans_x = v_prev_x;
	          v_trans_y = v_prev_y;
	          shrink_by = Math.sqrt(v_prev_lensq / 2);
	        }
	      }
	      return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
	    }
	    var contourMovements = [];
	    for (var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; (i++, j++, k++)) {
	      if (j === il) j = 0;
	      if (k === il) k = 0;
	      contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);
	    }
	    var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();
	    for ((h = 0, hl = holes.length); h < hl; h++) {
	      ahole = holes[h];
	      oneHoleMovements = [];
	      for ((i = 0, il = ahole.length, j = il - 1, k = i + 1); i < il; (i++, j++, k++)) {
	        if (j === il) j = 0;
	        if (k === il) k = 0;
	        oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);
	      }
	      holesMovements.push(oneHoleMovements);
	      verticesMovements = verticesMovements.concat(oneHoleMovements);
	    }
	    for (b = 0; b < bevelSegments; b++) {
	      t = b / bevelSegments;
	      z = bevelThickness * Math.cos(t * Math.PI / 2);
	      bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
	      for ((i = 0, il = contour.length); i < il; i++) {
	        vert = scalePt2(contour[i], contourMovements[i], bs);
	        v(vert.x, vert.y, -z);
	      }
	      for ((h = 0, hl = holes.length); h < hl; h++) {
	        ahole = holes[h];
	        oneHoleMovements = holesMovements[h];
	        for ((i = 0, il = ahole.length); i < il; i++) {
	          vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
	          v(vert.x, vert.y, -z);
	        }
	      }
	    }
	    bs = bevelSize + bevelOffset;
	    for (i = 0; i < vlen; i++) {
	      vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
	      if (!extrudeByPath) {
	        v(vert.x, vert.y, 0);
	      } else {
	        normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);
	        binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);
	        position2.copy(extrudePts[0]).add(normal).add(binormal);
	        v(position2.x, position2.y, position2.z);
	      }
	    }
	    var s;
	    for (s = 1; s <= steps; s++) {
	      for (i = 0; i < vlen; i++) {
	        vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];
	        if (!extrudeByPath) {
	          v(vert.x, vert.y, depth / steps * s);
	        } else {
	          normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);
	          binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);
	          position2.copy(extrudePts[s]).add(normal).add(binormal);
	          v(position2.x, position2.y, position2.z);
	        }
	      }
	    }
	    for (b = bevelSegments - 1; b >= 0; b--) {
	      t = b / bevelSegments;
	      z = bevelThickness * Math.cos(t * Math.PI / 2);
	      bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;
	      for ((i = 0, il = contour.length); i < il; i++) {
	        vert = scalePt2(contour[i], contourMovements[i], bs);
	        v(vert.x, vert.y, depth + z);
	      }
	      for ((h = 0, hl = holes.length); h < hl; h++) {
	        ahole = holes[h];
	        oneHoleMovements = holesMovements[h];
	        for ((i = 0, il = ahole.length); i < il; i++) {
	          vert = scalePt2(ahole[i], oneHoleMovements[i], bs);
	          if (!extrudeByPath) {
	            v(vert.x, vert.y, depth + z);
	          } else {
	            v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);
	          }
	        }
	      }
	    }
	    buildLidFaces();
	    buildSideFaces();
	    function buildLidFaces() {
	      var start = verticesArray.length / 3;
	      if (bevelEnabled) {
	        var layer = 0;
	        var offset = vlen * layer;
	        for (i = 0; i < flen; i++) {
	          face = faces[i];
	          f3(face[2] + offset, face[1] + offset, face[0] + offset);
	        }
	        layer = steps + bevelSegments * 2;
	        offset = vlen * layer;
	        for (i = 0; i < flen; i++) {
	          face = faces[i];
	          f3(face[0] + offset, face[1] + offset, face[2] + offset);
	        }
	      } else {
	        for (i = 0; i < flen; i++) {
	          face = faces[i];
	          f3(face[2], face[1], face[0]);
	        }
	        for (i = 0; i < flen; i++) {
	          face = faces[i];
	          f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);
	        }
	      }
	      scope.addGroup(start, verticesArray.length / 3 - start, 0);
	    }
	    function buildSideFaces() {
	      var start = verticesArray.length / 3;
	      var layeroffset = 0;
	      sidewalls(contour, layeroffset);
	      layeroffset += contour.length;
	      for ((h = 0, hl = holes.length); h < hl; h++) {
	        ahole = holes[h];
	        sidewalls(ahole, layeroffset);
	        layeroffset += ahole.length;
	      }
	      scope.addGroup(start, verticesArray.length / 3 - start, 1);
	    }
	    function sidewalls(contour, layeroffset) {
	      var j, k;
	      i = contour.length;
	      while (--i >= 0) {
	        j = i;
	        k = i - 1;
	        if (k < 0) k = contour.length - 1;
	        var s = 0, sl = steps + bevelSegments * 2;
	        for (s = 0; s < sl; s++) {
	          var slen1 = vlen * s;
	          var slen2 = vlen * (s + 1);
	          var a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;
	          f4(a, b, c, d);
	        }
	      }
	    }
	    function v(x, y, z) {
	      placeholder.push(x);
	      placeholder.push(y);
	      placeholder.push(z);
	    }
	    function f3(a, b, c) {
	      addVertex(a);
	      addVertex(b);
	      addVertex(c);
	      var nextIndex = verticesArray.length / 3;
	      var uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
	      addUV(uvs[0]);
	      addUV(uvs[1]);
	      addUV(uvs[2]);
	    }
	    function f4(a, b, c, d) {
	      addVertex(a);
	      addVertex(b);
	      addVertex(d);
	      addVertex(b);
	      addVertex(c);
	      addVertex(d);
	      var nextIndex = verticesArray.length / 3;
	      var uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
	      addUV(uvs[0]);
	      addUV(uvs[1]);
	      addUV(uvs[3]);
	      addUV(uvs[1]);
	      addUV(uvs[2]);
	      addUV(uvs[3]);
	    }
	    function addVertex(index) {
	      verticesArray.push(placeholder[index * 3 + 0]);
	      verticesArray.push(placeholder[index * 3 + 1]);
	      verticesArray.push(placeholder[index * 3 + 2]);
	    }
	    function addUV(vector2) {
	      uvArray.push(vector2.x);
	      uvArray.push(vector2.y);
	    }
	  }
	}
	ExtrudeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
	ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;
	ExtrudeBufferGeometry.prototype.toJSON = function () {
	  var data = BufferGeometry.prototype.toJSON.call(this);
	  var shapes = this.parameters.shapes;
	  var options = this.parameters.options;
	  return toJSON(shapes, options, data);
	};
	var WorldUVGenerator = {
	  generateTopUV: function (geometry, vertices, indexA, indexB, indexC) {
	    var a_x = vertices[indexA * 3];
	    var a_y = vertices[indexA * 3 + 1];
	    var b_x = vertices[indexB * 3];
	    var b_y = vertices[indexB * 3 + 1];
	    var c_x = vertices[indexC * 3];
	    var c_y = vertices[indexC * 3 + 1];
	    return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];
	  },
	  generateSideWallUV: function (geometry, vertices, indexA, indexB, indexC, indexD) {
	    var a_x = vertices[indexA * 3];
	    var a_y = vertices[indexA * 3 + 1];
	    var a_z = vertices[indexA * 3 + 2];
	    var b_x = vertices[indexB * 3];
	    var b_y = vertices[indexB * 3 + 1];
	    var b_z = vertices[indexB * 3 + 2];
	    var c_x = vertices[indexC * 3];
	    var c_y = vertices[indexC * 3 + 1];
	    var c_z = vertices[indexC * 3 + 2];
	    var d_x = vertices[indexD * 3];
	    var d_y = vertices[indexD * 3 + 1];
	    var d_z = vertices[indexD * 3 + 2];
	    if (Math.abs(a_y - b_y) < 0.01) {
	      return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];
	    } else {
	      return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];
	    }
	  }
	};
	function toJSON(shapes, options, data) {
	  data.shapes = [];
	  if (Array.isArray(shapes)) {
	    for (var i = 0, l = shapes.length; i < l; i++) {
	      var shape = shapes[i];
	      data.shapes.push(shape.uuid);
	    }
	  } else {
	    data.shapes.push(shapes.uuid);
	  }
	  if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();
	  return data;
	}
	function TextGeometry(text, parameters) {
	  Geometry.call(this);
	  this.type = "TextGeometry";
	  this.parameters = {
	    text: text,
	    parameters: parameters
	  };
	  this.fromBufferGeometry(new TextBufferGeometry(text, parameters));
	  this.mergeVertices();
	}
	TextGeometry.prototype = Object.create(Geometry.prototype);
	TextGeometry.prototype.constructor = TextGeometry;
	function TextBufferGeometry(text, parameters) {
	  parameters = parameters || ({});
	  var font = parameters.font;
	  if (!(font && font.isFont)) {
	    console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font.");
	    return new Geometry();
	  }
	  var shapes = font.generateShapes(text, parameters.size);
	  parameters.depth = parameters.height !== undefined ? parameters.height : 50;
	  if (parameters.bevelThickness === undefined) parameters.bevelThickness = 10;
	  if (parameters.bevelSize === undefined) parameters.bevelSize = 8;
	  if (parameters.bevelEnabled === undefined) parameters.bevelEnabled = false;
	  ExtrudeBufferGeometry.call(this, shapes, parameters);
	  this.type = "TextBufferGeometry";
	}
	TextBufferGeometry.prototype = Object.create(ExtrudeBufferGeometry.prototype);
	TextBufferGeometry.prototype.constructor = TextBufferGeometry;
	function SphereGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
	  Geometry.call(this);
	  this.type = "SphereGeometry";
	  this.parameters = {
	    radius: radius,
	    widthSegments: widthSegments,
	    heightSegments: heightSegments,
	    phiStart: phiStart,
	    phiLength: phiLength,
	    thetaStart: thetaStart,
	    thetaLength: thetaLength
	  };
	  this.fromBufferGeometry(new SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength));
	  this.mergeVertices();
	}
	SphereGeometry.prototype = Object.create(Geometry.prototype);
	SphereGeometry.prototype.constructor = SphereGeometry;
	function SphereBufferGeometry(radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength) {
	  BufferGeometry.call(this);
	  this.type = "SphereBufferGeometry";
	  this.parameters = {
	    radius: radius,
	    widthSegments: widthSegments,
	    heightSegments: heightSegments,
	    phiStart: phiStart,
	    phiLength: phiLength,
	    thetaStart: thetaStart,
	    thetaLength: thetaLength
	  };
	  radius = radius || 1;
	  widthSegments = Math.max(3, Math.floor(widthSegments) || 8);
	  heightSegments = Math.max(2, Math.floor(heightSegments) || 6);
	  phiStart = phiStart !== undefined ? phiStart : 0;
	  phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
	  thetaStart = thetaStart !== undefined ? thetaStart : 0;
	  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
	  var thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
	  var ix, iy;
	  var index = 0;
	  var grid = [];
	  var vertex = new Vector3();
	  var normal = new Vector3();
	  var indices = [];
	  var vertices = [];
	  var normals = [];
	  var uvs = [];
	  for (iy = 0; iy <= heightSegments; iy++) {
	    var verticesRow = [];
	    var v = iy / heightSegments;
	    var uOffset = 0;
	    if (iy == 0 && thetaStart == 0) {
	      uOffset = 0.5 / widthSegments;
	    } else if (iy == heightSegments && thetaEnd == Math.PI) {
	      uOffset = -0.5 / widthSegments;
	    }
	    for (ix = 0; ix <= widthSegments; ix++) {
	      var u = ix / widthSegments;
	      vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
	      vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
	      vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
	      vertices.push(vertex.x, vertex.y, vertex.z);
	      normal.copy(vertex).normalize();
	      normals.push(normal.x, normal.y, normal.z);
	      uvs.push(u + uOffset, 1 - v);
	      verticesRow.push(index++);
	    }
	    grid.push(verticesRow);
	  }
	  for (iy = 0; iy < heightSegments; iy++) {
	    for (ix = 0; ix < widthSegments; ix++) {
	      var a = grid[iy][ix + 1];
	      var b = grid[iy][ix];
	      var c = grid[iy + 1][ix];
	      var d = grid[iy + 1][ix + 1];
	      if (iy !== 0 || thetaStart > 0) indices.push(a, b, d);
	      if (iy !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
	    }
	  }
	  this.setIndex(indices);
	  this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
	  this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
	  this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
	}
	SphereBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
	SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;
	function RingGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
	  Geometry.call(this);
	  this.type = "RingGeometry";
	  this.parameters = {
	    innerRadius: innerRadius,
	    outerRadius: outerRadius,
	    thetaSegments: thetaSegments,
	    phiSegments: phiSegments,
	    thetaStart: thetaStart,
	    thetaLength: thetaLength
	  };
	  this.fromBufferGeometry(new RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength));
	  this.mergeVertices();
	}
	RingGeometry.prototype = Object.create(Geometry.prototype);
	RingGeometry.prototype.constructor = RingGeometry;
	function RingBufferGeometry(innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength) {
	  BufferGeometry.call(this);
	  this.type = "RingBufferGeometry";
	  this.parameters = {
	    innerRadius: innerRadius,
	    outerRadius: outerRadius,
	    thetaSegments: thetaSegments,
	    phiSegments: phiSegments,
	    thetaStart: thetaStart,
	    thetaLength: thetaLength
	  };
	  innerRadius = innerRadius || 0.5;
	  outerRadius = outerRadius || 1;
	  thetaStart = thetaStart !== undefined ? thetaStart : 0;
	  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	  thetaSegments = thetaSegments !== undefined ? Math.max(3, thetaSegments) : 8;
	  phiSegments = phiSegments !== undefined ? Math.max(1, phiSegments) : 1;
	  var indices = [];
	  var vertices = [];
	  var normals = [];
	  var uvs = [];
	  var segment;
	  var radius = innerRadius;
	  var radiusStep = (outerRadius - innerRadius) / phiSegments;
	  var vertex = new Vector3();
	  var uv = new Vector2();
	  var j, i;
	  for (j = 0; j <= phiSegments; j++) {
	    for (i = 0; i <= thetaSegments; i++) {
	      segment = thetaStart + i / thetaSegments * thetaLength;
	      vertex.x = radius * Math.cos(segment);
	      vertex.y = radius * Math.sin(segment);
	      vertices.push(vertex.x, vertex.y, vertex.z);
	      normals.push(0, 0, 1);
	      uv.x = (vertex.x / outerRadius + 1) / 2;
	      uv.y = (vertex.y / outerRadius + 1) / 2;
	      uvs.push(uv.x, uv.y);
	    }
	    radius += radiusStep;
	  }
	  for (j = 0; j < phiSegments; j++) {
	    var thetaSegmentLevel = j * (thetaSegments + 1);
	    for (i = 0; i < thetaSegments; i++) {
	      segment = i + thetaSegmentLevel;
	      var a = segment;
	      var b = segment + thetaSegments + 1;
	      var c = segment + thetaSegments + 2;
	      var d = segment + 1;
	      indices.push(a, b, d);
	      indices.push(b, c, d);
	    }
	  }
	  this.setIndex(indices);
	  this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
	  this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
	  this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
	}
	RingBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
	RingBufferGeometry.prototype.constructor = RingBufferGeometry;
	function LatheGeometry(points, segments, phiStart, phiLength) {
	  Geometry.call(this);
	  this.type = "LatheGeometry";
	  this.parameters = {
	    points: points,
	    segments: segments,
	    phiStart: phiStart,
	    phiLength: phiLength
	  };
	  this.fromBufferGeometry(new LatheBufferGeometry(points, segments, phiStart, phiLength));
	  this.mergeVertices();
	}
	LatheGeometry.prototype = Object.create(Geometry.prototype);
	LatheGeometry.prototype.constructor = LatheGeometry;
	function LatheBufferGeometry(points, segments, phiStart, phiLength) {
	  BufferGeometry.call(this);
	  this.type = "LatheBufferGeometry";
	  this.parameters = {
	    points: points,
	    segments: segments,
	    phiStart: phiStart,
	    phiLength: phiLength
	  };
	  segments = Math.floor(segments) || 12;
	  phiStart = phiStart || 0;
	  phiLength = phiLength || Math.PI * 2;
	  phiLength = MathUtils.clamp(phiLength, 0, Math.PI * 2);
	  var indices = [];
	  var vertices = [];
	  var uvs = [];
	  var base;
	  var inverseSegments = 1 / segments;
	  var vertex = new Vector3();
	  var uv = new Vector2();
	  var i, j;
	  for (i = 0; i <= segments; i++) {
	    var phi = phiStart + i * inverseSegments * phiLength;
	    var sin = Math.sin(phi);
	    var cos = Math.cos(phi);
	    for (j = 0; j <= points.length - 1; j++) {
	      vertex.x = points[j].x * sin;
	      vertex.y = points[j].y;
	      vertex.z = points[j].x * cos;
	      vertices.push(vertex.x, vertex.y, vertex.z);
	      uv.x = i / segments;
	      uv.y = j / (points.length - 1);
	      uvs.push(uv.x, uv.y);
	    }
	  }
	  for (i = 0; i < segments; i++) {
	    for (j = 0; j < points.length - 1; j++) {
	      base = j + i * points.length;
	      var a = base;
	      var b = base + points.length;
	      var c = base + points.length + 1;
	      var d = base + 1;
	      indices.push(a, b, d);
	      indices.push(b, c, d);
	    }
	  }
	  this.setIndex(indices);
	  this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
	  this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
	  this.computeVertexNormals();
	  if (phiLength === Math.PI * 2) {
	    var normals = this.attributes.normal.array;
	    var n1 = new Vector3();
	    var n2 = new Vector3();
	    var n = new Vector3();
	    base = segments * points.length * 3;
	    for ((i = 0, j = 0); i < points.length; (i++, j += 3)) {
	      n1.x = normals[j + 0];
	      n1.y = normals[j + 1];
	      n1.z = normals[j + 2];
	      n2.x = normals[base + j + 0];
	      n2.y = normals[base + j + 1];
	      n2.z = normals[base + j + 2];
	      n.addVectors(n1, n2).normalize();
	      normals[j + 0] = normals[base + j + 0] = n.x;
	      normals[j + 1] = normals[base + j + 1] = n.y;
	      normals[j + 2] = normals[base + j + 2] = n.z;
	    }
	  }
	}
	LatheBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
	LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;
	function ShapeGeometry(shapes, curveSegments) {
	  Geometry.call(this);
	  this.type = "ShapeGeometry";
	  if (typeof curveSegments === "object") {
	    console.warn("THREE.ShapeGeometry: Options parameter has been removed.");
	    curveSegments = curveSegments.curveSegments;
	  }
	  this.parameters = {
	    shapes: shapes,
	    curveSegments: curveSegments
	  };
	  this.fromBufferGeometry(new ShapeBufferGeometry(shapes, curveSegments));
	  this.mergeVertices();
	}
	ShapeGeometry.prototype = Object.create(Geometry.prototype);
	ShapeGeometry.prototype.constructor = ShapeGeometry;
	ShapeGeometry.prototype.toJSON = function () {
	  var data = Geometry.prototype.toJSON.call(this);
	  var shapes = this.parameters.shapes;
	  return toJSON$1(shapes, data);
	};
	function ShapeBufferGeometry(shapes, curveSegments) {
	  BufferGeometry.call(this);
	  this.type = "ShapeBufferGeometry";
	  this.parameters = {
	    shapes: shapes,
	    curveSegments: curveSegments
	  };
	  curveSegments = curveSegments || 12;
	  var indices = [];
	  var vertices = [];
	  var normals = [];
	  var uvs = [];
	  var groupStart = 0;
	  var groupCount = 0;
	  if (Array.isArray(shapes) === false) {
	    addShape(shapes);
	  } else {
	    for (var i = 0; i < shapes.length; i++) {
	      addShape(shapes[i]);
	      this.addGroup(groupStart, groupCount, i);
	      groupStart += groupCount;
	      groupCount = 0;
	    }
	  }
	  this.setIndex(indices);
	  this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
	  this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
	  this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
	  function addShape(shape) {
	    var i, l, shapeHole;
	    var indexOffset = vertices.length / 3;
	    var points = shape.extractPoints(curveSegments);
	    var shapeVertices = points.shape;
	    var shapeHoles = points.holes;
	    if (ShapeUtils.isClockWise(shapeVertices) === false) {
	      shapeVertices = shapeVertices.reverse();
	    }
	    for ((i = 0, l = shapeHoles.length); i < l; i++) {
	      shapeHole = shapeHoles[i];
	      if (ShapeUtils.isClockWise(shapeHole) === true) {
	        shapeHoles[i] = shapeHole.reverse();
	      }
	    }
	    var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);
	    for ((i = 0, l = shapeHoles.length); i < l; i++) {
	      shapeHole = shapeHoles[i];
	      shapeVertices = shapeVertices.concat(shapeHole);
	    }
	    for ((i = 0, l = shapeVertices.length); i < l; i++) {
	      var vertex = shapeVertices[i];
	      vertices.push(vertex.x, vertex.y, 0);
	      normals.push(0, 0, 1);
	      uvs.push(vertex.x, vertex.y);
	    }
	    for ((i = 0, l = faces.length); i < l; i++) {
	      var face = faces[i];
	      var a = face[0] + indexOffset;
	      var b = face[1] + indexOffset;
	      var c = face[2] + indexOffset;
	      indices.push(a, b, c);
	      groupCount += 3;
	    }
	  }
	}
	ShapeBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
	ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;
	ShapeBufferGeometry.prototype.toJSON = function () {
	  var data = BufferGeometry.prototype.toJSON.call(this);
	  var shapes = this.parameters.shapes;
	  return toJSON$1(shapes, data);
	};
	function toJSON$1(shapes, data) {
	  data.shapes = [];
	  if (Array.isArray(shapes)) {
	    for (var i = 0, l = shapes.length; i < l; i++) {
	      var shape = shapes[i];
	      data.shapes.push(shape.uuid);
	    }
	  } else {
	    data.shapes.push(shapes.uuid);
	  }
	  return data;
	}
	function EdgesGeometry(geometry, thresholdAngle) {
	  BufferGeometry.call(this);
	  this.type = "EdgesGeometry";
	  this.parameters = {
	    thresholdAngle: thresholdAngle
	  };
	  thresholdAngle = thresholdAngle !== undefined ? thresholdAngle : 1;
	  var vertices = [];
	  var thresholdDot = Math.cos(MathUtils.DEG2RAD * thresholdAngle);
	  var edge = [0, 0], edges = {}, edge1, edge2;
	  var key, keys = ["a", "b", "c"];
	  var geometry2;
	  if (geometry.isBufferGeometry) {
	    geometry2 = new Geometry();
	    geometry2.fromBufferGeometry(geometry);
	  } else {
	    geometry2 = geometry.clone();
	  }
	  geometry2.mergeVertices();
	  geometry2.computeFaceNormals();
	  var sourceVertices = geometry2.vertices;
	  var faces = geometry2.faces;
	  for (var i = 0, l = faces.length; i < l; i++) {
	    var face = faces[i];
	    for (var j = 0; j < 3; j++) {
	      edge1 = face[keys[j]];
	      edge2 = face[keys[(j + 1) % 3]];
	      edge[0] = Math.min(edge1, edge2);
	      edge[1] = Math.max(edge1, edge2);
	      key = edge[0] + "," + edge[1];
	      if (edges[key] === undefined) {
	        edges[key] = {
	          index1: edge[0],
	          index2: edge[1],
	          face1: i,
	          face2: undefined
	        };
	      } else {
	        edges[key].face2 = i;
	      }
	    }
	  }
	  for (key in edges) {
	    var e = edges[key];
	    if (e.face2 === undefined || faces[e.face1].normal.dot(faces[e.face2].normal) <= thresholdDot) {
	      var vertex = sourceVertices[e.index1];
	      vertices.push(vertex.x, vertex.y, vertex.z);
	      vertex = sourceVertices[e.index2];
	      vertices.push(vertex.x, vertex.y, vertex.z);
	    }
	  }
	  this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
	}
	EdgesGeometry.prototype = Object.create(BufferGeometry.prototype);
	EdgesGeometry.prototype.constructor = EdgesGeometry;
	function CylinderGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
	  Geometry.call(this);
	  this.type = "CylinderGeometry";
	  this.parameters = {
	    radiusTop: radiusTop,
	    radiusBottom: radiusBottom,
	    height: height,
	    radialSegments: radialSegments,
	    heightSegments: heightSegments,
	    openEnded: openEnded,
	    thetaStart: thetaStart,
	    thetaLength: thetaLength
	  };
	  this.fromBufferGeometry(new CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength));
	  this.mergeVertices();
	}
	CylinderGeometry.prototype = Object.create(Geometry.prototype);
	CylinderGeometry.prototype.constructor = CylinderGeometry;
	function CylinderBufferGeometry(radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
	  BufferGeometry.call(this);
	  this.type = "CylinderBufferGeometry";
	  this.parameters = {
	    radiusTop: radiusTop,
	    radiusBottom: radiusBottom,
	    height: height,
	    radialSegments: radialSegments,
	    heightSegments: heightSegments,
	    openEnded: openEnded,
	    thetaStart: thetaStart,
	    thetaLength: thetaLength
	  };
	  var scope = this;
	  radiusTop = radiusTop !== undefined ? radiusTop : 1;
	  radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
	  height = height || 1;
	  radialSegments = Math.floor(radialSegments) || 8;
	  heightSegments = Math.floor(heightSegments) || 1;
	  openEnded = openEnded !== undefined ? openEnded : false;
	  thetaStart = thetaStart !== undefined ? thetaStart : 0;
	  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	  var indices = [];
	  var vertices = [];
	  var normals = [];
	  var uvs = [];
	  var index = 0;
	  var indexArray = [];
	  var halfHeight = height / 2;
	  var groupStart = 0;
	  generateTorso();
	  if (openEnded === false) {
	    if (radiusTop > 0) generateCap(true);
	    if (radiusBottom > 0) generateCap(false);
	  }
	  this.setIndex(indices);
	  this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
	  this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
	  this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
	  function generateTorso() {
	    var x, y;
	    var normal = new Vector3();
	    var vertex = new Vector3();
	    var groupCount = 0;
	    var slope = (radiusBottom - radiusTop) / height;
	    for (y = 0; y <= heightSegments; y++) {
	      var indexRow = [];
	      var v = y / heightSegments;
	      var radius = v * (radiusBottom - radiusTop) + radiusTop;
	      for (x = 0; x <= radialSegments; x++) {
	        var u = x / radialSegments;
	        var theta = u * thetaLength + thetaStart;
	        var sinTheta = Math.sin(theta);
	        var cosTheta = Math.cos(theta);
	        vertex.x = radius * sinTheta;
	        vertex.y = -v * height + halfHeight;
	        vertex.z = radius * cosTheta;
	        vertices.push(vertex.x, vertex.y, vertex.z);
	        normal.set(sinTheta, slope, cosTheta).normalize();
	        normals.push(normal.x, normal.y, normal.z);
	        uvs.push(u, 1 - v);
	        indexRow.push(index++);
	      }
	      indexArray.push(indexRow);
	    }
	    for (x = 0; x < radialSegments; x++) {
	      for (y = 0; y < heightSegments; y++) {
	        var a = indexArray[y][x];
	        var b = indexArray[y + 1][x];
	        var c = indexArray[y + 1][x + 1];
	        var d = indexArray[y][x + 1];
	        indices.push(a, b, d);
	        indices.push(b, c, d);
	        groupCount += 6;
	      }
	    }
	    scope.addGroup(groupStart, groupCount, 0);
	    groupStart += groupCount;
	  }
	  function generateCap(top) {
	    var x, centerIndexStart, centerIndexEnd;
	    var uv = new Vector2();
	    var vertex = new Vector3();
	    var groupCount = 0;
	    var radius = top === true ? radiusTop : radiusBottom;
	    var sign = top === true ? 1 : -1;
	    centerIndexStart = index;
	    for (x = 1; x <= radialSegments; x++) {
	      vertices.push(0, halfHeight * sign, 0);
	      normals.push(0, sign, 0);
	      uvs.push(0.5, 0.5);
	      index++;
	    }
	    centerIndexEnd = index;
	    for (x = 0; x <= radialSegments; x++) {
	      var u = x / radialSegments;
	      var theta = u * thetaLength + thetaStart;
	      var cosTheta = Math.cos(theta);
	      var sinTheta = Math.sin(theta);
	      vertex.x = radius * sinTheta;
	      vertex.y = halfHeight * sign;
	      vertex.z = radius * cosTheta;
	      vertices.push(vertex.x, vertex.y, vertex.z);
	      normals.push(0, sign, 0);
	      uv.x = cosTheta * 0.5 + 0.5;
	      uv.y = sinTheta * 0.5 * sign + 0.5;
	      uvs.push(uv.x, uv.y);
	      index++;
	    }
	    for (x = 0; x < radialSegments; x++) {
	      var c = centerIndexStart + x;
	      var i = centerIndexEnd + x;
	      if (top === true) {
	        indices.push(i, i + 1, c);
	      } else {
	        indices.push(i + 1, i, c);
	      }
	      groupCount += 3;
	    }
	    scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);
	    groupStart += groupCount;
	  }
	}
	CylinderBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
	CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;
	function ConeGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
	  CylinderGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
	  this.type = "ConeGeometry";
	  this.parameters = {
	    radius: radius,
	    height: height,
	    radialSegments: radialSegments,
	    heightSegments: heightSegments,
	    openEnded: openEnded,
	    thetaStart: thetaStart,
	    thetaLength: thetaLength
	  };
	}
	ConeGeometry.prototype = Object.create(CylinderGeometry.prototype);
	ConeGeometry.prototype.constructor = ConeGeometry;
	function ConeBufferGeometry(radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength) {
	  CylinderBufferGeometry.call(this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);
	  this.type = "ConeBufferGeometry";
	  this.parameters = {
	    radius: radius,
	    height: height,
	    radialSegments: radialSegments,
	    heightSegments: heightSegments,
	    openEnded: openEnded,
	    thetaStart: thetaStart,
	    thetaLength: thetaLength
	  };
	}
	ConeBufferGeometry.prototype = Object.create(CylinderBufferGeometry.prototype);
	ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;
	function CircleGeometry(radius, segments, thetaStart, thetaLength) {
	  Geometry.call(this);
	  this.type = "CircleGeometry";
	  this.parameters = {
	    radius: radius,
	    segments: segments,
	    thetaStart: thetaStart,
	    thetaLength: thetaLength
	  };
	  this.fromBufferGeometry(new CircleBufferGeometry(radius, segments, thetaStart, thetaLength));
	  this.mergeVertices();
	}
	CircleGeometry.prototype = Object.create(Geometry.prototype);
	CircleGeometry.prototype.constructor = CircleGeometry;
	function CircleBufferGeometry(radius, segments, thetaStart, thetaLength) {
	  BufferGeometry.call(this);
	  this.type = "CircleBufferGeometry";
	  this.parameters = {
	    radius: radius,
	    segments: segments,
	    thetaStart: thetaStart,
	    thetaLength: thetaLength
	  };
	  radius = radius || 1;
	  segments = segments !== undefined ? Math.max(3, segments) : 8;
	  thetaStart = thetaStart !== undefined ? thetaStart : 0;
	  thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	  var indices = [];
	  var vertices = [];
	  var normals = [];
	  var uvs = [];
	  var i, s;
	  var vertex = new Vector3();
	  var uv = new Vector2();
	  vertices.push(0, 0, 0);
	  normals.push(0, 0, 1);
	  uvs.push(0.5, 0.5);
	  for ((s = 0, i = 3); s <= segments; (s++, i += 3)) {
	    var segment = thetaStart + s / segments * thetaLength;
	    vertex.x = radius * Math.cos(segment);
	    vertex.y = radius * Math.sin(segment);
	    vertices.push(vertex.x, vertex.y, vertex.z);
	    normals.push(0, 0, 1);
	    uv.x = (vertices[i] / radius + 1) / 2;
	    uv.y = (vertices[i + 1] / radius + 1) / 2;
	    uvs.push(uv.x, uv.y);
	  }
	  for (i = 1; i <= segments; i++) {
	    indices.push(i, i + 1, 0);
	  }
	  this.setIndex(indices);
	  this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
	  this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
	  this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
	}
	CircleBufferGeometry.prototype = Object.create(BufferGeometry.prototype);
	CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;
	var Geometries = Object.freeze({
	  __proto__: null,
	  WireframeGeometry: WireframeGeometry,
	  ParametricGeometry: ParametricGeometry,
	  ParametricBufferGeometry: ParametricBufferGeometry,
	  TetrahedronGeometry: TetrahedronGeometry,
	  TetrahedronBufferGeometry: TetrahedronBufferGeometry,
	  OctahedronGeometry: OctahedronGeometry,
	  OctahedronBufferGeometry: OctahedronBufferGeometry,
	  IcosahedronGeometry: IcosahedronGeometry,
	  IcosahedronBufferGeometry: IcosahedronBufferGeometry,
	  DodecahedronGeometry: DodecahedronGeometry,
	  DodecahedronBufferGeometry: DodecahedronBufferGeometry,
	  PolyhedronGeometry: PolyhedronGeometry,
	  PolyhedronBufferGeometry: PolyhedronBufferGeometry,
	  TubeGeometry: TubeGeometry,
	  TubeBufferGeometry: TubeBufferGeometry,
	  TorusKnotGeometry: TorusKnotGeometry,
	  TorusKnotBufferGeometry: TorusKnotBufferGeometry,
	  TorusGeometry: TorusGeometry,
	  TorusBufferGeometry: TorusBufferGeometry,
	  TextGeometry: TextGeometry,
	  TextBufferGeometry: TextBufferGeometry,
	  SphereGeometry: SphereGeometry,
	  SphereBufferGeometry: SphereBufferGeometry,
	  RingGeometry: RingGeometry,
	  RingBufferGeometry: RingBufferGeometry,
	  PlaneGeometry: PlaneGeometry,
	  PlaneBufferGeometry: PlaneBufferGeometry,
	  LatheGeometry: LatheGeometry,
	  LatheBufferGeometry: LatheBufferGeometry,
	  ShapeGeometry: ShapeGeometry,
	  ShapeBufferGeometry: ShapeBufferGeometry,
	  ExtrudeGeometry: ExtrudeGeometry,
	  ExtrudeBufferGeometry: ExtrudeBufferGeometry,
	  EdgesGeometry: EdgesGeometry,
	  ConeGeometry: ConeGeometry,
	  ConeBufferGeometry: ConeBufferGeometry,
	  CylinderGeometry: CylinderGeometry,
	  CylinderBufferGeometry: CylinderBufferGeometry,
	  CircleGeometry: CircleGeometry,
	  CircleBufferGeometry: CircleBufferGeometry,
	  BoxGeometry: BoxGeometry,
	  BoxBufferGeometry: BoxBufferGeometry
	});
	function ShadowMaterial(parameters) {
	  Material.call(this);
	  this.type = "ShadowMaterial";
	  this.color = new Color(0);
	  this.transparent = true;
	  this.setValues(parameters);
	}
	ShadowMaterial.prototype = Object.create(Material.prototype);
	ShadowMaterial.prototype.constructor = ShadowMaterial;
	ShadowMaterial.prototype.isShadowMaterial = true;
	ShadowMaterial.prototype.copy = function (source) {
	  Material.prototype.copy.call(this, source);
	  this.color.copy(source.color);
	  return this;
	};
	function RawShaderMaterial(parameters) {
	  ShaderMaterial.call(this, parameters);
	  this.type = "RawShaderMaterial";
	}
	RawShaderMaterial.prototype = Object.create(ShaderMaterial.prototype);
	RawShaderMaterial.prototype.constructor = RawShaderMaterial;
	RawShaderMaterial.prototype.isRawShaderMaterial = true;
	function MeshStandardMaterial(parameters) {
	  Material.call(this);
	  this.defines = {
	    "STANDARD": ""
	  };
	  this.type = "MeshStandardMaterial";
	  this.color = new Color(16777215);
	  this.roughness = 1;
	  this.metalness = 0;
	  this.map = null;
	  this.lightMap = null;
	  this.lightMapIntensity = 1;
	  this.aoMap = null;
	  this.aoMapIntensity = 1;
	  this.emissive = new Color(0);
	  this.emissiveIntensity = 1;
	  this.emissiveMap = null;
	  this.bumpMap = null;
	  this.bumpScale = 1;
	  this.normalMap = null;
	  this.normalMapType = TangentSpaceNormalMap;
	  this.normalScale = new Vector2(1, 1);
	  this.displacementMap = null;
	  this.displacementScale = 1;
	  this.displacementBias = 0;
	  this.roughnessMap = null;
	  this.metalnessMap = null;
	  this.alphaMap = null;
	  this.envMap = null;
	  this.envMapIntensity = 1;
	  this.refractionRatio = 0.98;
	  this.wireframe = false;
	  this.wireframeLinewidth = 1;
	  this.wireframeLinecap = "round";
	  this.wireframeLinejoin = "round";
	  this.skinning = false;
	  this.morphTargets = false;
	  this.morphNormals = false;
	  this.vertexTangents = false;
	  this.setValues(parameters);
	}
	MeshStandardMaterial.prototype = Object.create(Material.prototype);
	MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
	MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
	MeshStandardMaterial.prototype.copy = function (source) {
	  Material.prototype.copy.call(this, source);
	  this.defines = {
	    "STANDARD": ""
	  };
	  this.color.copy(source.color);
	  this.roughness = source.roughness;
	  this.metalness = source.metalness;
	  this.map = source.map;
	  this.lightMap = source.lightMap;
	  this.lightMapIntensity = source.lightMapIntensity;
	  this.aoMap = source.aoMap;
	  this.aoMapIntensity = source.aoMapIntensity;
	  this.emissive.copy(source.emissive);
	  this.emissiveMap = source.emissiveMap;
	  this.emissiveIntensity = source.emissiveIntensity;
	  this.bumpMap = source.bumpMap;
	  this.bumpScale = source.bumpScale;
	  this.normalMap = source.normalMap;
	  this.normalMapType = source.normalMapType;
	  this.normalScale.copy(source.normalScale);
	  this.displacementMap = source.displacementMap;
	  this.displacementScale = source.displacementScale;
	  this.displacementBias = source.displacementBias;
	  this.roughnessMap = source.roughnessMap;
	  this.metalnessMap = source.metalnessMap;
	  this.alphaMap = source.alphaMap;
	  this.envMap = source.envMap;
	  this.envMapIntensity = source.envMapIntensity;
	  this.refractionRatio = source.refractionRatio;
	  this.wireframe = source.wireframe;
	  this.wireframeLinewidth = source.wireframeLinewidth;
	  this.wireframeLinecap = source.wireframeLinecap;
	  this.wireframeLinejoin = source.wireframeLinejoin;
	  this.skinning = source.skinning;
	  this.morphTargets = source.morphTargets;
	  this.morphNormals = source.morphNormals;
	  this.vertexTangents = source.vertexTangents;
	  return this;
	};
	function MeshPhysicalMaterial(parameters) {
	  MeshStandardMaterial.call(this);
	  this.defines = {
	    "STANDARD": "",
	    "PHYSICAL": ""
	  };
	  this.type = "MeshPhysicalMaterial";
	  this.reflectivity = 0.5;
	  this.clearcoat = 0;
	  this.clearcoatRoughness = 0;
	  this.sheen = null;
	  this.clearcoatNormalScale = new Vector2(1, 1);
	  this.clearcoatNormalMap = null;
	  this.transparency = 0;
	  this.setValues(parameters);
	}
	MeshPhysicalMaterial.prototype = Object.create(MeshStandardMaterial.prototype);
	MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
	MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
	MeshPhysicalMaterial.prototype.copy = function (source) {
	  MeshStandardMaterial.prototype.copy.call(this, source);
	  this.defines = {
	    "STANDARD": "",
	    "PHYSICAL": ""
	  };
	  this.reflectivity = source.reflectivity;
	  this.clearcoat = source.clearcoat;
	  this.clearcoatRoughness = source.clearcoatRoughness;
	  if (source.sheen) this.sheen = (this.sheen || new Color()).copy(source.sheen); else this.sheen = null;
	  this.clearcoatNormalMap = source.clearcoatNormalMap;
	  this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
	  this.transparency = source.transparency;
	  return this;
	};
	function MeshPhongMaterial(parameters) {
	  Material.call(this);
	  this.type = "MeshPhongMaterial";
	  this.color = new Color(16777215);
	  this.specular = new Color(1118481);
	  this.shininess = 30;
	  this.map = null;
	  this.lightMap = null;
	  this.lightMapIntensity = 1;
	  this.aoMap = null;
	  this.aoMapIntensity = 1;
	  this.emissive = new Color(0);
	  this.emissiveIntensity = 1;
	  this.emissiveMap = null;
	  this.bumpMap = null;
	  this.bumpScale = 1;
	  this.normalMap = null;
	  this.normalMapType = TangentSpaceNormalMap;
	  this.normalScale = new Vector2(1, 1);
	  this.displacementMap = null;
	  this.displacementScale = 1;
	  this.displacementBias = 0;
	  this.specularMap = null;
	  this.alphaMap = null;
	  this.envMap = null;
	  this.combine = MultiplyOperation;
	  this.reflectivity = 1;
	  this.refractionRatio = 0.98;
	  this.wireframe = false;
	  this.wireframeLinewidth = 1;
	  this.wireframeLinecap = "round";
	  this.wireframeLinejoin = "round";
	  this.skinning = false;
	  this.morphTargets = false;
	  this.morphNormals = false;
	  this.setValues(parameters);
	}
	MeshPhongMaterial.prototype = Object.create(Material.prototype);
	MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
	MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
	MeshPhongMaterial.prototype.copy = function (source) {
	  Material.prototype.copy.call(this, source);
	  this.color.copy(source.color);
	  this.specular.copy(source.specular);
	  this.shininess = source.shininess;
	  this.map = source.map;
	  this.lightMap = source.lightMap;
	  this.lightMapIntensity = source.lightMapIntensity;
	  this.aoMap = source.aoMap;
	  this.aoMapIntensity = source.aoMapIntensity;
	  this.emissive.copy(source.emissive);
	  this.emissiveMap = source.emissiveMap;
	  this.emissiveIntensity = source.emissiveIntensity;
	  this.bumpMap = source.bumpMap;
	  this.bumpScale = source.bumpScale;
	  this.normalMap = source.normalMap;
	  this.normalMapType = source.normalMapType;
	  this.normalScale.copy(source.normalScale);
	  this.displacementMap = source.displacementMap;
	  this.displacementScale = source.displacementScale;
	  this.displacementBias = source.displacementBias;
	  this.specularMap = source.specularMap;
	  this.alphaMap = source.alphaMap;
	  this.envMap = source.envMap;
	  this.combine = source.combine;
	  this.reflectivity = source.reflectivity;
	  this.refractionRatio = source.refractionRatio;
	  this.wireframe = source.wireframe;
	  this.wireframeLinewidth = source.wireframeLinewidth;
	  this.wireframeLinecap = source.wireframeLinecap;
	  this.wireframeLinejoin = source.wireframeLinejoin;
	  this.skinning = source.skinning;
	  this.morphTargets = source.morphTargets;
	  this.morphNormals = source.morphNormals;
	  return this;
	};
	function MeshToonMaterial(parameters) {
	  Material.call(this);
	  this.defines = {
	    "TOON": ""
	  };
	  this.type = "MeshToonMaterial";
	  this.color = new Color(16777215);
	  this.specular = new Color(1118481);
	  this.shininess = 30;
	  this.map = null;
	  this.gradientMap = null;
	  this.lightMap = null;
	  this.lightMapIntensity = 1;
	  this.aoMap = null;
	  this.aoMapIntensity = 1;
	  this.emissive = new Color(0);
	  this.emissiveIntensity = 1;
	  this.emissiveMap = null;
	  this.bumpMap = null;
	  this.bumpScale = 1;
	  this.normalMap = null;
	  this.normalMapType = TangentSpaceNormalMap;
	  this.normalScale = new Vector2(1, 1);
	  this.displacementMap = null;
	  this.displacementScale = 1;
	  this.displacementBias = 0;
	  this.specularMap = null;
	  this.alphaMap = null;
	  this.wireframe = false;
	  this.wireframeLinewidth = 1;
	  this.wireframeLinecap = "round";
	  this.wireframeLinejoin = "round";
	  this.skinning = false;
	  this.morphTargets = false;
	  this.morphNormals = false;
	  this.setValues(parameters);
	}
	MeshToonMaterial.prototype = Object.create(Material.prototype);
	MeshToonMaterial.prototype.constructor = MeshToonMaterial;
	MeshToonMaterial.prototype.isMeshToonMaterial = true;
	MeshToonMaterial.prototype.copy = function (source) {
	  Material.prototype.copy.call(this, source);
	  this.color.copy(source.color);
	  this.specular.copy(source.specular);
	  this.shininess = source.shininess;
	  this.map = source.map;
	  this.gradientMap = source.gradientMap;
	  this.lightMap = source.lightMap;
	  this.lightMapIntensity = source.lightMapIntensity;
	  this.aoMap = source.aoMap;
	  this.aoMapIntensity = source.aoMapIntensity;
	  this.emissive.copy(source.emissive);
	  this.emissiveMap = source.emissiveMap;
	  this.emissiveIntensity = source.emissiveIntensity;
	  this.bumpMap = source.bumpMap;
	  this.bumpScale = source.bumpScale;
	  this.normalMap = source.normalMap;
	  this.normalMapType = source.normalMapType;
	  this.normalScale.copy(source.normalScale);
	  this.displacementMap = source.displacementMap;
	  this.displacementScale = source.displacementScale;
	  this.displacementBias = source.displacementBias;
	  this.specularMap = source.specularMap;
	  this.alphaMap = source.alphaMap;
	  this.wireframe = source.wireframe;
	  this.wireframeLinewidth = source.wireframeLinewidth;
	  this.wireframeLinecap = source.wireframeLinecap;
	  this.wireframeLinejoin = source.wireframeLinejoin;
	  this.skinning = source.skinning;
	  this.morphTargets = source.morphTargets;
	  this.morphNormals = source.morphNormals;
	  return this;
	};
	function MeshNormalMaterial(parameters) {
	  Material.call(this);
	  this.type = "MeshNormalMaterial";
	  this.bumpMap = null;
	  this.bumpScale = 1;
	  this.normalMap = null;
	  this.normalMapType = TangentSpaceNormalMap;
	  this.normalScale = new Vector2(1, 1);
	  this.displacementMap = null;
	  this.displacementScale = 1;
	  this.displacementBias = 0;
	  this.wireframe = false;
	  this.wireframeLinewidth = 1;
	  this.fog = false;
	  this.skinning = false;
	  this.morphTargets = false;
	  this.morphNormals = false;
	  this.setValues(parameters);
	}
	MeshNormalMaterial.prototype = Object.create(Material.prototype);
	MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
	MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
	MeshNormalMaterial.prototype.copy = function (source) {
	  Material.prototype.copy.call(this, source);
	  this.bumpMap = source.bumpMap;
	  this.bumpScale = source.bumpScale;
	  this.normalMap = source.normalMap;
	  this.normalMapType = source.normalMapType;
	  this.normalScale.copy(source.normalScale);
	  this.displacementMap = source.displacementMap;
	  this.displacementScale = source.displacementScale;
	  this.displacementBias = source.displacementBias;
	  this.wireframe = source.wireframe;
	  this.wireframeLinewidth = source.wireframeLinewidth;
	  this.skinning = source.skinning;
	  this.morphTargets = source.morphTargets;
	  this.morphNormals = source.morphNormals;
	  return this;
	};
	function MeshLambertMaterial(parameters) {
	  Material.call(this);
	  this.type = "MeshLambertMaterial";
	  this.color = new Color(16777215);
	  this.map = null;
	  this.lightMap = null;
	  this.lightMapIntensity = 1;
	  this.aoMap = null;
	  this.aoMapIntensity = 1;
	  this.emissive = new Color(0);
	  this.emissiveIntensity = 1;
	  this.emissiveMap = null;
	  this.specularMap = null;
	  this.alphaMap = null;
	  this.envMap = null;
	  this.combine = MultiplyOperation;
	  this.reflectivity = 1;
	  this.refractionRatio = 0.98;
	  this.wireframe = false;
	  this.wireframeLinewidth = 1;
	  this.wireframeLinecap = "round";
	  this.wireframeLinejoin = "round";
	  this.skinning = false;
	  this.morphTargets = false;
	  this.morphNormals = false;
	  this.setValues(parameters);
	}
	MeshLambertMaterial.prototype = Object.create(Material.prototype);
	MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
	MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
	MeshLambertMaterial.prototype.copy = function (source) {
	  Material.prototype.copy.call(this, source);
	  this.color.copy(source.color);
	  this.map = source.map;
	  this.lightMap = source.lightMap;
	  this.lightMapIntensity = source.lightMapIntensity;
	  this.aoMap = source.aoMap;
	  this.aoMapIntensity = source.aoMapIntensity;
	  this.emissive.copy(source.emissive);
	  this.emissiveMap = source.emissiveMap;
	  this.emissiveIntensity = source.emissiveIntensity;
	  this.specularMap = source.specularMap;
	  this.alphaMap = source.alphaMap;
	  this.envMap = source.envMap;
	  this.combine = source.combine;
	  this.reflectivity = source.reflectivity;
	  this.refractionRatio = source.refractionRatio;
	  this.wireframe = source.wireframe;
	  this.wireframeLinewidth = source.wireframeLinewidth;
	  this.wireframeLinecap = source.wireframeLinecap;
	  this.wireframeLinejoin = source.wireframeLinejoin;
	  this.skinning = source.skinning;
	  this.morphTargets = source.morphTargets;
	  this.morphNormals = source.morphNormals;
	  return this;
	};
	function MeshMatcapMaterial(parameters) {
	  Material.call(this);
	  this.defines = {
	    "MATCAP": ""
	  };
	  this.type = "MeshMatcapMaterial";
	  this.color = new Color(16777215);
	  this.matcap = null;
	  this.map = null;
	  this.bumpMap = null;
	  this.bumpScale = 1;
	  this.normalMap = null;
	  this.normalMapType = TangentSpaceNormalMap;
	  this.normalScale = new Vector2(1, 1);
	  this.displacementMap = null;
	  this.displacementScale = 1;
	  this.displacementBias = 0;
	  this.alphaMap = null;
	  this.skinning = false;
	  this.morphTargets = false;
	  this.morphNormals = false;
	  this.setValues(parameters);
	}
	MeshMatcapMaterial.prototype = Object.create(Material.prototype);
	MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;
	MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
	MeshMatcapMaterial.prototype.copy = function (source) {
	  Material.prototype.copy.call(this, source);
	  this.defines = {
	    "MATCAP": ""
	  };
	  this.color.copy(source.color);
	  this.matcap = source.matcap;
	  this.map = source.map;
	  this.bumpMap = source.bumpMap;
	  this.bumpScale = source.bumpScale;
	  this.normalMap = source.normalMap;
	  this.normalMapType = source.normalMapType;
	  this.normalScale.copy(source.normalScale);
	  this.displacementMap = source.displacementMap;
	  this.displacementScale = source.displacementScale;
	  this.displacementBias = source.displacementBias;
	  this.alphaMap = source.alphaMap;
	  this.skinning = source.skinning;
	  this.morphTargets = source.morphTargets;
	  this.morphNormals = source.morphNormals;
	  return this;
	};
	function LineDashedMaterial(parameters) {
	  LineBasicMaterial.call(this);
	  this.type = "LineDashedMaterial";
	  this.scale = 1;
	  this.dashSize = 3;
	  this.gapSize = 1;
	  this.setValues(parameters);
	}
	LineDashedMaterial.prototype = Object.create(LineBasicMaterial.prototype);
	LineDashedMaterial.prototype.constructor = LineDashedMaterial;
	LineDashedMaterial.prototype.isLineDashedMaterial = true;
	LineDashedMaterial.prototype.copy = function (source) {
	  LineBasicMaterial.prototype.copy.call(this, source);
	  this.scale = source.scale;
	  this.dashSize = source.dashSize;
	  this.gapSize = source.gapSize;
	  return this;
	};
	var Materials = Object.freeze({
	  __proto__: null,
	  ShadowMaterial: ShadowMaterial,
	  SpriteMaterial: SpriteMaterial,
	  RawShaderMaterial: RawShaderMaterial,
	  ShaderMaterial: ShaderMaterial,
	  PointsMaterial: PointsMaterial,
	  MeshPhysicalMaterial: MeshPhysicalMaterial,
	  MeshStandardMaterial: MeshStandardMaterial,
	  MeshPhongMaterial: MeshPhongMaterial,
	  MeshToonMaterial: MeshToonMaterial,
	  MeshNormalMaterial: MeshNormalMaterial,
	  MeshLambertMaterial: MeshLambertMaterial,
	  MeshDepthMaterial: MeshDepthMaterial,
	  MeshDistanceMaterial: MeshDistanceMaterial,
	  MeshBasicMaterial: MeshBasicMaterial,
	  MeshMatcapMaterial: MeshMatcapMaterial,
	  LineDashedMaterial: LineDashedMaterial,
	  LineBasicMaterial: LineBasicMaterial,
	  Material: Material
	});
	var AnimationUtils = {
	  arraySlice: function (array, from, to) {
	    if (AnimationUtils.isTypedArray(array)) {
	      return new array.constructor(array.subarray(from, to !== undefined ? to : array.length));
	    }
	    return array.slice(from, to);
	  },
	  convertArray: function (array, type, forceClone) {
	    if (!array || !forceClone && array.constructor === type) return array;
	    if (typeof type.BYTES_PER_ELEMENT === "number") {
	      return new type(array);
	    }
	    return Array.prototype.slice.call(array);
	  },
	  isTypedArray: function (object) {
	    return ArrayBuffer.isView(object) && !(object instanceof DataView);
	  },
	  getKeyframeOrder: function (times) {
	    function compareTime(i, j) {
	      return times[i] - times[j];
	    }
	    var n = times.length;
	    var result = new Array(n);
	    for (var i = 0; i !== n; ++i) result[i] = i;
	    result.sort(compareTime);
	    return result;
	  },
	  sortedArray: function (values, stride, order) {
	    var nValues = values.length;
	    var result = new values.constructor(nValues);
	    for (var i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
	      var srcOffset = order[i] * stride;
	      for (var j = 0; j !== stride; ++j) {
	        result[dstOffset++] = values[srcOffset + j];
	      }
	    }
	    return result;
	  },
	  flattenJSON: function (jsonKeys, times, values, valuePropertyName) {
	    var i = 1, key = jsonKeys[0];
	    while (key !== undefined && key[valuePropertyName] === undefined) {
	      key = jsonKeys[i++];
	    }
	    if (key === undefined) return;
	    var value = key[valuePropertyName];
	    if (value === undefined) return;
	    if (Array.isArray(value)) {
	      do {
	        value = key[valuePropertyName];
	        if (value !== undefined) {
	          times.push(key.time);
	          values.push.apply(values, value);
	        }
	        key = jsonKeys[i++];
	      } while (key !== undefined);
	    } else if (value.toArray !== undefined) {
	      do {
	        value = key[valuePropertyName];
	        if (value !== undefined) {
	          times.push(key.time);
	          value.toArray(values, values.length);
	        }
	        key = jsonKeys[i++];
	      } while (key !== undefined);
	    } else {
	      do {
	        value = key[valuePropertyName];
	        if (value !== undefined) {
	          times.push(key.time);
	          values.push(value);
	        }
	        key = jsonKeys[i++];
	      } while (key !== undefined);
	    }
	  },
	  subclip: function (sourceClip, name, startFrame, endFrame, fps) {
	    fps = fps || 30;
	    var clip = sourceClip.clone();
	    clip.name = name;
	    var tracks = [];
	    for (var i = 0; i < clip.tracks.length; ++i) {
	      var track = clip.tracks[i];
	      var valueSize = track.getValueSize();
	      var times = [];
	      var values = [];
	      for (var j = 0; j < track.times.length; ++j) {
	        var frame = track.times[j] * fps;
	        if (frame < startFrame || frame >= endFrame) continue;
	        times.push(track.times[j]);
	        for (var k = 0; k < valueSize; ++k) {
	          values.push(track.values[j * valueSize + k]);
	        }
	      }
	      if (times.length === 0) continue;
	      track.times = AnimationUtils.convertArray(times, track.times.constructor);
	      track.values = AnimationUtils.convertArray(values, track.values.constructor);
	      tracks.push(track);
	    }
	    clip.tracks = tracks;
	    var minStartTime = Infinity;
	    for (var i = 0; i < clip.tracks.length; ++i) {
	      if (minStartTime > clip.tracks[i].times[0]) {
	        minStartTime = clip.tracks[i].times[0];
	      }
	    }
	    for (var i = 0; i < clip.tracks.length; ++i) {
	      clip.tracks[i].shift(-1 * minStartTime);
	    }
	    clip.resetDuration();
	    return clip;
	  }
	};
	function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
	  this.parameterPositions = parameterPositions;
	  this._cachedIndex = 0;
	  this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
	  this.sampleValues = sampleValues;
	  this.valueSize = sampleSize;
	}
	Object.assign(Interpolant.prototype, {
	  evaluate: function (t) {
	    var pp = this.parameterPositions, i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
	    validate_interval: {
	      seek: {
	        var right;
	        linear_scan: {
	          forward_scan: if (!(t < t1)) {
	            for (var giveUpAt = i1 + 2; ; ) {
	              if (t1 === undefined) {
	                if (t < t0) break forward_scan;
	                i1 = pp.length;
	                this._cachedIndex = i1;
	                return this.afterEnd_(i1 - 1, t, t0);
	              }
	              if (i1 === giveUpAt) break;
	              t0 = t1;
	              t1 = pp[++i1];
	              if (t < t1) {
	                break seek;
	              }
	            }
	            right = pp.length;
	            break linear_scan;
	          }
	          if (!(t >= t0)) {
	            var t1global = pp[1];
	            if (t < t1global) {
	              i1 = 2;
	              t0 = t1global;
	            }
	            for (var giveUpAt = i1 - 2; ; ) {
	              if (t0 === undefined) {
	                this._cachedIndex = 0;
	                return this.beforeStart_(0, t, t1);
	              }
	              if (i1 === giveUpAt) break;
	              t1 = t0;
	              t0 = pp[--i1 - 1];
	              if (t >= t0) {
	                break seek;
	              }
	            }
	            right = i1;
	            i1 = 0;
	            break linear_scan;
	          }
	          break validate_interval;
	        }
	      }
	    }
	    return this.interpolate_(i1, t0, t, t1);
	  },
	  settings: null,
	  DefaultSettings_: {},
	  getSettings_: function () {
	    return this.settings || this.DefaultSettings_;
	  },
	  copySampleValue_: function (index) {
	    var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
	    for (var i = 0; i !== stride; ++i) {
	      result[i] = values[offset + i];
	    }
	    return result;
	  },
	  interpolate_: function () {
	    throw new Error("call to abstract method");
	  },
	  intervalChanged_: function () {}
	});
	Object.assign(Interpolant.prototype, {
	  beforeStart_: Interpolant.prototype.copySampleValue_,
	  afterEnd_: Interpolant.prototype.copySampleValue_
	});
	function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
	  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
	  this._weightPrev = -0;
	  this._offsetPrev = -0;
	  this._weightNext = -0;
	  this._offsetNext = -0;
	}
	CubicInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
	  constructor: CubicInterpolant,
	  DefaultSettings_: {
	    endingStart: ZeroCurvatureEnding,
	    endingEnd: ZeroCurvatureEnding
	  },
	  intervalChanged_: function (i1, t0, t1) {
	    var pp = this.parameterPositions, iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
	    if (tPrev === undefined) {
	      switch (this.getSettings_().endingStart) {
	        case ZeroSlopeEnding:
	          iPrev = i1;
	          tPrev = 2 * t0 - t1;
	          break;
	        case WrapAroundEnding:
	          iPrev = pp.length - 2;
	          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
	          break;
	        default:
	          iPrev = i1;
	          tPrev = t1;
	      }
	    }
	    if (tNext === undefined) {
	      switch (this.getSettings_().endingEnd) {
	        case ZeroSlopeEnding:
	          iNext = i1;
	          tNext = 2 * t1 - t0;
	          break;
	        case WrapAroundEnding:
	          iNext = 1;
	          tNext = t1 + pp[1] - pp[0];
	          break;
	        default:
	          iNext = i1 - 1;
	          tNext = t0;
	      }
	    }
	    var halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
	    this._weightPrev = halfDt / (t0 - tPrev);
	    this._weightNext = halfDt / (tNext - t1);
	    this._offsetPrev = iPrev * stride;
	    this._offsetNext = iNext * stride;
	  },
	  interpolate_: function (i1, t0, t, t1) {
	    var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;
	    var sP = -wP * ppp + 2 * wP * pp - wP * p;
	    var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
	    var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
	    var sN = wN * ppp - wN * pp;
	    for (var i = 0; i !== stride; ++i) {
	      result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
	    }
	    return result;
	  }
	});
	function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
	  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
	}
	LinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
	  constructor: LinearInterpolant,
	  interpolate_: function (i1, t0, t, t1) {
	    var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;
	    for (var i = 0; i !== stride; ++i) {
	      result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
	    }
	    return result;
	  }
	});
	function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
	  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
	}
	DiscreteInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
	  constructor: DiscreteInterpolant,
	  interpolate_: function (i1) {
	    return this.copySampleValue_(i1 - 1);
	  }
	});
	function KeyframeTrack(name, times, values, interpolation) {
	  if (name === undefined) throw new Error("THREE.KeyframeTrack: track name is undefined");
	  if (times === undefined || times.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
	  this.name = name;
	  this.times = AnimationUtils.convertArray(times, this.TimeBufferType);
	  this.values = AnimationUtils.convertArray(values, this.ValueBufferType);
	  this.setInterpolation(interpolation || this.DefaultInterpolation);
	}
	Object.assign(KeyframeTrack, {
	  toJSON: function (track) {
	    var trackType = track.constructor;
	    var json;
	    if (trackType.toJSON !== undefined) {
	      json = trackType.toJSON(track);
	    } else {
	      json = {
	        "name": track.name,
	        "times": AnimationUtils.convertArray(track.times, Array),
	        "values": AnimationUtils.convertArray(track.values, Array)
	      };
	      var interpolation = track.getInterpolation();
	      if (interpolation !== track.DefaultInterpolation) {
	        json.interpolation = interpolation;
	      }
	    }
	    json.type = track.ValueTypeName;
	    return json;
	  }
	});
	Object.assign(KeyframeTrack.prototype, {
	  constructor: KeyframeTrack,
	  TimeBufferType: Float32Array,
	  ValueBufferType: Float32Array,
	  DefaultInterpolation: InterpolateLinear,
	  InterpolantFactoryMethodDiscrete: function (result) {
	    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
	  },
	  InterpolantFactoryMethodLinear: function (result) {
	    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
	  },
	  InterpolantFactoryMethodSmooth: function (result) {
	    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
	  },
	  setInterpolation: function (interpolation) {
	    var factoryMethod;
	    switch (interpolation) {
	      case InterpolateDiscrete:
	        factoryMethod = this.InterpolantFactoryMethodDiscrete;
	        break;
	      case InterpolateLinear:
	        factoryMethod = this.InterpolantFactoryMethodLinear;
	        break;
	      case InterpolateSmooth:
	        factoryMethod = this.InterpolantFactoryMethodSmooth;
	        break;
	    }
	    if (factoryMethod === undefined) {
	      var message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
	      if (this.createInterpolant === undefined) {
	        if (interpolation !== this.DefaultInterpolation) {
	          this.setInterpolation(this.DefaultInterpolation);
	        } else {
	          throw new Error(message);
	        }
	      }
	      console.warn("THREE.KeyframeTrack:", message);
	      return this;
	    }
	    this.createInterpolant = factoryMethod;
	    return this;
	  },
	  getInterpolation: function () {
	    switch (this.createInterpolant) {
	      case this.InterpolantFactoryMethodDiscrete:
	        return InterpolateDiscrete;
	      case this.InterpolantFactoryMethodLinear:
	        return InterpolateLinear;
	      case this.InterpolantFactoryMethodSmooth:
	        return InterpolateSmooth;
	    }
	  },
	  getValueSize: function () {
	    return this.values.length / this.times.length;
	  },
	  shift: function (timeOffset) {
	    if (timeOffset !== 0) {
	      var times = this.times;
	      for (var i = 0, n = times.length; i !== n; ++i) {
	        times[i] += timeOffset;
	      }
	    }
	    return this;
	  },
	  scale: function (timeScale) {
	    if (timeScale !== 1) {
	      var times = this.times;
	      for (var i = 0, n = times.length; i !== n; ++i) {
	        times[i] *= timeScale;
	      }
	    }
	    return this;
	  },
	  trim: function (startTime, endTime) {
	    var times = this.times, nKeys = times.length, from = 0, to = nKeys - 1;
	    while (from !== nKeys && times[from] < startTime) {
	      ++from;
	    }
	    while (to !== -1 && times[to] > endTime) {
	      --to;
	    }
	    ++to;
	    if (from !== 0 || to !== nKeys) {
	      if (from >= to) {
	        to = Math.max(to, 1);
	        from = to - 1;
	      }
	      var stride = this.getValueSize();
	      this.times = AnimationUtils.arraySlice(times, from, to);
	      this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);
	    }
	    return this;
	  },
	  validate: function () {
	    var valid = true;
	    var valueSize = this.getValueSize();
	    if (valueSize - Math.floor(valueSize) !== 0) {
	      console.error("THREE.KeyframeTrack: Invalid value size in track.", this);
	      valid = false;
	    }
	    var times = this.times, values = this.values, nKeys = times.length;
	    if (nKeys === 0) {
	      console.error("THREE.KeyframeTrack: Track is empty.", this);
	      valid = false;
	    }
	    var prevTime = null;
	    for (var i = 0; i !== nKeys; i++) {
	      var currTime = times[i];
	      if (typeof currTime === "number" && isNaN(currTime)) {
	        console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i, currTime);
	        valid = false;
	        break;
	      }
	      if (prevTime !== null && prevTime > currTime) {
	        console.error("THREE.KeyframeTrack: Out of order keys.", this, i, currTime, prevTime);
	        valid = false;
	        break;
	      }
	      prevTime = currTime;
	    }
	    if (values !== undefined) {
	      if (AnimationUtils.isTypedArray(values)) {
	        for (var i = 0, n = values.length; i !== n; ++i) {
	          var value = values[i];
	          if (isNaN(value)) {
	            console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i, value);
	            valid = false;
	            break;
	          }
	        }
	      }
	    }
	    return valid;
	  },
	  optimize: function () {
	    var times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, writeIndex = 1, lastIndex = times.length - 1;
	    for (var i = 1; i < lastIndex; ++i) {
	      var keep = false;
	      var time = times[i];
	      var timeNext = times[i + 1];
	      if (time !== timeNext && (i !== 1 || time !== time[0])) {
	        if (!smoothInterpolation) {
	          var offset = i * stride, offsetP = offset - stride, offsetN = offset + stride;
	          for (var j = 0; j !== stride; ++j) {
	            var value = values[offset + j];
	            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
	              keep = true;
	              break;
	            }
	          }
	        } else {
	          keep = true;
	        }
	      }
	      if (keep) {
	        if (i !== writeIndex) {
	          times[writeIndex] = times[i];
	          var readOffset = i * stride, writeOffset = writeIndex * stride;
	          for (var j = 0; j !== stride; ++j) {
	            values[writeOffset + j] = values[readOffset + j];
	          }
	        }
	        ++writeIndex;
	      }
	    }
	    if (lastIndex > 0) {
	      times[writeIndex] = times[lastIndex];
	      for (var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {
	        values[writeOffset + j] = values[readOffset + j];
	      }
	      ++writeIndex;
	    }
	    if (writeIndex !== times.length) {
	      this.times = AnimationUtils.arraySlice(times, 0, writeIndex);
	      this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);
	    } else {
	      this.times = times;
	      this.values = values;
	    }
	    return this;
	  },
	  clone: function () {
	    var times = AnimationUtils.arraySlice(this.times, 0);
	    var values = AnimationUtils.arraySlice(this.values, 0);
	    var TypedKeyframeTrack = this.constructor;
	    var track = new TypedKeyframeTrack(this.name, times, values);
	    track.createInterpolant = this.createInterpolant;
	    return track;
	  }
	});
	function BooleanKeyframeTrack(name, times, values) {
	  KeyframeTrack.call(this, name, times, values);
	}
	BooleanKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
	  constructor: BooleanKeyframeTrack,
	  ValueTypeName: "bool",
	  ValueBufferType: Array,
	  DefaultInterpolation: InterpolateDiscrete,
	  InterpolantFactoryMethodLinear: undefined,
	  InterpolantFactoryMethodSmooth: undefined
	});
	function ColorKeyframeTrack(name, times, values, interpolation) {
	  KeyframeTrack.call(this, name, times, values, interpolation);
	}
	ColorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
	  constructor: ColorKeyframeTrack,
	  ValueTypeName: "color"
	});
	function NumberKeyframeTrack(name, times, values, interpolation) {
	  KeyframeTrack.call(this, name, times, values, interpolation);
	}
	NumberKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
	  constructor: NumberKeyframeTrack,
	  ValueTypeName: "number"
	});
	function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
	  Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
	}
	QuaternionLinearInterpolant.prototype = Object.assign(Object.create(Interpolant.prototype), {
	  constructor: QuaternionLinearInterpolant,
	  interpolate_: function (i1, t0, t, t1) {
	    var result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = i1 * stride, alpha = (t - t0) / (t1 - t0);
	    for (var end = offset + stride; offset !== end; offset += 4) {
	      Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
	    }
	    return result;
	  }
	});
	function QuaternionKeyframeTrack(name, times, values, interpolation) {
	  KeyframeTrack.call(this, name, times, values, interpolation);
	}
	QuaternionKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
	  constructor: QuaternionKeyframeTrack,
	  ValueTypeName: "quaternion",
	  DefaultInterpolation: InterpolateLinear,
	  InterpolantFactoryMethodLinear: function (result) {
	    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
	  },
	  InterpolantFactoryMethodSmooth: undefined
	});
	function StringKeyframeTrack(name, times, values, interpolation) {
	  KeyframeTrack.call(this, name, times, values, interpolation);
	}
	StringKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
	  constructor: StringKeyframeTrack,
	  ValueTypeName: "string",
	  ValueBufferType: Array,
	  DefaultInterpolation: InterpolateDiscrete,
	  InterpolantFactoryMethodLinear: undefined,
	  InterpolantFactoryMethodSmooth: undefined
	});
	function VectorKeyframeTrack(name, times, values, interpolation) {
	  KeyframeTrack.call(this, name, times, values, interpolation);
	}
	VectorKeyframeTrack.prototype = Object.assign(Object.create(KeyframeTrack.prototype), {
	  constructor: VectorKeyframeTrack,
	  ValueTypeName: "vector"
	});
	function AnimationClip(name, duration, tracks) {
	  this.name = name;
	  this.tracks = tracks;
	  this.duration = duration !== undefined ? duration : -1;
	  this.uuid = MathUtils.generateUUID();
	  if (this.duration < 0) {
	    this.resetDuration();
	  }
	}
	function getTrackTypeForValueTypeName(typeName) {
	  switch (typeName.toLowerCase()) {
	    case "scalar":
	    case "double":
	    case "float":
	    case "number":
	    case "integer":
	      return NumberKeyframeTrack;
	    case "vector":
	    case "vector2":
	    case "vector3":
	    case "vector4":
	      return VectorKeyframeTrack;
	    case "color":
	      return ColorKeyframeTrack;
	    case "quaternion":
	      return QuaternionKeyframeTrack;
	    case "bool":
	    case "boolean":
	      return BooleanKeyframeTrack;
	    case "string":
	      return StringKeyframeTrack;
	  }
	  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
	}
	function parseKeyframeTrack(json) {
	  if (json.type === undefined) {
	    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
	  }
	  var trackType = getTrackTypeForValueTypeName(json.type);
	  if (json.times === undefined) {
	    var times = [], values = [];
	    AnimationUtils.flattenJSON(json.keys, times, values, "value");
	    json.times = times;
	    json.values = values;
	  }
	  if (trackType.parse !== undefined) {
	    return trackType.parse(json);
	  } else {
	    return new trackType(json.name, json.times, json.values, json.interpolation);
	  }
	}
	Object.assign(AnimationClip, {
	  parse: function (json) {
	    var tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
	    for (var i = 0, n = jsonTracks.length; i !== n; ++i) {
	      tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
	    }
	    return new AnimationClip(json.name, json.duration, tracks);
	  },
	  toJSON: function (clip) {
	    var tracks = [], clipTracks = clip.tracks;
	    var json = {
	      "name": clip.name,
	      "duration": clip.duration,
	      "tracks": tracks,
	      "uuid": clip.uuid
	    };
	    for (var i = 0, n = clipTracks.length; i !== n; ++i) {
	      tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
	    }
	    return json;
	  },
	  CreateFromMorphTargetSequence: function (name, morphTargetSequence, fps, noLoop) {
	    var numMorphTargets = morphTargetSequence.length;
	    var tracks = [];
	    for (var i = 0; i < numMorphTargets; i++) {
	      var times = [];
	      var values = [];
	      times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
	      values.push(0, 1, 0);
	      var order = AnimationUtils.getKeyframeOrder(times);
	      times = AnimationUtils.sortedArray(times, 1, order);
	      values = AnimationUtils.sortedArray(values, 1, order);
	      if (!noLoop && times[0] === 0) {
	        times.push(numMorphTargets);
	        values.push(values[0]);
	      }
	      tracks.push(new NumberKeyframeTrack(".morphTargetInfluences[" + morphTargetSequence[i].name + "]", times, values).scale(1 / fps));
	    }
	    return new AnimationClip(name, -1, tracks);
	  },
	  findByName: function (objectOrClipArray, name) {
	    var clipArray = objectOrClipArray;
	    if (!Array.isArray(objectOrClipArray)) {
	      var o = objectOrClipArray;
	      clipArray = o.geometry && o.geometry.animations || o.animations;
	    }
	    for (var i = 0; i < clipArray.length; i++) {
	      if (clipArray[i].name === name) {
	        return clipArray[i];
	      }
	    }
	    return null;
	  },
	  CreateClipsFromMorphTargetSequences: function (morphTargets, fps, noLoop) {
	    var animationToMorphTargets = {};
	    var pattern = /^([\w-]*?)([\d]+)$/;
	    for (var i = 0, il = morphTargets.length; i < il; i++) {
	      var morphTarget = morphTargets[i];
	      var parts = morphTarget.name.match(pattern);
	      if (parts && parts.length > 1) {
	        var name = parts[1];
	        var animationMorphTargets = animationToMorphTargets[name];
	        if (!animationMorphTargets) {
	          animationToMorphTargets[name] = animationMorphTargets = [];
	        }
	        animationMorphTargets.push(morphTarget);
	      }
	    }
	    var clips = [];
	    for (var name in animationToMorphTargets) {
	      clips.push(AnimationClip.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
	    }
	    return clips;
	  },
	  parseAnimation: function (animation, bones) {
	    if (!animation) {
	      console.error("THREE.AnimationClip: No animation in JSONLoader data.");
	      return null;
	    }
	    var addNonemptyTrack = function (trackType, trackName, animationKeys, propertyName, destTracks) {
	      if (animationKeys.length !== 0) {
	        var times = [];
	        var values = [];
	        AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);
	        if (times.length !== 0) {
	          destTracks.push(new trackType(trackName, times, values));
	        }
	      }
	    };
	    var tracks = [];
	    var clipName = animation.name || "default";
	    var duration = animation.length || -1;
	    var fps = animation.fps || 30;
	    var hierarchyTracks = animation.hierarchy || [];
	    for (var h = 0; h < hierarchyTracks.length; h++) {
	      var animationKeys = hierarchyTracks[h].keys;
	      if (!animationKeys || animationKeys.length === 0) continue;
	      if (animationKeys[0].morphTargets) {
	        var morphTargetNames = {};
	        for (var k = 0; k < animationKeys.length; k++) {
	          if (animationKeys[k].morphTargets) {
	            for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {
	              morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
	            }
	          }
	        }
	        for (var morphTargetName in morphTargetNames) {
	          var times = [];
	          var values = [];
	          for (var m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
	            var animationKey = animationKeys[k];
	            times.push(animationKey.time);
	            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
	          }
	          tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
	        }
	        duration = morphTargetNames.length * (fps || 1);
	      } else {
	        var boneName = ".bones[" + bones[h].name + "]";
	        addNonemptyTrack(VectorKeyframeTrack, boneName + ".position", animationKeys, "pos", tracks);
	        addNonemptyTrack(QuaternionKeyframeTrack, boneName + ".quaternion", animationKeys, "rot", tracks);
	        addNonemptyTrack(VectorKeyframeTrack, boneName + ".scale", animationKeys, "scl", tracks);
	      }
	    }
	    if (tracks.length === 0) {
	      return null;
	    }
	    var clip = new AnimationClip(clipName, duration, tracks);
	    return clip;
	  }
	});
	Object.assign(AnimationClip.prototype, {
	  resetDuration: function () {
	    var tracks = this.tracks, duration = 0;
	    for (var i = 0, n = tracks.length; i !== n; ++i) {
	      var track = this.tracks[i];
	      duration = Math.max(duration, track.times[track.times.length - 1]);
	    }
	    this.duration = duration;
	    return this;
	  },
	  trim: function () {
	    for (var i = 0; i < this.tracks.length; i++) {
	      this.tracks[i].trim(0, this.duration);
	    }
	    return this;
	  },
	  validate: function () {
	    var valid = true;
	    for (var i = 0; i < this.tracks.length; i++) {
	      valid = valid && this.tracks[i].validate();
	    }
	    return valid;
	  },
	  optimize: function () {
	    for (var i = 0; i < this.tracks.length; i++) {
	      this.tracks[i].optimize();
	    }
	    return this;
	  },
	  clone: function () {
	    var tracks = [];
	    for (var i = 0; i < this.tracks.length; i++) {
	      tracks.push(this.tracks[i].clone());
	    }
	    return new AnimationClip(this.name, this.duration, tracks);
	  }
	});
	var Cache = {
	  enabled: false,
	  files: {},
	  add: function (key, file) {
	    if (this.enabled === false) return;
	    this.files[key] = file;
	  },
	  get: function (key) {
	    if (this.enabled === false) return;
	    return this.files[key];
	  },
	  remove: function (key) {
	    delete this.files[key];
	  },
	  clear: function () {
	    this.files = {};
	  }
	};
	function LoadingManager(onLoad, onProgress, onError) {
	  var scope = this;
	  var isLoading = false;
	  var itemsLoaded = 0;
	  var itemsTotal = 0;
	  var urlModifier = undefined;
	  var handlers = [];
	  this.onStart = undefined;
	  this.onLoad = onLoad;
	  this.onProgress = onProgress;
	  this.onError = onError;
	  this.itemStart = function (url) {
	    itemsTotal++;
	    if (isLoading === false) {
	      if (scope.onStart !== undefined) {
	        scope.onStart(url, itemsLoaded, itemsTotal);
	      }
	    }
	    isLoading = true;
	  };
	  this.itemEnd = function (url) {
	    itemsLoaded++;
	    if (scope.onProgress !== undefined) {
	      scope.onProgress(url, itemsLoaded, itemsTotal);
	    }
	    if (itemsLoaded === itemsTotal) {
	      isLoading = false;
	      if (scope.onLoad !== undefined) {
	        scope.onLoad();
	      }
	    }
	  };
	  this.itemError = function (url) {
	    if (scope.onError !== undefined) {
	      scope.onError(url);
	    }
	  };
	  this.resolveURL = function (url) {
	    if (urlModifier) {
	      return urlModifier(url);
	    }
	    return url;
	  };
	  this.setURLModifier = function (transform) {
	    urlModifier = transform;
	    return this;
	  };
	  this.addHandler = function (regex, loader) {
	    handlers.push(regex, loader);
	    return this;
	  };
	  this.removeHandler = function (regex) {
	    var index = handlers.indexOf(regex);
	    if (index !== -1) {
	      handlers.splice(index, 2);
	    }
	    return this;
	  };
	  this.getHandler = function (file) {
	    for (var i = 0, l = handlers.length; i < l; i += 2) {
	      var regex = handlers[i];
	      var loader = handlers[i + 1];
	      if (regex.global) regex.lastIndex = 0;
	      if (regex.test(file)) {
	        return loader;
	      }
	    }
	    return null;
	  };
	}
	var DefaultLoadingManager = new LoadingManager();
	function Loader(manager) {
	  this.manager = manager !== undefined ? manager : DefaultLoadingManager;
	  this.crossOrigin = "anonymous";
	  this.path = "";
	  this.resourcePath = "";
	}
	Object.assign(Loader.prototype, {
	  load: function () {},
	  parse: function () {},
	  setCrossOrigin: function (crossOrigin) {
	    this.crossOrigin = crossOrigin;
	    return this;
	  },
	  setPath: function (path) {
	    this.path = path;
	    return this;
	  },
	  setResourcePath: function (resourcePath) {
	    this.resourcePath = resourcePath;
	    return this;
	  }
	});
	var loading = {};
	function FileLoader(manager) {
	  Loader.call(this, manager);
	}
	FileLoader.prototype = Object.assign(Object.create(Loader.prototype), {
	  constructor: FileLoader,
	  load: function (url, onLoad, onProgress, onError) {
	    if (url === undefined) url = "";
	    if (this.path !== undefined) url = this.path + url;
	    url = this.manager.resolveURL(url);
	    var scope = this;
	    var cached = Cache.get(url);
	    if (cached !== undefined) {
	      scope.manager.itemStart(url);
	      setTimeout(function () {
	        if (onLoad) onLoad(cached);
	        scope.manager.itemEnd(url);
	      }, 0);
	      return cached;
	    }
	    if (loading[url] !== undefined) {
	      loading[url].push({
	        onLoad: onLoad,
	        onProgress: onProgress,
	        onError: onError
	      });
	      return;
	    }
	    var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
	    var dataUriRegexResult = url.match(dataUriRegex);
	    if (dataUriRegexResult) {
	      var mimeType = dataUriRegexResult[1];
	      var isBase64 = !!dataUriRegexResult[2];
	      var data = dataUriRegexResult[3];
	      data = decodeURIComponent(data);
	      if (isBase64) data = atob(data);
	      try {
	        var response;
	        var responseType = (this.responseType || "").toLowerCase();
	        switch (responseType) {
	          case "arraybuffer":
	          case "blob":
	            var view = new Uint8Array(data.length);
	            for (var i = 0; i < data.length; i++) {
	              view[i] = data.charCodeAt(i);
	            }
	            if (responseType === "blob") {
	              response = new Blob([view.buffer], {
	                type: mimeType
	              });
	            } else {
	              response = view.buffer;
	            }
	            break;
	          case "document":
	            var parser = new DOMParser();
	            response = parser.parseFromString(data, mimeType);
	            break;
	          case "json":
	            response = JSON.parse(data);
	            break;
	          default:
	            response = data;
	            break;
	        }
	        setTimeout(function () {
	          if (onLoad) onLoad(response);
	          scope.manager.itemEnd(url);
	        }, 0);
	      } catch (error) {
	        setTimeout(function () {
	          if (onError) onError(error);
	          scope.manager.itemError(url);
	          scope.manager.itemEnd(url);
	        }, 0);
	      }
	    } else {
	      loading[url] = [];
	      loading[url].push({
	        onLoad: onLoad,
	        onProgress: onProgress,
	        onError: onError
	      });
	      var request = new XMLHttpRequest();
	      request.open("GET", url, true);
	      request.addEventListener("load", function (event) {
	        var response = this.response;
	        var callbacks = loading[url];
	        delete loading[url];
	        if (this.status === 200 || this.status === 0) {
	          if (this.status === 0) console.warn("THREE.FileLoader: HTTP Status 0 received.");
	          Cache.add(url, response);
	          for (var i = 0, il = callbacks.length; i < il; i++) {
	            var callback = callbacks[i];
	            if (callback.onLoad) callback.onLoad(response);
	          }
	          scope.manager.itemEnd(url);
	        } else {
	          for (var i = 0, il = callbacks.length; i < il; i++) {
	            var callback = callbacks[i];
	            if (callback.onError) callback.onError(event);
	          }
	          scope.manager.itemError(url);
	          scope.manager.itemEnd(url);
	        }
	      }, false);
	      request.addEventListener("progress", function (event) {
	        var callbacks = loading[url];
	        for (var i = 0, il = callbacks.length; i < il; i++) {
	          var callback = callbacks[i];
	          if (callback.onProgress) callback.onProgress(event);
	        }
	      }, false);
	      request.addEventListener("error", function (event) {
	        var callbacks = loading[url];
	        delete loading[url];
	        for (var i = 0, il = callbacks.length; i < il; i++) {
	          var callback = callbacks[i];
	          if (callback.onError) callback.onError(event);
	        }
	        scope.manager.itemError(url);
	        scope.manager.itemEnd(url);
	      }, false);
	      request.addEventListener("abort", function (event) {
	        var callbacks = loading[url];
	        delete loading[url];
	        for (var i = 0, il = callbacks.length; i < il; i++) {
	          var callback = callbacks[i];
	          if (callback.onError) callback.onError(event);
	        }
	        scope.manager.itemError(url);
	        scope.manager.itemEnd(url);
	      }, false);
	      if (this.responseType !== undefined) request.responseType = this.responseType;
	      if (this.withCredentials !== undefined) request.withCredentials = this.withCredentials;
	      if (request.overrideMimeType) request.overrideMimeType(this.mimeType !== undefined ? this.mimeType : "text/plain");
	      for (var header in this.requestHeader) {
	        request.setRequestHeader(header, this.requestHeader[header]);
	      }
	      request.send(null);
	    }
	    scope.manager.itemStart(url);
	    return request;
	  },
	  setResponseType: function (value) {
	    this.responseType = value;
	    return this;
	  },
	  setWithCredentials: function (value) {
	    this.withCredentials = value;
	    return this;
	  },
	  setMimeType: function (value) {
	    this.mimeType = value;
	    return this;
	  },
	  setRequestHeader: function (value) {
	    this.requestHeader = value;
	    return this;
	  }
	});
	function AnimationLoader(manager) {
	  Loader.call(this, manager);
	}
	AnimationLoader.prototype = Object.assign(Object.create(Loader.prototype), {
	  constructor: AnimationLoader,
	  load: function (url, onLoad, onProgress, onError) {
	    var scope = this;
	    var loader = new FileLoader(scope.manager);
	    loader.setPath(scope.path);
	    loader.load(url, function (text) {
	      onLoad(scope.parse(JSON.parse(text)));
	    }, onProgress, onError);
	  },
	  parse: function (json) {
	    var animations = [];
	    for (var i = 0; i < json.length; i++) {
	      var clip = AnimationClip.parse(json[i]);
	      animations.push(clip);
	    }
	    return animations;
	  }
	});
	function CompressedTextureLoader(manager) {
	  Loader.call(this, manager);
	}
	CompressedTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
	  constructor: CompressedTextureLoader,
	  load: function (url, onLoad, onProgress, onError) {
	    var scope = this;
	    var images = [];
	    var texture = new CompressedTexture();
	    texture.image = images;
	    var loader = new FileLoader(this.manager);
	    loader.setPath(this.path);
	    loader.setResponseType("arraybuffer");
	    function loadTexture(i) {
	      loader.load(url[i], function (buffer) {
	        var texDatas = scope.parse(buffer, true);
	        images[i] = {
	          width: texDatas.width,
	          height: texDatas.height,
	          format: texDatas.format,
	          mipmaps: texDatas.mipmaps
	        };
	        loaded += 1;
	        if (loaded === 6) {
	          if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
	          texture.format = texDatas.format;
	          texture.needsUpdate = true;
	          if (onLoad) onLoad(texture);
	        }
	      }, onProgress, onError);
	    }
	    if (Array.isArray(url)) {
	      var loaded = 0;
	      for (var i = 0, il = url.length; i < il; ++i) {
	        loadTexture(i);
	      }
	    } else {
	      loader.load(url, function (buffer) {
	        var texDatas = scope.parse(buffer, true);
	        if (texDatas.isCubemap) {
	          var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
	          for (var f = 0; f < faces; f++) {
	            images[f] = {
	              mipmaps: []
	            };
	            for (var i = 0; i < texDatas.mipmapCount; i++) {
	              images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);
	              images[f].format = texDatas.format;
	              images[f].width = texDatas.width;
	              images[f].height = texDatas.height;
	            }
	          }
	        } else {
	          texture.image.width = texDatas.width;
	          texture.image.height = texDatas.height;
	          texture.mipmaps = texDatas.mipmaps;
	        }
	        if (texDatas.mipmapCount === 1) {
	          texture.minFilter = LinearFilter;
	        }
	        texture.format = texDatas.format;
	        texture.needsUpdate = true;
	        if (onLoad) onLoad(texture);
	      }, onProgress, onError);
	    }
	    return texture;
	  }
	});
	function DataTextureLoader(manager) {
	  Loader.call(this, manager);
	}
	DataTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
	  constructor: DataTextureLoader,
	  load: function (url, onLoad, onProgress, onError) {
	    var scope = this;
	    var texture = new DataTexture();
	    var loader = new FileLoader(this.manager);
	    loader.setResponseType("arraybuffer");
	    loader.setPath(this.path);
	    loader.load(url, function (buffer) {
	      var texData = scope.parse(buffer);
	      if (!texData) return;
	      if (texData.image !== undefined) {
	        texture.image = texData.image;
	      } else if (texData.data !== undefined) {
	        texture.image.width = texData.width;
	        texture.image.height = texData.height;
	        texture.image.data = texData.data;
	      }
	      texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
	      texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
	      texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
	      texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;
	      texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;
	      if (texData.format !== undefined) {
	        texture.format = texData.format;
	      }
	      if (texData.type !== undefined) {
	        texture.type = texData.type;
	      }
	      if (texData.mipmaps !== undefined) {
	        texture.mipmaps = texData.mipmaps;
	        texture.minFilter = LinearMipmapLinearFilter;
	      }
	      if (texData.mipmapCount === 1) {
	        texture.minFilter = LinearFilter;
	      }
	      texture.needsUpdate = true;
	      if (onLoad) onLoad(texture, texData);
	    }, onProgress, onError);
	    return texture;
	  }
	});
	function ImageLoader(manager) {
	  Loader.call(this, manager);
	}
	ImageLoader.prototype = Object.assign(Object.create(Loader.prototype), {
	  constructor: ImageLoader,
	  load: function (url, onLoad, onProgress, onError) {
	    if (this.path !== undefined) url = this.path + url;
	    url = this.manager.resolveURL(url);
	    var scope = this;
	    var cached = Cache.get(url);
	    if (cached !== undefined) {
	      scope.manager.itemStart(url);
	      setTimeout(function () {
	        if (onLoad) onLoad(cached);
	        scope.manager.itemEnd(url);
	      }, 0);
	      return cached;
	    }
	    var image = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
	    function onImageLoad() {
	      image.removeEventListener("load", onImageLoad, false);
	      image.removeEventListener("error", onImageError, false);
	      Cache.add(url, this);
	      if (onLoad) onLoad(this);
	      scope.manager.itemEnd(url);
	    }
	    function onImageError(event) {
	      image.removeEventListener("load", onImageLoad, false);
	      image.removeEventListener("error", onImageError, false);
	      if (onError) onError(event);
	      scope.manager.itemError(url);
	      scope.manager.itemEnd(url);
	    }
	    image.addEventListener("load", onImageLoad, false);
	    image.addEventListener("error", onImageError, false);
	    if (url.substr(0, 5) !== "data:") {
	      if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
	    }
	    scope.manager.itemStart(url);
	    image.src = url;
	    return image;
	  }
	});
	function CubeTextureLoader(manager) {
	  Loader.call(this, manager);
	}
	CubeTextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
	  constructor: CubeTextureLoader,
	  load: function (urls, onLoad, onProgress, onError) {
	    var texture = new CubeTexture();
	    var loader = new ImageLoader(this.manager);
	    loader.setCrossOrigin(this.crossOrigin);
	    loader.setPath(this.path);
	    var loaded = 0;
	    function loadTexture(i) {
	      loader.load(urls[i], function (image) {
	        texture.images[i] = image;
	        loaded++;
	        if (loaded === 6) {
	          texture.needsUpdate = true;
	          if (onLoad) onLoad(texture);
	        }
	      }, undefined, onError);
	    }
	    for (var i = 0; i < urls.length; ++i) {
	      loadTexture(i);
	    }
	    return texture;
	  }
	});
	function TextureLoader(manager) {
	  Loader.call(this, manager);
	}
	TextureLoader.prototype = Object.assign(Object.create(Loader.prototype), {
	  constructor: TextureLoader,
	  load: function (url, onLoad, onProgress, onError) {
	    var texture = new Texture();
	    var loader = new ImageLoader(this.manager);
	    loader.setCrossOrigin(this.crossOrigin);
	    loader.setPath(this.path);
	    loader.load(url, function (image) {
	      texture.image = image;
	      var isJPEG = url.search(/\.jpe?g($|\?)/i) > 0 || url.search(/^data\:image\/jpeg/) === 0;
	      texture.format = isJPEG ? RGBFormat : RGBAFormat;
	      texture.needsUpdate = true;
	      if (onLoad !== undefined) {
	        onLoad(texture);
	      }
	    }, onProgress, onError);
	    return texture;
	  }
	});
	function Curve() {
	  this.type = "Curve";
	  this.arcLengthDivisions = 200;
	}
	Object.assign(Curve.prototype, {
	  getPoint: function () {
	    console.warn("THREE.Curve: .getPoint() not implemented.");
	    return null;
	  },
	  getPointAt: function (u, optionalTarget) {
	    var t = this.getUtoTmapping(u);
	    return this.getPoint(t, optionalTarget);
	  },
	  getPoints: function (divisions) {
	    if (divisions === undefined) divisions = 5;
	    var points = [];
	    for (var d = 0; d <= divisions; d++) {
	      points.push(this.getPoint(d / divisions));
	    }
	    return points;
	  },
	  getSpacedPoints: function (divisions) {
	    if (divisions === undefined) divisions = 5;
	    var points = [];
	    for (var d = 0; d <= divisions; d++) {
	      points.push(this.getPointAt(d / divisions));
	    }
	    return points;
	  },
	  getLength: function () {
	    var lengths = this.getLengths();
	    return lengths[lengths.length - 1];
	  },
	  getLengths: function (divisions) {
	    if (divisions === undefined) divisions = this.arcLengthDivisions;
	    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
	      return this.cacheArcLengths;
	    }
	    this.needsUpdate = false;
	    var cache = [];
	    var current, last = this.getPoint(0);
	    var p, sum = 0;
	    cache.push(0);
	    for (p = 1; p <= divisions; p++) {
	      current = this.getPoint(p / divisions);
	      sum += current.distanceTo(last);
	      cache.push(sum);
	      last = current;
	    }
	    this.cacheArcLengths = cache;
	    return cache;
	  },
	  updateArcLengths: function () {
	    this.needsUpdate = true;
	    this.getLengths();
	  },
	  getUtoTmapping: function (u, distance) {
	    var arcLengths = this.getLengths();
	    var i = 0, il = arcLengths.length;
	    var targetArcLength;
	    if (distance) {
	      targetArcLength = distance;
	    } else {
	      targetArcLength = u * arcLengths[il - 1];
	    }
	    var low = 0, high = il - 1, comparison;
	    while (low <= high) {
	      i = Math.floor(low + (high - low) / 2);
	      comparison = arcLengths[i] - targetArcLength;
	      if (comparison < 0) {
	        low = i + 1;
	      } else if (comparison > 0) {
	        high = i - 1;
	      } else {
	        high = i;
	        break;
	      }
	    }
	    i = high;
	    if (arcLengths[i] === targetArcLength) {
	      return i / (il - 1);
	    }
	    var lengthBefore = arcLengths[i];
	    var lengthAfter = arcLengths[i + 1];
	    var segmentLength = lengthAfter - lengthBefore;
	    var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;
	    var t = (i + segmentFraction) / (il - 1);
	    return t;
	  },
	  getTangent: function (t) {
	    var delta = 0.0001;
	    var t1 = t - delta;
	    var t2 = t + delta;
	    if (t1 < 0) t1 = 0;
	    if (t2 > 1) t2 = 1;
	    var pt1 = this.getPoint(t1);
	    var pt2 = this.getPoint(t2);
	    var vec = pt2.clone().sub(pt1);
	    return vec.normalize();
	  },
	  getTangentAt: function (u) {
	    var t = this.getUtoTmapping(u);
	    return this.getTangent(t);
	  },
	  computeFrenetFrames: function (segments, closed) {
	    var normal = new Vector3();
	    var tangents = [];
	    var normals = [];
	    var binormals = [];
	    var vec = new Vector3();
	    var mat = new Matrix4();
	    var i, u, theta;
	    for (i = 0; i <= segments; i++) {
	      u = i / segments;
	      tangents[i] = this.getTangentAt(u);
	      tangents[i].normalize();
	    }
	    normals[0] = new Vector3();
	    binormals[0] = new Vector3();
	    var min = Number.MAX_VALUE;
	    var tx = Math.abs(tangents[0].x);
	    var ty = Math.abs(tangents[0].y);
	    var tz = Math.abs(tangents[0].z);
	    if (tx <= min) {
	      min = tx;
	      normal.set(1, 0, 0);
	    }
	    if (ty <= min) {
	      min = ty;
	      normal.set(0, 1, 0);
	    }
	    if (tz <= min) {
	      normal.set(0, 0, 1);
	    }
	    vec.crossVectors(tangents[0], normal).normalize();
	    normals[0].crossVectors(tangents[0], vec);
	    binormals[0].crossVectors(tangents[0], normals[0]);
	    for (i = 1; i <= segments; i++) {
	      normals[i] = normals[i - 1].clone();
	      binormals[i] = binormals[i - 1].clone();
	      vec.crossVectors(tangents[i - 1], tangents[i]);
	      if (vec.length() > Number.EPSILON) {
	        vec.normalize();
	        theta = Math.acos(MathUtils.clamp(tangents[i - 1].dot(tangents[i]), -1, 1));
	        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));
	      }
	      binormals[i].crossVectors(tangents[i], normals[i]);
	    }
	    if (closed === true) {
	      theta = Math.acos(MathUtils.clamp(normals[0].dot(normals[segments]), -1, 1));
	      theta /= segments;
	      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
	        theta = -theta;
	      }
	      for (i = 1; i <= segments; i++) {
	        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));
	        binormals[i].crossVectors(tangents[i], normals[i]);
	      }
	    }
	    return {
	      tangents: tangents,
	      normals: normals,
	      binormals: binormals
	    };
	  },
	  clone: function () {
	    return new this.constructor().copy(this);
	  },
	  copy: function (source) {
	    this.arcLengthDivisions = source.arcLengthDivisions;
	    return this;
	  },
	  toJSON: function () {
	    var data = {
	      metadata: {
	        version: 4.5,
	        type: "Curve",
	        generator: "Curve.toJSON"
	      }
	    };
	    data.arcLengthDivisions = this.arcLengthDivisions;
	    data.type = this.type;
	    return data;
	  },
	  fromJSON: function (json) {
	    this.arcLengthDivisions = json.arcLengthDivisions;
	    return this;
	  }
	});
	function EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
	  Curve.call(this);
	  this.type = "EllipseCurve";
	  this.aX = aX || 0;
	  this.aY = aY || 0;
	  this.xRadius = xRadius || 1;
	  this.yRadius = yRadius || 1;
	  this.aStartAngle = aStartAngle || 0;
	  this.aEndAngle = aEndAngle || 2 * Math.PI;
	  this.aClockwise = aClockwise || false;
	  this.aRotation = aRotation || 0;
	}
	EllipseCurve.prototype = Object.create(Curve.prototype);
	EllipseCurve.prototype.constructor = EllipseCurve;
	EllipseCurve.prototype.isEllipseCurve = true;
	EllipseCurve.prototype.getPoint = function (t, optionalTarget) {
	  var point = optionalTarget || new Vector2();
	  var twoPi = Math.PI * 2;
	  var deltaAngle = this.aEndAngle - this.aStartAngle;
	  var samePoints = Math.abs(deltaAngle) < Number.EPSILON;
	  while (deltaAngle < 0) deltaAngle += twoPi;
	  while (deltaAngle > twoPi) deltaAngle -= twoPi;
	  if (deltaAngle < Number.EPSILON) {
	    if (samePoints) {
	      deltaAngle = 0;
	    } else {
	      deltaAngle = twoPi;
	    }
	  }
	  if (this.aClockwise === true && !samePoints) {
	    if (deltaAngle === twoPi) {
	      deltaAngle = -twoPi;
	    } else {
	      deltaAngle = deltaAngle - twoPi;
	    }
	  }
	  var angle = this.aStartAngle + t * deltaAngle;
	  var x = this.aX + this.xRadius * Math.cos(angle);
	  var y = this.aY + this.yRadius * Math.sin(angle);
	  if (this.aRotation !== 0) {
	    var cos = Math.cos(this.aRotation);
	    var sin = Math.sin(this.aRotation);
	    var tx = x - this.aX;
	    var ty = y - this.aY;
	    x = tx * cos - ty * sin + this.aX;
	    y = tx * sin + ty * cos + this.aY;
	  }
	  return point.set(x, y);
	};
	EllipseCurve.prototype.copy = function (source) {
	  Curve.prototype.copy.call(this, source);
	  this.aX = source.aX;
	  this.aY = source.aY;
	  this.xRadius = source.xRadius;
	  this.yRadius = source.yRadius;
	  this.aStartAngle = source.aStartAngle;
	  this.aEndAngle = source.aEndAngle;
	  this.aClockwise = source.aClockwise;
	  this.aRotation = source.aRotation;
	  return this;
	};
	EllipseCurve.prototype.toJSON = function () {
	  var data = Curve.prototype.toJSON.call(this);
	  data.aX = this.aX;
	  data.aY = this.aY;
	  data.xRadius = this.xRadius;
	  data.yRadius = this.yRadius;
	  data.aStartAngle = this.aStartAngle;
	  data.aEndAngle = this.aEndAngle;
	  data.aClockwise = this.aClockwise;
	  data.aRotation = this.aRotation;
	  return data;
	};
	EllipseCurve.prototype.fromJSON = function (json) {
	  Curve.prototype.fromJSON.call(this, json);
	  this.aX = json.aX;
	  this.aY = json.aY;
	  this.xRadius = json.xRadius;
	  this.yRadius = json.yRadius;
	  this.aStartAngle = json.aStartAngle;
	  this.aEndAngle = json.aEndAngle;
	  this.aClockwise = json.aClockwise;
	  this.aRotation = json.aRotation;
	  return this;
	};
	function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
	  EllipseCurve.call(this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
	  this.type = "ArcCurve";
	}
	ArcCurve.prototype = Object.create(EllipseCurve.prototype);
	ArcCurve.prototype.constructor = ArcCurve;
	ArcCurve.prototype.isArcCurve = true;
	function CubicPoly() {
	  var c0 = 0, c1 = 0, c2 = 0, c3 = 0;
	  function init(x0, x1, t0, t1) {
	    c0 = x0;
	    c1 = t0;
	    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
	    c3 = 2 * x0 - 2 * x1 + t0 + t1;
	  }
	  return {
	    initCatmullRom: function (x0, x1, x2, x3, tension) {
	      init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
	    },
	    initNonuniformCatmullRom: function (x0, x1, x2, x3, dt0, dt1, dt2) {
	      var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
	      var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;
	      t1 *= dt1;
	      t2 *= dt1;
	      init(x1, x2, t1, t2);
	    },
	    calc: function (t) {
	      var t2 = t * t;
	      var t3 = t2 * t;
	      return c0 + c1 * t + c2 * t2 + c3 * t3;
	    }
	  };
	}
	var tmp = new Vector3();
	var px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();
	function CatmullRomCurve3(points, closed, curveType, tension) {
	  Curve.call(this);
	  this.type = "CatmullRomCurve3";
	  this.points = points || [];
	  this.closed = closed || false;
	  this.curveType = curveType || "centripetal";
	  this.tension = tension || 0.5;
	}
	CatmullRomCurve3.prototype = Object.create(Curve.prototype);
	CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
	CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
	CatmullRomCurve3.prototype.getPoint = function (t, optionalTarget) {
	  var point = optionalTarget || new Vector3();
	  var points = this.points;
	  var l = points.length;
	  var p = (l - (this.closed ? 0 : 1)) * t;
	  var intPoint = Math.floor(p);
	  var weight = p - intPoint;
	  if (this.closed) {
	    intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
	  } else if (weight === 0 && intPoint === l - 1) {
	    intPoint = l - 2;
	    weight = 1;
	  }
	  var p0, p1, p2, p3;
	  if (this.closed || intPoint > 0) {
	    p0 = points[(intPoint - 1) % l];
	  } else {
	    tmp.subVectors(points[0], points[1]).add(points[0]);
	    p0 = tmp;
	  }
	  p1 = points[intPoint % l];
	  p2 = points[(intPoint + 1) % l];
	  if (this.closed || intPoint + 2 < l) {
	    p3 = points[(intPoint + 2) % l];
	  } else {
	    tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
	    p3 = tmp;
	  }
	  if (this.curveType === "centripetal" || this.curveType === "chordal") {
	    var pow = this.curveType === "chordal" ? 0.5 : 0.25;
	    var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
	    var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
	    var dt2 = Math.pow(p2.distanceToSquared(p3), pow);
	    if (dt1 < 0.0001) dt1 = 1;
	    if (dt0 < 0.0001) dt0 = dt1;
	    if (dt2 < 0.0001) dt2 = dt1;
	    px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
	    py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
	    pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
	  } else if (this.curveType === "catmullrom") {
	    px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
	    py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
	    pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
	  }
	  point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
	  return point;
	};
	CatmullRomCurve3.prototype.copy = function (source) {
	  Curve.prototype.copy.call(this, source);
	  this.points = [];
	  for (var i = 0, l = source.points.length; i < l; i++) {
	    var point = source.points[i];
	    this.points.push(point.clone());
	  }
	  this.closed = source.closed;
	  this.curveType = source.curveType;
	  this.tension = source.tension;
	  return this;
	};
	CatmullRomCurve3.prototype.toJSON = function () {
	  var data = Curve.prototype.toJSON.call(this);
	  data.points = [];
	  for (var i = 0, l = this.points.length; i < l; i++) {
	    var point = this.points[i];
	    data.points.push(point.toArray());
	  }
	  data.closed = this.closed;
	  data.curveType = this.curveType;
	  data.tension = this.tension;
	  return data;
	};
	CatmullRomCurve3.prototype.fromJSON = function (json) {
	  Curve.prototype.fromJSON.call(this, json);
	  this.points = [];
	  for (var i = 0, l = json.points.length; i < l; i++) {
	    var point = json.points[i];
	    this.points.push(new Vector3().fromArray(point));
	  }
	  this.closed = json.closed;
	  this.curveType = json.curveType;
	  this.tension = json.tension;
	  return this;
	};
	function CatmullRom(t, p0, p1, p2, p3) {
	  var v0 = (p2 - p0) * 0.5;
	  var v1 = (p3 - p1) * 0.5;
	  var t2 = t * t;
	  var t3 = t * t2;
	  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
	}
	function QuadraticBezierP0(t, p) {
	  var k = 1 - t;
	  return k * k * p;
	}
	function QuadraticBezierP1(t, p) {
	  return 2 * (1 - t) * t * p;
	}
	function QuadraticBezierP2(t, p) {
	  return t * t * p;
	}
	function QuadraticBezier(t, p0, p1, p2) {
	  return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
	}
	function CubicBezierP0(t, p) {
	  var k = 1 - t;
	  return k * k * k * p;
	}
	function CubicBezierP1(t, p) {
	  var k = 1 - t;
	  return 3 * k * k * t * p;
	}
	function CubicBezierP2(t, p) {
	  return 3 * (1 - t) * t * t * p;
	}
	function CubicBezierP3(t, p) {
	  return t * t * t * p;
	}
	function CubicBezier(t, p0, p1, p2, p3) {
	  return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
	}
	function CubicBezierCurve(v0, v1, v2, v3) {
	  Curve.call(this);
	  this.type = "CubicBezierCurve";
	  this.v0 = v0 || new Vector2();
	  this.v1 = v1 || new Vector2();
	  this.v2 = v2 || new Vector2();
	  this.v3 = v3 || new Vector2();
	}
	CubicBezierCurve.prototype = Object.create(Curve.prototype);
	CubicBezierCurve.prototype.constructor = CubicBezierCurve;
	CubicBezierCurve.prototype.isCubicBezierCurve = true;
	CubicBezierCurve.prototype.getPoint = function (t, optionalTarget) {
	  var point = optionalTarget || new Vector2();
	  var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
	  point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
	  return point;
	};
	CubicBezierCurve.prototype.copy = function (source) {
	  Curve.prototype.copy.call(this, source);
	  this.v0.copy(source.v0);
	  this.v1.copy(source.v1);
	  this.v2.copy(source.v2);
	  this.v3.copy(source.v3);
	  return this;
	};
	CubicBezierCurve.prototype.toJSON = function () {
	  var data = Curve.prototype.toJSON.call(this);
	  data.v0 = this.v0.toArray();
	  data.v1 = this.v1.toArray();
	  data.v2 = this.v2.toArray();
	  data.v3 = this.v3.toArray();
	  return data;
	};
	CubicBezierCurve.prototype.fromJSON = function (json) {
	  Curve.prototype.fromJSON.call(this, json);
	  this.v0.fromArray(json.v0);
	  this.v1.fromArray(json.v1);
	  this.v2.fromArray(json.v2);
	  this.v3.fromArray(json.v3);
	  return this;
	};
	function CubicBezierCurve3(v0, v1, v2, v3) {
	  Curve.call(this);
	  this.type = "CubicBezierCurve3";
	  this.v0 = v0 || new Vector3();
	  this.v1 = v1 || new Vector3();
	  this.v2 = v2 || new Vector3();
	  this.v3 = v3 || new Vector3();
	}
	CubicBezierCurve3.prototype = Object.create(Curve.prototype);
	CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
	CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
	CubicBezierCurve3.prototype.getPoint = function (t, optionalTarget) {
	  var point = optionalTarget || new Vector3();
	  var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
	  point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
	  return point;
	};
	CubicBezierCurve3.prototype.copy = function (source) {
	  Curve.prototype.copy.call(this, source);
	  this.v0.copy(source.v0);
	  this.v1.copy(source.v1);
	  this.v2.copy(source.v2);
	  this.v3.copy(source.v3);
	  return this;
	};
	CubicBezierCurve3.prototype.toJSON = function () {
	  var data = Curve.prototype.toJSON.call(this);
	  data.v0 = this.v0.toArray();
	  data.v1 = this.v1.toArray();
	  data.v2 = this.v2.toArray();
	  data.v3 = this.v3.toArray();
	  return data;
	};
	CubicBezierCurve3.prototype.fromJSON = function (json) {
	  Curve.prototype.fromJSON.call(this, json);
	  this.v0.fromArray(json.v0);
	  this.v1.fromArray(json.v1);
	  this.v2.fromArray(json.v2);
	  this.v3.fromArray(json.v3);
	  return this;
	};
	function LineCurve(v1, v2) {
	  Curve.call(this);
	  this.type = "LineCurve";
	  this.v1 = v1 || new Vector2();
	  this.v2 = v2 || new Vector2();
	}
	LineCurve.prototype = Object.create(Curve.prototype);
	LineCurve.prototype.constructor = LineCurve;
	LineCurve.prototype.isLineCurve = true;
	LineCurve.prototype.getPoint = function (t, optionalTarget) {
	  var point = optionalTarget || new Vector2();
	  if (t === 1) {
	    point.copy(this.v2);
	  } else {
	    point.copy(this.v2).sub(this.v1);
	    point.multiplyScalar(t).add(this.v1);
	  }
	  return point;
	};
	LineCurve.prototype.getPointAt = function (u, optionalTarget) {
	  return this.getPoint(u, optionalTarget);
	};
	LineCurve.prototype.getTangent = function () {
	  var tangent = this.v2.clone().sub(this.v1);
	  return tangent.normalize();
	};
	LineCurve.prototype.copy = function (source) {
	  Curve.prototype.copy.call(this, source);
	  this.v1.copy(source.v1);
	  this.v2.copy(source.v2);
	  return this;
	};
	LineCurve.prototype.toJSON = function () {
	  var data = Curve.prototype.toJSON.call(this);
	  data.v1 = this.v1.toArray();
	  data.v2 = this.v2.toArray();
	  return data;
	};
	LineCurve.prototype.fromJSON = function (json) {
	  Curve.prototype.fromJSON.call(this, json);
	  this.v1.fromArray(json.v1);
	  this.v2.fromArray(json.v2);
	  return this;
	};
	function LineCurve3(v1, v2) {
	  Curve.call(this);
	  this.type = "LineCurve3";
	  this.v1 = v1 || new Vector3();
	  this.v2 = v2 || new Vector3();
	}
	LineCurve3.prototype = Object.create(Curve.prototype);
	LineCurve3.prototype.constructor = LineCurve3;
	LineCurve3.prototype.isLineCurve3 = true;
	LineCurve3.prototype.getPoint = function (t, optionalTarget) {
	  var point = optionalTarget || new Vector3();
	  if (t === 1) {
	    point.copy(this.v2);
	  } else {
	    point.copy(this.v2).sub(this.v1);
	    point.multiplyScalar(t).add(this.v1);
	  }
	  return point;
	};
	LineCurve3.prototype.getPointAt = function (u, optionalTarget) {
	  return this.getPoint(u, optionalTarget);
	};
	LineCurve3.prototype.copy = function (source) {
	  Curve.prototype.copy.call(this, source);
	  this.v1.copy(source.v1);
	  this.v2.copy(source.v2);
	  return this;
	};
	LineCurve3.prototype.toJSON = function () {
	  var data = Curve.prototype.toJSON.call(this);
	  data.v1 = this.v1.toArray();
	  data.v2 = this.v2.toArray();
	  return data;
	};
	LineCurve3.prototype.fromJSON = function (json) {
	  Curve.prototype.fromJSON.call(this, json);
	  this.v1.fromArray(json.v1);
	  this.v2.fromArray(json.v2);
	  return this;
	};
	function QuadraticBezierCurve(v0, v1, v2) {
	  Curve.call(this);
	  this.type = "QuadraticBezierCurve";
	  this.v0 = v0 || new Vector2();
	  this.v1 = v1 || new Vector2();
	  this.v2 = v2 || new Vector2();
	}
	QuadraticBezierCurve.prototype = Object.create(Curve.prototype);
	QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
	QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
	QuadraticBezierCurve.prototype.getPoint = function (t, optionalTarget) {
	  var point = optionalTarget || new Vector2();
	  var v0 = this.v0, v1 = this.v1, v2 = this.v2;
	  point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
	  return point;
	};
	QuadraticBezierCurve.prototype.copy = function (source) {
	  Curve.prototype.copy.call(this, source);
	  this.v0.copy(source.v0);
	  this.v1.copy(source.v1);
	  this.v2.copy(source.v2);
	  return this;
	};
	QuadraticBezierCurve.prototype.toJSON = function () {
	  var data = Curve.prototype.toJSON.call(this);
	  data.v0 = this.v0.toArray();
	  data.v1 = this.v1.toArray();
	  data.v2 = this.v2.toArray();
	  return data;
	};
	QuadraticBezierCurve.prototype.fromJSON = function (json) {
	  Curve.prototype.fromJSON.call(this, json);
	  this.v0.fromArray(json.v0);
	  this.v1.fromArray(json.v1);
	  this.v2.fromArray(json.v2);
	  return this;
	};
	function QuadraticBezierCurve3(v0, v1, v2) {
	  Curve.call(this);
	  this.type = "QuadraticBezierCurve3";
	  this.v0 = v0 || new Vector3();
	  this.v1 = v1 || new Vector3();
	  this.v2 = v2 || new Vector3();
	}
	QuadraticBezierCurve3.prototype = Object.create(Curve.prototype);
	QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
	QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
	QuadraticBezierCurve3.prototype.getPoint = function (t, optionalTarget) {
	  var point = optionalTarget || new Vector3();
	  var v0 = this.v0, v1 = this.v1, v2 = this.v2;
	  point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
	  return point;
	};
	QuadraticBezierCurve3.prototype.copy = function (source) {
	  Curve.prototype.copy.call(this, source);
	  this.v0.copy(source.v0);
	  this.v1.copy(source.v1);
	  this.v2.copy(source.v2);
	  return this;
	};
	QuadraticBezierCurve3.prototype.toJSON = function () {
	  var data = Curve.prototype.toJSON.call(this);
	  data.v0 = this.v0.toArray();
	  data.v1 = this.v1.toArray();
	  data.v2 = this.v2.toArray();
	  return data;
	};
	QuadraticBezierCurve3.prototype.fromJSON = function (json) {
	  Curve.prototype.fromJSON.call(this, json);
	  this.v0.fromArray(json.v0);
	  this.v1.fromArray(json.v1);
	  this.v2.fromArray(json.v2);
	  return this;
	};
	function SplineCurve(points) {
	  Curve.call(this);
	  this.type = "SplineCurve";
	  this.points = points || [];
	}
	SplineCurve.prototype = Object.create(Curve.prototype);
	SplineCurve.prototype.constructor = SplineCurve;
	SplineCurve.prototype.isSplineCurve = true;
	SplineCurve.prototype.getPoint = function (t, optionalTarget) {
	  var point = optionalTarget || new Vector2();
	  var points = this.points;
	  var p = (points.length - 1) * t;
	  var intPoint = Math.floor(p);
	  var weight = p - intPoint;
	  var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
	  var p1 = points[intPoint];
	  var p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
	  var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
	  point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
	  return point;
	};
	SplineCurve.prototype.copy = function (source) {
	  Curve.prototype.copy.call(this, source);
	  this.points = [];
	  for (var i = 0, l = source.points.length; i < l; i++) {
	    var point = source.points[i];
	    this.points.push(point.clone());
	  }
	  return this;
	};
	SplineCurve.prototype.toJSON = function () {
	  var data = Curve.prototype.toJSON.call(this);
	  data.points = [];
	  for (var i = 0, l = this.points.length; i < l; i++) {
	    var point = this.points[i];
	    data.points.push(point.toArray());
	  }
	  return data;
	};
	SplineCurve.prototype.fromJSON = function (json) {
	  Curve.prototype.fromJSON.call(this, json);
	  this.points = [];
	  for (var i = 0, l = json.points.length; i < l; i++) {
	    var point = json.points[i];
	    this.points.push(new Vector2().fromArray(point));
	  }
	  return this;
	};
	var Curves = Object.freeze({
	  __proto__: null,
	  ArcCurve: ArcCurve,
	  CatmullRomCurve3: CatmullRomCurve3,
	  CubicBezierCurve: CubicBezierCurve,
	  CubicBezierCurve3: CubicBezierCurve3,
	  EllipseCurve: EllipseCurve,
	  LineCurve: LineCurve,
	  LineCurve3: LineCurve3,
	  QuadraticBezierCurve: QuadraticBezierCurve,
	  QuadraticBezierCurve3: QuadraticBezierCurve3,
	  SplineCurve: SplineCurve
	});
	function CurvePath() {
	  Curve.call(this);
	  this.type = "CurvePath";
	  this.curves = [];
	  this.autoClose = false;
	}
	CurvePath.prototype = Object.assign(Object.create(Curve.prototype), {
	  constructor: CurvePath,
	  add: function (curve) {
	    this.curves.push(curve);
	  },
	  closePath: function () {
	    var startPoint = this.curves[0].getPoint(0);
	    var endPoint = this.curves[this.curves.length - 1].getPoint(1);
	    if (!startPoint.equals(endPoint)) {
	      this.curves.push(new LineCurve(endPoint, startPoint));
	    }
	  },
	  getPoint: function (t) {
	    var d = t * this.getLength();
	    var curveLengths = this.getCurveLengths();
	    var i = 0;
	    while (i < curveLengths.length) {
	      if (curveLengths[i] >= d) {
	        var diff = curveLengths[i] - d;
	        var curve = this.curves[i];
	        var segmentLength = curve.getLength();
	        var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
	        return curve.getPointAt(u);
	      }
	      i++;
	    }
	    return null;
	  },
	  getLength: function () {
	    var lens = this.getCurveLengths();
	    return lens[lens.length - 1];
	  },
	  updateArcLengths: function () {
	    this.needsUpdate = true;
	    this.cacheLengths = null;
	    this.getCurveLengths();
	  },
	  getCurveLengths: function () {
	    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
	      return this.cacheLengths;
	    }
	    var lengths = [], sums = 0;
	    for (var i = 0, l = this.curves.length; i < l; i++) {
	      sums += this.curves[i].getLength();
	      lengths.push(sums);
	    }
	    this.cacheLengths = lengths;
	    return lengths;
	  },
	  getSpacedPoints: function (divisions) {
	    if (divisions === undefined) divisions = 40;
	    var points = [];
	    for (var i = 0; i <= divisions; i++) {
	      points.push(this.getPoint(i / divisions));
	    }
	    if (this.autoClose) {
	      points.push(points[0]);
	    }
	    return points;
	  },
	  getPoints: function (divisions) {
	    divisions = divisions || 12;
	    var points = [], last;
	    for (var i = 0, curves = this.curves; i < curves.length; i++) {
	      var curve = curves[i];
	      var resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;
	      var pts = curve.getPoints(resolution);
	      for (var j = 0; j < pts.length; j++) {
	        var point = pts[j];
	        if (last && last.equals(point)) continue;
	        points.push(point);
	        last = point;
	      }
	    }
	    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
	      points.push(points[0]);
	    }
	    return points;
	  },
	  copy: function (source) {
	    Curve.prototype.copy.call(this, source);
	    this.curves = [];
	    for (var i = 0, l = source.curves.length; i < l; i++) {
	      var curve = source.curves[i];
	      this.curves.push(curve.clone());
	    }
	    this.autoClose = source.autoClose;
	    return this;
	  },
	  toJSON: function () {
	    var data = Curve.prototype.toJSON.call(this);
	    data.autoClose = this.autoClose;
	    data.curves = [];
	    for (var i = 0, l = this.curves.length; i < l; i++) {
	      var curve = this.curves[i];
	      data.curves.push(curve.toJSON());
	    }
	    return data;
	  },
	  fromJSON: function (json) {
	    Curve.prototype.fromJSON.call(this, json);
	    this.autoClose = json.autoClose;
	    this.curves = [];
	    for (var i = 0, l = json.curves.length; i < l; i++) {
	      var curve = json.curves[i];
	      this.curves.push(new Curves[curve.type]().fromJSON(curve));
	    }
	    return this;
	  }
	});
	function Path(points) {
	  CurvePath.call(this);
	  this.type = "Path";
	  this.currentPoint = new Vector2();
	  if (points) {
	    this.setFromPoints(points);
	  }
	}
	Path.prototype = Object.assign(Object.create(CurvePath.prototype), {
	  constructor: Path,
	  setFromPoints: function (points) {
	    this.moveTo(points[0].x, points[0].y);
	    for (var i = 1, l = points.length; i < l; i++) {
	      this.lineTo(points[i].x, points[i].y);
	    }
	    return this;
	  },
	  moveTo: function (x, y) {
	    this.currentPoint.set(x, y);
	    return this;
	  },
	  lineTo: function (x, y) {
	    var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
	    this.curves.push(curve);
	    this.currentPoint.set(x, y);
	    return this;
	  },
	  quadraticCurveTo: function (aCPx, aCPy, aX, aY) {
	    var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
	    this.curves.push(curve);
	    this.currentPoint.set(aX, aY);
	    return this;
	  },
	  bezierCurveTo: function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
	    var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
	    this.curves.push(curve);
	    this.currentPoint.set(aX, aY);
	    return this;
	  },
	  splineThru: function (pts) {
	    var npts = [this.currentPoint.clone()].concat(pts);
	    var curve = new SplineCurve(npts);
	    this.curves.push(curve);
	    this.currentPoint.copy(pts[pts.length - 1]);
	    return this;
	  },
	  arc: function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
	    var x0 = this.currentPoint.x;
	    var y0 = this.currentPoint.y;
	    this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
	    return this;
	  },
	  absarc: function (aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
	    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
	    return this;
	  },
	  ellipse: function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
	    var x0 = this.currentPoint.x;
	    var y0 = this.currentPoint.y;
	    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
	    return this;
	  },
	  absellipse: function (aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
	    var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
	    if (this.curves.length > 0) {
	      var firstPoint = curve.getPoint(0);
	      if (!firstPoint.equals(this.currentPoint)) {
	        this.lineTo(firstPoint.x, firstPoint.y);
	      }
	    }
	    this.curves.push(curve);
	    var lastPoint = curve.getPoint(1);
	    this.currentPoint.copy(lastPoint);
	    return this;
	  },
	  copy: function (source) {
	    CurvePath.prototype.copy.call(this, source);
	    this.currentPoint.copy(source.currentPoint);
	    return this;
	  },
	  toJSON: function () {
	    var data = CurvePath.prototype.toJSON.call(this);
	    data.currentPoint = this.currentPoint.toArray();
	    return data;
	  },
	  fromJSON: function (json) {
	    CurvePath.prototype.fromJSON.call(this, json);
	    this.currentPoint.fromArray(json.currentPoint);
	    return this;
	  }
	});
	function Shape(points) {
	  Path.call(this, points);
	  this.uuid = MathUtils.generateUUID();
	  this.type = "Shape";
	  this.holes = [];
	}
	Shape.prototype = Object.assign(Object.create(Path.prototype), {
	  constructor: Shape,
	  getPointsHoles: function (divisions) {
	    var holesPts = [];
	    for (var i = 0, l = this.holes.length; i < l; i++) {
	      holesPts[i] = this.holes[i].getPoints(divisions);
	    }
	    return holesPts;
	  },
	  extractPoints: function (divisions) {
	    return {
	      shape: this.getPoints(divisions),
	      holes: this.getPointsHoles(divisions)
	    };
	  },
	  copy: function (source) {
	    Path.prototype.copy.call(this, source);
	    this.holes = [];
	    for (var i = 0, l = source.holes.length; i < l; i++) {
	      var hole = source.holes[i];
	      this.holes.push(hole.clone());
	    }
	    return this;
	  },
	  toJSON: function () {
	    var data = Path.prototype.toJSON.call(this);
	    data.uuid = this.uuid;
	    data.holes = [];
	    for (var i = 0, l = this.holes.length; i < l; i++) {
	      var hole = this.holes[i];
	      data.holes.push(hole.toJSON());
	    }
	    return data;
	  },
	  fromJSON: function (json) {
	    Path.prototype.fromJSON.call(this, json);
	    this.uuid = json.uuid;
	    this.holes = [];
	    for (var i = 0, l = json.holes.length; i < l; i++) {
	      var hole = json.holes[i];
	      this.holes.push(new Path().fromJSON(hole));
	    }
	    return this;
	  }
	});
	function Light(color, intensity) {
	  Object3D.call(this);
	  this.type = "Light";
	  this.color = new Color(color);
	  this.intensity = intensity !== undefined ? intensity : 1;
	  this.receiveShadow = undefined;
	}
	Light.prototype = Object.assign(Object.create(Object3D.prototype), {
	  constructor: Light,
	  isLight: true,
	  copy: function (source) {
	    Object3D.prototype.copy.call(this, source);
	    this.color.copy(source.color);
	    this.intensity = source.intensity;
	    return this;
	  },
	  toJSON: function (meta) {
	    var data = Object3D.prototype.toJSON.call(this, meta);
	    data.object.color = this.color.getHex();
	    data.object.intensity = this.intensity;
	    if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
	    if (this.distance !== undefined) data.object.distance = this.distance;
	    if (this.angle !== undefined) data.object.angle = this.angle;
	    if (this.decay !== undefined) data.object.decay = this.decay;
	    if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
	    if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
	    return data;
	  }
	});
	function HemisphereLight(skyColor, groundColor, intensity) {
	  Light.call(this, skyColor, intensity);
	  this.type = "HemisphereLight";
	  this.castShadow = undefined;
	  this.position.copy(Object3D.DefaultUp);
	  this.updateMatrix();
	  this.groundColor = new Color(groundColor);
	}
	HemisphereLight.prototype = Object.assign(Object.create(Light.prototype), {
	  constructor: HemisphereLight,
	  isHemisphereLight: true,
	  copy: function (source) {
	    Light.prototype.copy.call(this, source);
	    this.groundColor.copy(source.groundColor);
	    return this;
	  }
	});
	function LightShadow(camera) {
	  this.camera = camera;
	  this.bias = 0;
	  this.radius = 1;
	  this.mapSize = new Vector2(512, 512);
	  this.map = null;
	  this.mapPass = null;
	  this.matrix = new Matrix4();
	  this._frustum = new Frustum();
	  this._frameExtents = new Vector2(1, 1);
	  this._viewportCount = 1;
	  this._viewports = [new Vector4(0, 0, 1, 1)];
	}
	Object.assign(LightShadow.prototype, {
	  _projScreenMatrix: new Matrix4(),
	  _lightPositionWorld: new Vector3(),
	  _lookTarget: new Vector3(),
	  getViewportCount: function () {
	    return this._viewportCount;
	  },
	  getFrustum: function () {
	    return this._frustum;
	  },
	  updateMatrices: function (light) {
	    var shadowCamera = this.camera, shadowMatrix = this.matrix, projScreenMatrix = this._projScreenMatrix, lookTarget = this._lookTarget, lightPositionWorld = this._lightPositionWorld;
	    lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
	    shadowCamera.position.copy(lightPositionWorld);
	    lookTarget.setFromMatrixPosition(light.target.matrixWorld);
	    shadowCamera.lookAt(lookTarget);
	    shadowCamera.updateMatrixWorld();
	    projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
	    this._frustum.setFromProjectionMatrix(projScreenMatrix);
	    shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);
	    shadowMatrix.multiply(shadowCamera.projectionMatrix);
	    shadowMatrix.multiply(shadowCamera.matrixWorldInverse);
	  },
	  getViewport: function (viewportIndex) {
	    return this._viewports[viewportIndex];
	  },
	  getFrameExtents: function () {
	    return this._frameExtents;
	  },
	  copy: function (source) {
	    this.camera = source.camera.clone();
	    this.bias = source.bias;
	    this.radius = source.radius;
	    this.mapSize.copy(source.mapSize);
	    return this;
	  },
	  clone: function () {
	    return new this.constructor().copy(this);
	  },
	  toJSON: function () {
	    var object = {};
	    if (this.bias !== 0) object.bias = this.bias;
	    if (this.radius !== 1) object.radius = this.radius;
	    if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
	    object.camera = this.camera.toJSON(false).object;
	    delete object.camera.matrix;
	    return object;
	  }
	});
	function SpotLightShadow() {
	  LightShadow.call(this, new PerspectiveCamera(50, 1, 0.5, 500));
	}
	SpotLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
	  constructor: SpotLightShadow,
	  isSpotLightShadow: true,
	  updateMatrices: function (light) {
	    var camera = this.camera;
	    var fov = MathUtils.RAD2DEG * 2 * light.angle;
	    var aspect = this.mapSize.width / this.mapSize.height;
	    var far = light.distance || camera.far;
	    if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
	      camera.fov = fov;
	      camera.aspect = aspect;
	      camera.far = far;
	      camera.updateProjectionMatrix();
	    }
	    LightShadow.prototype.updateMatrices.call(this, light);
	  }
	});
	function SpotLight(color, intensity, distance, angle, penumbra, decay) {
	  Light.call(this, color, intensity);
	  this.type = "SpotLight";
	  this.position.copy(Object3D.DefaultUp);
	  this.updateMatrix();
	  this.target = new Object3D();
	  Object.defineProperty(this, "power", {
	    get: function () {
	      return this.intensity * Math.PI;
	    },
	    set: function (power) {
	      this.intensity = power / Math.PI;
	    }
	  });
	  this.distance = distance !== undefined ? distance : 0;
	  this.angle = angle !== undefined ? angle : Math.PI / 3;
	  this.penumbra = penumbra !== undefined ? penumbra : 0;
	  this.decay = decay !== undefined ? decay : 1;
	  this.shadow = new SpotLightShadow();
	}
	SpotLight.prototype = Object.assign(Object.create(Light.prototype), {
	  constructor: SpotLight,
	  isSpotLight: true,
	  copy: function (source) {
	    Light.prototype.copy.call(this, source);
	    this.distance = source.distance;
	    this.angle = source.angle;
	    this.penumbra = source.penumbra;
	    this.decay = source.decay;
	    this.target = source.target.clone();
	    this.shadow = source.shadow.clone();
	    return this;
	  }
	});
	function PointLightShadow() {
	  LightShadow.call(this, new PerspectiveCamera(90, 1, 0.5, 500));
	  this._frameExtents = new Vector2(4, 2);
	  this._viewportCount = 6;
	  this._viewports = [new Vector4(2, 1, 1, 1), new Vector4(0, 1, 1, 1), new Vector4(3, 1, 1, 1), new Vector4(1, 1, 1, 1), new Vector4(3, 0, 1, 1), new Vector4(1, 0, 1, 1)];
	  this._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];
	  this._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
	}
	PointLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
	  constructor: PointLightShadow,
	  isPointLightShadow: true,
	  updateMatrices: function (light, viewportIndex) {
	    if (viewportIndex === undefined) viewportIndex = 0;
	    var camera = this.camera, shadowMatrix = this.matrix, lightPositionWorld = this._lightPositionWorld, lookTarget = this._lookTarget, projScreenMatrix = this._projScreenMatrix;
	    lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
	    camera.position.copy(lightPositionWorld);
	    lookTarget.copy(camera.position);
	    lookTarget.add(this._cubeDirections[viewportIndex]);
	    camera.up.copy(this._cubeUps[viewportIndex]);
	    camera.lookAt(lookTarget);
	    camera.updateMatrixWorld();
	    shadowMatrix.makeTranslation(-lightPositionWorld.x, -lightPositionWorld.y, -lightPositionWorld.z);
	    projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
	    this._frustum.setFromProjectionMatrix(projScreenMatrix);
	  }
	});
	function PointLight(color, intensity, distance, decay) {
	  Light.call(this, color, intensity);
	  this.type = "PointLight";
	  Object.defineProperty(this, "power", {
	    get: function () {
	      return this.intensity * 4 * Math.PI;
	    },
	    set: function (power) {
	      this.intensity = power / (4 * Math.PI);
	    }
	  });
	  this.distance = distance !== undefined ? distance : 0;
	  this.decay = decay !== undefined ? decay : 1;
	  this.shadow = new PointLightShadow();
	}
	PointLight.prototype = Object.assign(Object.create(Light.prototype), {
	  constructor: PointLight,
	  isPointLight: true,
	  copy: function (source) {
	    Light.prototype.copy.call(this, source);
	    this.distance = source.distance;
	    this.decay = source.decay;
	    this.shadow = source.shadow.clone();
	    return this;
	  }
	});
	function OrthographicCamera(left, right, top, bottom, near, far) {
	  Camera.call(this);
	  this.type = "OrthographicCamera";
	  this.zoom = 1;
	  this.view = null;
	  this.left = left !== undefined ? left : -1;
	  this.right = right !== undefined ? right : 1;
	  this.top = top !== undefined ? top : 1;
	  this.bottom = bottom !== undefined ? bottom : -1;
	  this.near = near !== undefined ? near : 0.1;
	  this.far = far !== undefined ? far : 2000;
	  this.updateProjectionMatrix();
	}
	OrthographicCamera.prototype = Object.assign(Object.create(Camera.prototype), {
	  constructor: OrthographicCamera,
	  isOrthographicCamera: true,
	  copy: function (source, recursive) {
	    Camera.prototype.copy.call(this, source, recursive);
	    this.left = source.left;
	    this.right = source.right;
	    this.top = source.top;
	    this.bottom = source.bottom;
	    this.near = source.near;
	    this.far = source.far;
	    this.zoom = source.zoom;
	    this.view = source.view === null ? null : Object.assign({}, source.view);
	    return this;
	  },
	  setViewOffset: function (fullWidth, fullHeight, x, y, width, height) {
	    if (this.view === null) {
	      this.view = {
	        enabled: true,
	        fullWidth: 1,
	        fullHeight: 1,
	        offsetX: 0,
	        offsetY: 0,
	        width: 1,
	        height: 1
	      };
	    }
	    this.view.enabled = true;
	    this.view.fullWidth = fullWidth;
	    this.view.fullHeight = fullHeight;
	    this.view.offsetX = x;
	    this.view.offsetY = y;
	    this.view.width = width;
	    this.view.height = height;
	    this.updateProjectionMatrix();
	  },
	  clearViewOffset: function () {
	    if (this.view !== null) {
	      this.view.enabled = false;
	    }
	    this.updateProjectionMatrix();
	  },
	  updateProjectionMatrix: function () {
	    var dx = (this.right - this.left) / (2 * this.zoom);
	    var dy = (this.top - this.bottom) / (2 * this.zoom);
	    var cx = (this.right + this.left) / 2;
	    var cy = (this.top + this.bottom) / 2;
	    var left = cx - dx;
	    var right = cx + dx;
	    var top = cy + dy;
	    var bottom = cy - dy;
	    if (this.view !== null && this.view.enabled) {
	      var scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
	      var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
	      left += scaleW * this.view.offsetX;
	      right = left + scaleW * this.view.width;
	      top -= scaleH * this.view.offsetY;
	      bottom = top - scaleH * this.view.height;
	    }
	    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);
	    this.projectionMatrixInverse.getInverse(this.projectionMatrix);
	  },
	  toJSON: function (meta) {
	    var data = Object3D.prototype.toJSON.call(this, meta);
	    data.object.zoom = this.zoom;
	    data.object.left = this.left;
	    data.object.right = this.right;
	    data.object.top = this.top;
	    data.object.bottom = this.bottom;
	    data.object.near = this.near;
	    data.object.far = this.far;
	    if (this.view !== null) data.object.view = Object.assign({}, this.view);
	    return data;
	  }
	});
	function DirectionalLightShadow() {
	  LightShadow.call(this, new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
	}
	DirectionalLightShadow.prototype = Object.assign(Object.create(LightShadow.prototype), {
	  constructor: DirectionalLightShadow,
	  isDirectionalLightShadow: true,
	  updateMatrices: function (light) {
	    LightShadow.prototype.updateMatrices.call(this, light);
	  }
	});
	function DirectionalLight(color, intensity) {
	  Light.call(this, color, intensity);
	  this.type = "DirectionalLight";
	  this.position.copy(Object3D.DefaultUp);
	  this.updateMatrix();
	  this.target = new Object3D();
	  this.shadow = new DirectionalLightShadow();
	}
	DirectionalLight.prototype = Object.assign(Object.create(Light.prototype), {
	  constructor: DirectionalLight,
	  isDirectionalLight: true,
	  copy: function (source) {
	    Light.prototype.copy.call(this, source);
	    this.target = source.target.clone();
	    this.shadow = source.shadow.clone();
	    return this;
	  }
	});
	function AmbientLight(color, intensity) {
	  Light.call(this, color, intensity);
	  this.type = "AmbientLight";
	  this.castShadow = undefined;
	}
	AmbientLight.prototype = Object.assign(Object.create(Light.prototype), {
	  constructor: AmbientLight,
	  isAmbientLight: true
	});
	function RectAreaLight(color, intensity, width, height) {
	  Light.call(this, color, intensity);
	  this.type = "RectAreaLight";
	  this.width = width !== undefined ? width : 10;
	  this.height = height !== undefined ? height : 10;
	}
	RectAreaLight.prototype = Object.assign(Object.create(Light.prototype), {
	  constructor: RectAreaLight,
	  isRectAreaLight: true,
	  copy: function (source) {
	    Light.prototype.copy.call(this, source);
	    this.width = source.width;
	    this.height = source.height;
	    return this;
	  },
	  toJSON: function (meta) {
	    var data = Light.prototype.toJSON.call(this, meta);
	    data.object.width = this.width;
	    data.object.height = this.height;
	    return data;
	  }
	});
	function MaterialLoader(manager) {
	  Loader.call(this, manager);
	  this.textures = {};
	}
	MaterialLoader.prototype = Object.assign(Object.create(Loader.prototype), {
	  constructor: MaterialLoader,
	  load: function (url, onLoad, onProgress, onError) {
	    var scope = this;
	    var loader = new FileLoader(scope.manager);
	    loader.setPath(scope.path);
	    loader.load(url, function (text) {
	      onLoad(scope.parse(JSON.parse(text)));
	    }, onProgress, onError);
	  },
	  parse: function (json) {
	    var textures = this.textures;
	    function getTexture(name) {
	      if (textures[name] === undefined) {
	        console.warn("THREE.MaterialLoader: Undefined texture", name);
	      }
	      return textures[name];
	    }
	    var material = new Materials[json.type]();
	    if (json.uuid !== undefined) material.uuid = json.uuid;
	    if (json.name !== undefined) material.name = json.name;
	    if (json.color !== undefined) material.color.setHex(json.color);
	    if (json.roughness !== undefined) material.roughness = json.roughness;
	    if (json.metalness !== undefined) material.metalness = json.metalness;
	    if (json.sheen !== undefined) material.sheen = new Color().setHex(json.sheen);
	    if (json.emissive !== undefined) material.emissive.setHex(json.emissive);
	    if (json.specular !== undefined) material.specular.setHex(json.specular);
	    if (json.shininess !== undefined) material.shininess = json.shininess;
	    if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;
	    if (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;
	    if (json.fog !== undefined) material.fog = json.fog;
	    if (json.flatShading !== undefined) material.flatShading = json.flatShading;
	    if (json.blending !== undefined) material.blending = json.blending;
	    if (json.combine !== undefined) material.combine = json.combine;
	    if (json.side !== undefined) material.side = json.side;
	    if (json.opacity !== undefined) material.opacity = json.opacity;
	    if (json.transparent !== undefined) material.transparent = json.transparent;
	    if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
	    if (json.depthTest !== undefined) material.depthTest = json.depthTest;
	    if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
	    if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
	    if (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;
	    if (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;
	    if (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;
	    if (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;
	    if (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;
	    if (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;
	    if (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;
	    if (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;
	    if (json.wireframe !== undefined) material.wireframe = json.wireframe;
	    if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
	    if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
	    if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
	    if (json.rotation !== undefined) material.rotation = json.rotation;
	    if (json.linewidth !== 1) material.linewidth = json.linewidth;
	    if (json.dashSize !== undefined) material.dashSize = json.dashSize;
	    if (json.gapSize !== undefined) material.gapSize = json.gapSize;
	    if (json.scale !== undefined) material.scale = json.scale;
	    if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
	    if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
	    if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;
	    if (json.skinning !== undefined) material.skinning = json.skinning;
	    if (json.morphTargets !== undefined) material.morphTargets = json.morphTargets;
	    if (json.morphNormals !== undefined) material.morphNormals = json.morphNormals;
	    if (json.dithering !== undefined) material.dithering = json.dithering;
	    if (json.vertexTangents !== undefined) material.vertexTangents = json.vertexTangents;
	    if (json.visible !== undefined) material.visible = json.visible;
	    if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;
	    if (json.userData !== undefined) material.userData = json.userData;
	    if (json.vertexColors !== undefined) {
	      if (typeof json.vertexColors === "number") {
	        material.vertexColors = json.vertexColors > 0 ? true : false;
	      } else {
	        material.vertexColors = json.vertexColors;
	      }
	    }
	    if (json.uniforms !== undefined) {
	      for (var name in json.uniforms) {
	        var uniform = json.uniforms[name];
	        material.uniforms[name] = {};
	        switch (uniform.type) {
	          case "t":
	            material.uniforms[name].value = getTexture(uniform.value);
	            break;
	          case "c":
	            material.uniforms[name].value = new Color().setHex(uniform.value);
	            break;
	          case "v2":
	            material.uniforms[name].value = new Vector2().fromArray(uniform.value);
	            break;
	          case "v3":
	            material.uniforms[name].value = new Vector3().fromArray(uniform.value);
	            break;
	          case "v4":
	            material.uniforms[name].value = new Vector4().fromArray(uniform.value);
	            break;
	          case "m3":
	            material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
	          case "m4":
	            material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
	            break;
	          default:
	            material.uniforms[name].value = uniform.value;
	        }
	      }
	    }
	    if (json.defines !== undefined) material.defines = json.defines;
	    if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
	    if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;
	    if (json.extensions !== undefined) {
	      for (var key in json.extensions) {
	        material.extensions[key] = json.extensions[key];
	      }
	    }
	    if (json.shading !== undefined) material.flatShading = json.shading === 1;
	    if (json.size !== undefined) material.size = json.size;
	    if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation;
	    if (json.map !== undefined) material.map = getTexture(json.map);
	    if (json.matcap !== undefined) material.matcap = getTexture(json.matcap);
	    if (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap);
	    if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
	    if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
	    if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
	    if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;
	    if (json.normalScale !== undefined) {
	      var normalScale = json.normalScale;
	      if (Array.isArray(normalScale) === false) {
	        normalScale = [normalScale, normalScale];
	      }
	      material.normalScale = new Vector2().fromArray(normalScale);
	    }
	    if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
	    if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
	    if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
	    if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
	    if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
	    if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
	    if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
	    if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
	    if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
	    if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;
	    if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
	    if (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;
	    if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
	    if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
	    if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
	    if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
	    if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
	    if (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
	    if (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
	    return material;
	  },
	  setTextures: function (value) {
	    this.textures = value;
	    return this;
	  }
	});
	var LoaderUtils = {
	  decodeText: function (array) {
	    if (typeof TextDecoder !== "undefined") {
	      return new TextDecoder().decode(array);
	    }
	    var s = "";
	    for (var i = 0, il = array.length; i < il; i++) {
	      s += String.fromCharCode(array[i]);
	    }
	    try {
	      return decodeURIComponent(escape(s));
	    } catch (e) {
	      return s;
	    }
	  },
	  extractUrlBase: function (url) {
	    var index = url.lastIndexOf("/");
	    if (index === -1) return "./";
	    return url.substr(0, index + 1);
	  }
	};
	function InstancedBufferGeometry() {
	  BufferGeometry.call(this);
	  this.type = "InstancedBufferGeometry";
	  this.maxInstancedCount = undefined;
	}
	InstancedBufferGeometry.prototype = Object.assign(Object.create(BufferGeometry.prototype), {
	  constructor: InstancedBufferGeometry,
	  isInstancedBufferGeometry: true,
	  copy: function (source) {
	    BufferGeometry.prototype.copy.call(this, source);
	    this.maxInstancedCount = source.maxInstancedCount;
	    return this;
	  },
	  clone: function () {
	    return new this.constructor().copy(this);
	  },
	  toJSON: function () {
	    var data = BufferGeometry.prototype.toJSON.call(this);
	    data.maxInstancedCount = this.maxInstancedCount;
	    data.isInstancedBufferGeometry = true;
	    return data;
	  }
	});
	function InstancedBufferAttribute(array, itemSize, normalized, meshPerAttribute) {
	  if (typeof normalized === "number") {
	    meshPerAttribute = normalized;
	    normalized = false;
	    console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.");
	  }
	  BufferAttribute.call(this, array, itemSize, normalized);
	  this.meshPerAttribute = meshPerAttribute || 1;
	}
	InstancedBufferAttribute.prototype = Object.assign(Object.create(BufferAttribute.prototype), {
	  constructor: InstancedBufferAttribute,
	  isInstancedBufferAttribute: true,
	  copy: function (source) {
	    BufferAttribute.prototype.copy.call(this, source);
	    this.meshPerAttribute = source.meshPerAttribute;
	    return this;
	  },
	  toJSON: function () {
	    var data = BufferAttribute.prototype.toJSON.call(this);
	    data.meshPerAttribute = this.meshPerAttribute;
	    data.isInstancedBufferAttribute = true;
	    return data;
	  }
	});
	function BufferGeometryLoader(manager) {
	  Loader.call(this, manager);
	}
	BufferGeometryLoader.prototype = Object.assign(Object.create(Loader.prototype), {
	  constructor: BufferGeometryLoader,
	  load: function (url, onLoad, onProgress, onError) {
	    var scope = this;
	    var loader = new FileLoader(scope.manager);
	    loader.setPath(scope.path);
	    loader.load(url, function (text) {
	      onLoad(scope.parse(JSON.parse(text)));
	    }, onProgress, onError);
	  },
	  parse: function (json) {
	    var geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
	    var index = json.data.index;
	    if (index !== undefined) {
	      var typedArray = new TYPED_ARRAYS[index.type](index.array);
	      geometry.setIndex(new BufferAttribute(typedArray, 1));
	    }
	    var attributes = json.data.attributes;
	    for (var key in attributes) {
	      var attribute = attributes[key];
	      var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
	      var bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
	      var bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);
	      if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
	      geometry.setAttribute(key, bufferAttribute);
	    }
	    var morphAttributes = json.data.morphAttributes;
	    if (morphAttributes) {
	      for (var key in morphAttributes) {
	        var attributeArray = morphAttributes[key];
	        var array = [];
	        for (var i = 0, il = attributeArray.length; i < il; i++) {
	          var attribute = attributeArray[i];
	          var typedArray = new TYPED_ARRAYS[attribute.type](attribute.array);
	          var bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);
	          if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
	          array.push(bufferAttribute);
	        }
	        geometry.morphAttributes[key] = array;
	      }
	    }
	    var morphTargetsRelative = json.data.morphTargetsRelative;
	    if (morphTargetsRelative) {
	      geometry.morphTargetsRelative = true;
	    }
	    var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
	    if (groups !== undefined) {
	      for (var i = 0, n = groups.length; i !== n; ++i) {
	        var group = groups[i];
	        geometry.addGroup(group.start, group.count, group.materialIndex);
	      }
	    }
	    var boundingSphere = json.data.boundingSphere;
	    if (boundingSphere !== undefined) {
	      var center = new Vector3();
	      if (boundingSphere.center !== undefined) {
	        center.fromArray(boundingSphere.center);
	      }
	      geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
	    }
	    if (json.name) geometry.name = json.name;
	    if (json.userData) geometry.userData = json.userData;
	    return geometry;
	  }
	});
	var TYPED_ARRAYS = {
	  Int8Array: Int8Array,
	  Uint8Array: Uint8Array,
	  Uint8ClampedArray: typeof Uint8ClampedArray !== "undefined" ? Uint8ClampedArray : Uint8Array,
	  Int16Array: Int16Array,
	  Uint16Array: Uint16Array,
	  Int32Array: Int32Array,
	  Uint32Array: Uint32Array,
	  Float32Array: Float32Array,
	  Float64Array: Float64Array
	};
	function ObjectLoader(manager) {
	  Loader.call(this, manager);
	}
	ObjectLoader.prototype = Object.assign(Object.create(Loader.prototype), {
	  constructor: ObjectLoader,
	  load: function (url, onLoad, onProgress, onError) {
	    var scope = this;
	    var path = this.path === "" ? LoaderUtils.extractUrlBase(url) : this.path;
	    this.resourcePath = this.resourcePath || path;
	    var loader = new FileLoader(scope.manager);
	    loader.setPath(this.path);
	    loader.load(url, function (text) {
	      var json = null;
	      try {
	        json = JSON.parse(text);
	      } catch (error) {
	        if (onError !== undefined) onError(error);
	        console.error("THREE:ObjectLoader: Can't parse " + url + ".", error.message);
	        return;
	      }
	      var metadata = json.metadata;
	      if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === "geometry") {
	        console.error("THREE.ObjectLoader: Can't load " + url);
	        return;
	      }
	      scope.parse(json, onLoad);
	    }, onProgress, onError);
	  },
	  parse: function (json, onLoad) {
	    var shapes = this.parseShape(json.shapes);
	    var geometries = this.parseGeometries(json.geometries, shapes);
	    var images = this.parseImages(json.images, function () {
	      if (onLoad !== undefined) onLoad(object);
	    });
	    var textures = this.parseTextures(json.textures, images);
	    var materials = this.parseMaterials(json.materials, textures);
	    var object = this.parseObject(json.object, geometries, materials);
	    if (json.animations) {
	      object.animations = this.parseAnimations(json.animations);
	    }
	    if (json.images === undefined || json.images.length === 0) {
	      if (onLoad !== undefined) onLoad(object);
	    }
	    return object;
	  },
	  parseShape: function (json) {
	    var shapes = {};
	    if (json !== undefined) {
	      for (var i = 0, l = json.length; i < l; i++) {
	        var shape = new Shape().fromJSON(json[i]);
	        shapes[shape.uuid] = shape;
	      }
	    }
	    return shapes;
	  },
	  parseGeometries: function (json, shapes) {
	    var geometries = {};
	    if (json !== undefined) {
	      var bufferGeometryLoader = new BufferGeometryLoader();
	      for (var i = 0, l = json.length; i < l; i++) {
	        var geometry;
	        var data = json[i];
	        switch (data.type) {
	          case "PlaneGeometry":
	          case "PlaneBufferGeometry":
	            geometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);
	            break;
	          case "BoxGeometry":
	          case "BoxBufferGeometry":
	          case "CubeGeometry":
	            geometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
	            break;
	          case "CircleGeometry":
	          case "CircleBufferGeometry":
	            geometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);
	            break;
	          case "CylinderGeometry":
	          case "CylinderBufferGeometry":
	            geometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
	            break;
	          case "ConeGeometry":
	          case "ConeBufferGeometry":
	            geometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
	            break;
	          case "SphereGeometry":
	          case "SphereBufferGeometry":
	            geometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
	            break;
	          case "DodecahedronGeometry":
	          case "DodecahedronBufferGeometry":
	          case "IcosahedronGeometry":
	          case "IcosahedronBufferGeometry":
	          case "OctahedronGeometry":
	          case "OctahedronBufferGeometry":
	          case "TetrahedronGeometry":
	          case "TetrahedronBufferGeometry":
	            geometry = new Geometries[data.type](data.radius, data.detail);
	            break;
	          case "RingGeometry":
	          case "RingBufferGeometry":
	            geometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
	            break;
	          case "TorusGeometry":
	          case "TorusBufferGeometry":
	            geometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
	            break;
	          case "TorusKnotGeometry":
	          case "TorusKnotBufferGeometry":
	            geometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
	            break;
	          case "TubeGeometry":
	          case "TubeBufferGeometry":
	            geometry = new Geometries[data.type](new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
	            break;
	          case "LatheGeometry":
	          case "LatheBufferGeometry":
	            geometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);
	            break;
	          case "PolyhedronGeometry":
	          case "PolyhedronBufferGeometry":
	            geometry = new Geometries[data.type](data.vertices, data.indices, data.radius, data.details);
	            break;
	          case "ShapeGeometry":
	          case "ShapeBufferGeometry":
	            var geometryShapes = [];
	            for (var j = 0, jl = data.shapes.length; j < jl; j++) {
	              var shape = shapes[data.shapes[j]];
	              geometryShapes.push(shape);
	            }
	            geometry = new Geometries[data.type](geometryShapes, data.curveSegments);
	            break;
	          case "ExtrudeGeometry":
	          case "ExtrudeBufferGeometry":
	            var geometryShapes = [];
	            for (var j = 0, jl = data.shapes.length; j < jl; j++) {
	              var shape = shapes[data.shapes[j]];
	              geometryShapes.push(shape);
	            }
	            var extrudePath = data.options.extrudePath;
	            if (extrudePath !== undefined) {
	              data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
	            }
	            geometry = new Geometries[data.type](geometryShapes, data.options);
	            break;
	          case "BufferGeometry":
	          case "InstancedBufferGeometry":
	            geometry = bufferGeometryLoader.parse(data);
	            break;
	          case "Geometry":
	            console.error("THREE.ObjectLoader: Loading \"Geometry\" is not supported anymore.");
	            break;
	          default:
	            console.warn("THREE.ObjectLoader: Unsupported geometry type \"" + data.type + "\"");
	            continue;
	        }
	        geometry.uuid = data.uuid;
	        if (data.name !== undefined) geometry.name = data.name;
	        if (geometry.isBufferGeometry === true && data.userData !== undefined) geometry.userData = data.userData;
	        geometries[data.uuid] = geometry;
	      }
	    }
	    return geometries;
	  },
	  parseMaterials: function (json, textures) {
	    var cache = {};
	    var materials = {};
	    if (json !== undefined) {
	      var loader = new MaterialLoader();
	      loader.setTextures(textures);
	      for (var i = 0, l = json.length; i < l; i++) {
	        var data = json[i];
	        if (data.type === "MultiMaterial") {
	          var array = [];
	          for (var j = 0; j < data.materials.length; j++) {
	            var material = data.materials[j];
	            if (cache[material.uuid] === undefined) {
	              cache[material.uuid] = loader.parse(material);
	            }
	            array.push(cache[material.uuid]);
	          }
	          materials[data.uuid] = array;
	        } else {
	          if (cache[data.uuid] === undefined) {
	            cache[data.uuid] = loader.parse(data);
	          }
	          materials[data.uuid] = cache[data.uuid];
	        }
	      }
	    }
	    return materials;
	  },
	  parseAnimations: function (json) {
	    var animations = [];
	    for (var i = 0; i < json.length; i++) {
	      var data = json[i];
	      var clip = AnimationClip.parse(data);
	      if (data.uuid !== undefined) clip.uuid = data.uuid;
	      animations.push(clip);
	    }
	    return animations;
	  },
	  parseImages: function (json, onLoad) {
	    var scope = this;
	    var images = {};
	    function loadImage(url) {
	      scope.manager.itemStart(url);
	      return loader.load(url, function () {
	        scope.manager.itemEnd(url);
	      }, undefined, function () {
	        scope.manager.itemError(url);
	        scope.manager.itemEnd(url);
	      });
	    }
	    if (json !== undefined && json.length > 0) {
	      var manager = new LoadingManager(onLoad);
	      var loader = new ImageLoader(manager);
	      loader.setCrossOrigin(this.crossOrigin);
	      for (var i = 0, il = json.length; i < il; i++) {
	        var image = json[i];
	        var url = image.url;
	        if (Array.isArray(url)) {
	          images[image.uuid] = [];
	          for (var j = 0, jl = url.length; j < jl; j++) {
	            var currentUrl = url[j];
	            var path = (/^(\/\/)|([a-z]+:(\/\/)?)/i).test(currentUrl) ? currentUrl : scope.resourcePath + currentUrl;
	            images[image.uuid].push(loadImage(path));
	          }
	        } else {
	          var path = (/^(\/\/)|([a-z]+:(\/\/)?)/i).test(image.url) ? image.url : scope.resourcePath + image.url;
	          images[image.uuid] = loadImage(path);
	        }
	      }
	    }
	    return images;
	  },
	  parseTextures: function (json, images) {
	    function parseConstant(value, type) {
	      if (typeof value === "number") return value;
	      console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", value);
	      return type[value];
	    }
	    var textures = {};
	    if (json !== undefined) {
	      for (var i = 0, l = json.length; i < l; i++) {
	        var data = json[i];
	        if (data.image === undefined) {
	          console.warn("THREE.ObjectLoader: No \"image\" specified for", data.uuid);
	        }
	        if (images[data.image] === undefined) {
	          console.warn("THREE.ObjectLoader: Undefined image", data.image);
	        }
	        var texture;
	        if (Array.isArray(images[data.image])) {
	          texture = new CubeTexture(images[data.image]);
	        } else {
	          texture = new Texture(images[data.image]);
	        }
	        texture.needsUpdate = true;
	        texture.uuid = data.uuid;
	        if (data.name !== undefined) texture.name = data.name;
	        if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
	        if (data.offset !== undefined) texture.offset.fromArray(data.offset);
	        if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
	        if (data.center !== undefined) texture.center.fromArray(data.center);
	        if (data.rotation !== undefined) texture.rotation = data.rotation;
	        if (data.wrap !== undefined) {
	          texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
	          texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
	        }
	        if (data.format !== undefined) texture.format = data.format;
	        if (data.type !== undefined) texture.type = data.type;
	        if (data.encoding !== undefined) texture.encoding = data.encoding;
	        if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
	        if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
	        if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
	        if (data.flipY !== undefined) texture.flipY = data.flipY;
	        if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;
	        if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;
	        textures[data.uuid] = texture;
	      }
	    }
	    return textures;
	  },
	  parseObject: function (data, geometries, materials) {
	    var object;
	    function getGeometry(name) {
	      if (geometries[name] === undefined) {
	        console.warn("THREE.ObjectLoader: Undefined geometry", name);
	      }
	      return geometries[name];
	    }
	    function getMaterial(name) {
	      if (name === undefined) return undefined;
	      if (Array.isArray(name)) {
	        var array = [];
	        for (var i = 0, l = name.length; i < l; i++) {
	          var uuid = name[i];
	          if (materials[uuid] === undefined) {
	            console.warn("THREE.ObjectLoader: Undefined material", uuid);
	          }
	          array.push(materials[uuid]);
	        }
	        return array;
	      }
	      if (materials[name] === undefined) {
	        console.warn("THREE.ObjectLoader: Undefined material", name);
	      }
	      return materials[name];
	    }
	    switch (data.type) {
	      case "Scene":
	        object = new Scene();
	        if (data.background !== undefined) {
	          if (Number.isInteger(data.background)) {
	            object.background = new Color(data.background);
	          }
	        }
	        if (data.fog !== undefined) {
	          if (data.fog.type === "Fog") {
	            object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
	          } else if (data.fog.type === "FogExp2") {
	            object.fog = new FogExp2(data.fog.color, data.fog.density);
	          }
	        }
	        break;
	      case "PerspectiveCamera":
	        object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
	        if (data.focus !== undefined) object.focus = data.focus;
	        if (data.zoom !== undefined) object.zoom = data.zoom;
	        if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
	        if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
	        if (data.view !== undefined) object.view = Object.assign({}, data.view);
	        break;
	      case "OrthographicCamera":
	        object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
	        if (data.zoom !== undefined) object.zoom = data.zoom;
	        if (data.view !== undefined) object.view = Object.assign({}, data.view);
	        break;
	      case "AmbientLight":
	        object = new AmbientLight(data.color, data.intensity);
	        break;
	      case "DirectionalLight":
	        object = new DirectionalLight(data.color, data.intensity);
	        break;
	      case "PointLight":
	        object = new PointLight(data.color, data.intensity, data.distance, data.decay);
	        break;
	      case "RectAreaLight":
	        object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
	        break;
	      case "SpotLight":
	        object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
	        break;
	      case "HemisphereLight":
	        object = new HemisphereLight(data.color, data.groundColor, data.intensity);
	        break;
	      case "SkinnedMesh":
	        console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
	      case "Mesh":
	        var geometry = getGeometry(data.geometry);
	        var material = getMaterial(data.material);
	        if (geometry.bones && geometry.bones.length > 0) {
	          object = new SkinnedMesh(geometry, material);
	        } else {
	          object = new Mesh(geometry, material);
	        }
	        break;
	      case "InstancedMesh":
	        var geometry = getGeometry(data.geometry);
	        var material = getMaterial(data.material);
	        var count = data.count;
	        var instanceMatrix = data.instanceMatrix;
	        object = new InstancedMesh(geometry, material, count);
	        object.instanceMatrix = new BufferAttribute(new Float32Array(instanceMatrix.array), 16);
	        break;
	      case "LOD":
	        object = new LOD();
	        break;
	      case "Line":
	        object = new Line(getGeometry(data.geometry), getMaterial(data.material), data.mode);
	        break;
	      case "LineLoop":
	        object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
	        break;
	      case "LineSegments":
	        object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
	        break;
	      case "PointCloud":
	      case "Points":
	        object = new Points(getGeometry(data.geometry), getMaterial(data.material));
	        break;
	      case "Sprite":
	        object = new Sprite(getMaterial(data.material));
	        break;
	      case "Group":
	        object = new Group();
	        break;
	      default:
	        object = new Object3D();
	    }
	    object.uuid = data.uuid;
	    if (data.name !== undefined) object.name = data.name;
	    if (data.matrix !== undefined) {
	      object.matrix.fromArray(data.matrix);
	      if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;
	      if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
	    } else {
	      if (data.position !== undefined) object.position.fromArray(data.position);
	      if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
	      if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
	      if (data.scale !== undefined) object.scale.fromArray(data.scale);
	    }
	    if (data.castShadow !== undefined) object.castShadow = data.castShadow;
	    if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;
	    if (data.shadow) {
	      if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
	      if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
	      if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
	      if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
	    }
	    if (data.visible !== undefined) object.visible = data.visible;
	    if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
	    if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
	    if (data.userData !== undefined) object.userData = data.userData;
	    if (data.layers !== undefined) object.layers.mask = data.layers;
	    if (data.children !== undefined) {
	      var children = data.children;
	      for (var i = 0; i < children.length; i++) {
	        object.add(this.parseObject(children[i], geometries, materials));
	      }
	    }
	    if (data.type === "LOD") {
	      if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;
	      var levels = data.levels;
	      for (var l = 0; l < levels.length; l++) {
	        var level = levels[l];
	        var child = object.getObjectByProperty("uuid", level.object);
	        if (child !== undefined) {
	          object.addLevel(child, level.distance);
	        }
	      }
	    }
	    return object;
	  }
	});
	var TEXTURE_MAPPING = {
	  UVMapping: UVMapping,
	  CubeReflectionMapping: CubeReflectionMapping,
	  CubeRefractionMapping: CubeRefractionMapping,
	  EquirectangularReflectionMapping: EquirectangularReflectionMapping,
	  EquirectangularRefractionMapping: EquirectangularRefractionMapping,
	  SphericalReflectionMapping: SphericalReflectionMapping,
	  CubeUVReflectionMapping: CubeUVReflectionMapping,
	  CubeUVRefractionMapping: CubeUVRefractionMapping
	};
	var TEXTURE_WRAPPING = {
	  RepeatWrapping: RepeatWrapping,
	  ClampToEdgeWrapping: ClampToEdgeWrapping,
	  MirroredRepeatWrapping: MirroredRepeatWrapping
	};
	var TEXTURE_FILTER = {
	  NearestFilter: NearestFilter,
	  NearestMipmapNearestFilter: NearestMipmapNearestFilter,
	  NearestMipmapLinearFilter: NearestMipmapLinearFilter,
	  LinearFilter: LinearFilter,
	  LinearMipmapNearestFilter: LinearMipmapNearestFilter,
	  LinearMipmapLinearFilter: LinearMipmapLinearFilter
	};
	function ImageBitmapLoader(manager) {
	  if (typeof createImageBitmap === "undefined") {
	    console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");
	  }
	  if (typeof fetch === "undefined") {
	    console.warn("THREE.ImageBitmapLoader: fetch() not supported.");
	  }
	  Loader.call(this, manager);
	  this.options = undefined;
	}
	ImageBitmapLoader.prototype = Object.assign(Object.create(Loader.prototype), {
	  constructor: ImageBitmapLoader,
	  setOptions: function setOptions(options) {
	    this.options = options;
	    return this;
	  },
	  load: function (url, onLoad, onProgress, onError) {
	    if (url === undefined) url = "";
	    if (this.path !== undefined) url = this.path + url;
	    url = this.manager.resolveURL(url);
	    var scope = this;
	    var cached = Cache.get(url);
	    if (cached !== undefined) {
	      scope.manager.itemStart(url);
	      setTimeout(function () {
	        if (onLoad) onLoad(cached);
	        scope.manager.itemEnd(url);
	      }, 0);
	      return cached;
	    }
	    fetch(url).then(function (res) {
	      return res.blob();
	    }).then(function (blob) {
	      if (scope.options === undefined) {
	        return createImageBitmap(blob);
	      } else {
	        return createImageBitmap(blob, scope.options);
	      }
	    }).then(function (imageBitmap) {
	      Cache.add(url, imageBitmap);
	      if (onLoad) onLoad(imageBitmap);
	      scope.manager.itemEnd(url);
	    }).catch(function (e) {
	      if (onError) onError(e);
	      scope.manager.itemError(url);
	      scope.manager.itemEnd(url);
	    });
	    scope.manager.itemStart(url);
	  }
	});
	function ShapePath() {
	  this.type = "ShapePath";
	  this.color = new Color();
	  this.subPaths = [];
	  this.currentPath = null;
	}
	Object.assign(ShapePath.prototype, {
	  moveTo: function (x, y) {
	    this.currentPath = new Path();
	    this.subPaths.push(this.currentPath);
	    this.currentPath.moveTo(x, y);
	    return this;
	  },
	  lineTo: function (x, y) {
	    this.currentPath.lineTo(x, y);
	    return this;
	  },
	  quadraticCurveTo: function (aCPx, aCPy, aX, aY) {
	    this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
	    return this;
	  },
	  bezierCurveTo: function (aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
	    this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
	    return this;
	  },
	  splineThru: function (pts) {
	    this.currentPath.splineThru(pts);
	    return this;
	  },
	  toShapes: function (isCCW, noHoles) {
	    function toShapesNoHoles(inSubpaths) {
	      var shapes = [];
	      for (var i = 0, l = inSubpaths.length; i < l; i++) {
	        var tmpPath = inSubpaths[i];
	        var tmpShape = new Shape();
	        tmpShape.curves = tmpPath.curves;
	        shapes.push(tmpShape);
	      }
	      return shapes;
	    }
	    function isPointInsidePolygon(inPt, inPolygon) {
	      var polyLen = inPolygon.length;
	      var inside = false;
	      for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {
	        var edgeLowPt = inPolygon[p];
	        var edgeHighPt = inPolygon[q];
	        var edgeDx = edgeHighPt.x - edgeLowPt.x;
	        var edgeDy = edgeHighPt.y - edgeLowPt.y;
	        if (Math.abs(edgeDy) > Number.EPSILON) {
	          if (edgeDy < 0) {
	            edgeLowPt = inPolygon[q];
	            edgeDx = -edgeDx;
	            edgeHighPt = inPolygon[p];
	            edgeDy = -edgeDy;
	          }
	          if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;
	          if (inPt.y === edgeLowPt.y) {
	            if (inPt.x === edgeLowPt.x) return true;
	          } else {
	            var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
	            if (perpEdge === 0) return true;
	            if (perpEdge < 0) continue;
	            inside = !inside;
	          }
	        } else {
	          if (inPt.y !== edgeLowPt.y) continue;
	          if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true;
	        }
	      }
	      return inside;
	    }
	    var isClockWise = ShapeUtils.isClockWise;
	    var subPaths = this.subPaths;
	    if (subPaths.length === 0) return [];
	    if (noHoles === true) return toShapesNoHoles(subPaths);
	    var solid, tmpPath, tmpShape, shapes = [];
	    if (subPaths.length === 1) {
	      tmpPath = subPaths[0];
	      tmpShape = new Shape();
	      tmpShape.curves = tmpPath.curves;
	      shapes.push(tmpShape);
	      return shapes;
	    }
	    var holesFirst = !isClockWise(subPaths[0].getPoints());
	    holesFirst = isCCW ? !holesFirst : holesFirst;
	    var betterShapeHoles = [];
	    var newShapes = [];
	    var newShapeHoles = [];
	    var mainIdx = 0;
	    var tmpPoints;
	    newShapes[mainIdx] = undefined;
	    newShapeHoles[mainIdx] = [];
	    for (var i = 0, l = subPaths.length; i < l; i++) {
	      tmpPath = subPaths[i];
	      tmpPoints = tmpPath.getPoints();
	      solid = isClockWise(tmpPoints);
	      solid = isCCW ? !solid : solid;
	      if (solid) {
	        if (!holesFirst && newShapes[mainIdx]) mainIdx++;
	        newShapes[mainIdx] = {
	          s: new Shape(),
	          p: tmpPoints
	        };
	        newShapes[mainIdx].s.curves = tmpPath.curves;
	        if (holesFirst) mainIdx++;
	        newShapeHoles[mainIdx] = [];
	      } else {
	        newShapeHoles[mainIdx].push({
	          h: tmpPath,
	          p: tmpPoints[0]
	        });
	      }
	    }
	    if (!newShapes[0]) return toShapesNoHoles(subPaths);
	    if (newShapes.length > 1) {
	      var ambiguous = false;
	      var toChange = [];
	      for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
	        betterShapeHoles[sIdx] = [];
	      }
	      for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
	        var sho = newShapeHoles[sIdx];
	        for (var hIdx = 0; hIdx < sho.length; hIdx++) {
	          var ho = sho[hIdx];
	          var hole_unassigned = true;
	          for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
	            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
	              if (sIdx !== s2Idx) toChange.push({
	                froms: sIdx,
	                tos: s2Idx,
	                hole: hIdx
	              });
	              if (hole_unassigned) {
	                hole_unassigned = false;
	                betterShapeHoles[s2Idx].push(ho);
	              } else {
	                ambiguous = true;
	              }
	            }
	          }
	          if (hole_unassigned) {
	            betterShapeHoles[sIdx].push(ho);
	          }
	        }
	      }
	      if (toChange.length > 0) {
	        if (!ambiguous) newShapeHoles = betterShapeHoles;
	      }
	    }
	    var tmpHoles;
	    for (var i = 0, il = newShapes.length; i < il; i++) {
	      tmpShape = newShapes[i].s;
	      shapes.push(tmpShape);
	      tmpHoles = newShapeHoles[i];
	      for (var j = 0, jl = tmpHoles.length; j < jl; j++) {
	        tmpShape.holes.push(tmpHoles[j].h);
	      }
	    }
	    return shapes;
	  }
	});
	function Font(data) {
	  this.type = "Font";
	  this.data = data;
	}
	Object.assign(Font.prototype, {
	  isFont: true,
	  generateShapes: function (text, size) {
	    if (size === undefined) size = 100;
	    var shapes = [];
	    var paths = createPaths(text, size, this.data);
	    for (var p = 0, pl = paths.length; p < pl; p++) {
	      Array.prototype.push.apply(shapes, paths[p].toShapes());
	    }
	    return shapes;
	  }
	});
	function createPaths(text, size, data) {
	  var chars = Array.from ? Array.from(text) : String(text).split("");
	  var scale = size / data.resolution;
	  var line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;
	  var paths = [];
	  var offsetX = 0, offsetY = 0;
	  for (var i = 0; i < chars.length; i++) {
	    var char = chars[i];
	    if (char === "\n") {
	      offsetX = 0;
	      offsetY -= line_height;
	    } else {
	      var ret = createPath(char, scale, offsetX, offsetY, data);
	      offsetX += ret.offsetX;
	      paths.push(ret.path);
	    }
	  }
	  return paths;
	}
	function createPath(char, scale, offsetX, offsetY, data) {
	  var glyph = data.glyphs[char] || data.glyphs["?"];
	  if (!glyph) {
	    console.error("THREE.Font: character \"" + char + "\" does not exists in font family " + data.familyName + ".");
	    return;
	  }
	  var path = new ShapePath();
	  var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
	  if (glyph.o) {
	    var outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(" "));
	    for (var i = 0, l = outline.length; i < l; ) {
	      var action = outline[i++];
	      switch (action) {
	        case "m":
	          x = outline[i++] * scale + offsetX;
	          y = outline[i++] * scale + offsetY;
	          path.moveTo(x, y);
	          break;
	        case "l":
	          x = outline[i++] * scale + offsetX;
	          y = outline[i++] * scale + offsetY;
	          path.lineTo(x, y);
	          break;
	        case "q":
	          cpx = outline[i++] * scale + offsetX;
	          cpy = outline[i++] * scale + offsetY;
	          cpx1 = outline[i++] * scale + offsetX;
	          cpy1 = outline[i++] * scale + offsetY;
	          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);
	          break;
	        case "b":
	          cpx = outline[i++] * scale + offsetX;
	          cpy = outline[i++] * scale + offsetY;
	          cpx1 = outline[i++] * scale + offsetX;
	          cpy1 = outline[i++] * scale + offsetY;
	          cpx2 = outline[i++] * scale + offsetX;
	          cpy2 = outline[i++] * scale + offsetY;
	          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);
	          break;
	      }
	    }
	  }
	  return {
	    offsetX: glyph.ha * scale,
	    path: path
	  };
	}
	function FontLoader(manager) {
	  Loader.call(this, manager);
	}
	FontLoader.prototype = Object.assign(Object.create(Loader.prototype), {
	  constructor: FontLoader,
	  load: function (url, onLoad, onProgress, onError) {
	    var scope = this;
	    var loader = new FileLoader(this.manager);
	    loader.setPath(this.path);
	    loader.load(url, function (text) {
	      var json;
	      try {
	        json = JSON.parse(text);
	      } catch (e) {
	        console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.");
	        json = JSON.parse(text.substring(65, text.length - 2));
	      }
	      var font = scope.parse(json);
	      if (onLoad) onLoad(font);
	    }, onProgress, onError);
	  },
	  parse: function (json) {
	    return new Font(json);
	  }
	});
	var _context;
	var AudioContext = {
	  getContext: function () {
	    if (_context === undefined) {
	      _context = new (window.AudioContext || window.webkitAudioContext)();
	    }
	    return _context;
	  },
	  setContext: function (value) {
	    _context = value;
	  }
	};
	function AudioLoader(manager) {
	  Loader.call(this, manager);
	}
	AudioLoader.prototype = Object.assign(Object.create(Loader.prototype), {
	  constructor: AudioLoader,
	  load: function (url, onLoad, onProgress, onError) {
	    var loader = new FileLoader(this.manager);
	    loader.setResponseType("arraybuffer");
	    loader.setPath(this.path);
	    loader.load(url, function (buffer) {
	      var bufferCopy = buffer.slice(0);
	      var context = AudioContext.getContext();
	      context.decodeAudioData(bufferCopy, function (audioBuffer) {
	        onLoad(audioBuffer);
	      });
	    }, onProgress, onError);
	  }
	});
	function SphericalHarmonics3() {
	  this.coefficients = [];
	  for (var i = 0; i < 9; i++) {
	    this.coefficients.push(new Vector3());
	  }
	}
	Object.assign(SphericalHarmonics3.prototype, {
	  isSphericalHarmonics3: true,
	  set: function (coefficients) {
	    for (var i = 0; i < 9; i++) {
	      this.coefficients[i].copy(coefficients[i]);
	    }
	    return this;
	  },
	  zero: function () {
	    for (var i = 0; i < 9; i++) {
	      this.coefficients[i].set(0, 0, 0);
	    }
	    return this;
	  },
	  getAt: function (normal, target) {
	    var x = normal.x, y = normal.y, z = normal.z;
	    var coeff = this.coefficients;
	    target.copy(coeff[0]).multiplyScalar(0.282095);
	    target.addScale(coeff[1], 0.488603 * y);
	    target.addScale(coeff[2], 0.488603 * z);
	    target.addScale(coeff[3], 0.488603 * x);
	    target.addScale(coeff[4], 1.092548 * (x * y));
	    target.addScale(coeff[5], 1.092548 * (y * z));
	    target.addScale(coeff[6], 0.315392 * (3 * z * z - 1));
	    target.addScale(coeff[7], 1.092548 * (x * z));
	    target.addScale(coeff[8], 0.546274 * (x * x - y * y));
	    return target;
	  },
	  getIrradianceAt: function (normal, target) {
	    var x = normal.x, y = normal.y, z = normal.z;
	    var coeff = this.coefficients;
	    target.copy(coeff[0]).multiplyScalar(0.886227);
	    target.addScale(coeff[1], 2 * 0.511664 * y);
	    target.addScale(coeff[2], 2 * 0.511664 * z);
	    target.addScale(coeff[3], 2 * 0.511664 * x);
	    target.addScale(coeff[4], 2 * 0.429043 * x * y);
	    target.addScale(coeff[5], 2 * 0.429043 * y * z);
	    target.addScale(coeff[6], 0.743125 * z * z - 0.247708);
	    target.addScale(coeff[7], 2 * 0.429043 * x * z);
	    target.addScale(coeff[8], 0.429043 * (x * x - y * y));
	    return target;
	  },
	  add: function (sh) {
	    for (var i = 0; i < 9; i++) {
	      this.coefficients[i].add(sh.coefficients[i]);
	    }
	    return this;
	  },
	  scale: function (s) {
	    for (var i = 0; i < 9; i++) {
	      this.coefficients[i].multiplyScalar(s);
	    }
	    return this;
	  },
	  lerp: function (sh, alpha) {
	    for (var i = 0; i < 9; i++) {
	      this.coefficients[i].lerp(sh.coefficients[i], alpha);
	    }
	    return this;
	  },
	  equals: function (sh) {
	    for (var i = 0; i < 9; i++) {
	      if (!this.coefficients[i].equals(sh.coefficients[i])) {
	        return false;
	      }
	    }
	    return true;
	  },
	  copy: function (sh) {
	    return this.set(sh.coefficients);
	  },
	  clone: function () {
	    return new this.constructor().copy(this);
	  },
	  fromArray: function (array, offset) {
	    if (offset === undefined) offset = 0;
	    var coefficients = this.coefficients;
	    for (var i = 0; i < 9; i++) {
	      coefficients[i].fromArray(array, offset + i * 3);
	    }
	    return this;
	  },
	  toArray: function (array, offset) {
	    if (array === undefined) array = [];
	    if (offset === undefined) offset = 0;
	    var coefficients = this.coefficients;
	    for (var i = 0; i < 9; i++) {
	      coefficients[i].toArray(array, offset + i * 3);
	    }
	    return array;
	  }
	});
	Object.assign(SphericalHarmonics3, {
	  getBasisAt: function (normal, shBasis) {
	    var x = normal.x, y = normal.y, z = normal.z;
	    shBasis[0] = 0.282095;
	    shBasis[1] = 0.488603 * y;
	    shBasis[2] = 0.488603 * z;
	    shBasis[3] = 0.488603 * x;
	    shBasis[4] = 1.092548 * x * y;
	    shBasis[5] = 1.092548 * y * z;
	    shBasis[6] = 0.315392 * (3 * z * z - 1);
	    shBasis[7] = 1.092548 * x * z;
	    shBasis[8] = 0.546274 * (x * x - y * y);
	  }
	});
	function LightProbe(sh, intensity) {
	  Light.call(this, undefined, intensity);
	  this.sh = sh !== undefined ? sh : new SphericalHarmonics3();
	}
	LightProbe.prototype = Object.assign(Object.create(Light.prototype), {
	  constructor: LightProbe,
	  isLightProbe: true,
	  copy: function (source) {
	    Light.prototype.copy.call(this, source);
	    this.sh.copy(source.sh);
	    this.intensity = source.intensity;
	    return this;
	  },
	  toJSON: function (meta) {
	    var data = Light.prototype.toJSON.call(this, meta);
	    return data;
	  }
	});
	function HemisphereLightProbe(skyColor, groundColor, intensity) {
	  LightProbe.call(this, undefined, intensity);
	  var color1 = new Color().set(skyColor);
	  var color2 = new Color().set(groundColor);
	  var sky = new Vector3(color1.r, color1.g, color1.b);
	  var ground = new Vector3(color2.r, color2.g, color2.b);
	  var c0 = Math.sqrt(Math.PI);
	  var c1 = c0 * Math.sqrt(0.75);
	  this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);
	  this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);
	}
	HemisphereLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
	  constructor: HemisphereLightProbe,
	  isHemisphereLightProbe: true,
	  copy: function (source) {
	    LightProbe.prototype.copy.call(this, source);
	    return this;
	  },
	  toJSON: function (meta) {
	    var data = LightProbe.prototype.toJSON.call(this, meta);
	    return data;
	  }
	});
	function AmbientLightProbe(color, intensity) {
	  LightProbe.call(this, undefined, intensity);
	  var color1 = new Color().set(color);
	  this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));
	}
	AmbientLightProbe.prototype = Object.assign(Object.create(LightProbe.prototype), {
	  constructor: AmbientLightProbe,
	  isAmbientLightProbe: true,
	  copy: function (source) {
	    LightProbe.prototype.copy.call(this, source);
	    return this;
	  },
	  toJSON: function (meta) {
	    var data = LightProbe.prototype.toJSON.call(this, meta);
	    return data;
	  }
	});
	var _eyeRight = new Matrix4();
	var _eyeLeft = new Matrix4();
	function StereoCamera() {
	  this.type = "StereoCamera";
	  this.aspect = 1;
	  this.eyeSep = 0.064;
	  this.cameraL = new PerspectiveCamera();
	  this.cameraL.layers.enable(1);
	  this.cameraL.matrixAutoUpdate = false;
	  this.cameraR = new PerspectiveCamera();
	  this.cameraR.layers.enable(2);
	  this.cameraR.matrixAutoUpdate = false;
	  this._cache = {
	    focus: null,
	    fov: null,
	    aspect: null,
	    near: null,
	    far: null,
	    zoom: null,
	    eyeSep: null
	  };
	}
	Object.assign(StereoCamera.prototype, {
	  update: function (camera) {
	    var cache = this._cache;
	    var needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;
	    if (needsUpdate) {
	      cache.focus = camera.focus;
	      cache.fov = camera.fov;
	      cache.aspect = camera.aspect * this.aspect;
	      cache.near = camera.near;
	      cache.far = camera.far;
	      cache.zoom = camera.zoom;
	      cache.eyeSep = this.eyeSep;
	      var projectionMatrix = camera.projectionMatrix.clone();
	      var eyeSepHalf = cache.eyeSep / 2;
	      var eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
	      var ymax = cache.near * Math.tan(MathUtils.DEG2RAD * cache.fov * 0.5) / cache.zoom;
	      var xmin, xmax;
	      _eyeLeft.elements[12] = -eyeSepHalf;
	      _eyeRight.elements[12] = eyeSepHalf;
	      xmin = -ymax * cache.aspect + eyeSepOnProjection;
	      xmax = ymax * cache.aspect + eyeSepOnProjection;
	      projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
	      projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
	      this.cameraL.projectionMatrix.copy(projectionMatrix);
	      xmin = -ymax * cache.aspect - eyeSepOnProjection;
	      xmax = ymax * cache.aspect - eyeSepOnProjection;
	      projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
	      projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
	      this.cameraR.projectionMatrix.copy(projectionMatrix);
	    }
	    this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
	    this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
	  }
	});
	function Clock(autoStart) {
	  this.autoStart = autoStart !== undefined ? autoStart : true;
	  this.startTime = 0;
	  this.oldTime = 0;
	  this.elapsedTime = 0;
	  this.running = false;
	}
	Object.assign(Clock.prototype, {
	  start: function () {
	    this.startTime = (typeof performance === "undefined" ? Date : performance).now();
	    this.oldTime = this.startTime;
	    this.elapsedTime = 0;
	    this.running = true;
	  },
	  stop: function () {
	    this.getElapsedTime();
	    this.running = false;
	    this.autoStart = false;
	  },
	  getElapsedTime: function () {
	    this.getDelta();
	    return this.elapsedTime;
	  },
	  getDelta: function () {
	    var diff = 0;
	    if (this.autoStart && !this.running) {
	      this.start();
	      return 0;
	    }
	    if (this.running) {
	      var newTime = (typeof performance === "undefined" ? Date : performance).now();
	      diff = (newTime - this.oldTime) / 1000;
	      this.oldTime = newTime;
	      this.elapsedTime += diff;
	    }
	    return diff;
	  }
	});
	var _position$2 = new Vector3();
	var _quaternion$3 = new Quaternion();
	var _scale$1 = new Vector3();
	var _orientation = new Vector3();
	function AudioListener() {
	  Object3D.call(this);
	  this.type = "AudioListener";
	  this.context = AudioContext.getContext();
	  this.gain = this.context.createGain();
	  this.gain.connect(this.context.destination);
	  this.filter = null;
	  this.timeDelta = 0;
	  this._clock = new Clock();
	}
	AudioListener.prototype = Object.assign(Object.create(Object3D.prototype), {
	  constructor: AudioListener,
	  getInput: function () {
	    return this.gain;
	  },
	  removeFilter: function () {
	    if (this.filter !== null) {
	      this.gain.disconnect(this.filter);
	      this.filter.disconnect(this.context.destination);
	      this.gain.connect(this.context.destination);
	      this.filter = null;
	    }
	    return this;
	  },
	  getFilter: function () {
	    return this.filter;
	  },
	  setFilter: function (value) {
	    if (this.filter !== null) {
	      this.gain.disconnect(this.filter);
	      this.filter.disconnect(this.context.destination);
	    } else {
	      this.gain.disconnect(this.context.destination);
	    }
	    this.filter = value;
	    this.gain.connect(this.filter);
	    this.filter.connect(this.context.destination);
	    return this;
	  },
	  getMasterVolume: function () {
	    return this.gain.gain.value;
	  },
	  setMasterVolume: function (value) {
	    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
	    return this;
	  },
	  updateMatrixWorld: function (force) {
	    Object3D.prototype.updateMatrixWorld.call(this, force);
	    var listener = this.context.listener;
	    var up = this.up;
	    this.timeDelta = this._clock.getDelta();
	    this.matrixWorld.decompose(_position$2, _quaternion$3, _scale$1);
	    _orientation.set(0, 0, -1).applyQuaternion(_quaternion$3);
	    if (listener.positionX) {
	      var endTime = this.context.currentTime + this.timeDelta;
	      listener.positionX.linearRampToValueAtTime(_position$2.x, endTime);
	      listener.positionY.linearRampToValueAtTime(_position$2.y, endTime);
	      listener.positionZ.linearRampToValueAtTime(_position$2.z, endTime);
	      listener.forwardX.linearRampToValueAtTime(_orientation.x, endTime);
	      listener.forwardY.linearRampToValueAtTime(_orientation.y, endTime);
	      listener.forwardZ.linearRampToValueAtTime(_orientation.z, endTime);
	      listener.upX.linearRampToValueAtTime(up.x, endTime);
	      listener.upY.linearRampToValueAtTime(up.y, endTime);
	      listener.upZ.linearRampToValueAtTime(up.z, endTime);
	    } else {
	      listener.setPosition(_position$2.x, _position$2.y, _position$2.z);
	      listener.setOrientation(_orientation.x, _orientation.y, _orientation.z, up.x, up.y, up.z);
	    }
	  }
	});
	function Audio(listener) {
	  Object3D.call(this);
	  this.type = "Audio";
	  this.listener = listener;
	  this.context = listener.context;
	  this.gain = this.context.createGain();
	  this.gain.connect(listener.getInput());
	  this.autoplay = false;
	  this.buffer = null;
	  this.detune = 0;
	  this.loop = false;
	  this.loopStart = 0;
	  this.loopEnd = 0;
	  this.offset = 0;
	  this.duration = undefined;
	  this.playbackRate = 1;
	  this.isPlaying = false;
	  this.hasPlaybackControl = true;
	  this.sourceType = "empty";
	  this._startedAt = 0;
	  this._pausedAt = 0;
	  this.filters = [];
	}
	Audio.prototype = Object.assign(Object.create(Object3D.prototype), {
	  constructor: Audio,
	  getOutput: function () {
	    return this.gain;
	  },
	  setNodeSource: function (audioNode) {
	    this.hasPlaybackControl = false;
	    this.sourceType = "audioNode";
	    this.source = audioNode;
	    this.connect();
	    return this;
	  },
	  setMediaElementSource: function (mediaElement) {
	    this.hasPlaybackControl = false;
	    this.sourceType = "mediaNode";
	    this.source = this.context.createMediaElementSource(mediaElement);
	    this.connect();
	    return this;
	  },
	  setMediaStreamSource: function (mediaStream) {
	    this.hasPlaybackControl = false;
	    this.sourceType = "mediaStreamNode";
	    this.source = this.context.createMediaStreamSource(mediaStream);
	    this.connect();
	    return this;
	  },
	  setBuffer: function (audioBuffer) {
	    this.buffer = audioBuffer;
	    this.sourceType = "buffer";
	    if (this.autoplay) this.play();
	    return this;
	  },
	  play: function (delay) {
	    if (delay === undefined) delay = 0;
	    if (this.isPlaying === true) {
	      console.warn("THREE.Audio: Audio is already playing.");
	      return;
	    }
	    if (this.hasPlaybackControl === false) {
	      console.warn("THREE.Audio: this Audio has no playback control.");
	      return;
	    }
	    this._startedAt = this.context.currentTime + delay;
	    var source = this.context.createBufferSource();
	    source.buffer = this.buffer;
	    source.loop = this.loop;
	    source.loopStart = this.loopStart;
	    source.loopEnd = this.loopEnd;
	    source.onended = this.onEnded.bind(this);
	    source.start(this._startedAt, this._pausedAt + this.offset, this.duration);
	    this.isPlaying = true;
	    this.source = source;
	    this.setDetune(this.detune);
	    this.setPlaybackRate(this.playbackRate);
	    return this.connect();
	  },
	  pause: function () {
	    if (this.hasPlaybackControl === false) {
	      console.warn("THREE.Audio: this Audio has no playback control.");
	      return;
	    }
	    if (this.isPlaying === true) {
	      this._pausedAt += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
	      this.source.stop();
	      this.source.onended = null;
	      this.isPlaying = false;
	    }
	    return this;
	  },
	  stop: function () {
	    if (this.hasPlaybackControl === false) {
	      console.warn("THREE.Audio: this Audio has no playback control.");
	      return;
	    }
	    this._pausedAt = 0;
	    this.source.stop();
	    this.source.onended = null;
	    this.isPlaying = false;
	    return this;
	  },
	  connect: function () {
	    if (this.filters.length > 0) {
	      this.source.connect(this.filters[0]);
	      for (var i = 1, l = this.filters.length; i < l; i++) {
	        this.filters[i - 1].connect(this.filters[i]);
	      }
	      this.filters[this.filters.length - 1].connect(this.getOutput());
	    } else {
	      this.source.connect(this.getOutput());
	    }
	    return this;
	  },
	  disconnect: function () {
	    if (this.filters.length > 0) {
	      this.source.disconnect(this.filters[0]);
	      for (var i = 1, l = this.filters.length; i < l; i++) {
	        this.filters[i - 1].disconnect(this.filters[i]);
	      }
	      this.filters[this.filters.length - 1].disconnect(this.getOutput());
	    } else {
	      this.source.disconnect(this.getOutput());
	    }
	    return this;
	  },
	  getFilters: function () {
	    return this.filters;
	  },
	  setFilters: function (value) {
	    if (!value) value = [];
	    if (this.isPlaying === true) {
	      this.disconnect();
	      this.filters = value;
	      this.connect();
	    } else {
	      this.filters = value;
	    }
	    return this;
	  },
	  setDetune: function (value) {
	    this.detune = value;
	    if (this.source.detune === undefined) return;
	    if (this.isPlaying === true) {
	      this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
	    }
	    return this;
	  },
	  getDetune: function () {
	    return this.detune;
	  },
	  getFilter: function () {
	    return this.getFilters()[0];
	  },
	  setFilter: function (filter) {
	    return this.setFilters(filter ? [filter] : []);
	  },
	  setPlaybackRate: function (value) {
	    if (this.hasPlaybackControl === false) {
	      console.warn("THREE.Audio: this Audio has no playback control.");
	      return;
	    }
	    this.playbackRate = value;
	    if (this.isPlaying === true) {
	      this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
	    }
	    return this;
	  },
	  getPlaybackRate: function () {
	    return this.playbackRate;
	  },
	  onEnded: function () {
	    this.isPlaying = false;
	  },
	  getLoop: function () {
	    if (this.hasPlaybackControl === false) {
	      console.warn("THREE.Audio: this Audio has no playback control.");
	      return false;
	    }
	    return this.loop;
	  },
	  setLoop: function (value) {
	    if (this.hasPlaybackControl === false) {
	      console.warn("THREE.Audio: this Audio has no playback control.");
	      return;
	    }
	    this.loop = value;
	    if (this.isPlaying === true) {
	      this.source.loop = this.loop;
	    }
	    return this;
	  },
	  setLoopStart: function (value) {
	    this.loopStart = value;
	    return this;
	  },
	  setLoopEnd: function (value) {
	    this.loopEnd = value;
	    return this;
	  },
	  getVolume: function () {
	    return this.gain.gain.value;
	  },
	  setVolume: function (value) {
	    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
	    return this;
	  }
	});
	var _position$3 = new Vector3();
	var _quaternion$4 = new Quaternion();
	var _scale$2 = new Vector3();
	var _orientation$1 = new Vector3();
	function PositionalAudio(listener) {
	  Audio.call(this, listener);
	  this.panner = this.context.createPanner();
	  this.panner.panningModel = "HRTF";
	  this.panner.connect(this.gain);
	}
	PositionalAudio.prototype = Object.assign(Object.create(Audio.prototype), {
	  constructor: PositionalAudio,
	  getOutput: function () {
	    return this.panner;
	  },
	  getRefDistance: function () {
	    return this.panner.refDistance;
	  },
	  setRefDistance: function (value) {
	    this.panner.refDistance = value;
	    return this;
	  },
	  getRolloffFactor: function () {
	    return this.panner.rolloffFactor;
	  },
	  setRolloffFactor: function (value) {
	    this.panner.rolloffFactor = value;
	    return this;
	  },
	  getDistanceModel: function () {
	    return this.panner.distanceModel;
	  },
	  setDistanceModel: function (value) {
	    this.panner.distanceModel = value;
	    return this;
	  },
	  getMaxDistance: function () {
	    return this.panner.maxDistance;
	  },
	  setMaxDistance: function (value) {
	    this.panner.maxDistance = value;
	    return this;
	  },
	  setDirectionalCone: function (coneInnerAngle, coneOuterAngle, coneOuterGain) {
	    this.panner.coneInnerAngle = coneInnerAngle;
	    this.panner.coneOuterAngle = coneOuterAngle;
	    this.panner.coneOuterGain = coneOuterGain;
	    return this;
	  },
	  updateMatrixWorld: function (force) {
	    Object3D.prototype.updateMatrixWorld.call(this, force);
	    if (this.hasPlaybackControl === true && this.isPlaying === false) return;
	    this.matrixWorld.decompose(_position$3, _quaternion$4, _scale$2);
	    _orientation$1.set(0, 0, 1).applyQuaternion(_quaternion$4);
	    var panner = this.panner;
	    if (panner.positionX) {
	      var endTime = this.context.currentTime + this.listener.timeDelta;
	      panner.positionX.linearRampToValueAtTime(_position$3.x, endTime);
	      panner.positionY.linearRampToValueAtTime(_position$3.y, endTime);
	      panner.positionZ.linearRampToValueAtTime(_position$3.z, endTime);
	      panner.orientationX.linearRampToValueAtTime(_orientation$1.x, endTime);
	      panner.orientationY.linearRampToValueAtTime(_orientation$1.y, endTime);
	      panner.orientationZ.linearRampToValueAtTime(_orientation$1.z, endTime);
	    } else {
	      panner.setPosition(_position$3.x, _position$3.y, _position$3.z);
	      panner.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z);
	    }
	  }
	});
	function AudioAnalyser(audio, fftSize) {
	  this.analyser = audio.context.createAnalyser();
	  this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;
	  this.data = new Uint8Array(this.analyser.frequencyBinCount);
	  audio.getOutput().connect(this.analyser);
	}
	Object.assign(AudioAnalyser.prototype, {
	  getFrequencyData: function () {
	    this.analyser.getByteFrequencyData(this.data);
	    return this.data;
	  },
	  getAverageFrequency: function () {
	    var value = 0, data = this.getFrequencyData();
	    for (var i = 0; i < data.length; i++) {
	      value += data[i];
	    }
	    return value / data.length;
	  }
	});
	function PropertyMixer(binding, typeName, valueSize) {
	  this.binding = binding;
	  this.valueSize = valueSize;
	  var bufferType = Float64Array, mixFunction;
	  switch (typeName) {
	    case "quaternion":
	      mixFunction = this._slerp;
	      break;
	    case "string":
	    case "bool":
	      bufferType = Array;
	      mixFunction = this._select;
	      break;
	    default:
	      mixFunction = this._lerp;
	  }
	  this.buffer = new bufferType(valueSize * 4);
	  this._mixBufferRegion = mixFunction;
	  this.cumulativeWeight = 0;
	  this.useCount = 0;
	  this.referenceCount = 0;
	}
	Object.assign(PropertyMixer.prototype, {
	  accumulate: function (accuIndex, weight) {
	    var buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride, currentWeight = this.cumulativeWeight;
	    if (currentWeight === 0) {
	      for (var i = 0; i !== stride; ++i) {
	        buffer[offset + i] = buffer[i];
	      }
	      currentWeight = weight;
	    } else {
	      currentWeight += weight;
	      var mix = weight / currentWeight;
	      this._mixBufferRegion(buffer, offset, 0, mix, stride);
	    }
	    this.cumulativeWeight = currentWeight;
	  },
	  apply: function (accuIndex) {
	    var stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, binding = this.binding;
	    this.cumulativeWeight = 0;
	    if (weight < 1) {
	      var originalValueOffset = stride * 3;
	      this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
	    }
	    for (var i = stride, e = stride + stride; i !== e; ++i) {
	      if (buffer[i] !== buffer[i + stride]) {
	        binding.setValue(buffer, offset);
	        break;
	      }
	    }
	  },
	  saveOriginalState: function () {
	    var binding = this.binding;
	    var buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * 3;
	    binding.getValue(buffer, originalValueOffset);
	    for (var i = stride, e = originalValueOffset; i !== e; ++i) {
	      buffer[i] = buffer[originalValueOffset + i % stride];
	    }
	    this.cumulativeWeight = 0;
	  },
	  restoreOriginalState: function () {
	    var originalValueOffset = this.valueSize * 3;
	    this.binding.setValue(this.buffer, originalValueOffset);
	  },
	  _select: function (buffer, dstOffset, srcOffset, t, stride) {
	    if (t >= 0.5) {
	      for (var i = 0; i !== stride; ++i) {
	        buffer[dstOffset + i] = buffer[srcOffset + i];
	      }
	    }
	  },
	  _slerp: function (buffer, dstOffset, srcOffset, t) {
	    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
	  },
	  _lerp: function (buffer, dstOffset, srcOffset, t, stride) {
	    var s = 1 - t;
	    for (var i = 0; i !== stride; ++i) {
	      var j = dstOffset + i;
	      buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
	    }
	  }
	});
	var _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
	var _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
	var _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
	var _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
	var _directoryRe = (/((?:WC+[\/:])*)/).source.replace("WC", _wordChar);
	var _nodeRe = (/(WCOD+)?/).source.replace("WCOD", _wordCharOrDot);
	var _objectRe = (/(?:\.(WC+)(?:\[(.+)\])?)?/).source.replace("WC", _wordChar);
	var _propertyRe = (/\.(WC+)(?:\[(.+)\])?/).source.replace("WC", _wordChar);
	var _trackRe = new RegExp("" + "^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$");
	var _supportedObjectNames = ["material", "materials", "bones"];
	function Composite(targetGroup, path, optionalParsedPath) {
	  var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
	  this._targetGroup = targetGroup;
	  this._bindings = targetGroup.subscribe_(path, parsedPath);
	}
	Object.assign(Composite.prototype, {
	  getValue: function (array, offset) {
	    this.bind();
	    var firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
	    if (binding !== undefined) binding.getValue(array, offset);
	  },
	  setValue: function (array, offset) {
	    var bindings = this._bindings;
	    for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
	      bindings[i].setValue(array, offset);
	    }
	  },
	  bind: function () {
	    var bindings = this._bindings;
	    for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
	      bindings[i].bind();
	    }
	  },
	  unbind: function () {
	    var bindings = this._bindings;
	    for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
	      bindings[i].unbind();
	    }
	  }
	});
	function PropertyBinding(rootNode, path, parsedPath) {
	  this.path = path;
	  this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
	  this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;
	  this.rootNode = rootNode;
	}
	Object.assign(PropertyBinding, {
	  Composite: Composite,
	  create: function (root, path, parsedPath) {
	    if (!(root && root.isAnimationObjectGroup)) {
	      return new PropertyBinding(root, path, parsedPath);
	    } else {
	      return new PropertyBinding.Composite(root, path, parsedPath);
	    }
	  },
	  sanitizeNodeName: function (name) {
	    return name.replace(/\s/g, "_").replace(_reservedRe, "");
	  },
	  parseTrackName: function (trackName) {
	    var matches = _trackRe.exec(trackName);
	    if (!matches) {
	      throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
	    }
	    var results = {
	      nodeName: matches[2],
	      objectName: matches[3],
	      objectIndex: matches[4],
	      propertyName: matches[5],
	      propertyIndex: matches[6]
	    };
	    var lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
	    if (lastDot !== undefined && lastDot !== -1) {
	      var objectName = results.nodeName.substring(lastDot + 1);
	      if (_supportedObjectNames.indexOf(objectName) !== -1) {
	        results.nodeName = results.nodeName.substring(0, lastDot);
	        results.objectName = objectName;
	      }
	    }
	    if (results.propertyName === null || results.propertyName.length === 0) {
	      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
	    }
	    return results;
	  },
	  findNode: function (root, nodeName) {
	    if (!nodeName || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
	      return root;
	    }
	    if (root.skeleton) {
	      var bone = root.skeleton.getBoneByName(nodeName);
	      if (bone !== undefined) {
	        return bone;
	      }
	    }
	    if (root.children) {
	      var searchNodeSubtree = function (children) {
	        for (var i = 0; i < children.length; i++) {
	          var childNode = children[i];
	          if (childNode.name === nodeName || childNode.uuid === nodeName) {
	            return childNode;
	          }
	          var result = searchNodeSubtree(childNode.children);
	          if (result) return result;
	        }
	        return null;
	      };
	      var subTreeNode = searchNodeSubtree(root.children);
	      if (subTreeNode) {
	        return subTreeNode;
	      }
	    }
	    return null;
	  }
	});
	Object.assign(PropertyBinding.prototype, {
	  _getValue_unavailable: function () {},
	  _setValue_unavailable: function () {},
	  BindingType: {
	    Direct: 0,
	    EntireArray: 1,
	    ArrayElement: 2,
	    HasFromToArray: 3
	  },
	  Versioning: {
	    None: 0,
	    NeedsUpdate: 1,
	    MatrixWorldNeedsUpdate: 2
	  },
	  GetterByBindingType: [function getValue_direct(buffer, offset) {
	    buffer[offset] = this.node[this.propertyName];
	  }, function getValue_array(buffer, offset) {
	    var source = this.resolvedProperty;
	    for (var i = 0, n = source.length; i !== n; ++i) {
	      buffer[offset++] = source[i];
	    }
	  }, function getValue_arrayElement(buffer, offset) {
	    buffer[offset] = this.resolvedProperty[this.propertyIndex];
	  }, function getValue_toArray(buffer, offset) {
	    this.resolvedProperty.toArray(buffer, offset);
	  }],
	  SetterByBindingTypeAndVersioning: [[function setValue_direct(buffer, offset) {
	    this.targetObject[this.propertyName] = buffer[offset];
	  }, function setValue_direct_setNeedsUpdate(buffer, offset) {
	    this.targetObject[this.propertyName] = buffer[offset];
	    this.targetObject.needsUpdate = true;
	  }, function setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
	    this.targetObject[this.propertyName] = buffer[offset];
	    this.targetObject.matrixWorldNeedsUpdate = true;
	  }], [function setValue_array(buffer, offset) {
	    var dest = this.resolvedProperty;
	    for (var i = 0, n = dest.length; i !== n; ++i) {
	      dest[i] = buffer[offset++];
	    }
	  }, function setValue_array_setNeedsUpdate(buffer, offset) {
	    var dest = this.resolvedProperty;
	    for (var i = 0, n = dest.length; i !== n; ++i) {
	      dest[i] = buffer[offset++];
	    }
	    this.targetObject.needsUpdate = true;
	  }, function setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
	    var dest = this.resolvedProperty;
	    for (var i = 0, n = dest.length; i !== n; ++i) {
	      dest[i] = buffer[offset++];
	    }
	    this.targetObject.matrixWorldNeedsUpdate = true;
	  }], [function setValue_arrayElement(buffer, offset) {
	    this.resolvedProperty[this.propertyIndex] = buffer[offset];
	  }, function setValue_arrayElement_setNeedsUpdate(buffer, offset) {
	    this.resolvedProperty[this.propertyIndex] = buffer[offset];
	    this.targetObject.needsUpdate = true;
	  }, function setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
	    this.resolvedProperty[this.propertyIndex] = buffer[offset];
	    this.targetObject.matrixWorldNeedsUpdate = true;
	  }], [function setValue_fromArray(buffer, offset) {
	    this.resolvedProperty.fromArray(buffer, offset);
	  }, function setValue_fromArray_setNeedsUpdate(buffer, offset) {
	    this.resolvedProperty.fromArray(buffer, offset);
	    this.targetObject.needsUpdate = true;
	  }, function setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
	    this.resolvedProperty.fromArray(buffer, offset);
	    this.targetObject.matrixWorldNeedsUpdate = true;
	  }]],
	  getValue: function getValue_unbound(targetArray, offset) {
	    this.bind();
	    this.getValue(targetArray, offset);
	  },
	  setValue: function getValue_unbound(sourceArray, offset) {
	    this.bind();
	    this.setValue(sourceArray, offset);
	  },
	  bind: function () {
	    var targetObject = this.node, parsedPath = this.parsedPath, objectName = parsedPath.objectName, propertyName = parsedPath.propertyName, propertyIndex = parsedPath.propertyIndex;
	    if (!targetObject) {
	      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;
	      this.node = targetObject;
	    }
	    this.getValue = this._getValue_unavailable;
	    this.setValue = this._setValue_unavailable;
	    if (!targetObject) {
	      console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
	      return;
	    }
	    if (objectName) {
	      var objectIndex = parsedPath.objectIndex;
	      switch (objectName) {
	        case "materials":
	          if (!targetObject.material) {
	            console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
	            return;
	          }
	          if (!targetObject.material.materials) {
	            console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
	            return;
	          }
	          targetObject = targetObject.material.materials;
	          break;
	        case "bones":
	          if (!targetObject.skeleton) {
	            console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
	            return;
	          }
	          targetObject = targetObject.skeleton.bones;
	          for (var i = 0; i < targetObject.length; i++) {
	            if (targetObject[i].name === objectIndex) {
	              objectIndex = i;
	              break;
	            }
	          }
	          break;
	        default:
	          if (targetObject[objectName] === undefined) {
	            console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
	            return;
	          }
	          targetObject = targetObject[objectName];
	      }
	      if (objectIndex !== undefined) {
	        if (targetObject[objectIndex] === undefined) {
	          console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
	          return;
	        }
	        targetObject = targetObject[objectIndex];
	      }
	    }
	    var nodeProperty = targetObject[propertyName];
	    if (nodeProperty === undefined) {
	      var nodeName = parsedPath.nodeName;
	      console.error("THREE.PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
	      return;
	    }
	    var versioning = this.Versioning.None;
	    this.targetObject = targetObject;
	    if (targetObject.needsUpdate !== undefined) {
	      versioning = this.Versioning.NeedsUpdate;
	    } else if (targetObject.matrixWorldNeedsUpdate !== undefined) {
	      versioning = this.Versioning.MatrixWorldNeedsUpdate;
	    }
	    var bindingType = this.BindingType.Direct;
	    if (propertyIndex !== undefined) {
	      if (propertyName === "morphTargetInfluences") {
	        if (!targetObject.geometry) {
	          console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
	          return;
	        }
	        if (targetObject.geometry.isBufferGeometry) {
	          if (!targetObject.geometry.morphAttributes) {
	            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
	            return;
	          }
	          for (var i = 0; i < this.node.geometry.morphAttributes.position.length; i++) {
	            if (targetObject.geometry.morphAttributes.position[i].name === propertyIndex) {
	              propertyIndex = i;
	              break;
	            }
	          }
	        } else {
	          if (!targetObject.geometry.morphTargets) {
	            console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
	            return;
	          }
	          for (var i = 0; i < this.node.geometry.morphTargets.length; i++) {
	            if (targetObject.geometry.morphTargets[i].name === propertyIndex) {
	              propertyIndex = i;
	              break;
	            }
	          }
	        }
	      }
	      bindingType = this.BindingType.ArrayElement;
	      this.resolvedProperty = nodeProperty;
	      this.propertyIndex = propertyIndex;
	    } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
	      bindingType = this.BindingType.HasFromToArray;
	      this.resolvedProperty = nodeProperty;
	    } else if (Array.isArray(nodeProperty)) {
	      bindingType = this.BindingType.EntireArray;
	      this.resolvedProperty = nodeProperty;
	    } else {
	      this.propertyName = propertyName;
	    }
	    this.getValue = this.GetterByBindingType[bindingType];
	    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
	  },
	  unbind: function () {
	    this.node = null;
	    this.getValue = this._getValue_unbound;
	    this.setValue = this._setValue_unbound;
	  }
	});
	Object.assign(PropertyBinding.prototype, {
	  _getValue_unbound: PropertyBinding.prototype.getValue,
	  _setValue_unbound: PropertyBinding.prototype.setValue
	});
	function AnimationObjectGroup() {
	  this.uuid = MathUtils.generateUUID();
	  this._objects = Array.prototype.slice.call(arguments);
	  this.nCachedObjects_ = 0;
	  var indices = {};
	  this._indicesByUUID = indices;
	  for (var i = 0, n = arguments.length; i !== n; ++i) {
	    indices[arguments[i].uuid] = i;
	  }
	  this._paths = [];
	  this._parsedPaths = [];
	  this._bindings = [];
	  this._bindingsIndicesByPath = {};
	  var scope = this;
	  this.stats = {
	    objects: {
	      get total() {
	        return scope._objects.length;
	      },
	      get inUse() {
	        return this.total - scope.nCachedObjects_;
	      }
	    },
	    get bindingsPerObject() {
	      return scope._bindings.length;
	    }
	  };
	}
	Object.assign(AnimationObjectGroup.prototype, {
	  isAnimationObjectGroup: true,
	  add: function () {
	    var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length, knownObject = undefined;
	    for (var i = 0, n = arguments.length; i !== n; ++i) {
	      var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
	      if (index === undefined) {
	        index = nObjects++;
	        indicesByUUID[uuid] = index;
	        objects.push(object);
	        for (var j = 0, m = nBindings; j !== m; ++j) {
	          bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
	        }
	      } else if (index < nCachedObjects) {
	        knownObject = objects[index];
	        var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];
	        indicesByUUID[lastCachedObject.uuid] = index;
	        objects[index] = lastCachedObject;
	        indicesByUUID[uuid] = firstActiveIndex;
	        objects[firstActiveIndex] = object;
	        for (var j = 0, m = nBindings; j !== m; ++j) {
	          var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], binding = bindingsForPath[index];
	          bindingsForPath[index] = lastCached;
	          if (binding === undefined) {
	            binding = new PropertyBinding(object, paths[j], parsedPaths[j]);
	          }
	          bindingsForPath[firstActiveIndex] = binding;
	        }
	      } else if (objects[index] !== knownObject) {
	        console.error("THREE.AnimationObjectGroup: Different objects with the same UUID " + "detected. Clean the caches or recreate your infrastructure when reloading scenes.");
	      }
	    }
	    this.nCachedObjects_ = nCachedObjects;
	  },
	  remove: function () {
	    var objects = this._objects, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
	    for (var i = 0, n = arguments.length; i !== n; ++i) {
	      var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
	      if (index !== undefined && index >= nCachedObjects) {
	        var lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];
	        indicesByUUID[firstActiveObject.uuid] = index;
	        objects[index] = firstActiveObject;
	        indicesByUUID[uuid] = lastCachedIndex;
	        objects[lastCachedIndex] = object;
	        for (var j = 0, m = nBindings; j !== m; ++j) {
	          var bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];
	          bindingsForPath[index] = firstActive;
	          bindingsForPath[lastCachedIndex] = binding;
	        }
	      }
	    }
	    this.nCachedObjects_ = nCachedObjects;
	  },
	  uncache: function () {
	    var objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;
	    for (var i = 0, n = arguments.length; i !== n; ++i) {
	      var object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];
	      if (index !== undefined) {
	        delete indicesByUUID[uuid];
	        if (index < nCachedObjects) {
	          var firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];
	          indicesByUUID[lastCachedObject.uuid] = index;
	          objects[index] = lastCachedObject;
	          indicesByUUID[lastObject.uuid] = firstActiveIndex;
	          objects[firstActiveIndex] = lastObject;
	          objects.pop();
	          for (var j = 0, m = nBindings; j !== m; ++j) {
	            var bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];
	            bindingsForPath[index] = lastCached;
	            bindingsForPath[firstActiveIndex] = last;
	            bindingsForPath.pop();
	          }
	        } else {
	          var lastIndex = --nObjects, lastObject = objects[lastIndex];
	          indicesByUUID[lastObject.uuid] = index;
	          objects[index] = lastObject;
	          objects.pop();
	          for (var j = 0, m = nBindings; j !== m; ++j) {
	            var bindingsForPath = bindings[j];
	            bindingsForPath[index] = bindingsForPath[lastIndex];
	            bindingsForPath.pop();
	          }
	        }
	      }
	    }
	    this.nCachedObjects_ = nCachedObjects;
	  },
	  subscribe_: function (path, parsedPath) {
	    var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path], bindings = this._bindings;
	    if (index !== undefined) return bindings[index];
	    var paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);
	    index = bindings.length;
	    indicesByPath[path] = index;
	    paths.push(path);
	    parsedPaths.push(parsedPath);
	    bindings.push(bindingsForPath);
	    for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {
	      var object = objects[i];
	      bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
	    }
	    return bindingsForPath;
	  },
	  unsubscribe_: function (path) {
	    var indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];
	    if (index !== undefined) {
	      var paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];
	      indicesByPath[lastBindingsPath] = index;
	      bindings[index] = lastBindings;
	      bindings.pop();
	      parsedPaths[index] = parsedPaths[lastBindingsIndex];
	      parsedPaths.pop();
	      paths[index] = paths[lastBindingsIndex];
	      paths.pop();
	    }
	  }
	});
	function AnimationAction(mixer, clip, localRoot) {
	  this._mixer = mixer;
	  this._clip = clip;
	  this._localRoot = localRoot || null;
	  var tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);
	  var interpolantSettings = {
	    endingStart: ZeroCurvatureEnding,
	    endingEnd: ZeroCurvatureEnding
	  };
	  for (var i = 0; i !== nTracks; ++i) {
	    var interpolant = tracks[i].createInterpolant(null);
	    interpolants[i] = interpolant;
	    interpolant.settings = interpolantSettings;
	  }
	  this._interpolantSettings = interpolantSettings;
	  this._interpolants = interpolants;
	  this._propertyBindings = new Array(nTracks);
	  this._cacheIndex = null;
	  this._byClipCacheIndex = null;
	  this._timeScaleInterpolant = null;
	  this._weightInterpolant = null;
	  this.loop = LoopRepeat;
	  this._loopCount = -1;
	  this._startTime = null;
	  this.time = 0;
	  this.timeScale = 1;
	  this._effectiveTimeScale = 1;
	  this.weight = 1;
	  this._effectiveWeight = 1;
	  this.repetitions = Infinity;
	  this.paused = false;
	  this.enabled = true;
	  this.clampWhenFinished = false;
	  this.zeroSlopeAtStart = true;
	  this.zeroSlopeAtEnd = true;
	}
	Object.assign(AnimationAction.prototype, {
	  play: function () {
	    this._mixer._activateAction(this);
	    return this;
	  },
	  stop: function () {
	    this._mixer._deactivateAction(this);
	    return this.reset();
	  },
	  reset: function () {
	    this.paused = false;
	    this.enabled = true;
	    this.time = 0;
	    this._loopCount = -1;
	    this._startTime = null;
	    return this.stopFading().stopWarping();
	  },
	  isRunning: function () {
	    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
	  },
	  isScheduled: function () {
	    return this._mixer._isActiveAction(this);
	  },
	  startAt: function (time) {
	    this._startTime = time;
	    return this;
	  },
	  setLoop: function (mode, repetitions) {
	    this.loop = mode;
	    this.repetitions = repetitions;
	    return this;
	  },
	  setEffectiveWeight: function (weight) {
	    this.weight = weight;
	    this._effectiveWeight = this.enabled ? weight : 0;
	    return this.stopFading();
	  },
	  getEffectiveWeight: function () {
	    return this._effectiveWeight;
	  },
	  fadeIn: function (duration) {
	    return this._scheduleFading(duration, 0, 1);
	  },
	  fadeOut: function (duration) {
	    return this._scheduleFading(duration, 1, 0);
	  },
	  crossFadeFrom: function (fadeOutAction, duration, warp) {
	    fadeOutAction.fadeOut(duration);
	    this.fadeIn(duration);
	    if (warp) {
	      var fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;
	      fadeOutAction.warp(1, startEndRatio, duration);
	      this.warp(endStartRatio, 1, duration);
	    }
	    return this;
	  },
	  crossFadeTo: function (fadeInAction, duration, warp) {
	    return fadeInAction.crossFadeFrom(this, duration, warp);
	  },
	  stopFading: function () {
	    var weightInterpolant = this._weightInterpolant;
	    if (weightInterpolant !== null) {
	      this._weightInterpolant = null;
	      this._mixer._takeBackControlInterpolant(weightInterpolant);
	    }
	    return this;
	  },
	  setEffectiveTimeScale: function (timeScale) {
	    this.timeScale = timeScale;
	    this._effectiveTimeScale = this.paused ? 0 : timeScale;
	    return this.stopWarping();
	  },
	  getEffectiveTimeScale: function () {
	    return this._effectiveTimeScale;
	  },
	  setDuration: function (duration) {
	    this.timeScale = this._clip.duration / duration;
	    return this.stopWarping();
	  },
	  syncWith: function (action) {
	    this.time = action.time;
	    this.timeScale = action.timeScale;
	    return this.stopWarping();
	  },
	  halt: function (duration) {
	    return this.warp(this._effectiveTimeScale, 0, duration);
	  },
	  warp: function (startTimeScale, endTimeScale, duration) {
	    var mixer = this._mixer, now = mixer.time, interpolant = this._timeScaleInterpolant, timeScale = this.timeScale;
	    if (interpolant === null) {
	      interpolant = mixer._lendControlInterpolant();
	      this._timeScaleInterpolant = interpolant;
	    }
	    var times = interpolant.parameterPositions, values = interpolant.sampleValues;
	    times[0] = now;
	    times[1] = now + duration;
	    values[0] = startTimeScale / timeScale;
	    values[1] = endTimeScale / timeScale;
	    return this;
	  },
	  stopWarping: function () {
	    var timeScaleInterpolant = this._timeScaleInterpolant;
	    if (timeScaleInterpolant !== null) {
	      this._timeScaleInterpolant = null;
	      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
	    }
	    return this;
	  },
	  getMixer: function () {
	    return this._mixer;
	  },
	  getClip: function () {
	    return this._clip;
	  },
	  getRoot: function () {
	    return this._localRoot || this._mixer._root;
	  },
	  _update: function (time, deltaTime, timeDirection, accuIndex) {
	    if (!this.enabled) {
	      this._updateWeight(time);
	      return;
	    }
	    var startTime = this._startTime;
	    if (startTime !== null) {
	      var timeRunning = (time - startTime) * timeDirection;
	      if (timeRunning < 0 || timeDirection === 0) {
	        return;
	      }
	      this._startTime = null;
	      deltaTime = timeDirection * timeRunning;
	    }
	    deltaTime *= this._updateTimeScale(time);
	    var clipTime = this._updateTime(deltaTime);
	    var weight = this._updateWeight(time);
	    if (weight > 0) {
	      var interpolants = this._interpolants;
	      var propertyMixers = this._propertyBindings;
	      for (var j = 0, m = interpolants.length; j !== m; ++j) {
	        interpolants[j].evaluate(clipTime);
	        propertyMixers[j].accumulate(accuIndex, weight);
	      }
	    }
	  },
	  _updateWeight: function (time) {
	    var weight = 0;
	    if (this.enabled) {
	      weight = this.weight;
	      var interpolant = this._weightInterpolant;
	      if (interpolant !== null) {
	        var interpolantValue = interpolant.evaluate(time)[0];
	        weight *= interpolantValue;
	        if (time > interpolant.parameterPositions[1]) {
	          this.stopFading();
	          if (interpolantValue === 0) {
	            this.enabled = false;
	          }
	        }
	      }
	    }
	    this._effectiveWeight = weight;
	    return weight;
	  },
	  _updateTimeScale: function (time) {
	    var timeScale = 0;
	    if (!this.paused) {
	      timeScale = this.timeScale;
	      var interpolant = this._timeScaleInterpolant;
	      if (interpolant !== null) {
	        var interpolantValue = interpolant.evaluate(time)[0];
	        timeScale *= interpolantValue;
	        if (time > interpolant.parameterPositions[1]) {
	          this.stopWarping();
	          if (timeScale === 0) {
	            this.paused = true;
	          } else {
	            this.timeScale = timeScale;
	          }
	        }
	      }
	    }
	    this._effectiveTimeScale = timeScale;
	    return timeScale;
	  },
	  _updateTime: function (deltaTime) {
	    var time = this.time + deltaTime;
	    var duration = this._clip.duration;
	    var loop = this.loop;
	    var loopCount = this._loopCount;
	    var pingPong = loop === LoopPingPong;
	    if (deltaTime === 0) {
	      if (loopCount === -1) return time;
	      return pingPong && (loopCount & 1) === 1 ? duration - time : time;
	    }
	    if (loop === LoopOnce) {
	      if (loopCount === -1) {
	        this._loopCount = 0;
	        this._setEndings(true, true, false);
	      }
	      handle_stop: {
	        if (time >= duration) {
	          time = duration;
	        } else if (time < 0) {
	          time = 0;
	        } else {
	          this.time = time;
	          break handle_stop;
	        }
	        if (this.clampWhenFinished) this.paused = true; else this.enabled = false;
	        this.time = time;
	        this._mixer.dispatchEvent({
	          type: "finished",
	          action: this,
	          direction: deltaTime < 0 ? -1 : 1
	        });
	      }
	    } else {
	      if (loopCount === -1) {
	        if (deltaTime >= 0) {
	          loopCount = 0;
	          this._setEndings(true, this.repetitions === 0, pingPong);
	        } else {
	          this._setEndings(this.repetitions === 0, true, pingPong);
	        }
	      }
	      if (time >= duration || time < 0) {
	        var loopDelta = Math.floor(time / duration);
	        time -= duration * loopDelta;
	        loopCount += Math.abs(loopDelta);
	        var pending = this.repetitions - loopCount;
	        if (pending <= 0) {
	          if (this.clampWhenFinished) this.paused = true; else this.enabled = false;
	          time = deltaTime > 0 ? duration : 0;
	          this.time = time;
	          this._mixer.dispatchEvent({
	            type: "finished",
	            action: this,
	            direction: deltaTime > 0 ? 1 : -1
	          });
	        } else {
	          if (pending === 1) {
	            var atStart = deltaTime < 0;
	            this._setEndings(atStart, !atStart, pingPong);
	          } else {
	            this._setEndings(false, false, pingPong);
	          }
	          this._loopCount = loopCount;
	          this.time = time;
	          this._mixer.dispatchEvent({
	            type: "loop",
	            action: this,
	            loopDelta: loopDelta
	          });
	        }
	      } else {
	        this.time = time;
	      }
	      if (pingPong && (loopCount & 1) === 1) {
	        return duration - time;
	      }
	    }
	    return time;
	  },
	  _setEndings: function (atStart, atEnd, pingPong) {
	    var settings = this._interpolantSettings;
	    if (pingPong) {
	      settings.endingStart = ZeroSlopeEnding;
	      settings.endingEnd = ZeroSlopeEnding;
	    } else {
	      if (atStart) {
	        settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
	      } else {
	        settings.endingStart = WrapAroundEnding;
	      }
	      if (atEnd) {
	        settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
	      } else {
	        settings.endingEnd = WrapAroundEnding;
	      }
	    }
	  },
	  _scheduleFading: function (duration, weightNow, weightThen) {
	    var mixer = this._mixer, now = mixer.time, interpolant = this._weightInterpolant;
	    if (interpolant === null) {
	      interpolant = mixer._lendControlInterpolant();
	      this._weightInterpolant = interpolant;
	    }
	    var times = interpolant.parameterPositions, values = interpolant.sampleValues;
	    times[0] = now;
	    values[0] = weightNow;
	    times[1] = now + duration;
	    values[1] = weightThen;
	    return this;
	  }
	});
	function AnimationMixer(root) {
	  this._root = root;
	  this._initMemoryManager();
	  this._accuIndex = 0;
	  this.time = 0;
	  this.timeScale = 1;
	}
	AnimationMixer.prototype = Object.assign(Object.create(EventDispatcher.prototype), {
	  constructor: AnimationMixer,
	  _bindAction: function (action, prototypeAction) {
	    var root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName, bindingsByName = bindingsByRoot[rootUuid];
	    if (bindingsByName === undefined) {
	      bindingsByName = {};
	      bindingsByRoot[rootUuid] = bindingsByName;
	    }
	    for (var i = 0; i !== nTracks; ++i) {
	      var track = tracks[i], trackName = track.name, binding = bindingsByName[trackName];
	      if (binding !== undefined) {
	        bindings[i] = binding;
	      } else {
	        binding = bindings[i];
	        if (binding !== undefined) {
	          if (binding._cacheIndex === null) {
	            ++binding.referenceCount;
	            this._addInactiveBinding(binding, rootUuid, trackName);
	          }
	          continue;
	        }
	        var path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
	        binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
	        ++binding.referenceCount;
	        this._addInactiveBinding(binding, rootUuid, trackName);
	        bindings[i] = binding;
	      }
	      interpolants[i].resultBuffer = binding.buffer;
	    }
	  },
	  _activateAction: function (action) {
	    if (!this._isActiveAction(action)) {
	      if (action._cacheIndex === null) {
	        var rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];
	        this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
	        this._addInactiveAction(action, clipUuid, rootUuid);
	      }
	      var bindings = action._propertyBindings;
	      for (var i = 0, n = bindings.length; i !== n; ++i) {
	        var binding = bindings[i];
	        if (binding.useCount++ === 0) {
	          this._lendBinding(binding);
	          binding.saveOriginalState();
	        }
	      }
	      this._lendAction(action);
	    }
	  },
	  _deactivateAction: function (action) {
	    if (this._isActiveAction(action)) {
	      var bindings = action._propertyBindings;
	      for (var i = 0, n = bindings.length; i !== n; ++i) {
	        var binding = bindings[i];
	        if (--binding.useCount === 0) {
	          binding.restoreOriginalState();
	          this._takeBackBinding(binding);
	        }
	      }
	      this._takeBackAction(action);
	    }
	  },
	  _initMemoryManager: function () {
	    this._actions = [];
	    this._nActiveActions = 0;
	    this._actionsByClip = {};
	    this._bindings = [];
	    this._nActiveBindings = 0;
	    this._bindingsByRootAndName = {};
	    this._controlInterpolants = [];
	    this._nActiveControlInterpolants = 0;
	    var scope = this;
	    this.stats = {
	      actions: {
	        get total() {
	          return scope._actions.length;
	        },
	        get inUse() {
	          return scope._nActiveActions;
	        }
	      },
	      bindings: {
	        get total() {
	          return scope._bindings.length;
	        },
	        get inUse() {
	          return scope._nActiveBindings;
	        }
	      },
	      controlInterpolants: {
	        get total() {
	          return scope._controlInterpolants.length;
	        },
	        get inUse() {
	          return scope._nActiveControlInterpolants;
	        }
	      }
	    };
	  },
	  _isActiveAction: function (action) {
	    var index = action._cacheIndex;
	    return index !== null && index < this._nActiveActions;
	  },
	  _addInactiveAction: function (action, clipUuid, rootUuid) {
	    var actions = this._actions, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
	    if (actionsForClip === undefined) {
	      actionsForClip = {
	        knownActions: [action],
	        actionByRoot: {}
	      };
	      action._byClipCacheIndex = 0;
	      actionsByClip[clipUuid] = actionsForClip;
	    } else {
	      var knownActions = actionsForClip.knownActions;
	      action._byClipCacheIndex = knownActions.length;
	      knownActions.push(action);
	    }
	    action._cacheIndex = actions.length;
	    actions.push(action);
	    actionsForClip.actionByRoot[rootUuid] = action;
	  },
	  _removeInactiveAction: function (action) {
	    var actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;
	    lastInactiveAction._cacheIndex = cacheIndex;
	    actions[cacheIndex] = lastInactiveAction;
	    actions.pop();
	    action._cacheIndex = null;
	    var clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;
	    lastKnownAction._byClipCacheIndex = byClipCacheIndex;
	    knownActionsForClip[byClipCacheIndex] = lastKnownAction;
	    knownActionsForClip.pop();
	    action._byClipCacheIndex = null;
	    var actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;
	    delete actionByRoot[rootUuid];
	    if (knownActionsForClip.length === 0) {
	      delete actionsByClip[clipUuid];
	    }
	    this._removeInactiveBindingsForAction(action);
	  },
	  _removeInactiveBindingsForAction: function (action) {
	    var bindings = action._propertyBindings;
	    for (var i = 0, n = bindings.length; i !== n; ++i) {
	      var binding = bindings[i];
	      if (--binding.referenceCount === 0) {
	        this._removeInactiveBinding(binding);
	      }
	    }
	  },
	  _lendAction: function (action) {
	    var actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];
	    action._cacheIndex = lastActiveIndex;
	    actions[lastActiveIndex] = action;
	    firstInactiveAction._cacheIndex = prevIndex;
	    actions[prevIndex] = firstInactiveAction;
	  },
	  _takeBackAction: function (action) {
	    var actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];
	    action._cacheIndex = firstInactiveIndex;
	    actions[firstInactiveIndex] = action;
	    lastActiveAction._cacheIndex = prevIndex;
	    actions[prevIndex] = lastActiveAction;
	  },
	  _addInactiveBinding: function (binding, rootUuid, trackName) {
	    var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], bindings = this._bindings;
	    if (bindingByName === undefined) {
	      bindingByName = {};
	      bindingsByRoot[rootUuid] = bindingByName;
	    }
	    bindingByName[trackName] = binding;
	    binding._cacheIndex = bindings.length;
	    bindings.push(binding);
	  },
	  _removeInactiveBinding: function (binding) {
	    var bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;
	    lastInactiveBinding._cacheIndex = cacheIndex;
	    bindings[cacheIndex] = lastInactiveBinding;
	    bindings.pop();
	    delete bindingByName[trackName];
	    if (Object.keys(bindingByName).length === 0) {
	      delete bindingsByRoot[rootUuid];
	    }
	  },
	  _lendBinding: function (binding) {
	    var bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];
	    binding._cacheIndex = lastActiveIndex;
	    bindings[lastActiveIndex] = binding;
	    firstInactiveBinding._cacheIndex = prevIndex;
	    bindings[prevIndex] = firstInactiveBinding;
	  },
	  _takeBackBinding: function (binding) {
	    var bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];
	    binding._cacheIndex = firstInactiveIndex;
	    bindings[firstInactiveIndex] = binding;
	    lastActiveBinding._cacheIndex = prevIndex;
	    bindings[prevIndex] = lastActiveBinding;
	  },
	  _lendControlInterpolant: function () {
	    var interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++, interpolant = interpolants[lastActiveIndex];
	    if (interpolant === undefined) {
	      interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);
	      interpolant.__cacheIndex = lastActiveIndex;
	      interpolants[lastActiveIndex] = interpolant;
	    }
	    return interpolant;
	  },
	  _takeBackControlInterpolant: function (interpolant) {
	    var interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];
	    interpolant.__cacheIndex = firstInactiveIndex;
	    interpolants[firstInactiveIndex] = interpolant;
	    lastActiveInterpolant.__cacheIndex = prevIndex;
	    interpolants[prevIndex] = lastActiveInterpolant;
	  },
	  _controlInterpolantsResultBuffer: new Float32Array(1),
	  clipAction: function (clip, optionalRoot) {
	    var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject !== null ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid], prototypeAction = null;
	    if (actionsForClip !== undefined) {
	      var existingAction = actionsForClip.actionByRoot[rootUuid];
	      if (existingAction !== undefined) {
	        return existingAction;
	      }
	      prototypeAction = actionsForClip.knownActions[0];
	      if (clipObject === null) clipObject = prototypeAction._clip;
	    }
	    if (clipObject === null) return null;
	    var newAction = new AnimationAction(this, clipObject, optionalRoot);
	    this._bindAction(newAction, prototypeAction);
	    this._addInactiveAction(newAction, clipUuid, rootUuid);
	    return newAction;
	  },
	  existingAction: function (clip, optionalRoot) {
	    var root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === "string" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];
	    if (actionsForClip !== undefined) {
	      return actionsForClip.actionByRoot[rootUuid] || null;
	    }
	    return null;
	  },
	  stopAllAction: function () {
	    var actions = this._actions, nActions = this._nActiveActions, bindings = this._bindings, nBindings = this._nActiveBindings;
	    this._nActiveActions = 0;
	    this._nActiveBindings = 0;
	    for (var i = 0; i !== nActions; ++i) {
	      actions[i].reset();
	    }
	    for (var i = 0; i !== nBindings; ++i) {
	      bindings[i].useCount = 0;
	    }
	    return this;
	  },
	  update: function (deltaTime) {
	    deltaTime *= this.timeScale;
	    var actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;
	    for (var i = 0; i !== nActions; ++i) {
	      var action = actions[i];
	      action._update(time, deltaTime, timeDirection, accuIndex);
	    }
	    var bindings = this._bindings, nBindings = this._nActiveBindings;
	    for (var i = 0; i !== nBindings; ++i) {
	      bindings[i].apply(accuIndex);
	    }
	    return this;
	  },
	  setTime: function (timeInSeconds) {
	    this.time = 0;
	    for (var i = 0; i < this._actions.length; i++) {
	      this._actions[i].time = 0;
	    }
	    return this.update(timeInSeconds);
	  },
	  getRoot: function () {
	    return this._root;
	  },
	  uncacheClip: function (clip) {
	    var actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];
	    if (actionsForClip !== undefined) {
	      var actionsToRemove = actionsForClip.knownActions;
	      for (var i = 0, n = actionsToRemove.length; i !== n; ++i) {
	        var action = actionsToRemove[i];
	        this._deactivateAction(action);
	        var cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];
	        action._cacheIndex = null;
	        action._byClipCacheIndex = null;
	        lastInactiveAction._cacheIndex = cacheIndex;
	        actions[cacheIndex] = lastInactiveAction;
	        actions.pop();
	        this._removeInactiveBindingsForAction(action);
	      }
	      delete actionsByClip[clipUuid];
	    }
	  },
	  uncacheRoot: function (root) {
	    var rootUuid = root.uuid, actionsByClip = this._actionsByClip;
	    for (var clipUuid in actionsByClip) {
	      var actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];
	      if (action !== undefined) {
	        this._deactivateAction(action);
	        this._removeInactiveAction(action);
	      }
	    }
	    var bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];
	    if (bindingByName !== undefined) {
	      for (var trackName in bindingByName) {
	        var binding = bindingByName[trackName];
	        binding.restoreOriginalState();
	        this._removeInactiveBinding(binding);
	      }
	    }
	  },
	  uncacheAction: function (clip, optionalRoot) {
	    var action = this.existingAction(clip, optionalRoot);
	    if (action !== null) {
	      this._deactivateAction(action);
	      this._removeInactiveAction(action);
	    }
	  }
	});
	function Uniform(value) {
	  if (typeof value === "string") {
	    console.warn("THREE.Uniform: Type parameter is no longer needed.");
	    value = arguments[1];
	  }
	  this.value = value;
	}
	Uniform.prototype.clone = function () {
	  return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
	};
	function InstancedInterleavedBuffer(array, stride, meshPerAttribute) {
	  InterleavedBuffer.call(this, array, stride);
	  this.meshPerAttribute = meshPerAttribute || 1;
	}
	InstancedInterleavedBuffer.prototype = Object.assign(Object.create(InterleavedBuffer.prototype), {
	  constructor: InstancedInterleavedBuffer,
	  isInstancedInterleavedBuffer: true,
	  copy: function (source) {
	    InterleavedBuffer.prototype.copy.call(this, source);
	    this.meshPerAttribute = source.meshPerAttribute;
	    return this;
	  }
	});
	function Raycaster(origin, direction, near, far) {
	  this.ray = new Ray(origin, direction);
	  this.near = near || 0;
	  this.far = far || Infinity;
	  this.camera = null;
	  this.layers = new Layers();
	  this.params = {
	    Mesh: {},
	    Line: {
	      threshold: 1
	    },
	    LOD: {},
	    Points: {
	      threshold: 1
	    },
	    Sprite: {}
	  };
	  Object.defineProperties(this.params, {
	    PointCloud: {
	      get: function () {
	        console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points.");
	        return this.Points;
	      }
	    }
	  });
	}
	function ascSort(a, b) {
	  return a.distance - b.distance;
	}
	function intersectObject(object, raycaster, intersects, recursive) {
	  if (object.layers.test(raycaster.layers)) {
	    object.raycast(raycaster, intersects);
	  }
	  if (recursive === true) {
	    var children = object.children;
	    for (var i = 0, l = children.length; i < l; i++) {
	      intersectObject(children[i], raycaster, intersects, true);
	    }
	  }
	}
	Object.assign(Raycaster.prototype, {
	  set: function (origin, direction) {
	    this.ray.set(origin, direction);
	  },
	  setFromCamera: function (coords, camera) {
	    if (camera && camera.isPerspectiveCamera) {
	      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
	      this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
	      this.camera = camera;
	    } else if (camera && camera.isOrthographicCamera) {
	      this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
	      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
	      this.camera = camera;
	    } else {
	      console.error("THREE.Raycaster: Unsupported camera type.");
	    }
	  },
	  intersectObject: function (object, recursive, optionalTarget) {
	    var intersects = optionalTarget || [];
	    intersectObject(object, this, intersects, recursive);
	    intersects.sort(ascSort);
	    return intersects;
	  },
	  intersectObjects: function (objects, recursive, optionalTarget) {
	    var intersects = optionalTarget || [];
	    if (Array.isArray(objects) === false) {
	      console.warn("THREE.Raycaster.intersectObjects: objects is not an Array.");
	      return intersects;
	    }
	    for (var i = 0, l = objects.length; i < l; i++) {
	      intersectObject(objects[i], this, intersects, recursive);
	    }
	    intersects.sort(ascSort);
	    return intersects;
	  }
	});
	function Spherical(radius, phi, theta) {
	  this.radius = radius !== undefined ? radius : 1;
	  this.phi = phi !== undefined ? phi : 0;
	  this.theta = theta !== undefined ? theta : 0;
	  return this;
	}
	Object.assign(Spherical.prototype, {
	  set: function (radius, phi, theta) {
	    this.radius = radius;
	    this.phi = phi;
	    this.theta = theta;
	    return this;
	  },
	  clone: function () {
	    return new this.constructor().copy(this);
	  },
	  copy: function (other) {
	    this.radius = other.radius;
	    this.phi = other.phi;
	    this.theta = other.theta;
	    return this;
	  },
	  makeSafe: function () {
	    var EPS = 0.000001;
	    this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));
	    return this;
	  },
	  setFromVector3: function (v) {
	    return this.setFromCartesianCoords(v.x, v.y, v.z);
	  },
	  setFromCartesianCoords: function (x, y, z) {
	    this.radius = Math.sqrt(x * x + y * y + z * z);
	    if (this.radius === 0) {
	      this.theta = 0;
	      this.phi = 0;
	    } else {
	      this.theta = Math.atan2(x, z);
	      this.phi = Math.acos(MathUtils.clamp(y / this.radius, -1, 1));
	    }
	    return this;
	  }
	});
	function Cylindrical(radius, theta, y) {
	  this.radius = radius !== undefined ? radius : 1;
	  this.theta = theta !== undefined ? theta : 0;
	  this.y = y !== undefined ? y : 0;
	  return this;
	}
	Object.assign(Cylindrical.prototype, {
	  set: function (radius, theta, y) {
	    this.radius = radius;
	    this.theta = theta;
	    this.y = y;
	    return this;
	  },
	  clone: function () {
	    return new this.constructor().copy(this);
	  },
	  copy: function (other) {
	    this.radius = other.radius;
	    this.theta = other.theta;
	    this.y = other.y;
	    return this;
	  },
	  setFromVector3: function (v) {
	    return this.setFromCartesianCoords(v.x, v.y, v.z);
	  },
	  setFromCartesianCoords: function (x, y, z) {
	    this.radius = Math.sqrt(x * x + z * z);
	    this.theta = Math.atan2(x, z);
	    this.y = y;
	    return this;
	  }
	});
	var _vector$7 = new Vector2();
	function Box2(min, max) {
	  this.min = min !== undefined ? min : new Vector2(+Infinity, +Infinity);
	  this.max = max !== undefined ? max : new Vector2(-Infinity, -Infinity);
	}
	Object.assign(Box2.prototype, {
	  set: function (min, max) {
	    this.min.copy(min);
	    this.max.copy(max);
	    return this;
	  },
	  setFromPoints: function (points) {
	    this.makeEmpty();
	    for (var i = 0, il = points.length; i < il; i++) {
	      this.expandByPoint(points[i]);
	    }
	    return this;
	  },
	  setFromCenterAndSize: function (center, size) {
	    var halfSize = _vector$7.copy(size).multiplyScalar(0.5);
	    this.min.copy(center).sub(halfSize);
	    this.max.copy(center).add(halfSize);
	    return this;
	  },
	  clone: function () {
	    return new this.constructor().copy(this);
	  },
	  copy: function (box) {
	    this.min.copy(box.min);
	    this.max.copy(box.max);
	    return this;
	  },
	  makeEmpty: function () {
	    this.min.x = this.min.y = +Infinity;
	    this.max.x = this.max.y = -Infinity;
	    return this;
	  },
	  isEmpty: function () {
	    return this.max.x < this.min.x || this.max.y < this.min.y;
	  },
	  getCenter: function (target) {
	    if (target === undefined) {
	      console.warn("THREE.Box2: .getCenter() target is now required");
	      target = new Vector2();
	    }
	    return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
	  },
	  getSize: function (target) {
	    if (target === undefined) {
	      console.warn("THREE.Box2: .getSize() target is now required");
	      target = new Vector2();
	    }
	    return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
	  },
	  expandByPoint: function (point) {
	    this.min.min(point);
	    this.max.max(point);
	    return this;
	  },
	  expandByVector: function (vector) {
	    this.min.sub(vector);
	    this.max.add(vector);
	    return this;
	  },
	  expandByScalar: function (scalar) {
	    this.min.addScalar(-scalar);
	    this.max.addScalar(scalar);
	    return this;
	  },
	  containsPoint: function (point) {
	    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;
	  },
	  containsBox: function (box) {
	    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
	  },
	  getParameter: function (point, target) {
	    if (target === undefined) {
	      console.warn("THREE.Box2: .getParameter() target is now required");
	      target = new Vector2();
	    }
	    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
	  },
	  intersectsBox: function (box) {
	    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
	  },
	  clampPoint: function (point, target) {
	    if (target === undefined) {
	      console.warn("THREE.Box2: .clampPoint() target is now required");
	      target = new Vector2();
	    }
	    return target.copy(point).clamp(this.min, this.max);
	  },
	  distanceToPoint: function (point) {
	    var clampedPoint = _vector$7.copy(point).clamp(this.min, this.max);
	    return clampedPoint.sub(point).length();
	  },
	  intersect: function (box) {
	    this.min.max(box.min);
	    this.max.min(box.max);
	    return this;
	  },
	  union: function (box) {
	    this.min.min(box.min);
	    this.max.max(box.max);
	    return this;
	  },
	  translate: function (offset) {
	    this.min.add(offset);
	    this.max.add(offset);
	    return this;
	  },
	  equals: function (box) {
	    return box.min.equals(this.min) && box.max.equals(this.max);
	  }
	});
	var _startP = new Vector3();
	var _startEnd = new Vector3();
	function Line3(start, end) {
	  this.start = start !== undefined ? start : new Vector3();
	  this.end = end !== undefined ? end : new Vector3();
	}
	Object.assign(Line3.prototype, {
	  set: function (start, end) {
	    this.start.copy(start);
	    this.end.copy(end);
	    return this;
	  },
	  clone: function () {
	    return new this.constructor().copy(this);
	  },
	  copy: function (line) {
	    this.start.copy(line.start);
	    this.end.copy(line.end);
	    return this;
	  },
	  getCenter: function (target) {
	    if (target === undefined) {
	      console.warn("THREE.Line3: .getCenter() target is now required");
	      target = new Vector3();
	    }
	    return target.addVectors(this.start, this.end).multiplyScalar(0.5);
	  },
	  delta: function (target) {
	    if (target === undefined) {
	      console.warn("THREE.Line3: .delta() target is now required");
	      target = new Vector3();
	    }
	    return target.subVectors(this.end, this.start);
	  },
	  distanceSq: function () {
	    return this.start.distanceToSquared(this.end);
	  },
	  distance: function () {
	    return this.start.distanceTo(this.end);
	  },
	  at: function (t, target) {
	    if (target === undefined) {
	      console.warn("THREE.Line3: .at() target is now required");
	      target = new Vector3();
	    }
	    return this.delta(target).multiplyScalar(t).add(this.start);
	  },
	  closestPointToPointParameter: function (point, clampToLine) {
	    _startP.subVectors(point, this.start);
	    _startEnd.subVectors(this.end, this.start);
	    var startEnd2 = _startEnd.dot(_startEnd);
	    var startEnd_startP = _startEnd.dot(_startP);
	    var t = startEnd_startP / startEnd2;
	    if (clampToLine) {
	      t = MathUtils.clamp(t, 0, 1);
	    }
	    return t;
	  },
	  closestPointToPoint: function (point, clampToLine, target) {
	    var t = this.closestPointToPointParameter(point, clampToLine);
	    if (target === undefined) {
	      console.warn("THREE.Line3: .closestPointToPoint() target is now required");
	      target = new Vector3();
	    }
	    return this.delta(target).multiplyScalar(t).add(this.start);
	  },
	  applyMatrix4: function (matrix) {
	    this.start.applyMatrix4(matrix);
	    this.end.applyMatrix4(matrix);
	    return this;
	  },
	  equals: function (line) {
	    return line.start.equals(this.start) && line.end.equals(this.end);
	  }
	});
	function ImmediateRenderObject(material) {
	  Object3D.call(this);
	  this.material = material;
	  this.render = function () {};
	}
	ImmediateRenderObject.prototype = Object.create(Object3D.prototype);
	ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
	ImmediateRenderObject.prototype.isImmediateRenderObject = true;
	var _vector$8 = new Vector3();
	function SpotLightHelper(light, color) {
	  Object3D.call(this);
	  this.light = light;
	  this.light.updateMatrixWorld();
	  this.matrix = light.matrixWorld;
	  this.matrixAutoUpdate = false;
	  this.color = color;
	  var geometry = new BufferGeometry();
	  var positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
	  for (var i = 0, j = 1, l = 32; i < l; (i++, j++)) {
	    var p1 = i / l * Math.PI * 2;
	    var p2 = j / l * Math.PI * 2;
	    positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
	  }
	  geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
	  var material = new LineBasicMaterial({
	    fog: false
	  });
	  this.cone = new LineSegments(geometry, material);
	  this.add(this.cone);
	  this.update();
	}
	SpotLightHelper.prototype = Object.create(Object3D.prototype);
	SpotLightHelper.prototype.constructor = SpotLightHelper;
	SpotLightHelper.prototype.dispose = function () {
	  this.cone.geometry.dispose();
	  this.cone.material.dispose();
	};
	SpotLightHelper.prototype.update = function () {
	  this.light.updateMatrixWorld();
	  var coneLength = this.light.distance ? this.light.distance : 1000;
	  var coneWidth = coneLength * Math.tan(this.light.angle);
	  this.cone.scale.set(coneWidth, coneWidth, coneLength);
	  _vector$8.setFromMatrixPosition(this.light.target.matrixWorld);
	  this.cone.lookAt(_vector$8);
	  if (this.color !== undefined) {
	    this.cone.material.color.set(this.color);
	  } else {
	    this.cone.material.color.copy(this.light.color);
	  }
	};
	var _vector$9 = new Vector3();
	var _boneMatrix = new Matrix4();
	var _matrixWorldInv = new Matrix4();
	function getBoneList(object) {
	  var boneList = [];
	  if (object && object.isBone) {
	    boneList.push(object);
	  }
	  for (var i = 0; i < object.children.length; i++) {
	    boneList.push.apply(boneList, getBoneList(object.children[i]));
	  }
	  return boneList;
	}
	function SkeletonHelper(object) {
	  var bones = getBoneList(object);
	  var geometry = new BufferGeometry();
	  var vertices = [];
	  var colors = [];
	  var color1 = new Color(0, 0, 1);
	  var color2 = new Color(0, 1, 0);
	  for (var i = 0; i < bones.length; i++) {
	    var bone = bones[i];
	    if (bone.parent && bone.parent.isBone) {
	      vertices.push(0, 0, 0);
	      vertices.push(0, 0, 0);
	      colors.push(color1.r, color1.g, color1.b);
	      colors.push(color2.r, color2.g, color2.b);
	    }
	  }
	  geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
	  geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
	  var material = new LineBasicMaterial({
	    vertexColors: true,
	    depthTest: false,
	    depthWrite: false,
	    transparent: true
	  });
	  LineSegments.call(this, geometry, material);
	  this.root = object;
	  this.bones = bones;
	  this.matrix = object.matrixWorld;
	  this.matrixAutoUpdate = false;
	}
	SkeletonHelper.prototype = Object.create(LineSegments.prototype);
	SkeletonHelper.prototype.constructor = SkeletonHelper;
	SkeletonHelper.prototype.isSkeletonHelper = true;
	SkeletonHelper.prototype.updateMatrixWorld = function (force) {
	  var bones = this.bones;
	  var geometry = this.geometry;
	  var position = geometry.getAttribute("position");
	  _matrixWorldInv.getInverse(this.root.matrixWorld);
	  for (var i = 0, j = 0; i < bones.length; i++) {
	    var bone = bones[i];
	    if (bone.parent && bone.parent.isBone) {
	      _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
	      _vector$9.setFromMatrixPosition(_boneMatrix);
	      position.setXYZ(j, _vector$9.x, _vector$9.y, _vector$9.z);
	      _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
	      _vector$9.setFromMatrixPosition(_boneMatrix);
	      position.setXYZ(j + 1, _vector$9.x, _vector$9.y, _vector$9.z);
	      j += 2;
	    }
	  }
	  geometry.getAttribute("position").needsUpdate = true;
	  Object3D.prototype.updateMatrixWorld.call(this, force);
	};
	function PointLightHelper(light, sphereSize, color) {
	  this.light = light;
	  this.light.updateMatrixWorld();
	  this.color = color;
	  var geometry = new SphereBufferGeometry(sphereSize, 4, 2);
	  var material = new MeshBasicMaterial({
	    wireframe: true,
	    fog: false
	  });
	  Mesh.call(this, geometry, material);
	  this.matrix = this.light.matrixWorld;
	  this.matrixAutoUpdate = false;
	  this.update();
	}
	PointLightHelper.prototype = Object.create(Mesh.prototype);
	PointLightHelper.prototype.constructor = PointLightHelper;
	PointLightHelper.prototype.dispose = function () {
	  this.geometry.dispose();
	  this.material.dispose();
	};
	PointLightHelper.prototype.update = function () {
	  if (this.color !== undefined) {
	    this.material.color.set(this.color);
	  } else {
	    this.material.color.copy(this.light.color);
	  }
	};
	var _vector$a = new Vector3();
	var _color1 = new Color();
	var _color2 = new Color();
	function HemisphereLightHelper(light, size, color) {
	  Object3D.call(this);
	  this.light = light;
	  this.light.updateMatrixWorld();
	  this.matrix = light.matrixWorld;
	  this.matrixAutoUpdate = false;
	  this.color = color;
	  var geometry = new OctahedronBufferGeometry(size);
	  geometry.rotateY(Math.PI * 0.5);
	  this.material = new MeshBasicMaterial({
	    wireframe: true,
	    fog: false
	  });
	  if (this.color === undefined) this.material.vertexColors = true;
	  var position = geometry.getAttribute("position");
	  var colors = new Float32Array(position.count * 3);
	  geometry.setAttribute("color", new BufferAttribute(colors, 3));
	  this.add(new Mesh(geometry, this.material));
	  this.update();
	}
	HemisphereLightHelper.prototype = Object.create(Object3D.prototype);
	HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;
	HemisphereLightHelper.prototype.dispose = function () {
	  this.children[0].geometry.dispose();
	  this.children[0].material.dispose();
	};
	HemisphereLightHelper.prototype.update = function () {
	  var mesh = this.children[0];
	  if (this.color !== undefined) {
	    this.material.color.set(this.color);
	  } else {
	    var colors = mesh.geometry.getAttribute("color");
	    _color1.copy(this.light.color);
	    _color2.copy(this.light.groundColor);
	    for (var i = 0, l = colors.count; i < l; i++) {
	      var color = i < l / 2 ? _color1 : _color2;
	      colors.setXYZ(i, color.r, color.g, color.b);
	    }
	    colors.needsUpdate = true;
	  }
	  mesh.lookAt(_vector$a.setFromMatrixPosition(this.light.matrixWorld).negate());
	};
	function GridHelper(size, divisions, color1, color2) {
	  size = size || 10;
	  divisions = divisions || 10;
	  color1 = new Color(color1 !== undefined ? color1 : 4473924);
	  color2 = new Color(color2 !== undefined ? color2 : 8947848);
	  var center = divisions / 2;
	  var step = size / divisions;
	  var halfSize = size / 2;
	  var vertices = [], colors = [];
	  for (var i = 0, j = 0, k = -halfSize; i <= divisions; (i++, k += step)) {
	    vertices.push(-halfSize, 0, k, halfSize, 0, k);
	    vertices.push(k, 0, -halfSize, k, 0, halfSize);
	    var color = i === center ? color1 : color2;
	    color.toArray(colors, j);
	    j += 3;
	    color.toArray(colors, j);
	    j += 3;
	    color.toArray(colors, j);
	    j += 3;
	    color.toArray(colors, j);
	    j += 3;
	  }
	  var geometry = new BufferGeometry();
	  geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
	  geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
	  var material = new LineBasicMaterial({
	    vertexColors: true
	  });
	  LineSegments.call(this, geometry, material);
	}
	GridHelper.prototype = Object.assign(Object.create(LineSegments.prototype), {
	  constructor: GridHelper,
	  copy: function (source) {
	    LineSegments.prototype.copy.call(this, source);
	    this.geometry.copy(source.geometry);
	    this.material.copy(source.material);
	    return this;
	  },
	  clone: function () {
	    return new this.constructor().copy(this);
	  }
	});
	function PolarGridHelper(radius, radials, circles, divisions, color1, color2) {
	  radius = radius || 10;
	  radials = radials || 16;
	  circles = circles || 8;
	  divisions = divisions || 64;
	  color1 = new Color(color1 !== undefined ? color1 : 4473924);
	  color2 = new Color(color2 !== undefined ? color2 : 8947848);
	  var vertices = [];
	  var colors = [];
	  var x, z;
	  var v, i, j, r, color;
	  for (i = 0; i <= radials; i++) {
	    v = i / radials * (Math.PI * 2);
	    x = Math.sin(v) * radius;
	    z = Math.cos(v) * radius;
	    vertices.push(0, 0, 0);
	    vertices.push(x, 0, z);
	    color = i & 1 ? color1 : color2;
	    colors.push(color.r, color.g, color.b);
	    colors.push(color.r, color.g, color.b);
	  }
	  for (i = 0; i <= circles; i++) {
	    color = i & 1 ? color1 : color2;
	    r = radius - radius / circles * i;
	    for (j = 0; j < divisions; j++) {
	      v = j / divisions * (Math.PI * 2);
	      x = Math.sin(v) * r;
	      z = Math.cos(v) * r;
	      vertices.push(x, 0, z);
	      colors.push(color.r, color.g, color.b);
	      v = (j + 1) / divisions * (Math.PI * 2);
	      x = Math.sin(v) * r;
	      z = Math.cos(v) * r;
	      vertices.push(x, 0, z);
	      colors.push(color.r, color.g, color.b);
	    }
	  }
	  var geometry = new BufferGeometry();
	  geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
	  geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
	  var material = new LineBasicMaterial({
	    vertexColors: true
	  });
	  LineSegments.call(this, geometry, material);
	}
	PolarGridHelper.prototype = Object.create(LineSegments.prototype);
	PolarGridHelper.prototype.constructor = PolarGridHelper;
	var _v1$5 = new Vector3();
	var _v2$3 = new Vector3();
	var _v3$1 = new Vector3();
	function DirectionalLightHelper(light, size, color) {
	  Object3D.call(this);
	  this.light = light;
	  this.light.updateMatrixWorld();
	  this.matrix = light.matrixWorld;
	  this.matrixAutoUpdate = false;
	  this.color = color;
	  if (size === undefined) size = 1;
	  var geometry = new BufferGeometry();
	  geometry.setAttribute("position", new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));
	  var material = new LineBasicMaterial({
	    fog: false
	  });
	  this.lightPlane = new Line(geometry, material);
	  this.add(this.lightPlane);
	  geometry = new BufferGeometry();
	  geometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
	  this.targetLine = new Line(geometry, material);
	  this.add(this.targetLine);
	  this.update();
	}
	DirectionalLightHelper.prototype = Object.create(Object3D.prototype);
	DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;
	DirectionalLightHelper.prototype.dispose = function () {
	  this.lightPlane.geometry.dispose();
	  this.lightPlane.material.dispose();
	  this.targetLine.geometry.dispose();
	  this.targetLine.material.dispose();
	};
	DirectionalLightHelper.prototype.update = function () {
	  _v1$5.setFromMatrixPosition(this.light.matrixWorld);
	  _v2$3.setFromMatrixPosition(this.light.target.matrixWorld);
	  _v3$1.subVectors(_v2$3, _v1$5);
	  this.lightPlane.lookAt(_v2$3);
	  if (this.color !== undefined) {
	    this.lightPlane.material.color.set(this.color);
	    this.targetLine.material.color.set(this.color);
	  } else {
	    this.lightPlane.material.color.copy(this.light.color);
	    this.targetLine.material.color.copy(this.light.color);
	  }
	  this.targetLine.lookAt(_v2$3);
	  this.targetLine.scale.z = _v3$1.length();
	};
	var _vector$b = new Vector3();
	var _camera = new Camera();
	function CameraHelper(camera) {
	  var geometry = new BufferGeometry();
	  var material = new LineBasicMaterial({
	    color: 16777215,
	    vertexColors: true
	  });
	  var vertices = [];
	  var colors = [];
	  var pointMap = {};
	  var colorFrustum = new Color(16755200);
	  var colorCone = new Color(16711680);
	  var colorUp = new Color(43775);
	  var colorTarget = new Color(16777215);
	  var colorCross = new Color(3355443);
	  addLine("n1", "n2", colorFrustum);
	  addLine("n2", "n4", colorFrustum);
	  addLine("n4", "n3", colorFrustum);
	  addLine("n3", "n1", colorFrustum);
	  addLine("f1", "f2", colorFrustum);
	  addLine("f2", "f4", colorFrustum);
	  addLine("f4", "f3", colorFrustum);
	  addLine("f3", "f1", colorFrustum);
	  addLine("n1", "f1", colorFrustum);
	  addLine("n2", "f2", colorFrustum);
	  addLine("n3", "f3", colorFrustum);
	  addLine("n4", "f4", colorFrustum);
	  addLine("p", "n1", colorCone);
	  addLine("p", "n2", colorCone);
	  addLine("p", "n3", colorCone);
	  addLine("p", "n4", colorCone);
	  addLine("u1", "u2", colorUp);
	  addLine("u2", "u3", colorUp);
	  addLine("u3", "u1", colorUp);
	  addLine("c", "t", colorTarget);
	  addLine("p", "c", colorCross);
	  addLine("cn1", "cn2", colorCross);
	  addLine("cn3", "cn4", colorCross);
	  addLine("cf1", "cf2", colorCross);
	  addLine("cf3", "cf4", colorCross);
	  function addLine(a, b, color) {
	    addPoint(a, color);
	    addPoint(b, color);
	  }
	  function addPoint(id, color) {
	    vertices.push(0, 0, 0);
	    colors.push(color.r, color.g, color.b);
	    if (pointMap[id] === undefined) {
	      pointMap[id] = [];
	    }
	    pointMap[id].push(vertices.length / 3 - 1);
	  }
	  geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
	  geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
	  LineSegments.call(this, geometry, material);
	  this.camera = camera;
	  if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix();
	  this.matrix = camera.matrixWorld;
	  this.matrixAutoUpdate = false;
	  this.pointMap = pointMap;
	  this.update();
	}
	CameraHelper.prototype = Object.create(LineSegments.prototype);
	CameraHelper.prototype.constructor = CameraHelper;
	CameraHelper.prototype.update = function () {
	  var geometry = this.geometry;
	  var pointMap = this.pointMap;
	  var w = 1, h = 1;
	  _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
	  setPoint("c", pointMap, geometry, _camera, 0, 0, -1);
	  setPoint("t", pointMap, geometry, _camera, 0, 0, 1);
	  setPoint("n1", pointMap, geometry, _camera, -w, -h, -1);
	  setPoint("n2", pointMap, geometry, _camera, w, -h, -1);
	  setPoint("n3", pointMap, geometry, _camera, -w, h, -1);
	  setPoint("n4", pointMap, geometry, _camera, w, h, -1);
	  setPoint("f1", pointMap, geometry, _camera, -w, -h, 1);
	  setPoint("f2", pointMap, geometry, _camera, w, -h, 1);
	  setPoint("f3", pointMap, geometry, _camera, -w, h, 1);
	  setPoint("f4", pointMap, geometry, _camera, w, h, 1);
	  setPoint("u1", pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);
	  setPoint("u2", pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);
	  setPoint("u3", pointMap, geometry, _camera, 0, h * 2, -1);
	  setPoint("cf1", pointMap, geometry, _camera, -w, 0, 1);
	  setPoint("cf2", pointMap, geometry, _camera, w, 0, 1);
	  setPoint("cf3", pointMap, geometry, _camera, 0, -h, 1);
	  setPoint("cf4", pointMap, geometry, _camera, 0, h, 1);
	  setPoint("cn1", pointMap, geometry, _camera, -w, 0, -1);
	  setPoint("cn2", pointMap, geometry, _camera, w, 0, -1);
	  setPoint("cn3", pointMap, geometry, _camera, 0, -h, -1);
	  setPoint("cn4", pointMap, geometry, _camera, 0, h, -1);
	  geometry.getAttribute("position").needsUpdate = true;
	};
	function setPoint(point, pointMap, geometry, camera, x, y, z) {
	  _vector$b.set(x, y, z).unproject(camera);
	  var points = pointMap[point];
	  if (points !== undefined) {
	    var position = geometry.getAttribute("position");
	    for (var i = 0, l = points.length; i < l; i++) {
	      position.setXYZ(points[i], _vector$b.x, _vector$b.y, _vector$b.z);
	    }
	  }
	}
	var _box$3 = new Box3();
	function BoxHelper(object, color) {
	  this.object = object;
	  if (color === undefined) color = 16776960;
	  var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
	  var positions = new Float32Array(8 * 3);
	  var geometry = new BufferGeometry();
	  geometry.setIndex(new BufferAttribute(indices, 1));
	  geometry.setAttribute("position", new BufferAttribute(positions, 3));
	  LineSegments.call(this, geometry, new LineBasicMaterial({
	    color: color
	  }));
	  this.matrixAutoUpdate = false;
	  this.update();
	}
	BoxHelper.prototype = Object.create(LineSegments.prototype);
	BoxHelper.prototype.constructor = BoxHelper;
	BoxHelper.prototype.update = function (object) {
	  if (object !== undefined) {
	    console.warn("THREE.BoxHelper: .update() has no longer arguments.");
	  }
	  if (this.object !== undefined) {
	    _box$3.setFromObject(this.object);
	  }
	  if (_box$3.isEmpty()) return;
	  var min = _box$3.min;
	  var max = _box$3.max;
	  var position = this.geometry.attributes.position;
	  var array = position.array;
	  array[0] = max.x;
	  array[1] = max.y;
	  array[2] = max.z;
	  array[3] = min.x;
	  array[4] = max.y;
	  array[5] = max.z;
	  array[6] = min.x;
	  array[7] = min.y;
	  array[8] = max.z;
	  array[9] = max.x;
	  array[10] = min.y;
	  array[11] = max.z;
	  array[12] = max.x;
	  array[13] = max.y;
	  array[14] = min.z;
	  array[15] = min.x;
	  array[16] = max.y;
	  array[17] = min.z;
	  array[18] = min.x;
	  array[19] = min.y;
	  array[20] = min.z;
	  array[21] = max.x;
	  array[22] = min.y;
	  array[23] = min.z;
	  position.needsUpdate = true;
	  this.geometry.computeBoundingSphere();
	};
	BoxHelper.prototype.setFromObject = function (object) {
	  this.object = object;
	  this.update();
	  return this;
	};
	BoxHelper.prototype.copy = function (source) {
	  LineSegments.prototype.copy.call(this, source);
	  this.object = source.object;
	  return this;
	};
	BoxHelper.prototype.clone = function () {
	  return new this.constructor().copy(this);
	};
	function Box3Helper(box, color) {
	  this.type = "Box3Helper";
	  this.box = box;
	  color = color || 16776960;
	  var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
	  var positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
	  var geometry = new BufferGeometry();
	  geometry.setIndex(new BufferAttribute(indices, 1));
	  geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
	  LineSegments.call(this, geometry, new LineBasicMaterial({
	    color: color
	  }));
	  this.geometry.computeBoundingSphere();
	}
	Box3Helper.prototype = Object.create(LineSegments.prototype);
	Box3Helper.prototype.constructor = Box3Helper;
	Box3Helper.prototype.updateMatrixWorld = function (force) {
	  var box = this.box;
	  if (box.isEmpty()) return;
	  box.getCenter(this.position);
	  box.getSize(this.scale);
	  this.scale.multiplyScalar(0.5);
	  Object3D.prototype.updateMatrixWorld.call(this, force);
	};
	function PlaneHelper(plane, size, hex) {
	  this.type = "PlaneHelper";
	  this.plane = plane;
	  this.size = size === undefined ? 1 : size;
	  var color = hex !== undefined ? hex : 16776960;
	  var positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];
	  var geometry = new BufferGeometry();
	  geometry.setAttribute("position", new Float32BufferAttribute(positions, 3));
	  geometry.computeBoundingSphere();
	  Line.call(this, geometry, new LineBasicMaterial({
	    color: color
	  }));
	  var positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];
	  var geometry2 = new BufferGeometry();
	  geometry2.setAttribute("position", new Float32BufferAttribute(positions2, 3));
	  geometry2.computeBoundingSphere();
	  this.add(new Mesh(geometry2, new MeshBasicMaterial({
	    color: color,
	    opacity: 0.2,
	    transparent: true,
	    depthWrite: false
	  })));
	}
	PlaneHelper.prototype = Object.create(Line.prototype);
	PlaneHelper.prototype.constructor = PlaneHelper;
	PlaneHelper.prototype.updateMatrixWorld = function (force) {
	  var scale = -this.plane.constant;
	  if (Math.abs(scale) < 1e-8) scale = 1e-8;
	  this.scale.set(0.5 * this.size, 0.5 * this.size, scale);
	  this.children[0].material.side = scale < 0 ? BackSide : FrontSide;
	  this.lookAt(this.plane.normal);
	  Object3D.prototype.updateMatrixWorld.call(this, force);
	};
	var _axis = new Vector3();
	var _lineGeometry, _coneGeometry;
	function ArrowHelper(dir, origin, length, color, headLength, headWidth) {
	  Object3D.call(this);
	  if (dir === undefined) dir = new Vector3(0, 0, 1);
	  if (origin === undefined) origin = new Vector3(0, 0, 0);
	  if (length === undefined) length = 1;
	  if (color === undefined) color = 16776960;
	  if (headLength === undefined) headLength = 0.2 * length;
	  if (headWidth === undefined) headWidth = 0.2 * headLength;
	  if (_lineGeometry === undefined) {
	    _lineGeometry = new BufferGeometry();
	    _lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
	    _coneGeometry = new CylinderBufferGeometry(0, 0.5, 1, 5, 1);
	    _coneGeometry.translate(0, -0.5, 0);
	  }
	  this.position.copy(origin);
	  this.line = new Line(_lineGeometry, new LineBasicMaterial({
	    color: color
	  }));
	  this.line.matrixAutoUpdate = false;
	  this.add(this.line);
	  this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({
	    color: color
	  }));
	  this.cone.matrixAutoUpdate = false;
	  this.add(this.cone);
	  this.setDirection(dir);
	  this.setLength(length, headLength, headWidth);
	}
	ArrowHelper.prototype = Object.create(Object3D.prototype);
	ArrowHelper.prototype.constructor = ArrowHelper;
	ArrowHelper.prototype.setDirection = function (dir) {
	  if (dir.y > 0.99999) {
	    this.quaternion.set(0, 0, 0, 1);
	  } else if (dir.y < -0.99999) {
	    this.quaternion.set(1, 0, 0, 0);
	  } else {
	    _axis.set(dir.z, 0, -dir.x).normalize();
	    var radians = Math.acos(dir.y);
	    this.quaternion.setFromAxisAngle(_axis, radians);
	  }
	};
	ArrowHelper.prototype.setLength = function (length, headLength, headWidth) {
	  if (headLength === undefined) headLength = 0.2 * length;
	  if (headWidth === undefined) headWidth = 0.2 * headLength;
	  this.line.scale.set(1, Math.max(0.0001, length - headLength), 1);
	  this.line.updateMatrix();
	  this.cone.scale.set(headWidth, headLength, headWidth);
	  this.cone.position.y = length;
	  this.cone.updateMatrix();
	};
	ArrowHelper.prototype.setColor = function (color) {
	  this.line.material.color.set(color);
	  this.cone.material.color.set(color);
	};
	ArrowHelper.prototype.copy = function (source) {
	  Object3D.prototype.copy.call(this, source, false);
	  this.line.copy(source.line);
	  this.cone.copy(source.cone);
	  return this;
	};
	ArrowHelper.prototype.clone = function () {
	  return new this.constructor().copy(this);
	};
	function AxesHelper(size) {
	  size = size || 1;
	  var vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];
	  var colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];
	  var geometry = new BufferGeometry();
	  geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
	  geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
	  var material = new LineBasicMaterial({
	    vertexColors: true
	  });
	  LineSegments.call(this, geometry, material);
	}
	AxesHelper.prototype = Object.create(LineSegments.prototype);
	AxesHelper.prototype.constructor = AxesHelper;
	var LOD_MIN = 4;
	var LOD_MAX = 8;
	var SIZE_MAX = Math.pow(2, LOD_MAX);
	var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
	var TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
	var MAX_SAMPLES = 20;
	var ENCODINGS = {
	  [LinearEncoding]: 0,
	  [sRGBEncoding]: 1,
	  [RGBEEncoding]: 2,
	  [RGBM7Encoding]: 3,
	  [RGBM16Encoding]: 4,
	  [RGBDEncoding]: 5,
	  [GammaEncoding]: 6
	};
	var _flatCamera = new OrthographicCamera();
	var _blurMaterial = _getBlurShader(MAX_SAMPLES);
	var _equirectShader = null;
	var _cubemapShader = null;
	var {_lodPlanes, _sizeLods, _sigmas} = _createPlanes();
	var _pingPongRenderTarget = null;
	var _renderer = null;
	var _oldTarget = null;
	var PHI = (1 + Math.sqrt(5)) / 2;
	var INV_PHI = 1 / PHI;
	var _axisDirections = [new Vector3(1, 1, 1), new Vector3(-1, 1, 1), new Vector3(1, 1, -1), new Vector3(-1, 1, -1), new Vector3(0, PHI, INV_PHI), new Vector3(0, PHI, -INV_PHI), new Vector3(INV_PHI, 0, PHI), new Vector3(-INV_PHI, 0, PHI), new Vector3(PHI, INV_PHI, 0), new Vector3(-PHI, INV_PHI, 0)];
	function PMREMGenerator(renderer) {
	  _renderer = renderer;
	  _compileMaterial(_blurMaterial);
	}
	PMREMGenerator.prototype = {
	  constructor: PMREMGenerator,
	  fromScene: function (scene, sigma = 0, near = 0.1, far = 100) {
	    _oldTarget = _renderer.getRenderTarget();
	    var cubeUVRenderTarget = _allocateTargets();
	    _sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
	    if (sigma > 0) {
	      _blur(cubeUVRenderTarget, 0, 0, sigma);
	    }
	    _applyPMREM(cubeUVRenderTarget);
	    _cleanup(cubeUVRenderTarget);
	    return cubeUVRenderTarget;
	  },
	  fromEquirectangular: function (equirectangular) {
	    equirectangular.magFilter = NearestFilter;
	    equirectangular.minFilter = NearestFilter;
	    equirectangular.generateMipmaps = false;
	    return this.fromCubemap(equirectangular);
	  },
	  fromCubemap: function (cubemap) {
	    _oldTarget = _renderer.getRenderTarget();
	    var cubeUVRenderTarget = _allocateTargets(cubemap);
	    _textureToCubeUV(cubemap, cubeUVRenderTarget);
	    _applyPMREM(cubeUVRenderTarget);
	    _cleanup(cubeUVRenderTarget);
	    return cubeUVRenderTarget;
	  },
	  compileCubemapShader: function () {
	    if (_cubemapShader == null) {
	      _cubemapShader = _getCubemapShader();
	      _compileMaterial(_cubemapShader);
	    }
	  },
	  compileEquirectangularShader: function () {
	    if (_equirectShader == null) {
	      _equirectShader = _getEquirectShader();
	      _compileMaterial(_equirectShader);
	    }
	  },
	  dispose: function () {
	    _blurMaterial.dispose();
	    if (_cubemapShader != null) _cubemapShader.dispose();
	    if (_equirectShader != null) _equirectShader.dispose();
	    for (var i = 0; i < _lodPlanes.length; i++) {
	      _lodPlanes[i].dispose();
	    }
	  }
	};
	function _createPlanes() {
	  var _lodPlanes = [];
	  var _sizeLods = [];
	  var _sigmas = [];
	  var lod = LOD_MAX;
	  for (var i = 0; i < TOTAL_LODS; i++) {
	    var sizeLod = Math.pow(2, lod);
	    _sizeLods.push(sizeLod);
	    var sigma = 1 / sizeLod;
	    if (i > LOD_MAX - LOD_MIN) {
	      sigma = EXTRA_LOD_SIGMA[i - LOD_MAX + LOD_MIN - 1];
	    } else if (i == 0) {
	      sigma = 0;
	    }
	    _sigmas.push(sigma);
	    var texelSize = 1 / (sizeLod - 1);
	    var min = -texelSize / 2;
	    var max = 1 + texelSize / 2;
	    var uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
	    var cubeFaces = 6;
	    var vertices = 6;
	    var positionSize = 3;
	    var uvSize = 2;
	    var faceIndexSize = 1;
	    var position = new Float32Array(positionSize * vertices * cubeFaces);
	    var uv = new Float32Array(uvSize * vertices * cubeFaces);
	    var faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
	    for (var face = 0; face < cubeFaces; face++) {
	      var x = face % 3 * 2 / 3 - 1;
	      var y = face > 2 ? 0 : -1;
	      var coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];
	      position.set(coordinates, positionSize * vertices * face);
	      uv.set(uv1, uvSize * vertices * face);
	      var fill = [face, face, face, face, face, face];
	      faceIndex.set(fill, faceIndexSize * vertices * face);
	    }
	    var planes = new BufferGeometry();
	    planes.setAttribute("position", new BufferAttribute(position, positionSize));
	    planes.setAttribute("uv", new BufferAttribute(uv, uvSize));
	    planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
	    _lodPlanes.push(planes);
	    if (lod > LOD_MIN) {
	      lod--;
	    }
	  }
	  return {
	    _lodPlanes,
	    _sizeLods,
	    _sigmas
	  };
	}
	function _allocateTargets(equirectangular) {
	  var params = {
	    magFilter: NearestFilter,
	    minFilter: NearestFilter,
	    generateMipmaps: false,
	    type: equirectangular ? equirectangular.type : UnsignedByteType,
	    format: equirectangular ? equirectangular.format : RGBEFormat,
	    encoding: equirectangular ? equirectangular.encoding : RGBEEncoding,
	    depthBuffer: false,
	    stencilBuffer: false
	  };
	  var cubeUVRenderTarget = _createRenderTarget(params);
	  cubeUVRenderTarget.depthBuffer = equirectangular ? false : true;
	  _pingPongRenderTarget = _createRenderTarget(params);
	  return cubeUVRenderTarget;
	}
	function _cleanup(outputTarget) {
	  _pingPongRenderTarget.dispose();
	  _renderer.setRenderTarget(_oldTarget);
	  outputTarget.scissorTest = false;
	  outputTarget.setSize(outputTarget.width, outputTarget.height);
	}
	function _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
	  var fov = 90;
	  var aspect = 1;
	  var cubeCamera = new PerspectiveCamera(fov, aspect, near, far);
	  var upSign = [1, 1, 1, 1, -1, 1];
	  var forwardSign = [1, 1, -1, -1, -1, 1];
	  var outputEncoding = _renderer.outputEncoding;
	  var toneMapping = _renderer.toneMapping;
	  var toneMappingExposure = _renderer.toneMappingExposure;
	  var clearColor = _renderer.getClearColor();
	  var clearAlpha = _renderer.getClearAlpha();
	  _renderer.toneMapping = LinearToneMapping;
	  _renderer.toneMappingExposure = 1;
	  _renderer.outputEncoding = LinearEncoding;
	  scene.scale.z *= -1;
	  var background = scene.background;
	  if (background && background.isColor) {
	    background.convertSRGBToLinear();
	    var maxComponent = Math.max(background.r, background.g, background.b);
	    var fExp = Math.min(Math.max(Math.ceil(Math.log2(maxComponent)), -128), 127);
	    background = background.multiplyScalar(Math.pow(2, -fExp));
	    var alpha = (fExp + 128) / 255;
	    _renderer.setClearColor(background, alpha);
	    scene.background = null;
	  }
	  for (var i = 0; i < 6; i++) {
	    var col = i % 3;
	    if (col == 0) {
	      cubeCamera.up.set(0, upSign[i], 0);
	      cubeCamera.lookAt(forwardSign[i], 0, 0);
	    } else if (col == 1) {
	      cubeCamera.up.set(0, 0, upSign[i]);
	      cubeCamera.lookAt(0, forwardSign[i], 0);
	    } else {
	      cubeCamera.up.set(0, upSign[i], 0);
	      cubeCamera.lookAt(0, 0, forwardSign[i]);
	    }
	    _setViewport(cubeUVRenderTarget, col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);
	    _renderer.setRenderTarget(cubeUVRenderTarget);
	    _renderer.render(scene, cubeCamera);
	  }
	  _renderer.toneMapping = toneMapping;
	  _renderer.toneMappingExposure = toneMappingExposure;
	  _renderer.outputEncoding = outputEncoding;
	  _renderer.setClearColor(clearColor, clearAlpha);
	  scene.scale.z *= -1;
	}
	function _textureToCubeUV(texture, cubeUVRenderTarget) {
	  var scene = new Scene();
	  if (texture.isCubeTexture) {
	    if (_cubemapShader == null) {
	      _cubemapShader = _getCubemapShader();
	    }
	  } else {
	    if (_equirectShader == null) {
	      _equirectShader = _getEquirectShader();
	    }
	  }
	  var material = texture.isCubeTexture ? _cubemapShader : _equirectShader;
	  scene.add(new Mesh(_lodPlanes[0], material));
	  var uniforms = material.uniforms;
	  uniforms["envMap"].value = texture;
	  if (!texture.isCubeTexture) {
	    uniforms["texelSize"].value.set(1 / texture.image.width, 1 / texture.image.height);
	  }
	  uniforms["inputEncoding"].value = ENCODINGS[texture.encoding];
	  uniforms["outputEncoding"].value = ENCODINGS[texture.encoding];
	  _setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);
	  _renderer.setRenderTarget(cubeUVRenderTarget);
	  _renderer.render(scene, _flatCamera);
	}
	function _compileMaterial(material) {
	  var tmpScene = new Scene();
	  tmpScene.add(new Mesh(_lodPlanes[0], material));
	  _renderer.compile(tmpScene, _flatCamera);
	}
	function _createRenderTarget(params) {
	  var cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);
	  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
	  cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
	  cubeUVRenderTarget.scissorTest = true;
	  return cubeUVRenderTarget;
	}
	function _setViewport(target, x, y, width, height) {
	  target.viewport.set(x, y, width, height);
	  target.scissor.set(x, y, width, height);
	}
	function _applyPMREM(cubeUVRenderTarget) {
	  var autoClear = _renderer.autoClear;
	  _renderer.autoClear = false;
	  for (var i = 1; i < TOTAL_LODS; i++) {
	    var sigma = Math.sqrt(_sigmas[i] * _sigmas[i] - _sigmas[i - 1] * _sigmas[i - 1]);
	    var poleAxis = _axisDirections[(i - 1) % _axisDirections.length];
	    _blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
	  }
	  _renderer.autoClear = autoClear;
	}
	function _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
	  _halfBlur(cubeUVRenderTarget, _pingPongRenderTarget, lodIn, lodOut, sigma, "latitudinal", poleAxis);
	  _halfBlur(_pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, "longitudinal", poleAxis);
	}
	function _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
	  if (direction !== "latitudinal" && direction !== "longitudinal") {
	    console.error("blur direction must be either latitudinal or longitudinal!");
	  }
	  var STANDARD_DEVIATIONS = 3;
	  var blurScene = new Scene();
	  blurScene.add(new Mesh(_lodPlanes[lodOut], _blurMaterial));
	  var blurUniforms = _blurMaterial.uniforms;
	  var pixels = _sizeLods[lodIn] - 1;
	  var radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
	  var sigmaPixels = sigmaRadians / radiansPerPixel;
	  var samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
	  if (samples > MAX_SAMPLES) {
	    console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
	  }
	  var weights = [];
	  var sum = 0;
	  for (var i = 0; i < MAX_SAMPLES; ++i) {
	    var x = i / sigmaPixels;
	    var weight = Math.exp(-x * x / 2);
	    weights.push(weight);
	    if (i == 0) {
	      sum += weight;
	    } else if (i < samples) {
	      sum += 2 * weight;
	    }
	  }
	  for (var i = 0; i < weights.length; i++) {
	    weights[i] = weights[i] / sum;
	  }
	  blurUniforms["envMap"].value = targetIn.texture;
	  blurUniforms["samples"].value = samples;
	  blurUniforms["weights"].value = weights;
	  blurUniforms["latitudinal"].value = direction === "latitudinal";
	  if (poleAxis) {
	    blurUniforms["poleAxis"].value = poleAxis;
	  }
	  blurUniforms["dTheta"].value = radiansPerPixel;
	  blurUniforms["mipInt"].value = LOD_MAX - lodIn;
	  blurUniforms["inputEncoding"].value = ENCODINGS[targetIn.texture.encoding];
	  blurUniforms["outputEncoding"].value = ENCODINGS[targetIn.texture.encoding];
	  var outputSize = _sizeLods[lodOut];
	  var x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);
	  var y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);
	  _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
	  _renderer.setRenderTarget(targetOut);
	  _renderer.render(blurScene, _flatCamera);
	}
	function _getBlurShader(maxSamples) {
	  var weights = new Float32Array(maxSamples);
	  var poleAxis = new Vector3(0, 1, 0);
	  var shaderMaterial = new RawShaderMaterial({
	    defines: {
	      "n": maxSamples
	    },
	    uniforms: {
	      "envMap": {
	        value: null
	      },
	      "samples": {
	        value: 1
	      },
	      "weights": {
	        value: weights
	      },
	      "latitudinal": {
	        value: false
	      },
	      "dTheta": {
	        value: 0
	      },
	      "mipInt": {
	        value: 0
	      },
	      "poleAxis": {
	        value: poleAxis
	      },
	      "inputEncoding": {
	        value: ENCODINGS[LinearEncoding]
	      },
	      "outputEncoding": {
	        value: ENCODINGS[LinearEncoding]
	      }
	    },
	    vertexShader: _getCommonVertexShader(),
	    fragmentShader: `
precision mediump float;
precision mediump int;
varying vec3 vOutputDirection;
uniform sampler2D envMap;
uniform int samples;
uniform float weights[n];
uniform bool latitudinal;
uniform float dTheta;
uniform float mipInt;
uniform vec3 poleAxis;

${_getEncodings()}

#define ENVMAP_TYPE_CUBE_UV
#include <cube_uv_reflection_fragment>

void main() {
	gl_FragColor = vec4(0.0);
	for (int i = 0; i < n; i++) {
		if (i >= samples)
			break;
		for (int dir = -1; dir < 2; dir += 2) {
			if (i == 0 && dir == 1)
				continue;
			vec3 axis = latitudinal ? poleAxis : cross(poleAxis, vOutputDirection);
			if (all(equal(axis, vec3(0.0))))
				axis = cross(vec3(0.0, 1.0, 0.0), vOutputDirection);
			axis = normalize(axis);
			float theta = dTheta * float(dir * i);
			float cosTheta = cos(theta);
			// Rodrigues' axis-angle rotation
			vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross(axis, vOutputDirection) * sin(theta)
					+ axis * dot(axis, vOutputDirection) * (1.0 - cosTheta);
			gl_FragColor.rgb +=
					weights[i] * bilinearCubeUV(envMap, sampleDirection, mipInt);
		}
	}
	gl_FragColor = linearToOutputTexel(gl_FragColor);
}
		`,
	    blending: NoBlending,
	    depthTest: false,
	    depthWrite: false
	  });
	  shaderMaterial.type = "SphericalGaussianBlur";
	  return shaderMaterial;
	}
	function _getEquirectShader() {
	  var texelSize = new Vector2(1, 1);
	  var shaderMaterial = new RawShaderMaterial({
	    uniforms: {
	      "envMap": {
	        value: null
	      },
	      "texelSize": {
	        value: texelSize
	      },
	      "inputEncoding": {
	        value: ENCODINGS[LinearEncoding]
	      },
	      "outputEncoding": {
	        value: ENCODINGS[LinearEncoding]
	      }
	    },
	    vertexShader: _getCommonVertexShader(),
	    fragmentShader: `
precision mediump float;
precision mediump int;
varying vec3 vOutputDirection;
uniform sampler2D envMap;
uniform vec2 texelSize;

${_getEncodings()}

#define RECIPROCAL_PI 0.31830988618
#define RECIPROCAL_PI2 0.15915494

void main() {
	gl_FragColor = vec4(0.0);
	vec3 outputDirection = normalize(vOutputDirection);
	vec2 uv;
	uv.y = asin(clamp(outputDirection.y, -1.0, 1.0)) * RECIPROCAL_PI + 0.5;
	uv.x = atan(outputDirection.z, outputDirection.x) * RECIPROCAL_PI2 + 0.5;
	vec2 f = fract(uv / texelSize - 0.5);
	uv -= f * texelSize;
	vec3 tl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	uv.x += texelSize.x;
	vec3 tr = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	uv.y += texelSize.y;
	vec3 br = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	uv.x -= texelSize.x;
	vec3 bl = envMapTexelToLinear(texture2D(envMap, uv)).rgb;
	vec3 tm = mix(tl, tr, f.x);
	vec3 bm = mix(bl, br, f.x);
	gl_FragColor.rgb = mix(tm, bm, f.y);
	gl_FragColor = linearToOutputTexel(gl_FragColor);
}
		`,
	    blending: NoBlending,
	    depthTest: false,
	    depthWrite: false
	  });
	  shaderMaterial.type = "EquirectangularToCubeUV";
	  return shaderMaterial;
	}
	function _getCubemapShader() {
	  var shaderMaterial = new RawShaderMaterial({
	    uniforms: {
	      "envMap": {
	        value: null
	      },
	      "inputEncoding": {
	        value: ENCODINGS[LinearEncoding]
	      },
	      "outputEncoding": {
	        value: ENCODINGS[LinearEncoding]
	      }
	    },
	    vertexShader: _getCommonVertexShader(),
	    fragmentShader: `
precision mediump float;
precision mediump int;
varying vec3 vOutputDirection;
uniform samplerCube envMap;

${_getEncodings()}

void main() {
	gl_FragColor = vec4(0.0);
	gl_FragColor.rgb = envMapTexelToLinear(textureCube(envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ))).rgb;
	gl_FragColor = linearToOutputTexel(gl_FragColor);
}
		`,
	    blending: NoBlending,
	    depthTest: false,
	    depthWrite: false
	  });
	  shaderMaterial.type = "CubemapToCubeUV";
	  return shaderMaterial;
	}
	function _getCommonVertexShader() {
	  return `
precision mediump float;
precision mediump int;
attribute vec3 position;
attribute vec2 uv;
attribute float faceIndex;
varying vec3 vOutputDirection;
vec3 getDirection(vec2 uv, float face) {
	uv = 2.0 * uv - 1.0;
	vec3 direction = vec3(uv, 1.0);
	if (face == 0.0) {
		direction = direction.zyx;
		direction.z *= -1.0;
	} else if (face == 1.0) {
		direction = direction.xzy;
		direction.z *= -1.0;
	} else if (face == 3.0) {
		direction = direction.zyx;
		direction.x *= -1.0;
	} else if (face == 4.0) {
		direction = direction.xzy;
		direction.y *= -1.0;
	} else if (face == 5.0) {
		direction.xz *= -1.0;
	}
	return direction;
}
void main() {
	vOutputDirection = getDirection(uv, faceIndex);
	gl_Position = vec4( position, 1.0 );
}
	`;
	}
	function _getEncodings() {
	  return `
uniform int inputEncoding;
uniform int outputEncoding;

#include <encodings_pars_fragment>

vec4 inputTexelToLinear(vec4 value){
	if(inputEncoding == 0){
		return value;
	}else if(inputEncoding == 1){
		return sRGBToLinear(value);
	}else if(inputEncoding == 2){
		return RGBEToLinear(value);
	}else if(inputEncoding == 3){
		return RGBMToLinear(value, 7.0);
	}else if(inputEncoding == 4){
		return RGBMToLinear(value, 16.0);
	}else if(inputEncoding == 5){
		return RGBDToLinear(value, 256.0);
	}else{
		return GammaToLinear(value, 2.2);
	}
}

vec4 linearToOutputTexel(vec4 value){
	if(outputEncoding == 0){
		return value;
	}else if(outputEncoding == 1){
		return LinearTosRGB(value);
	}else if(outputEncoding == 2){
		return LinearToRGBE(value);
	}else if(outputEncoding == 3){
		return LinearToRGBM(value, 7.0);
	}else if(outputEncoding == 4){
		return LinearToRGBM(value, 16.0);
	}else if(outputEncoding == 5){
		return LinearToRGBD(value, 256.0);
	}else{
		return LinearToGamma(value, 2.2);
	}
}

vec4 envMapTexelToLinear(vec4 color) {
	return inputTexelToLinear(color);
}
	`;
	}
	function Face4(a, b, c, d, normal, color, materialIndex) {
	  console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead.");
	  return new Face3(a, b, c, normal, color, materialIndex);
	}
	var LineStrip = 0;
	var LinePieces = 1;
	var NoColors = 0;
	var FaceColors = 1;
	var VertexColors = 2;
	function MeshFaceMaterial(materials) {
	  console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead.");
	  return materials;
	}
	function MultiMaterial(materials) {
	  if (materials === undefined) materials = [];
	  console.warn("THREE.MultiMaterial has been removed. Use an Array instead.");
	  materials.isMultiMaterial = true;
	  materials.materials = materials;
	  materials.clone = function () {
	    return materials.slice();
	  };
	  return materials;
	}
	function PointCloud(geometry, material) {
	  console.warn("THREE.PointCloud has been renamed to THREE.Points.");
	  return new Points(geometry, material);
	}
	function Particle(material) {
	  console.warn("THREE.Particle has been renamed to THREE.Sprite.");
	  return new Sprite(material);
	}
	function ParticleSystem(geometry, material) {
	  console.warn("THREE.ParticleSystem has been renamed to THREE.Points.");
	  return new Points(geometry, material);
	}
	function PointCloudMaterial(parameters) {
	  console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.");
	  return new PointsMaterial(parameters);
	}
	function ParticleBasicMaterial(parameters) {
	  console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.");
	  return new PointsMaterial(parameters);
	}
	function ParticleSystemMaterial(parameters) {
	  console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.");
	  return new PointsMaterial(parameters);
	}
	function Vertex(x, y, z) {
	  console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead.");
	  return new Vector3(x, y, z);
	}
	function DynamicBufferAttribute(array, itemSize) {
	  console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.");
	  return new BufferAttribute(array, itemSize).setUsage(DynamicDrawUsage);
	}
	function Int8Attribute(array, itemSize) {
	  console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.");
	  return new Int8BufferAttribute(array, itemSize);
	}
	function Uint8Attribute(array, itemSize) {
	  console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.");
	  return new Uint8BufferAttribute(array, itemSize);
	}
	function Uint8ClampedAttribute(array, itemSize) {
	  console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.");
	  return new Uint8ClampedBufferAttribute(array, itemSize);
	}
	function Int16Attribute(array, itemSize) {
	  console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.");
	  return new Int16BufferAttribute(array, itemSize);
	}
	function Uint16Attribute(array, itemSize) {
	  console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.");
	  return new Uint16BufferAttribute(array, itemSize);
	}
	function Int32Attribute(array, itemSize) {
	  console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.");
	  return new Int32BufferAttribute(array, itemSize);
	}
	function Uint32Attribute(array, itemSize) {
	  console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.");
	  return new Uint32BufferAttribute(array, itemSize);
	}
	function Float32Attribute(array, itemSize) {
	  console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.");
	  return new Float32BufferAttribute(array, itemSize);
	}
	function Float64Attribute(array, itemSize) {
	  console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.");
	  return new Float64BufferAttribute(array, itemSize);
	}
	Curve.create = function (construct, getPoint) {
	  console.log("THREE.Curve.create() has been deprecated");
	  construct.prototype = Object.create(Curve.prototype);
	  construct.prototype.constructor = construct;
	  construct.prototype.getPoint = getPoint;
	  return construct;
	};
	Object.assign(CurvePath.prototype, {
	  createPointsGeometry: function (divisions) {
	    console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
	    var pts = this.getPoints(divisions);
	    return this.createGeometry(pts);
	  },
	  createSpacedPointsGeometry: function (divisions) {
	    console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
	    var pts = this.getSpacedPoints(divisions);
	    return this.createGeometry(pts);
	  },
	  createGeometry: function (points) {
	    console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
	    var geometry = new Geometry();
	    for (var i = 0, l = points.length; i < l; i++) {
	      var point = points[i];
	      geometry.vertices.push(new Vector3(point.x, point.y, point.z || 0));
	    }
	    return geometry;
	  }
	});
	Object.assign(Path.prototype, {
	  fromPoints: function (points) {
	    console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints().");
	    return this.setFromPoints(points);
	  }
	});
	function ClosedSplineCurve3(points) {
	  console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
	  CatmullRomCurve3.call(this, points);
	  this.type = "catmullrom";
	  this.closed = true;
	}
	ClosedSplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);
	function SplineCurve3(points) {
	  console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.");
	  CatmullRomCurve3.call(this, points);
	  this.type = "catmullrom";
	}
	SplineCurve3.prototype = Object.create(CatmullRomCurve3.prototype);
	function Spline(points) {
	  console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.");
	  CatmullRomCurve3.call(this, points);
	  this.type = "catmullrom";
	}
	Spline.prototype = Object.create(CatmullRomCurve3.prototype);
	Object.assign(Spline.prototype, {
	  initFromArray: function () {
	    console.error("THREE.Spline: .initFromArray() has been removed.");
	  },
	  getControlPointsArray: function () {
	    console.error("THREE.Spline: .getControlPointsArray() has been removed.");
	  },
	  reparametrizeByArcLength: function () {
	    console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.");
	  }
	});
	function AxisHelper(size) {
	  console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper.");
	  return new AxesHelper(size);
	}
	function BoundingBoxHelper(object, color) {
	  console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.");
	  return new BoxHelper(object, color);
	}
	function EdgesHelper(object, hex) {
	  console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.");
	  return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({
	    color: hex !== undefined ? hex : 16777215
	  }));
	}
	GridHelper.prototype.setColors = function () {
	  console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.");
	};
	SkeletonHelper.prototype.update = function () {
	  console.error("THREE.SkeletonHelper: update() no longer needs to be called.");
	};
	function WireframeHelper(object, hex) {
	  console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.");
	  return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({
	    color: hex !== undefined ? hex : 16777215
	  }));
	}
	Object.assign(Loader.prototype, {
	  extractUrlBase: function (url) {
	    console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.");
	    return LoaderUtils.extractUrlBase(url);
	  }
	});
	Loader.Handlers = {
	  add: function () {
	    console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.");
	  },
	  get: function () {
	    console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.");
	  }
	};
	function XHRLoader(manager) {
	  console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader.");
	  return new FileLoader(manager);
	}
	function BinaryTextureLoader(manager) {
	  console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.");
	  return new DataTextureLoader(manager);
	}
	Object.assign(ObjectLoader.prototype, {
	  setTexturePath: function (value) {
	    console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().");
	    return this.setResourcePath(value);
	  }
	});
	Object.assign(Box2.prototype, {
	  center: function (optionalTarget) {
	    console.warn("THREE.Box2: .center() has been renamed to .getCenter().");
	    return this.getCenter(optionalTarget);
	  },
	  empty: function () {
	    console.warn("THREE.Box2: .empty() has been renamed to .isEmpty().");
	    return this.isEmpty();
	  },
	  isIntersectionBox: function (box) {
	    console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().");
	    return this.intersectsBox(box);
	  },
	  size: function (optionalTarget) {
	    console.warn("THREE.Box2: .size() has been renamed to .getSize().");
	    return this.getSize(optionalTarget);
	  }
	});
	Object.assign(Box3.prototype, {
	  center: function (optionalTarget) {
	    console.warn("THREE.Box3: .center() has been renamed to .getCenter().");
	    return this.getCenter(optionalTarget);
	  },
	  empty: function () {
	    console.warn("THREE.Box3: .empty() has been renamed to .isEmpty().");
	    return this.isEmpty();
	  },
	  isIntersectionBox: function (box) {
	    console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().");
	    return this.intersectsBox(box);
	  },
	  isIntersectionSphere: function (sphere) {
	    console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().");
	    return this.intersectsSphere(sphere);
	  },
	  size: function (optionalTarget) {
	    console.warn("THREE.Box3: .size() has been renamed to .getSize().");
	    return this.getSize(optionalTarget);
	  }
	});
	Frustum.prototype.setFromMatrix = function (m) {
	  console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().");
	  return this.setFromProjectionMatrix(m);
	};
	Line3.prototype.center = function (optionalTarget) {
	  console.warn("THREE.Line3: .center() has been renamed to .getCenter().");
	  return this.getCenter(optionalTarget);
	};
	Object.assign(MathUtils, {
	  random16: function () {
	    console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead.");
	    return Math.random();
	  },
	  nearestPowerOfTwo: function (value) {
	    console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().");
	    return MathUtils.floorPowerOfTwo(value);
	  },
	  nextPowerOfTwo: function (value) {
	    console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().");
	    return MathUtils.ceilPowerOfTwo(value);
	  }
	});
	Object.assign(Matrix3.prototype, {
	  flattenToArrayOffset: function (array, offset) {
	    console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
	    return this.toArray(array, offset);
	  },
	  multiplyVector3: function (vector) {
	    console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
	    return vector.applyMatrix3(this);
	  },
	  multiplyVector3Array: function () {
	    console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.");
	  },
	  applyToBufferAttribute: function (attribute) {
	    console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.");
	    return attribute.applyMatrix3(this);
	  },
	  applyToVector3Array: function () {
	    console.error("THREE.Matrix3: .applyToVector3Array() has been removed.");
	  }
	});
	Object.assign(Matrix4.prototype, {
	  extractPosition: function (m) {
	    console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().");
	    return this.copyPosition(m);
	  },
	  flattenToArrayOffset: function (array, offset) {
	    console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.");
	    return this.toArray(array, offset);
	  },
	  getPosition: function () {
	    console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
	    return new Vector3().setFromMatrixColumn(this, 3);
	  },
	  setRotationFromQuaternion: function (q) {
	    console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().");
	    return this.makeRotationFromQuaternion(q);
	  },
	  multiplyToArray: function () {
	    console.warn("THREE.Matrix4: .multiplyToArray() has been removed.");
	  },
	  multiplyVector3: function (vector) {
	    console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.");
	    return vector.applyMatrix4(this);
	  },
	  multiplyVector4: function (vector) {
	    console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
	    return vector.applyMatrix4(this);
	  },
	  multiplyVector3Array: function () {
	    console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.");
	  },
	  rotateAxis: function (v) {
	    console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
	    v.transformDirection(this);
	  },
	  crossVector: function (vector) {
	    console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
	    return vector.applyMatrix4(this);
	  },
	  translate: function () {
	    console.error("THREE.Matrix4: .translate() has been removed.");
	  },
	  rotateX: function () {
	    console.error("THREE.Matrix4: .rotateX() has been removed.");
	  },
	  rotateY: function () {
	    console.error("THREE.Matrix4: .rotateY() has been removed.");
	  },
	  rotateZ: function () {
	    console.error("THREE.Matrix4: .rotateZ() has been removed.");
	  },
	  rotateByAxis: function () {
	    console.error("THREE.Matrix4: .rotateByAxis() has been removed.");
	  },
	  applyToBufferAttribute: function (attribute) {
	    console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.");
	    return attribute.applyMatrix4(this);
	  },
	  applyToVector3Array: function () {
	    console.error("THREE.Matrix4: .applyToVector3Array() has been removed.");
	  },
	  makeFrustum: function (left, right, bottom, top, near, far) {
	    console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.");
	    return this.makePerspective(left, right, top, bottom, near, far);
	  }
	});
	Plane.prototype.isIntersectionLine = function (line) {
	  console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().");
	  return this.intersectsLine(line);
	};
	Quaternion.prototype.multiplyVector3 = function (vector) {
	  console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
	  return vector.applyQuaternion(this);
	};
	Object.assign(Ray.prototype, {
	  isIntersectionBox: function (box) {
	    console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().");
	    return this.intersectsBox(box);
	  },
	  isIntersectionPlane: function (plane) {
	    console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().");
	    return this.intersectsPlane(plane);
	  },
	  isIntersectionSphere: function (sphere) {
	    console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().");
	    return this.intersectsSphere(sphere);
	  }
	});
	Object.assign(Triangle.prototype, {
	  area: function () {
	    console.warn("THREE.Triangle: .area() has been renamed to .getArea().");
	    return this.getArea();
	  },
	  barycoordFromPoint: function (point, target) {
	    console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
	    return this.getBarycoord(point, target);
	  },
	  midpoint: function (target) {
	    console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint().");
	    return this.getMidpoint(target);
	  },
	  normal: function (target) {
	    console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
	    return this.getNormal(target);
	  },
	  plane: function (target) {
	    console.warn("THREE.Triangle: .plane() has been renamed to .getPlane().");
	    return this.getPlane(target);
	  }
	});
	Object.assign(Triangle, {
	  barycoordFromPoint: function (point, a, b, c, target) {
	    console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().");
	    return Triangle.getBarycoord(point, a, b, c, target);
	  },
	  normal: function (a, b, c, target) {
	    console.warn("THREE.Triangle: .normal() has been renamed to .getNormal().");
	    return Triangle.getNormal(a, b, c, target);
	  }
	});
	Object.assign(Shape.prototype, {
	  extractAllPoints: function (divisions) {
	    console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.");
	    return this.extractPoints(divisions);
	  },
	  extrude: function (options) {
	    console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.");
	    return new ExtrudeGeometry(this, options);
	  },
	  makeGeometry: function (options) {
	    console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.");
	    return new ShapeGeometry(this, options);
	  }
	});
	Object.assign(Vector2.prototype, {
	  fromAttribute: function (attribute, index, offset) {
	    console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().");
	    return this.fromBufferAttribute(attribute, index, offset);
	  },
	  distanceToManhattan: function (v) {
	    console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
	    return this.manhattanDistanceTo(v);
	  },
	  lengthManhattan: function () {
	    console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().");
	    return this.manhattanLength();
	  }
	});
	Object.assign(Vector3.prototype, {
	  setEulerFromRotationMatrix: function () {
	    console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.");
	  },
	  setEulerFromQuaternion: function () {
	    console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.");
	  },
	  getPositionFromMatrix: function (m) {
	    console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().");
	    return this.setFromMatrixPosition(m);
	  },
	  getScaleFromMatrix: function (m) {
	    console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().");
	    return this.setFromMatrixScale(m);
	  },
	  getColumnFromMatrix: function (index, matrix) {
	    console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().");
	    return this.setFromMatrixColumn(matrix, index);
	  },
	  applyProjection: function (m) {
	    console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.");
	    return this.applyMatrix4(m);
	  },
	  fromAttribute: function (attribute, index, offset) {
	    console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().");
	    return this.fromBufferAttribute(attribute, index, offset);
	  },
	  distanceToManhattan: function (v) {
	    console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().");
	    return this.manhattanDistanceTo(v);
	  },
	  lengthManhattan: function () {
	    console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().");
	    return this.manhattanLength();
	  }
	});
	Object.assign(Vector4.prototype, {
	  fromAttribute: function (attribute, index, offset) {
	    console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().");
	    return this.fromBufferAttribute(attribute, index, offset);
	  },
	  lengthManhattan: function () {
	    console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().");
	    return this.manhattanLength();
	  }
	});
	Object.assign(Geometry.prototype, {
	  computeTangents: function () {
	    console.error("THREE.Geometry: .computeTangents() has been removed.");
	  },
	  computeLineDistances: function () {
	    console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.");
	  },
	  applyMatrix: function (matrix) {
	    console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().");
	    return this.applyMatrix4(matrix);
	  }
	});
	Object.assign(Object3D.prototype, {
	  getChildByName: function (name) {
	    console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().");
	    return this.getObjectByName(name);
	  },
	  renderDepth: function () {
	    console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.");
	  },
	  translate: function (distance, axis) {
	    console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.");
	    return this.translateOnAxis(axis, distance);
	  },
	  getWorldRotation: function () {
	    console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.");
	  },
	  applyMatrix: function (matrix) {
	    console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().");
	    return this.applyMatrix4(matrix);
	  }
	});
	Object.defineProperties(Object3D.prototype, {
	  eulerOrder: {
	    get: function () {
	      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
	      return this.rotation.order;
	    },
	    set: function (value) {
	      console.warn("THREE.Object3D: .eulerOrder is now .rotation.order.");
	      this.rotation.order = value;
	    }
	  },
	  useQuaternion: {
	    get: function () {
	      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
	    },
	    set: function () {
	      console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.");
	    }
	  }
	});
	Object.assign(Mesh.prototype, {
	  setDrawMode: function () {
	    console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
	  }
	});
	Object.defineProperties(Mesh.prototype, {
	  drawMode: {
	    get: function () {
	      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.");
	      return TrianglesDrawMode;
	    },
	    set: function () {
	      console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.");
	    }
	  }
	});
	Object.defineProperties(LOD.prototype, {
	  objects: {
	    get: function () {
	      console.warn("THREE.LOD: .objects has been renamed to .levels.");
	      return this.levels;
	    }
	  }
	});
	Object.defineProperty(Skeleton.prototype, "useVertexTexture", {
	  get: function () {
	    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
	  },
	  set: function () {
	    console.warn("THREE.Skeleton: useVertexTexture has been removed.");
	  }
	});
	SkinnedMesh.prototype.initBones = function () {
	  console.error("THREE.SkinnedMesh: initBones() has been removed.");
	};
	Object.defineProperty(Curve.prototype, "__arcLengthDivisions", {
	  get: function () {
	    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
	    return this.arcLengthDivisions;
	  },
	  set: function (value) {
	    console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.");
	    this.arcLengthDivisions = value;
	  }
	});
	PerspectiveCamera.prototype.setLens = function (focalLength, filmGauge) {
	  console.warn("THREE.PerspectiveCamera.setLens is deprecated. " + "Use .setFocalLength and .filmGauge for a photographic setup.");
	  if (filmGauge !== undefined) this.filmGauge = filmGauge;
	  this.setFocalLength(focalLength);
	};
	Object.defineProperties(Light.prototype, {
	  onlyShadow: {
	    set: function () {
	      console.warn("THREE.Light: .onlyShadow has been removed.");
	    }
	  },
	  shadowCameraFov: {
	    set: function (value) {
	      console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov.");
	      this.shadow.camera.fov = value;
	    }
	  },
	  shadowCameraLeft: {
	    set: function (value) {
	      console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left.");
	      this.shadow.camera.left = value;
	    }
	  },
	  shadowCameraRight: {
	    set: function (value) {
	      console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right.");
	      this.shadow.camera.right = value;
	    }
	  },
	  shadowCameraTop: {
	    set: function (value) {
	      console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top.");
	      this.shadow.camera.top = value;
	    }
	  },
	  shadowCameraBottom: {
	    set: function (value) {
	      console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.");
	      this.shadow.camera.bottom = value;
	    }
	  },
	  shadowCameraNear: {
	    set: function (value) {
	      console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near.");
	      this.shadow.camera.near = value;
	    }
	  },
	  shadowCameraFar: {
	    set: function (value) {
	      console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far.");
	      this.shadow.camera.far = value;
	    }
	  },
	  shadowCameraVisible: {
	    set: function () {
	      console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.");
	    }
	  },
	  shadowBias: {
	    set: function (value) {
	      console.warn("THREE.Light: .shadowBias is now .shadow.bias.");
	      this.shadow.bias = value;
	    }
	  },
	  shadowDarkness: {
	    set: function () {
	      console.warn("THREE.Light: .shadowDarkness has been removed.");
	    }
	  },
	  shadowMapWidth: {
	    set: function (value) {
	      console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.");
	      this.shadow.mapSize.width = value;
	    }
	  },
	  shadowMapHeight: {
	    set: function (value) {
	      console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.");
	      this.shadow.mapSize.height = value;
	    }
	  }
	});
	Object.defineProperties(BufferAttribute.prototype, {
	  length: {
	    get: function () {
	      console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead.");
	      return this.array.length;
	    }
	  },
	  dynamic: {
	    get: function () {
	      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
	      return this.usage === DynamicDrawUsage;
	    },
	    set: function () {
	      console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.");
	      this.setUsage(DynamicDrawUsage);
	    }
	  }
	});
	Object.assign(BufferAttribute.prototype, {
	  setDynamic: function (value) {
	    console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.");
	    this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
	    return this;
	  },
	  copyIndicesArray: function () {
	    console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.");
	  },
	  setArray: function () {
	    console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
	  }
	});
	Object.assign(BufferGeometry.prototype, {
	  addIndex: function (index) {
	    console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().");
	    this.setIndex(index);
	  },
	  addAttribute: function (name, attribute) {
	    console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().");
	    if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {
	      console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).");
	      return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));
	    }
	    if (name === "index") {
	      console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.");
	      this.setIndex(attribute);
	      return this;
	    }
	    return this.setAttribute(name, attribute);
	  },
	  addDrawCall: function (start, count, indexOffset) {
	    if (indexOffset !== undefined) {
	      console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.");
	    }
	    console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup().");
	    this.addGroup(start, count);
	  },
	  clearDrawCalls: function () {
	    console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().");
	    this.clearGroups();
	  },
	  computeTangents: function () {
	    console.warn("THREE.BufferGeometry: .computeTangents() has been removed.");
	  },
	  computeOffsets: function () {
	    console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.");
	  },
	  removeAttribute: function (name) {
	    console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().");
	    return this.deleteAttribute(name);
	  },
	  applyMatrix: function (matrix) {
	    console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().");
	    return this.applyMatrix4(matrix);
	  }
	});
	Object.defineProperties(BufferGeometry.prototype, {
	  drawcalls: {
	    get: function () {
	      console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups.");
	      return this.groups;
	    }
	  },
	  offsets: {
	    get: function () {
	      console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups.");
	      return this.groups;
	    }
	  }
	});
	Object.defineProperties(Raycaster.prototype, {
	  linePrecision: {
	    get: function () {
	      console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.");
	      return this.params.Line.threshold;
	    },
	    set: function (value) {
	      console.warn("THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.");
	      this.params.Line.threshold = value;
	    }
	  }
	});
	Object.defineProperties(InterleavedBuffer.prototype, {
	  dynamic: {
	    get: function () {
	      console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.");
	      return this.usage === DynamicDrawUsage;
	    },
	    set: function (value) {
	      console.warn("THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.");
	      this.setUsage(value);
	    }
	  }
	});
	Object.assign(InterleavedBuffer.prototype, {
	  setDynamic: function (value) {
	    console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.");
	    this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);
	    return this;
	  },
	  setArray: function () {
	    console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers");
	  }
	});
	Object.assign(ExtrudeBufferGeometry.prototype, {
	  getArrays: function () {
	    console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.");
	  },
	  addShapeList: function () {
	    console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.");
	  },
	  addShape: function () {
	    console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.");
	  }
	});
	Object.defineProperties(Uniform.prototype, {
	  dynamic: {
	    set: function () {
	      console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.");
	    }
	  },
	  onUpdate: {
	    value: function () {
	      console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.");
	      return this;
	    }
	  }
	});
	Object.defineProperties(Material.prototype, {
	  wrapAround: {
	    get: function () {
	      console.warn("THREE.Material: .wrapAround has been removed.");
	    },
	    set: function () {
	      console.warn("THREE.Material: .wrapAround has been removed.");
	    }
	  },
	  overdraw: {
	    get: function () {
	      console.warn("THREE.Material: .overdraw has been removed.");
	    },
	    set: function () {
	      console.warn("THREE.Material: .overdraw has been removed.");
	    }
	  },
	  wrapRGB: {
	    get: function () {
	      console.warn("THREE.Material: .wrapRGB has been removed.");
	      return new Color();
	    }
	  },
	  shading: {
	    get: function () {
	      console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
	    },
	    set: function (value) {
	      console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.");
	      this.flatShading = value === FlatShading;
	    }
	  },
	  stencilMask: {
	    get: function () {
	      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
	      return this.stencilFuncMask;
	    },
	    set: function (value) {
	      console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead.");
	      this.stencilFuncMask = value;
	    }
	  }
	});
	Object.defineProperties(MeshPhongMaterial.prototype, {
	  metal: {
	    get: function () {
	      console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.");
	      return false;
	    },
	    set: function () {
	      console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead");
	    }
	  }
	});
	Object.defineProperties(ShaderMaterial.prototype, {
	  derivatives: {
	    get: function () {
	      console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
	      return this.extensions.derivatives;
	    },
	    set: function (value) {
	      console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.");
	      this.extensions.derivatives = value;
	    }
	  }
	});
	Object.assign(WebGLRenderer.prototype, {
	  clearTarget: function (renderTarget, color, depth, stencil) {
	    console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.");
	    this.setRenderTarget(renderTarget);
	    this.clear(color, depth, stencil);
	  },
	  animate: function (callback) {
	    console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop().");
	    this.setAnimationLoop(callback);
	  },
	  getCurrentRenderTarget: function () {
	    console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().");
	    return this.getRenderTarget();
	  },
	  getMaxAnisotropy: function () {
	    console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().");
	    return this.capabilities.getMaxAnisotropy();
	  },
	  getPrecision: function () {
	    console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.");
	    return this.capabilities.precision;
	  },
	  resetGLState: function () {
	    console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset().");
	    return this.state.reset();
	  },
	  supportsFloatTextures: function () {
	    console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).");
	    return this.extensions.get("OES_texture_float");
	  },
	  supportsHalfFloatTextures: function () {
	    console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).");
	    return this.extensions.get("OES_texture_half_float");
	  },
	  supportsStandardDerivatives: function () {
	    console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).");
	    return this.extensions.get("OES_standard_derivatives");
	  },
	  supportsCompressedTextureS3TC: function () {
	    console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).");
	    return this.extensions.get("WEBGL_compressed_texture_s3tc");
	  },
	  supportsCompressedTexturePVRTC: function () {
	    console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).");
	    return this.extensions.get("WEBGL_compressed_texture_pvrtc");
	  },
	  supportsBlendMinMax: function () {
	    console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).");
	    return this.extensions.get("EXT_blend_minmax");
	  },
	  supportsVertexTextures: function () {
	    console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.");
	    return this.capabilities.vertexTextures;
	  },
	  supportsInstancedArrays: function () {
	    console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).");
	    return this.extensions.get("ANGLE_instanced_arrays");
	  },
	  enableScissorTest: function (boolean) {
	    console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().");
	    this.setScissorTest(boolean);
	  },
	  initMaterial: function () {
	    console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.");
	  },
	  addPrePlugin: function () {
	    console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.");
	  },
	  addPostPlugin: function () {
	    console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.");
	  },
	  updateShadowMap: function () {
	    console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.");
	  },
	  setFaceCulling: function () {
	    console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.");
	  },
	  allocTextureUnit: function () {
	    console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.");
	  },
	  setTexture: function () {
	    console.warn("THREE.WebGLRenderer: .setTexture() has been removed.");
	  },
	  setTexture2D: function () {
	    console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.");
	  },
	  setTextureCube: function () {
	    console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.");
	  },
	  getActiveMipMapLevel: function () {
	    console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().");
	    return this.getActiveMipmapLevel();
	  }
	});
	Object.defineProperties(WebGLRenderer.prototype, {
	  shadowMapEnabled: {
	    get: function () {
	      return this.shadowMap.enabled;
	    },
	    set: function (value) {
	      console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.");
	      this.shadowMap.enabled = value;
	    }
	  },
	  shadowMapType: {
	    get: function () {
	      return this.shadowMap.type;
	    },
	    set: function (value) {
	      console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.");
	      this.shadowMap.type = value;
	    }
	  },
	  shadowMapCullFace: {
	    get: function () {
	      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
	      return undefined;
	    },
	    set: function () {
	      console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.");
	    }
	  },
	  context: {
	    get: function () {
	      console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.");
	      return this.getContext();
	    }
	  },
	  vr: {
	    get: function () {
	      console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr");
	      return this.xr;
	    }
	  },
	  gammaInput: {
	    get: function () {
	      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
	      return false;
	    },
	    set: function () {
	      console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.");
	    }
	  },
	  gammaOutput: {
	    get: function () {
	      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
	      return false;
	    },
	    set: function (value) {
	      console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.");
	      this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;
	    }
	  }
	});
	Object.defineProperties(WebGLShadowMap.prototype, {
	  cullFace: {
	    get: function () {
	      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
	      return undefined;
	    },
	    set: function () {
	      console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.");
	    }
	  },
	  renderReverseSided: {
	    get: function () {
	      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
	      return undefined;
	    },
	    set: function () {
	      console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.");
	    }
	  },
	  renderSingleSided: {
	    get: function () {
	      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
	      return undefined;
	    },
	    set: function () {
	      console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.");
	    }
	  }
	});
	function WebGLRenderTargetCube(width, height, options) {
	  console.warn("THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).");
	  return new WebGLCubeRenderTarget(width, options);
	}
	Object.defineProperties(WebGLRenderTarget.prototype, {
	  wrapS: {
	    get: function () {
	      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
	      return this.texture.wrapS;
	    },
	    set: function (value) {
	      console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.");
	      this.texture.wrapS = value;
	    }
	  },
	  wrapT: {
	    get: function () {
	      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
	      return this.texture.wrapT;
	    },
	    set: function (value) {
	      console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.");
	      this.texture.wrapT = value;
	    }
	  },
	  magFilter: {
	    get: function () {
	      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
	      return this.texture.magFilter;
	    },
	    set: function (value) {
	      console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.");
	      this.texture.magFilter = value;
	    }
	  },
	  minFilter: {
	    get: function () {
	      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
	      return this.texture.minFilter;
	    },
	    set: function (value) {
	      console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.");
	      this.texture.minFilter = value;
	    }
	  },
	  anisotropy: {
	    get: function () {
	      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
	      return this.texture.anisotropy;
	    },
	    set: function (value) {
	      console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.");
	      this.texture.anisotropy = value;
	    }
	  },
	  offset: {
	    get: function () {
	      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
	      return this.texture.offset;
	    },
	    set: function (value) {
	      console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset.");
	      this.texture.offset = value;
	    }
	  },
	  repeat: {
	    get: function () {
	      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
	      return this.texture.repeat;
	    },
	    set: function (value) {
	      console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat.");
	      this.texture.repeat = value;
	    }
	  },
	  format: {
	    get: function () {
	      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
	      return this.texture.format;
	    },
	    set: function (value) {
	      console.warn("THREE.WebGLRenderTarget: .format is now .texture.format.");
	      this.texture.format = value;
	    }
	  },
	  type: {
	    get: function () {
	      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
	      return this.texture.type;
	    },
	    set: function (value) {
	      console.warn("THREE.WebGLRenderTarget: .type is now .texture.type.");
	      this.texture.type = value;
	    }
	  },
	  generateMipmaps: {
	    get: function () {
	      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
	      return this.texture.generateMipmaps;
	    },
	    set: function (value) {
	      console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.");
	      this.texture.generateMipmaps = value;
	    }
	  }
	});
	Object.defineProperties(Audio.prototype, {
	  load: {
	    value: function (file) {
	      console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
	      var scope = this;
	      var audioLoader = new AudioLoader();
	      audioLoader.load(file, function (buffer) {
	        scope.setBuffer(buffer);
	      });
	      return this;
	    }
	  },
	  startTime: {
	    set: function () {
	      console.warn("THREE.Audio: .startTime is now .play( delay ).");
	    }
	  }
	});
	AudioAnalyser.prototype.getData = function () {
	  console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData().");
	  return this.getFrequencyData();
	};
	CubeCamera.prototype.updateCubeMap = function (renderer, scene) {
	  console.warn("THREE.CubeCamera: .updateCubeMap() is now .update().");
	  return this.update(renderer, scene);
	};
	var GeometryUtils = {
	  merge: function (geometry1, geometry2, materialIndexOffset) {
	    console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
	    var matrix;
	    if (geometry2.isMesh) {
	      geometry2.matrixAutoUpdate && geometry2.updateMatrix();
	      matrix = geometry2.matrix;
	      geometry2 = geometry2.geometry;
	    }
	    geometry1.merge(geometry2, matrix, materialIndexOffset);
	  },
	  center: function (geometry) {
	    console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.");
	    return geometry.center();
	  }
	};
	ImageUtils.crossOrigin = undefined;
	ImageUtils.loadTexture = function (url, mapping, onLoad, onError) {
	  console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
	  var loader = new TextureLoader();
	  loader.setCrossOrigin(this.crossOrigin);
	  var texture = loader.load(url, onLoad, undefined, onError);
	  if (mapping) texture.mapping = mapping;
	  return texture;
	};
	ImageUtils.loadTextureCube = function (urls, mapping, onLoad, onError) {
	  console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
	  var loader = new CubeTextureLoader();
	  loader.setCrossOrigin(this.crossOrigin);
	  var texture = loader.load(urls, onLoad, undefined, onError);
	  if (mapping) texture.mapping = mapping;
	  return texture;
	};
	ImageUtils.loadCompressedTexture = function () {
	  console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.");
	};
	ImageUtils.loadCompressedTextureCube = function () {
	  console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.");
	};
	function CanvasRenderer() {
	  console.error("THREE.CanvasRenderer has been removed");
	}
	function JSONLoader() {
	  console.error("THREE.JSONLoader has been removed.");
	}
	var SceneUtils = {
	  createMultiMaterialObject: function () {
	    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
	  },
	  detach: function () {
	    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
	  },
	  attach: function () {
	    console.error("THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js");
	  }
	};
	function LensFlare() {
	  console.error("THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js");
	}
	if (typeof __THREE_DEVTOOLS__ !== "undefined") {
	  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
	    detail: {
	      revision: REVISION
	    }
	  }));
	}

	var three = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ACESFilmicToneMapping: ACESFilmicToneMapping,
		AddEquation: AddEquation,
		AddOperation: AddOperation,
		AdditiveBlending: AdditiveBlending,
		AlphaFormat: AlphaFormat,
		AlwaysDepth: AlwaysDepth,
		AlwaysStencilFunc: AlwaysStencilFunc,
		AmbientLight: AmbientLight,
		AmbientLightProbe: AmbientLightProbe,
		AnimationClip: AnimationClip,
		AnimationLoader: AnimationLoader,
		AnimationMixer: AnimationMixer,
		AnimationObjectGroup: AnimationObjectGroup,
		AnimationUtils: AnimationUtils,
		ArcCurve: ArcCurve,
		ArrayCamera: ArrayCamera,
		ArrowHelper: ArrowHelper,
		Audio: Audio,
		AudioAnalyser: AudioAnalyser,
		AudioContext: AudioContext,
		AudioListener: AudioListener,
		AudioLoader: AudioLoader,
		AxesHelper: AxesHelper,
		AxisHelper: AxisHelper,
		BackSide: BackSide,
		BasicDepthPacking: BasicDepthPacking,
		BasicShadowMap: BasicShadowMap,
		BinaryTextureLoader: BinaryTextureLoader,
		Bone: Bone,
		BooleanKeyframeTrack: BooleanKeyframeTrack,
		BoundingBoxHelper: BoundingBoxHelper,
		Box2: Box2,
		Box3: Box3,
		Box3Helper: Box3Helper,
		BoxBufferGeometry: BoxBufferGeometry,
		BoxGeometry: BoxGeometry,
		BoxHelper: BoxHelper,
		BufferAttribute: BufferAttribute,
		BufferGeometry: BufferGeometry,
		BufferGeometryLoader: BufferGeometryLoader,
		ByteType: ByteType,
		Cache: Cache,
		Camera: Camera,
		CameraHelper: CameraHelper,
		CanvasRenderer: CanvasRenderer,
		CanvasTexture: CanvasTexture,
		CatmullRomCurve3: CatmullRomCurve3,
		CineonToneMapping: CineonToneMapping,
		CircleBufferGeometry: CircleBufferGeometry,
		CircleGeometry: CircleGeometry,
		ClampToEdgeWrapping: ClampToEdgeWrapping,
		Clock: Clock,
		ClosedSplineCurve3: ClosedSplineCurve3,
		Color: Color,
		ColorKeyframeTrack: ColorKeyframeTrack,
		CompressedTexture: CompressedTexture,
		CompressedTextureLoader: CompressedTextureLoader,
		ConeBufferGeometry: ConeBufferGeometry,
		ConeGeometry: ConeGeometry,
		CubeCamera: CubeCamera,
		CubeGeometry: BoxGeometry,
		CubeReflectionMapping: CubeReflectionMapping,
		CubeRefractionMapping: CubeRefractionMapping,
		CubeTexture: CubeTexture,
		CubeTextureLoader: CubeTextureLoader,
		CubeUVReflectionMapping: CubeUVReflectionMapping,
		CubeUVRefractionMapping: CubeUVRefractionMapping,
		CubicBezierCurve: CubicBezierCurve,
		CubicBezierCurve3: CubicBezierCurve3,
		CubicInterpolant: CubicInterpolant,
		CullFaceBack: CullFaceBack,
		CullFaceFront: CullFaceFront,
		CullFaceFrontBack: CullFaceFrontBack,
		CullFaceNone: CullFaceNone,
		Curve: Curve,
		CurvePath: CurvePath,
		CustomBlending: CustomBlending,
		CylinderBufferGeometry: CylinderBufferGeometry,
		CylinderGeometry: CylinderGeometry,
		Cylindrical: Cylindrical,
		DataTexture: DataTexture,
		DataTexture2DArray: DataTexture2DArray,
		DataTexture3D: DataTexture3D,
		DataTextureLoader: DataTextureLoader,
		DecrementStencilOp: DecrementStencilOp,
		DecrementWrapStencilOp: DecrementWrapStencilOp,
		DefaultLoadingManager: DefaultLoadingManager,
		DepthFormat: DepthFormat,
		DepthStencilFormat: DepthStencilFormat,
		DepthTexture: DepthTexture,
		DirectionalLight: DirectionalLight,
		DirectionalLightHelper: DirectionalLightHelper,
		DirectionalLightShadow: DirectionalLightShadow,
		DiscreteInterpolant: DiscreteInterpolant,
		DodecahedronBufferGeometry: DodecahedronBufferGeometry,
		DodecahedronGeometry: DodecahedronGeometry,
		DoubleSide: DoubleSide,
		DstAlphaFactor: DstAlphaFactor,
		DstColorFactor: DstColorFactor,
		DynamicBufferAttribute: DynamicBufferAttribute,
		DynamicCopyUsage: DynamicCopyUsage,
		DynamicDrawUsage: DynamicDrawUsage,
		DynamicReadUsage: DynamicReadUsage,
		EdgesGeometry: EdgesGeometry,
		EdgesHelper: EdgesHelper,
		EllipseCurve: EllipseCurve,
		EqualDepth: EqualDepth,
		EqualStencilFunc: EqualStencilFunc,
		EquirectangularReflectionMapping: EquirectangularReflectionMapping,
		EquirectangularRefractionMapping: EquirectangularRefractionMapping,
		Euler: Euler,
		EventDispatcher: EventDispatcher,
		ExtrudeBufferGeometry: ExtrudeBufferGeometry,
		ExtrudeGeometry: ExtrudeGeometry,
		Face3: Face3,
		Face4: Face4,
		FaceColors: FaceColors,
		FileLoader: FileLoader,
		FlatShading: FlatShading,
		Float32Attribute: Float32Attribute,
		Float32BufferAttribute: Float32BufferAttribute,
		Float64Attribute: Float64Attribute,
		Float64BufferAttribute: Float64BufferAttribute,
		FloatType: FloatType,
		Fog: Fog,
		FogExp2: FogExp2,
		Font: Font,
		FontLoader: FontLoader,
		FrontFaceDirectionCCW: FrontFaceDirectionCCW,
		FrontFaceDirectionCW: FrontFaceDirectionCW,
		FrontSide: FrontSide,
		Frustum: Frustum,
		GammaEncoding: GammaEncoding,
		Geometry: Geometry,
		GeometryUtils: GeometryUtils,
		GreaterDepth: GreaterDepth,
		GreaterEqualDepth: GreaterEqualDepth,
		GreaterEqualStencilFunc: GreaterEqualStencilFunc,
		GreaterStencilFunc: GreaterStencilFunc,
		GridHelper: GridHelper,
		Group: Group,
		HalfFloatType: HalfFloatType,
		HemisphereLight: HemisphereLight,
		HemisphereLightHelper: HemisphereLightHelper,
		HemisphereLightProbe: HemisphereLightProbe,
		IcosahedronBufferGeometry: IcosahedronBufferGeometry,
		IcosahedronGeometry: IcosahedronGeometry,
		ImageBitmapLoader: ImageBitmapLoader,
		ImageLoader: ImageLoader,
		ImageUtils: ImageUtils,
		ImmediateRenderObject: ImmediateRenderObject,
		IncrementStencilOp: IncrementStencilOp,
		IncrementWrapStencilOp: IncrementWrapStencilOp,
		InstancedBufferAttribute: InstancedBufferAttribute,
		InstancedBufferGeometry: InstancedBufferGeometry,
		InstancedInterleavedBuffer: InstancedInterleavedBuffer,
		InstancedMesh: InstancedMesh,
		Int16Attribute: Int16Attribute,
		Int16BufferAttribute: Int16BufferAttribute,
		Int32Attribute: Int32Attribute,
		Int32BufferAttribute: Int32BufferAttribute,
		Int8Attribute: Int8Attribute,
		Int8BufferAttribute: Int8BufferAttribute,
		IntType: IntType,
		InterleavedBuffer: InterleavedBuffer,
		InterleavedBufferAttribute: InterleavedBufferAttribute,
		Interpolant: Interpolant,
		InterpolateDiscrete: InterpolateDiscrete,
		InterpolateLinear: InterpolateLinear,
		InterpolateSmooth: InterpolateSmooth,
		InvertStencilOp: InvertStencilOp,
		JSONLoader: JSONLoader,
		KeepStencilOp: KeepStencilOp,
		KeyframeTrack: KeyframeTrack,
		LOD: LOD,
		LatheBufferGeometry: LatheBufferGeometry,
		LatheGeometry: LatheGeometry,
		Layers: Layers,
		LensFlare: LensFlare,
		LessDepth: LessDepth,
		LessEqualDepth: LessEqualDepth,
		LessEqualStencilFunc: LessEqualStencilFunc,
		LessStencilFunc: LessStencilFunc,
		Light: Light,
		LightProbe: LightProbe,
		LightShadow: LightShadow,
		Line: Line,
		Line3: Line3,
		LineBasicMaterial: LineBasicMaterial,
		LineCurve: LineCurve,
		LineCurve3: LineCurve3,
		LineDashedMaterial: LineDashedMaterial,
		LineLoop: LineLoop,
		LinePieces: LinePieces,
		LineSegments: LineSegments,
		LineStrip: LineStrip,
		LinearEncoding: LinearEncoding,
		LinearFilter: LinearFilter,
		LinearInterpolant: LinearInterpolant,
		LinearMipMapLinearFilter: LinearMipMapLinearFilter,
		LinearMipMapNearestFilter: LinearMipMapNearestFilter,
		LinearMipmapLinearFilter: LinearMipmapLinearFilter,
		LinearMipmapNearestFilter: LinearMipmapNearestFilter,
		LinearToneMapping: LinearToneMapping,
		Loader: Loader,
		LoaderUtils: LoaderUtils,
		LoadingManager: LoadingManager,
		LogLuvEncoding: LogLuvEncoding,
		LoopOnce: LoopOnce,
		LoopPingPong: LoopPingPong,
		LoopRepeat: LoopRepeat,
		LuminanceAlphaFormat: LuminanceAlphaFormat,
		LuminanceFormat: LuminanceFormat,
		MOUSE: MOUSE,
		Material: Material,
		MaterialLoader: MaterialLoader,
		Math: MathUtils,
		MathUtils: MathUtils,
		Matrix3: Matrix3,
		Matrix4: Matrix4,
		MaxEquation: MaxEquation,
		Mesh: Mesh,
		MeshBasicMaterial: MeshBasicMaterial,
		MeshDepthMaterial: MeshDepthMaterial,
		MeshDistanceMaterial: MeshDistanceMaterial,
		MeshFaceMaterial: MeshFaceMaterial,
		MeshLambertMaterial: MeshLambertMaterial,
		MeshMatcapMaterial: MeshMatcapMaterial,
		MeshNormalMaterial: MeshNormalMaterial,
		MeshPhongMaterial: MeshPhongMaterial,
		MeshPhysicalMaterial: MeshPhysicalMaterial,
		MeshStandardMaterial: MeshStandardMaterial,
		MeshToonMaterial: MeshToonMaterial,
		MinEquation: MinEquation,
		MirroredRepeatWrapping: MirroredRepeatWrapping,
		MixOperation: MixOperation,
		MultiMaterial: MultiMaterial,
		MultiplyBlending: MultiplyBlending,
		MultiplyOperation: MultiplyOperation,
		NearestFilter: NearestFilter,
		NearestMipMapLinearFilter: NearestMipMapLinearFilter,
		NearestMipMapNearestFilter: NearestMipMapNearestFilter,
		NearestMipmapLinearFilter: NearestMipmapLinearFilter,
		NearestMipmapNearestFilter: NearestMipmapNearestFilter,
		NeverDepth: NeverDepth,
		NeverStencilFunc: NeverStencilFunc,
		NoBlending: NoBlending,
		NoColors: NoColors,
		NoToneMapping: NoToneMapping,
		NormalBlending: NormalBlending,
		NotEqualDepth: NotEqualDepth,
		NotEqualStencilFunc: NotEqualStencilFunc,
		NumberKeyframeTrack: NumberKeyframeTrack,
		Object3D: Object3D,
		ObjectLoader: ObjectLoader,
		ObjectSpaceNormalMap: ObjectSpaceNormalMap,
		OctahedronBufferGeometry: OctahedronBufferGeometry,
		OctahedronGeometry: OctahedronGeometry,
		OneFactor: OneFactor,
		OneMinusDstAlphaFactor: OneMinusDstAlphaFactor,
		OneMinusDstColorFactor: OneMinusDstColorFactor,
		OneMinusSrcAlphaFactor: OneMinusSrcAlphaFactor,
		OneMinusSrcColorFactor: OneMinusSrcColorFactor,
		OrthographicCamera: OrthographicCamera,
		PCFShadowMap: PCFShadowMap,
		PCFSoftShadowMap: PCFSoftShadowMap,
		PMREMGenerator: PMREMGenerator,
		ParametricBufferGeometry: ParametricBufferGeometry,
		ParametricGeometry: ParametricGeometry,
		Particle: Particle,
		ParticleBasicMaterial: ParticleBasicMaterial,
		ParticleSystem: ParticleSystem,
		ParticleSystemMaterial: ParticleSystemMaterial,
		Path: Path,
		PerspectiveCamera: PerspectiveCamera,
		Plane: Plane,
		PlaneBufferGeometry: PlaneBufferGeometry,
		PlaneGeometry: PlaneGeometry,
		PlaneHelper: PlaneHelper,
		PointCloud: PointCloud,
		PointCloudMaterial: PointCloudMaterial,
		PointLight: PointLight,
		PointLightHelper: PointLightHelper,
		Points: Points,
		PointsMaterial: PointsMaterial,
		PolarGridHelper: PolarGridHelper,
		PolyhedronBufferGeometry: PolyhedronBufferGeometry,
		PolyhedronGeometry: PolyhedronGeometry,
		PositionalAudio: PositionalAudio,
		PropertyBinding: PropertyBinding,
		PropertyMixer: PropertyMixer,
		QuadraticBezierCurve: QuadraticBezierCurve,
		QuadraticBezierCurve3: QuadraticBezierCurve3,
		Quaternion: Quaternion,
		QuaternionKeyframeTrack: QuaternionKeyframeTrack,
		QuaternionLinearInterpolant: QuaternionLinearInterpolant,
		REVISION: REVISION,
		RGBADepthPacking: RGBADepthPacking,
		RGBAFormat: RGBAFormat,
		RGBAIntegerFormat: RGBAIntegerFormat,
		RGBA_ASTC_10x10_Format: RGBA_ASTC_10x10_Format,
		RGBA_ASTC_10x5_Format: RGBA_ASTC_10x5_Format,
		RGBA_ASTC_10x6_Format: RGBA_ASTC_10x6_Format,
		RGBA_ASTC_10x8_Format: RGBA_ASTC_10x8_Format,
		RGBA_ASTC_12x10_Format: RGBA_ASTC_12x10_Format,
		RGBA_ASTC_12x12_Format: RGBA_ASTC_12x12_Format,
		RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,
		RGBA_ASTC_5x4_Format: RGBA_ASTC_5x4_Format,
		RGBA_ASTC_5x5_Format: RGBA_ASTC_5x5_Format,
		RGBA_ASTC_6x5_Format: RGBA_ASTC_6x5_Format,
		RGBA_ASTC_6x6_Format: RGBA_ASTC_6x6_Format,
		RGBA_ASTC_8x5_Format: RGBA_ASTC_8x5_Format,
		RGBA_ASTC_8x6_Format: RGBA_ASTC_8x6_Format,
		RGBA_ASTC_8x8_Format: RGBA_ASTC_8x8_Format,
		RGBA_ETC2_EAC_Format: RGBA_ETC2_EAC_Format,
		RGBA_PVRTC_2BPPV1_Format: RGBA_PVRTC_2BPPV1_Format,
		RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,
		RGBA_S3TC_DXT1_Format: RGBA_S3TC_DXT1_Format,
		RGBA_S3TC_DXT3_Format: RGBA_S3TC_DXT3_Format,
		RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,
		RGBDEncoding: RGBDEncoding,
		RGBEEncoding: RGBEEncoding,
		RGBEFormat: RGBEFormat,
		RGBFormat: RGBFormat,
		RGBIntegerFormat: RGBIntegerFormat,
		RGBM16Encoding: RGBM16Encoding,
		RGBM7Encoding: RGBM7Encoding,
		RGB_ETC1_Format: RGB_ETC1_Format,
		RGB_ETC2_Format: RGB_ETC2_Format,
		RGB_PVRTC_2BPPV1_Format: RGB_PVRTC_2BPPV1_Format,
		RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,
		RGB_S3TC_DXT1_Format: RGB_S3TC_DXT1_Format,
		RGFormat: RGFormat,
		RGIntegerFormat: RGIntegerFormat,
		RawShaderMaterial: RawShaderMaterial,
		Ray: Ray,
		Raycaster: Raycaster,
		RectAreaLight: RectAreaLight,
		RedFormat: RedFormat,
		RedIntegerFormat: RedIntegerFormat,
		ReinhardToneMapping: ReinhardToneMapping,
		RepeatWrapping: RepeatWrapping,
		ReplaceStencilOp: ReplaceStencilOp,
		ReverseSubtractEquation: ReverseSubtractEquation,
		RingBufferGeometry: RingBufferGeometry,
		RingGeometry: RingGeometry,
		SRGB8_ALPHA8_ASTC_10x10_Format: SRGB8_ALPHA8_ASTC_10x10_Format,
		SRGB8_ALPHA8_ASTC_10x5_Format: SRGB8_ALPHA8_ASTC_10x5_Format,
		SRGB8_ALPHA8_ASTC_10x6_Format: SRGB8_ALPHA8_ASTC_10x6_Format,
		SRGB8_ALPHA8_ASTC_10x8_Format: SRGB8_ALPHA8_ASTC_10x8_Format,
		SRGB8_ALPHA8_ASTC_12x10_Format: SRGB8_ALPHA8_ASTC_12x10_Format,
		SRGB8_ALPHA8_ASTC_12x12_Format: SRGB8_ALPHA8_ASTC_12x12_Format,
		SRGB8_ALPHA8_ASTC_4x4_Format: SRGB8_ALPHA8_ASTC_4x4_Format,
		SRGB8_ALPHA8_ASTC_5x4_Format: SRGB8_ALPHA8_ASTC_5x4_Format,
		SRGB8_ALPHA8_ASTC_5x5_Format: SRGB8_ALPHA8_ASTC_5x5_Format,
		SRGB8_ALPHA8_ASTC_6x5_Format: SRGB8_ALPHA8_ASTC_6x5_Format,
		SRGB8_ALPHA8_ASTC_6x6_Format: SRGB8_ALPHA8_ASTC_6x6_Format,
		SRGB8_ALPHA8_ASTC_8x5_Format: SRGB8_ALPHA8_ASTC_8x5_Format,
		SRGB8_ALPHA8_ASTC_8x6_Format: SRGB8_ALPHA8_ASTC_8x6_Format,
		SRGB8_ALPHA8_ASTC_8x8_Format: SRGB8_ALPHA8_ASTC_8x8_Format,
		Scene: Scene,
		SceneUtils: SceneUtils,
		ShaderChunk: ShaderChunk,
		ShaderLib: ShaderLib,
		ShaderMaterial: ShaderMaterial,
		ShadowMaterial: ShadowMaterial,
		Shape: Shape,
		ShapeBufferGeometry: ShapeBufferGeometry,
		ShapeGeometry: ShapeGeometry,
		ShapePath: ShapePath,
		ShapeUtils: ShapeUtils,
		ShortType: ShortType,
		Skeleton: Skeleton,
		SkeletonHelper: SkeletonHelper,
		SkinnedMesh: SkinnedMesh,
		SmoothShading: SmoothShading,
		Sphere: Sphere,
		SphereBufferGeometry: SphereBufferGeometry,
		SphereGeometry: SphereGeometry,
		Spherical: Spherical,
		SphericalHarmonics3: SphericalHarmonics3,
		SphericalReflectionMapping: SphericalReflectionMapping,
		Spline: Spline,
		SplineCurve: SplineCurve,
		SplineCurve3: SplineCurve3,
		SpotLight: SpotLight,
		SpotLightHelper: SpotLightHelper,
		SpotLightShadow: SpotLightShadow,
		Sprite: Sprite,
		SpriteMaterial: SpriteMaterial,
		SrcAlphaFactor: SrcAlphaFactor,
		SrcAlphaSaturateFactor: SrcAlphaSaturateFactor,
		SrcColorFactor: SrcColorFactor,
		StaticCopyUsage: StaticCopyUsage,
		StaticDrawUsage: StaticDrawUsage,
		StaticReadUsage: StaticReadUsage,
		StereoCamera: StereoCamera,
		StreamCopyUsage: StreamCopyUsage,
		StreamDrawUsage: StreamDrawUsage,
		StreamReadUsage: StreamReadUsage,
		StringKeyframeTrack: StringKeyframeTrack,
		SubtractEquation: SubtractEquation,
		SubtractiveBlending: SubtractiveBlending,
		TOUCH: TOUCH,
		TangentSpaceNormalMap: TangentSpaceNormalMap,
		TetrahedronBufferGeometry: TetrahedronBufferGeometry,
		TetrahedronGeometry: TetrahedronGeometry,
		TextBufferGeometry: TextBufferGeometry,
		TextGeometry: TextGeometry,
		Texture: Texture,
		TextureLoader: TextureLoader,
		TorusBufferGeometry: TorusBufferGeometry,
		TorusGeometry: TorusGeometry,
		TorusKnotBufferGeometry: TorusKnotBufferGeometry,
		TorusKnotGeometry: TorusKnotGeometry,
		Triangle: Triangle,
		TriangleFanDrawMode: TriangleFanDrawMode,
		TriangleStripDrawMode: TriangleStripDrawMode,
		TrianglesDrawMode: TrianglesDrawMode,
		TubeBufferGeometry: TubeBufferGeometry,
		TubeGeometry: TubeGeometry,
		UVMapping: UVMapping,
		Uint16Attribute: Uint16Attribute,
		Uint16BufferAttribute: Uint16BufferAttribute,
		Uint32Attribute: Uint32Attribute,
		Uint32BufferAttribute: Uint32BufferAttribute,
		Uint8Attribute: Uint8Attribute,
		Uint8BufferAttribute: Uint8BufferAttribute,
		Uint8ClampedAttribute: Uint8ClampedAttribute,
		Uint8ClampedBufferAttribute: Uint8ClampedBufferAttribute,
		Uncharted2ToneMapping: Uncharted2ToneMapping,
		Uniform: Uniform,
		UniformsLib: UniformsLib,
		UniformsUtils: UniformsUtils,
		UnsignedByteType: UnsignedByteType,
		UnsignedInt248Type: UnsignedInt248Type,
		UnsignedIntType: UnsignedIntType,
		UnsignedShort4444Type: UnsignedShort4444Type,
		UnsignedShort5551Type: UnsignedShort5551Type,
		UnsignedShort565Type: UnsignedShort565Type,
		UnsignedShortType: UnsignedShortType,
		VSMShadowMap: VSMShadowMap,
		Vector2: Vector2,
		Vector3: Vector3,
		Vector4: Vector4,
		VectorKeyframeTrack: VectorKeyframeTrack,
		Vertex: Vertex,
		VertexColors: VertexColors,
		VideoTexture: VideoTexture,
		WebGLCubeRenderTarget: WebGLCubeRenderTarget,
		WebGLMultisampleRenderTarget: WebGLMultisampleRenderTarget,
		WebGLRenderTarget: WebGLRenderTarget,
		WebGLRenderTargetCube: WebGLRenderTargetCube,
		WebGLRenderer: WebGLRenderer,
		WebGLUtils: WebGLUtils,
		WireframeGeometry: WireframeGeometry,
		WireframeHelper: WireframeHelper,
		WrapAroundEnding: WrapAroundEnding,
		XHRLoader: XHRLoader,
		ZeroCurvatureEnding: ZeroCurvatureEnding,
		ZeroFactor: ZeroFactor,
		ZeroSlopeEnding: ZeroSlopeEnding,
		ZeroStencilOp: ZeroStencilOp,
		sRGBEncoding: sRGBEncoding
	});

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/** Built-in value references. */
	var Symbol$1 = root.Symbol;

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Built-in value references. */
	var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	/** Used for built-in method references. */
	var objectProto$1 = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString$1 = objectProto$1.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString$1.call(value);
	}

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag$1 && symToStringTag$1 in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	/** `Object#toString` result references. */
	var symbolTag = '[object Symbol]';

	/**
	 * Checks if `value` is classified as a `Symbol` primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	 * @example
	 *
	 * _.isSymbol(Symbol.iterator);
	 * // => true
	 *
	 * _.isSymbol('abc');
	 * // => false
	 */
	function isSymbol(value) {
	  return typeof value == 'symbol' ||
	    (isObjectLike(value) && baseGetTag(value) == symbolTag);
	}

	/** Used as references for various `Number` constants. */
	var NAN = 0 / 0;

	/**
	 * The base implementation of `_.toNumber` which doesn't ensure correct
	 * conversions of binary, hexadecimal, or octal string values.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 */
	function baseToNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return NAN;
	  }
	  return +value;
	}

	/**
	 * A specialized version of `_.map` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function arrayMap(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      result = Array(length);

	  while (++index < length) {
	    result[index] = iteratee(array[index], index, array);
	  }
	  return result;
	}

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	/** Used as references for various `Number` constants. */
	var INFINITY = 1 / 0;

	/** Used to convert symbols to primitives and strings. */
	var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
	    symbolToString = symbolProto ? symbolProto.toString : undefined;

	/**
	 * The base implementation of `_.toString` which doesn't convert nullish
	 * values to empty strings.
	 *
	 * @private
	 * @param {*} value The value to process.
	 * @returns {string} Returns the string.
	 */
	function baseToString(value) {
	  // Exit early for strings to avoid a performance hit in some environments.
	  if (typeof value == 'string') {
	    return value;
	  }
	  if (isArray(value)) {
	    // Recursively convert values (susceptible to call stack limits).
	    return arrayMap(value, baseToString) + '';
	  }
	  if (isSymbol(value)) {
	    return symbolToString ? symbolToString.call(value) : '';
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	}

	/**
	 * Creates a function that performs a mathematical operation on two values.
	 *
	 * @private
	 * @param {Function} operator The function to perform the operation.
	 * @param {number} [defaultValue] The value used for `undefined` arguments.
	 * @returns {Function} Returns the new mathematical operation function.
	 */
	function createMathOperation(operator, defaultValue) {
	  return function(value, other) {
	    var result;
	    if (value === undefined && other === undefined) {
	      return defaultValue;
	    }
	    if (value !== undefined) {
	      result = value;
	    }
	    if (other !== undefined) {
	      if (result === undefined) {
	        return other;
	      }
	      if (typeof value == 'string' || typeof other == 'string') {
	        value = baseToString(value);
	        other = baseToString(other);
	      } else {
	        value = baseToNumber(value);
	        other = baseToNumber(other);
	      }
	      result = operator(value, other);
	    }
	    return result;
	  };
	}

	/**
	 * Adds two numbers.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.4.0
	 * @category Math
	 * @param {number} augend The first number in an addition.
	 * @param {number} addend The second number in an addition.
	 * @returns {number} Returns the total.
	 * @example
	 *
	 * _.add(6, 4);
	 * // => 10
	 */
	var add = createMathOperation(function(augend, addend) {
	  return augend + addend;
	}, 0);

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return value != null && (type == 'object' || type == 'function');
	}

	/** Used as references for various `Number` constants. */
	var NAN$1 = 0 / 0;

	/** Used to match leading and trailing whitespace. */
	var reTrim = /^\s+|\s+$/g;

	/** Used to detect bad signed hexadecimal string values. */
	var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	/** Used to detect binary string values. */
	var reIsBinary = /^0b[01]+$/i;

	/** Used to detect octal string values. */
	var reIsOctal = /^0o[0-7]+$/i;

	/** Built-in method references without a dependency on `root`. */
	var freeParseInt = parseInt;

	/**
	 * Converts `value` to a number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to process.
	 * @returns {number} Returns the number.
	 * @example
	 *
	 * _.toNumber(3.2);
	 * // => 3.2
	 *
	 * _.toNumber(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toNumber(Infinity);
	 * // => Infinity
	 *
	 * _.toNumber('3.2');
	 * // => 3.2
	 */
	function toNumber(value) {
	  if (typeof value == 'number') {
	    return value;
	  }
	  if (isSymbol(value)) {
	    return NAN$1;
	  }
	  if (isObject(value)) {
	    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	    value = isObject(other) ? (other + '') : other;
	  }
	  if (typeof value != 'string') {
	    return value === 0 ? value : +value;
	  }
	  value = value.replace(reTrim, '');
	  var isBinary = reIsBinary.test(value);
	  return (isBinary || reIsOctal.test(value))
	    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	    : (reIsBadHex.test(value) ? NAN$1 : +value);
	}

	/** Used as references for various `Number` constants. */
	var INFINITY$1 = 1 / 0,
	    MAX_INTEGER = 1.7976931348623157e+308;

	/**
	 * Converts `value` to a finite number.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.12.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted number.
	 * @example
	 *
	 * _.toFinite(3.2);
	 * // => 3.2
	 *
	 * _.toFinite(Number.MIN_VALUE);
	 * // => 5e-324
	 *
	 * _.toFinite(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toFinite('3.2');
	 * // => 3.2
	 */
	function toFinite(value) {
	  if (!value) {
	    return value === 0 ? value : 0;
	  }
	  value = toNumber(value);
	  if (value === INFINITY$1 || value === -INFINITY$1) {
	    var sign = (value < 0 ? -1 : 1);
	    return sign * MAX_INTEGER;
	  }
	  return value === value ? value : 0;
	}

	/**
	 * Converts `value` to an integer.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted integer.
	 * @example
	 *
	 * _.toInteger(3.2);
	 * // => 3
	 *
	 * _.toInteger(Number.MIN_VALUE);
	 * // => 0
	 *
	 * _.toInteger(Infinity);
	 * // => 1.7976931348623157e+308
	 *
	 * _.toInteger('3.2');
	 * // => 3
	 */
	function toInteger(value) {
	  var result = toFinite(value),
	      remainder = result % 1;

	  return result === result ? (remainder ? result - remainder : result) : 0;
	}

	/** Error message constants. */
	var FUNC_ERROR_TEXT = 'Expected a function';

	/**
	 * The opposite of `_.before`; this method creates a function that invokes
	 * `func` once it's called `n` or more times.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {number} n The number of calls before `func` is invoked.
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new restricted function.
	 * @example
	 *
	 * var saves = ['profile', 'settings'];
	 *
	 * var done = _.after(saves.length, function() {
	 *   console.log('done saving!');
	 * });
	 *
	 * _.forEach(saves, function(type) {
	 *   asyncSave({ 'type': type, 'complete': done });
	 * });
	 * // => Logs 'done saving!' after the two async saves have completed.
	 */
	function after(n, func) {
	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT);
	  }
	  n = toInteger(n);
	  return function() {
	    if (--n < 1) {
	      return func.apply(this, arguments);
	    }
	  };
	}

	/**
	 * This method returns the first argument it receives.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {*} value Any value.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 *
	 * console.log(_.identity(object) === object);
	 * // => true
	 */
	function identity(value) {
	  return value;
	}

	/** `Object#toString` result references. */
	var asyncTag = '[object AsyncFunction]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    proxyTag = '[object Proxy]';

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  if (!isObject(value)) {
	    return false;
	  }
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 9 which returns 'object' for typed arrays and other constructors.
	  var tag = baseGetTag(value);
	  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	}

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	/** Used for built-in method references. */
	var funcProto = Function.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to convert.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Used for built-in method references. */
	var funcProto$1 = Function.prototype,
	    objectProto$2 = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$1 = funcProto$1.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString$1.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	/* Built-in method references that are verified to be native. */
	var WeakMap$1 = getNative(root, 'WeakMap');

	/** Used to store function metadata. */
	var metaMap = WeakMap$1 && new WeakMap$1;

	/**
	 * The base implementation of `setData` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to associate metadata with.
	 * @param {*} data The metadata.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetData = !metaMap ? identity : function(func, data) {
	  metaMap.set(func, data);
	  return func;
	};

	/** Built-in value references. */
	var objectCreate = Object.create;

	/**
	 * The base implementation of `_.create` without support for assigning
	 * properties to the created object.
	 *
	 * @private
	 * @param {Object} proto The object to inherit from.
	 * @returns {Object} Returns the new object.
	 */
	var baseCreate = (function() {
	  function object() {}
	  return function(proto) {
	    if (!isObject(proto)) {
	      return {};
	    }
	    if (objectCreate) {
	      return objectCreate(proto);
	    }
	    object.prototype = proto;
	    var result = new object;
	    object.prototype = undefined;
	    return result;
	  };
	}());

	/**
	 * Creates a function that produces an instance of `Ctor` regardless of
	 * whether it was invoked as part of a `new` expression or by `call` or `apply`.
	 *
	 * @private
	 * @param {Function} Ctor The constructor to wrap.
	 * @returns {Function} Returns the new wrapped function.
	 */
	function createCtor(Ctor) {
	  return function() {
	    // Use a `switch` statement to work with class constructors. See
	    // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
	    // for more details.
	    var args = arguments;
	    switch (args.length) {
	      case 0: return new Ctor;
	      case 1: return new Ctor(args[0]);
	      case 2: return new Ctor(args[0], args[1]);
	      case 3: return new Ctor(args[0], args[1], args[2]);
	      case 4: return new Ctor(args[0], args[1], args[2], args[3]);
	      case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
	      case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
	      case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
	    }
	    var thisBinding = baseCreate(Ctor.prototype),
	        result = Ctor.apply(thisBinding, args);

	    // Mimic the constructor's `return` behavior.
	    // See https://es5.github.io/#x13.2.2 for more details.
	    return isObject(result) ? result : thisBinding;
	  };
	}

	/** Used to compose bitmasks for function metadata. */
	var WRAP_BIND_FLAG = 1;

	/**
	 * Creates a function that wraps `func` to invoke it with the optional `this`
	 * binding of `thisArg`.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	 * @param {*} [thisArg] The `this` binding of `func`.
	 * @returns {Function} Returns the new wrapped function.
	 */
	function createBind(func, bitmask, thisArg) {
	  var isBind = bitmask & WRAP_BIND_FLAG,
	      Ctor = createCtor(func);

	  function wrapper() {
	    var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	    return fn.apply(isBind ? thisArg : this, arguments);
	  }
	  return wrapper;
	}

	/**
	 * A faster alternative to `Function#apply`, this function invokes `func`
	 * with the `this` binding of `thisArg` and the arguments of `args`.
	 *
	 * @private
	 * @param {Function} func The function to invoke.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} args The arguments to invoke `func` with.
	 * @returns {*} Returns the result of `func`.
	 */
	function apply(func, thisArg, args) {
	  switch (args.length) {
	    case 0: return func.call(thisArg);
	    case 1: return func.call(thisArg, args[0]);
	    case 2: return func.call(thisArg, args[0], args[1]);
	    case 3: return func.call(thisArg, args[0], args[1], args[2]);
	  }
	  return func.apply(thisArg, args);
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax = Math.max;

	/**
	 * Creates an array that is the composition of partially applied arguments,
	 * placeholders, and provided arguments into a single array of arguments.
	 *
	 * @private
	 * @param {Array} args The provided arguments.
	 * @param {Array} partials The arguments to prepend to those provided.
	 * @param {Array} holders The `partials` placeholder indexes.
	 * @params {boolean} [isCurried] Specify composing for a curried function.
	 * @returns {Array} Returns the new array of composed arguments.
	 */
	function composeArgs(args, partials, holders, isCurried) {
	  var argsIndex = -1,
	      argsLength = args.length,
	      holdersLength = holders.length,
	      leftIndex = -1,
	      leftLength = partials.length,
	      rangeLength = nativeMax(argsLength - holdersLength, 0),
	      result = Array(leftLength + rangeLength),
	      isUncurried = !isCurried;

	  while (++leftIndex < leftLength) {
	    result[leftIndex] = partials[leftIndex];
	  }
	  while (++argsIndex < holdersLength) {
	    if (isUncurried || argsIndex < argsLength) {
	      result[holders[argsIndex]] = args[argsIndex];
	    }
	  }
	  while (rangeLength--) {
	    result[leftIndex++] = args[argsIndex++];
	  }
	  return result;
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax$1 = Math.max;

	/**
	 * This function is like `composeArgs` except that the arguments composition
	 * is tailored for `_.partialRight`.
	 *
	 * @private
	 * @param {Array} args The provided arguments.
	 * @param {Array} partials The arguments to append to those provided.
	 * @param {Array} holders The `partials` placeholder indexes.
	 * @params {boolean} [isCurried] Specify composing for a curried function.
	 * @returns {Array} Returns the new array of composed arguments.
	 */
	function composeArgsRight(args, partials, holders, isCurried) {
	  var argsIndex = -1,
	      argsLength = args.length,
	      holdersIndex = -1,
	      holdersLength = holders.length,
	      rightIndex = -1,
	      rightLength = partials.length,
	      rangeLength = nativeMax$1(argsLength - holdersLength, 0),
	      result = Array(rangeLength + rightLength),
	      isUncurried = !isCurried;

	  while (++argsIndex < rangeLength) {
	    result[argsIndex] = args[argsIndex];
	  }
	  var offset = argsIndex;
	  while (++rightIndex < rightLength) {
	    result[offset + rightIndex] = partials[rightIndex];
	  }
	  while (++holdersIndex < holdersLength) {
	    if (isUncurried || argsIndex < argsLength) {
	      result[offset + holders[holdersIndex]] = args[argsIndex++];
	    }
	  }
	  return result;
	}

	/**
	 * Gets the number of `placeholder` occurrences in `array`.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} placeholder The placeholder to search for.
	 * @returns {number} Returns the placeholder count.
	 */
	function countHolders(array, placeholder) {
	  var length = array.length,
	      result = 0;

	  while (length--) {
	    if (array[length] === placeholder) {
	      ++result;
	    }
	  }
	  return result;
	}

	/**
	 * The function whose prototype chain sequence wrappers inherit from.
	 *
	 * @private
	 */
	function baseLodash() {
	  // No operation performed.
	}

	/** Used as references for the maximum length and index of an array. */
	var MAX_ARRAY_LENGTH = 4294967295;

	/**
	 * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
	 *
	 * @private
	 * @constructor
	 * @param {*} value The value to wrap.
	 */
	function LazyWrapper(value) {
	  this.__wrapped__ = value;
	  this.__actions__ = [];
	  this.__dir__ = 1;
	  this.__filtered__ = false;
	  this.__iteratees__ = [];
	  this.__takeCount__ = MAX_ARRAY_LENGTH;
	  this.__views__ = [];
	}

	// Ensure `LazyWrapper` is an instance of `baseLodash`.
	LazyWrapper.prototype = baseCreate(baseLodash.prototype);
	LazyWrapper.prototype.constructor = LazyWrapper;

	/**
	 * This method returns `undefined`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.3.0
	 * @category Util
	 * @example
	 *
	 * _.times(2, _.noop);
	 * // => [undefined, undefined]
	 */
	function noop() {
	  // No operation performed.
	}

	/**
	 * Gets metadata for `func`.
	 *
	 * @private
	 * @param {Function} func The function to query.
	 * @returns {*} Returns the metadata for `func`.
	 */
	var getData = !metaMap ? noop : function(func) {
	  return metaMap.get(func);
	};

	/** Used to lookup unminified function names. */
	var realNames = {};

	/** Used for built-in method references. */
	var objectProto$3 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

	/**
	 * Gets the name of `func`.
	 *
	 * @private
	 * @param {Function} func The function to query.
	 * @returns {string} Returns the function name.
	 */
	function getFuncName(func) {
	  var result = (func.name + ''),
	      array = realNames[result],
	      length = hasOwnProperty$2.call(realNames, result) ? array.length : 0;

	  while (length--) {
	    var data = array[length],
	        otherFunc = data.func;
	    if (otherFunc == null || otherFunc == func) {
	      return data.name;
	    }
	  }
	  return result;
	}

	/**
	 * The base constructor for creating `lodash` wrapper objects.
	 *
	 * @private
	 * @param {*} value The value to wrap.
	 * @param {boolean} [chainAll] Enable explicit method chain sequences.
	 */
	function LodashWrapper(value, chainAll) {
	  this.__wrapped__ = value;
	  this.__actions__ = [];
	  this.__chain__ = !!chainAll;
	  this.__index__ = 0;
	  this.__values__ = undefined;
	}

	LodashWrapper.prototype = baseCreate(baseLodash.prototype);
	LodashWrapper.prototype.constructor = LodashWrapper;

	/**
	 * Copies the values of `source` to `array`.
	 *
	 * @private
	 * @param {Array} source The array to copy values from.
	 * @param {Array} [array=[]] The array to copy values to.
	 * @returns {Array} Returns `array`.
	 */
	function copyArray$1(source, array) {
	  var index = -1,
	      length = source.length;

	  array || (array = Array(length));
	  while (++index < length) {
	    array[index] = source[index];
	  }
	  return array;
	}

	/**
	 * Creates a clone of `wrapper`.
	 *
	 * @private
	 * @param {Object} wrapper The wrapper to clone.
	 * @returns {Object} Returns the cloned wrapper.
	 */
	function wrapperClone(wrapper) {
	  if (wrapper instanceof LazyWrapper) {
	    return wrapper.clone();
	  }
	  var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
	  result.__actions__ = copyArray$1(wrapper.__actions__);
	  result.__index__  = wrapper.__index__;
	  result.__values__ = wrapper.__values__;
	  return result;
	}

	/** Used for built-in method references. */
	var objectProto$4 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

	/**
	 * Creates a `lodash` object which wraps `value` to enable implicit method
	 * chain sequences. Methods that operate on and return arrays, collections,
	 * and functions can be chained together. Methods that retrieve a single value
	 * or may return a primitive value will automatically end the chain sequence
	 * and return the unwrapped value. Otherwise, the value must be unwrapped
	 * with `_#value`.
	 *
	 * Explicit chain sequences, which must be unwrapped with `_#value`, may be
	 * enabled using `_.chain`.
	 *
	 * The execution of chained methods is lazy, that is, it's deferred until
	 * `_#value` is implicitly or explicitly called.
	 *
	 * Lazy evaluation allows several methods to support shortcut fusion.
	 * Shortcut fusion is an optimization to merge iteratee calls; this avoids
	 * the creation of intermediate arrays and can greatly reduce the number of
	 * iteratee executions. Sections of a chain sequence qualify for shortcut
	 * fusion if the section is applied to an array and iteratees accept only
	 * one argument. The heuristic for whether a section qualifies for shortcut
	 * fusion is subject to change.
	 *
	 * Chaining is supported in custom builds as long as the `_#value` method is
	 * directly or indirectly included in the build.
	 *
	 * In addition to lodash methods, wrappers have `Array` and `String` methods.
	 *
	 * The wrapper `Array` methods are:
	 * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
	 *
	 * The wrapper `String` methods are:
	 * `replace` and `split`
	 *
	 * The wrapper methods that support shortcut fusion are:
	 * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
	 * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
	 * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
	 *
	 * The chainable wrapper methods are:
	 * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
	 * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
	 * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
	 * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
	 * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
	 * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
	 * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
	 * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
	 * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
	 * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
	 * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
	 * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
	 * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
	 * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
	 * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
	 * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
	 * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
	 * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
	 * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
	 * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
	 * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
	 * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
	 * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
	 * `zipObject`, `zipObjectDeep`, and `zipWith`
	 *
	 * The wrapper methods that are **not** chainable by default are:
	 * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
	 * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
	 * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
	 * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
	 * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
	 * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
	 * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
	 * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
	 * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
	 * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
	 * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
	 * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
	 * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
	 * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
	 * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
	 * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
	 * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
	 * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
	 * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
	 * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
	 * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
	 * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
	 * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
	 * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
	 * `upperFirst`, `value`, and `words`
	 *
	 * @name _
	 * @constructor
	 * @category Seq
	 * @param {*} value The value to wrap in a `lodash` instance.
	 * @returns {Object} Returns the new `lodash` wrapper instance.
	 * @example
	 *
	 * function square(n) {
	 *   return n * n;
	 * }
	 *
	 * var wrapped = _([1, 2, 3]);
	 *
	 * // Returns an unwrapped value.
	 * wrapped.reduce(_.add);
	 * // => 6
	 *
	 * // Returns a wrapped value.
	 * var squares = wrapped.map(square);
	 *
	 * _.isArray(squares);
	 * // => false
	 *
	 * _.isArray(squares.value());
	 * // => true
	 */
	function lodash(value) {
	  if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
	    if (value instanceof LodashWrapper) {
	      return value;
	    }
	    if (hasOwnProperty$3.call(value, '__wrapped__')) {
	      return wrapperClone(value);
	    }
	  }
	  return new LodashWrapper(value);
	}

	// Ensure wrappers are instances of `baseLodash`.
	lodash.prototype = baseLodash.prototype;
	lodash.prototype.constructor = lodash;

	/**
	 * Checks if `func` has a lazy counterpart.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
	 *  else `false`.
	 */
	function isLaziable(func) {
	  var funcName = getFuncName(func),
	      other = lodash[funcName];

	  if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
	    return false;
	  }
	  if (func === other) {
	    return true;
	  }
	  var data = getData(other);
	  return !!data && func === data[0];
	}

	/** Used to detect hot functions by number of calls within a span of milliseconds. */
	var HOT_COUNT = 800,
	    HOT_SPAN = 16;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeNow = Date.now;

	/**
	 * Creates a function that'll short out and invoke `identity` instead
	 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	 * milliseconds.
	 *
	 * @private
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new shortable function.
	 */
	function shortOut(func) {
	  var count = 0,
	      lastCalled = 0;

	  return function() {
	    var stamp = nativeNow(),
	        remaining = HOT_SPAN - (stamp - lastCalled);

	    lastCalled = stamp;
	    if (remaining > 0) {
	      if (++count >= HOT_COUNT) {
	        return arguments[0];
	      }
	    } else {
	      count = 0;
	    }
	    return func.apply(undefined, arguments);
	  };
	}

	/**
	 * Sets metadata for `func`.
	 *
	 * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
	 * period of time, it will trip its breaker and transition to an identity
	 * function to avoid garbage collection pauses in V8. See
	 * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
	 * for more details.
	 *
	 * @private
	 * @param {Function} func The function to associate metadata with.
	 * @param {*} data The metadata.
	 * @returns {Function} Returns `func`.
	 */
	var setData = shortOut(baseSetData);

	/** Used to match wrap detail comments. */
	var reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
	    reSplitDetails = /,? & /;

	/**
	 * Extracts wrapper details from the `source` body comment.
	 *
	 * @private
	 * @param {string} source The source to inspect.
	 * @returns {Array} Returns the wrapper details.
	 */
	function getWrapDetails(source) {
	  var match = source.match(reWrapDetails);
	  return match ? match[1].split(reSplitDetails) : [];
	}

	/** Used to match wrap detail comments. */
	var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/;

	/**
	 * Inserts wrapper `details` in a comment at the top of the `source` body.
	 *
	 * @private
	 * @param {string} source The source to modify.
	 * @returns {Array} details The details to insert.
	 * @returns {string} Returns the modified source.
	 */
	function insertWrapDetails(source, details) {
	  var length = details.length;
	  if (!length) {
	    return source;
	  }
	  var lastIndex = length - 1;
	  details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
	  details = details.join(length > 2 ? ', ' : ' ');
	  return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
	}

	/**
	 * Creates a function that returns `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {*} value The value to return from the new function.
	 * @returns {Function} Returns the new constant function.
	 * @example
	 *
	 * var objects = _.times(2, _.constant({ 'a': 1 }));
	 *
	 * console.log(objects);
	 * // => [{ 'a': 1 }, { 'a': 1 }]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => true
	 */
	function constant(value) {
	  return function() {
	    return value;
	  };
	}

	var defineProperty = (function() {
	  try {
	    var func = getNative(Object, 'defineProperty');
	    func({}, '', {});
	    return func;
	  } catch (e) {}
	}());

	/**
	 * The base implementation of `setToString` without support for hot loop shorting.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var baseSetToString = !defineProperty ? identity : function(func, string) {
	  return defineProperty(func, 'toString', {
	    'configurable': true,
	    'enumerable': false,
	    'value': constant(string),
	    'writable': true
	  });
	};

	/**
	 * Sets the `toString` method of `func` to return `string`.
	 *
	 * @private
	 * @param {Function} func The function to modify.
	 * @param {Function} string The `toString` result.
	 * @returns {Function} Returns `func`.
	 */
	var setToString = shortOut(baseSetToString);

	/**
	 * A specialized version of `_.forEach` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns `array`.
	 */
	function arrayEach(array, iteratee) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (iteratee(array[index], index, array) === false) {
	      break;
	    }
	  }
	  return array;
	}

	/**
	 * The base implementation of `_.findIndex` and `_.findLastIndex` without
	 * support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} predicate The function invoked per iteration.
	 * @param {number} fromIndex The index to search from.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseFindIndex(array, predicate, fromIndex, fromRight) {
	  var length = array.length,
	      index = fromIndex + (fromRight ? 1 : -1);

	  while ((fromRight ? index-- : ++index < length)) {
	    if (predicate(array[index], index, array)) {
	      return index;
	    }
	  }
	  return -1;
	}

	/**
	 * The base implementation of `_.isNaN` without support for number objects.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	 */
	function baseIsNaN(value) {
	  return value !== value;
	}

	/**
	 * A specialized version of `_.indexOf` which performs strict equality
	 * comparisons of values, i.e. `===`.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function strictIndexOf(array, value, fromIndex) {
	  var index = fromIndex - 1,
	      length = array.length;

	  while (++index < length) {
	    if (array[index] === value) {
	      return index;
	    }
	  }
	  return -1;
	}

	/**
	 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseIndexOf(array, value, fromIndex) {
	  return value === value
	    ? strictIndexOf(array, value, fromIndex)
	    : baseFindIndex(array, baseIsNaN, fromIndex);
	}

	/**
	 * A specialized version of `_.includes` for arrays without support for
	 * specifying an index to search from.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludes(array, value) {
	  var length = array == null ? 0 : array.length;
	  return !!length && baseIndexOf(array, value, 0) > -1;
	}

	/** Used to compose bitmasks for function metadata. */
	var WRAP_BIND_FLAG$1 = 1,
	    WRAP_BIND_KEY_FLAG = 2,
	    WRAP_CURRY_FLAG = 8,
	    WRAP_CURRY_RIGHT_FLAG = 16,
	    WRAP_PARTIAL_FLAG = 32,
	    WRAP_PARTIAL_RIGHT_FLAG = 64,
	    WRAP_ARY_FLAG = 128,
	    WRAP_REARG_FLAG = 256,
	    WRAP_FLIP_FLAG = 512;

	/** Used to associate wrap methods with their bit flags. */
	var wrapFlags = [
	  ['ary', WRAP_ARY_FLAG],
	  ['bind', WRAP_BIND_FLAG$1],
	  ['bindKey', WRAP_BIND_KEY_FLAG],
	  ['curry', WRAP_CURRY_FLAG],
	  ['curryRight', WRAP_CURRY_RIGHT_FLAG],
	  ['flip', WRAP_FLIP_FLAG],
	  ['partial', WRAP_PARTIAL_FLAG],
	  ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
	  ['rearg', WRAP_REARG_FLAG]
	];

	/**
	 * Updates wrapper `details` based on `bitmask` flags.
	 *
	 * @private
	 * @returns {Array} details The details to modify.
	 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	 * @returns {Array} Returns `details`.
	 */
	function updateWrapDetails(details, bitmask) {
	  arrayEach(wrapFlags, function(pair) {
	    var value = '_.' + pair[0];
	    if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
	      details.push(value);
	    }
	  });
	  return details.sort();
	}

	/**
	 * Sets the `toString` method of `wrapper` to mimic the source of `reference`
	 * with wrapper details in a comment at the top of the source body.
	 *
	 * @private
	 * @param {Function} wrapper The function to modify.
	 * @param {Function} reference The reference function.
	 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	 * @returns {Function} Returns `wrapper`.
	 */
	function setWrapToString(wrapper, reference, bitmask) {
	  var source = (reference + '');
	  return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
	}

	/** Used to compose bitmasks for function metadata. */
	var WRAP_BIND_FLAG$2 = 1,
	    WRAP_BIND_KEY_FLAG$1 = 2,
	    WRAP_CURRY_BOUND_FLAG = 4,
	    WRAP_CURRY_FLAG$1 = 8,
	    WRAP_PARTIAL_FLAG$1 = 32,
	    WRAP_PARTIAL_RIGHT_FLAG$1 = 64;

	/**
	 * Creates a function that wraps `func` to continue currying.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	 * @param {Function} wrapFunc The function to create the `func` wrapper.
	 * @param {*} placeholder The placeholder value.
	 * @param {*} [thisArg] The `this` binding of `func`.
	 * @param {Array} [partials] The arguments to prepend to those provided to
	 *  the new function.
	 * @param {Array} [holders] The `partials` placeholder indexes.
	 * @param {Array} [argPos] The argument positions of the new function.
	 * @param {number} [ary] The arity cap of `func`.
	 * @param {number} [arity] The arity of `func`.
	 * @returns {Function} Returns the new wrapped function.
	 */
	function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
	  var isCurry = bitmask & WRAP_CURRY_FLAG$1,
	      newHolders = isCurry ? holders : undefined,
	      newHoldersRight = isCurry ? undefined : holders,
	      newPartials = isCurry ? partials : undefined,
	      newPartialsRight = isCurry ? undefined : partials;

	  bitmask |= (isCurry ? WRAP_PARTIAL_FLAG$1 : WRAP_PARTIAL_RIGHT_FLAG$1);
	  bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG$1 : WRAP_PARTIAL_FLAG$1);

	  if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
	    bitmask &= ~(WRAP_BIND_FLAG$2 | WRAP_BIND_KEY_FLAG$1);
	  }
	  var newData = [
	    func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
	    newHoldersRight, argPos, ary, arity
	  ];

	  var result = wrapFunc.apply(undefined, newData);
	  if (isLaziable(func)) {
	    setData(result, newData);
	  }
	  result.placeholder = placeholder;
	  return setWrapToString(result, func, bitmask);
	}

	/**
	 * Gets the argument placeholder value for `func`.
	 *
	 * @private
	 * @param {Function} func The function to inspect.
	 * @returns {*} Returns the placeholder value.
	 */
	function getHolder(func) {
	  var object = func;
	  return object.placeholder;
	}

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** Used to detect unsigned integer values. */
	var reIsUint = /^(?:0|[1-9]\d*)$/;

	/**
	 * Checks if `value` is a valid array-like index.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	 */
	function isIndex(value, length) {
	  var type = typeof value;
	  length = length == null ? MAX_SAFE_INTEGER : length;

	  return !!length &&
	    (type == 'number' ||
	      (type != 'symbol' && reIsUint.test(value))) &&
	        (value > -1 && value % 1 == 0 && value < length);
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMin = Math.min;

	/**
	 * Reorder `array` according to the specified indexes where the element at
	 * the first index is assigned as the first element, the element at
	 * the second index is assigned as the second element, and so on.
	 *
	 * @private
	 * @param {Array} array The array to reorder.
	 * @param {Array} indexes The arranged array indexes.
	 * @returns {Array} Returns `array`.
	 */
	function reorder(array, indexes) {
	  var arrLength = array.length,
	      length = nativeMin(indexes.length, arrLength),
	      oldArray = copyArray$1(array);

	  while (length--) {
	    var index = indexes[length];
	    array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
	  }
	  return array;
	}

	/** Used as the internal argument placeholder. */
	var PLACEHOLDER = '__lodash_placeholder__';

	/**
	 * Replaces all `placeholder` elements in `array` with an internal placeholder
	 * and returns an array of their indexes.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {*} placeholder The placeholder to replace.
	 * @returns {Array} Returns the new array of placeholder indexes.
	 */
	function replaceHolders(array, placeholder) {
	  var index = -1,
	      length = array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (value === placeholder || value === PLACEHOLDER) {
	      array[index] = PLACEHOLDER;
	      result[resIndex++] = index;
	    }
	  }
	  return result;
	}

	/** Used to compose bitmasks for function metadata. */
	var WRAP_BIND_FLAG$3 = 1,
	    WRAP_BIND_KEY_FLAG$2 = 2,
	    WRAP_CURRY_FLAG$2 = 8,
	    WRAP_CURRY_RIGHT_FLAG$1 = 16,
	    WRAP_ARY_FLAG$1 = 128,
	    WRAP_FLIP_FLAG$1 = 512;

	/**
	 * Creates a function that wraps `func` to invoke it with optional `this`
	 * binding of `thisArg`, partial application, and currying.
	 *
	 * @private
	 * @param {Function|string} func The function or method name to wrap.
	 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	 * @param {*} [thisArg] The `this` binding of `func`.
	 * @param {Array} [partials] The arguments to prepend to those provided to
	 *  the new function.
	 * @param {Array} [holders] The `partials` placeholder indexes.
	 * @param {Array} [partialsRight] The arguments to append to those provided
	 *  to the new function.
	 * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
	 * @param {Array} [argPos] The argument positions of the new function.
	 * @param {number} [ary] The arity cap of `func`.
	 * @param {number} [arity] The arity of `func`.
	 * @returns {Function} Returns the new wrapped function.
	 */
	function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
	  var isAry = bitmask & WRAP_ARY_FLAG$1,
	      isBind = bitmask & WRAP_BIND_FLAG$3,
	      isBindKey = bitmask & WRAP_BIND_KEY_FLAG$2,
	      isCurried = bitmask & (WRAP_CURRY_FLAG$2 | WRAP_CURRY_RIGHT_FLAG$1),
	      isFlip = bitmask & WRAP_FLIP_FLAG$1,
	      Ctor = isBindKey ? undefined : createCtor(func);

	  function wrapper() {
	    var length = arguments.length,
	        args = Array(length),
	        index = length;

	    while (index--) {
	      args[index] = arguments[index];
	    }
	    if (isCurried) {
	      var placeholder = getHolder(wrapper),
	          holdersCount = countHolders(args, placeholder);
	    }
	    if (partials) {
	      args = composeArgs(args, partials, holders, isCurried);
	    }
	    if (partialsRight) {
	      args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
	    }
	    length -= holdersCount;
	    if (isCurried && length < arity) {
	      var newHolders = replaceHolders(args, placeholder);
	      return createRecurry(
	        func, bitmask, createHybrid, wrapper.placeholder, thisArg,
	        args, newHolders, argPos, ary, arity - length
	      );
	    }
	    var thisBinding = isBind ? thisArg : this,
	        fn = isBindKey ? thisBinding[func] : func;

	    length = args.length;
	    if (argPos) {
	      args = reorder(args, argPos);
	    } else if (isFlip && length > 1) {
	      args.reverse();
	    }
	    if (isAry && ary < length) {
	      args.length = ary;
	    }
	    if (this && this !== root && this instanceof wrapper) {
	      fn = Ctor || createCtor(fn);
	    }
	    return fn.apply(thisBinding, args);
	  }
	  return wrapper;
	}

	/**
	 * Creates a function that wraps `func` to enable currying.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	 * @param {number} arity The arity of `func`.
	 * @returns {Function} Returns the new wrapped function.
	 */
	function createCurry(func, bitmask, arity) {
	  var Ctor = createCtor(func);

	  function wrapper() {
	    var length = arguments.length,
	        args = Array(length),
	        index = length,
	        placeholder = getHolder(wrapper);

	    while (index--) {
	      args[index] = arguments[index];
	    }
	    var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
	      ? []
	      : replaceHolders(args, placeholder);

	    length -= holders.length;
	    if (length < arity) {
	      return createRecurry(
	        func, bitmask, createHybrid, wrapper.placeholder, undefined,
	        args, holders, undefined, undefined, arity - length);
	    }
	    var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	    return apply(fn, this, args);
	  }
	  return wrapper;
	}

	/** Used to compose bitmasks for function metadata. */
	var WRAP_BIND_FLAG$4 = 1;

	/**
	 * Creates a function that wraps `func` to invoke it with the `this` binding
	 * of `thisArg` and `partials` prepended to the arguments it receives.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {Array} partials The arguments to prepend to those provided to
	 *  the new function.
	 * @returns {Function} Returns the new wrapped function.
	 */
	function createPartial(func, bitmask, thisArg, partials) {
	  var isBind = bitmask & WRAP_BIND_FLAG$4,
	      Ctor = createCtor(func);

	  function wrapper() {
	    var argsIndex = -1,
	        argsLength = arguments.length,
	        leftIndex = -1,
	        leftLength = partials.length,
	        args = Array(leftLength + argsLength),
	        fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

	    while (++leftIndex < leftLength) {
	      args[leftIndex] = partials[leftIndex];
	    }
	    while (argsLength--) {
	      args[leftIndex++] = arguments[++argsIndex];
	    }
	    return apply(fn, isBind ? thisArg : this, args);
	  }
	  return wrapper;
	}

	/** Used as the internal argument placeholder. */
	var PLACEHOLDER$1 = '__lodash_placeholder__';

	/** Used to compose bitmasks for function metadata. */
	var WRAP_BIND_FLAG$5 = 1,
	    WRAP_BIND_KEY_FLAG$3 = 2,
	    WRAP_CURRY_BOUND_FLAG$1 = 4,
	    WRAP_CURRY_FLAG$3 = 8,
	    WRAP_ARY_FLAG$2 = 128,
	    WRAP_REARG_FLAG$1 = 256;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMin$1 = Math.min;

	/**
	 * Merges the function metadata of `source` into `data`.
	 *
	 * Merging metadata reduces the number of wrappers used to invoke a function.
	 * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
	 * may be applied regardless of execution order. Methods like `_.ary` and
	 * `_.rearg` modify function arguments, making the order in which they are
	 * executed important, preventing the merging of metadata. However, we make
	 * an exception for a safe combined case where curried functions have `_.ary`
	 * and or `_.rearg` applied.
	 *
	 * @private
	 * @param {Array} data The destination metadata.
	 * @param {Array} source The source metadata.
	 * @returns {Array} Returns `data`.
	 */
	function mergeData(data, source) {
	  var bitmask = data[1],
	      srcBitmask = source[1],
	      newBitmask = bitmask | srcBitmask,
	      isCommon = newBitmask < (WRAP_BIND_FLAG$5 | WRAP_BIND_KEY_FLAG$3 | WRAP_ARY_FLAG$2);

	  var isCombo =
	    ((srcBitmask == WRAP_ARY_FLAG$2) && (bitmask == WRAP_CURRY_FLAG$3)) ||
	    ((srcBitmask == WRAP_ARY_FLAG$2) && (bitmask == WRAP_REARG_FLAG$1) && (data[7].length <= source[8])) ||
	    ((srcBitmask == (WRAP_ARY_FLAG$2 | WRAP_REARG_FLAG$1)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG$3));

	  // Exit early if metadata can't be merged.
	  if (!(isCommon || isCombo)) {
	    return data;
	  }
	  // Use source `thisArg` if available.
	  if (srcBitmask & WRAP_BIND_FLAG$5) {
	    data[2] = source[2];
	    // Set when currying a bound function.
	    newBitmask |= bitmask & WRAP_BIND_FLAG$5 ? 0 : WRAP_CURRY_BOUND_FLAG$1;
	  }
	  // Compose partial arguments.
	  var value = source[3];
	  if (value) {
	    var partials = data[3];
	    data[3] = partials ? composeArgs(partials, value, source[4]) : value;
	    data[4] = partials ? replaceHolders(data[3], PLACEHOLDER$1) : source[4];
	  }
	  // Compose partial right arguments.
	  value = source[5];
	  if (value) {
	    partials = data[5];
	    data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
	    data[6] = partials ? replaceHolders(data[5], PLACEHOLDER$1) : source[6];
	  }
	  // Use source `argPos` if available.
	  value = source[7];
	  if (value) {
	    data[7] = value;
	  }
	  // Use source `ary` if it's smaller.
	  if (srcBitmask & WRAP_ARY_FLAG$2) {
	    data[8] = data[8] == null ? source[8] : nativeMin$1(data[8], source[8]);
	  }
	  // Use source `arity` if one is not provided.
	  if (data[9] == null) {
	    data[9] = source[9];
	  }
	  // Use source `func` and merge bitmasks.
	  data[0] = source[0];
	  data[1] = newBitmask;

	  return data;
	}

	/** Error message constants. */
	var FUNC_ERROR_TEXT$1 = 'Expected a function';

	/** Used to compose bitmasks for function metadata. */
	var WRAP_BIND_FLAG$6 = 1,
	    WRAP_BIND_KEY_FLAG$4 = 2,
	    WRAP_CURRY_FLAG$4 = 8,
	    WRAP_CURRY_RIGHT_FLAG$2 = 16,
	    WRAP_PARTIAL_FLAG$2 = 32,
	    WRAP_PARTIAL_RIGHT_FLAG$2 = 64;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax$2 = Math.max;

	/**
	 * Creates a function that either curries or invokes `func` with optional
	 * `this` binding and partially applied arguments.
	 *
	 * @private
	 * @param {Function|string} func The function or method name to wrap.
	 * @param {number} bitmask The bitmask flags.
	 *    1 - `_.bind`
	 *    2 - `_.bindKey`
	 *    4 - `_.curry` or `_.curryRight` of a bound function
	 *    8 - `_.curry`
	 *   16 - `_.curryRight`
	 *   32 - `_.partial`
	 *   64 - `_.partialRight`
	 *  128 - `_.rearg`
	 *  256 - `_.ary`
	 *  512 - `_.flip`
	 * @param {*} [thisArg] The `this` binding of `func`.
	 * @param {Array} [partials] The arguments to be partially applied.
	 * @param {Array} [holders] The `partials` placeholder indexes.
	 * @param {Array} [argPos] The argument positions of the new function.
	 * @param {number} [ary] The arity cap of `func`.
	 * @param {number} [arity] The arity of `func`.
	 * @returns {Function} Returns the new wrapped function.
	 */
	function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
	  var isBindKey = bitmask & WRAP_BIND_KEY_FLAG$4;
	  if (!isBindKey && typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT$1);
	  }
	  var length = partials ? partials.length : 0;
	  if (!length) {
	    bitmask &= ~(WRAP_PARTIAL_FLAG$2 | WRAP_PARTIAL_RIGHT_FLAG$2);
	    partials = holders = undefined;
	  }
	  ary = ary === undefined ? ary : nativeMax$2(toInteger(ary), 0);
	  arity = arity === undefined ? arity : toInteger(arity);
	  length -= holders ? holders.length : 0;

	  if (bitmask & WRAP_PARTIAL_RIGHT_FLAG$2) {
	    var partialsRight = partials,
	        holdersRight = holders;

	    partials = holders = undefined;
	  }
	  var data = isBindKey ? undefined : getData(func);

	  var newData = [
	    func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
	    argPos, ary, arity
	  ];

	  if (data) {
	    mergeData(newData, data);
	  }
	  func = newData[0];
	  bitmask = newData[1];
	  thisArg = newData[2];
	  partials = newData[3];
	  holders = newData[4];
	  arity = newData[9] = newData[9] === undefined
	    ? (isBindKey ? 0 : func.length)
	    : nativeMax$2(newData[9] - length, 0);

	  if (!arity && bitmask & (WRAP_CURRY_FLAG$4 | WRAP_CURRY_RIGHT_FLAG$2)) {
	    bitmask &= ~(WRAP_CURRY_FLAG$4 | WRAP_CURRY_RIGHT_FLAG$2);
	  }
	  if (!bitmask || bitmask == WRAP_BIND_FLAG$6) {
	    var result = createBind(func, bitmask, thisArg);
	  } else if (bitmask == WRAP_CURRY_FLAG$4 || bitmask == WRAP_CURRY_RIGHT_FLAG$2) {
	    result = createCurry(func, bitmask, arity);
	  } else if ((bitmask == WRAP_PARTIAL_FLAG$2 || bitmask == (WRAP_BIND_FLAG$6 | WRAP_PARTIAL_FLAG$2)) && !holders.length) {
	    result = createPartial(func, bitmask, thisArg, partials);
	  } else {
	    result = createHybrid.apply(undefined, newData);
	  }
	  var setter = data ? baseSetData : setData;
	  return setWrapToString(setter(result, newData), func, bitmask);
	}

	/** Used to compose bitmasks for function metadata. */
	var WRAP_ARY_FLAG$3 = 128;

	/**
	 * Creates a function that invokes `func`, with up to `n` arguments,
	 * ignoring any additional arguments.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Function
	 * @param {Function} func The function to cap arguments for.
	 * @param {number} [n=func.length] The arity cap.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {Function} Returns the new capped function.
	 * @example
	 *
	 * _.map(['6', '8', '10'], _.ary(parseInt, 1));
	 * // => [6, 8, 10]
	 */
	function ary(func, n, guard) {
	  n = guard ? undefined : n;
	  n = (func && n == null) ? func.length : n;
	  return createWrap(func, WRAP_ARY_FLAG$3, undefined, undefined, undefined, undefined, n);
	}

	/**
	 * The base implementation of `assignValue` and `assignMergeValue` without
	 * value checks.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function baseAssignValue(object, key, value) {
	  if (key == '__proto__' && defineProperty) {
	    defineProperty(object, key, {
	      'configurable': true,
	      'enumerable': true,
	      'value': value,
	      'writable': true
	    });
	  } else {
	    object[key] = value;
	  }
	}

	/**
	 * Performs a
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * comparison between two values to determine if they are equivalent.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.eq(object, object);
	 * // => true
	 *
	 * _.eq(object, other);
	 * // => false
	 *
	 * _.eq('a', 'a');
	 * // => true
	 *
	 * _.eq('a', Object('a'));
	 * // => false
	 *
	 * _.eq(NaN, NaN);
	 * // => true
	 */
	function eq(value, other) {
	  return value === other || (value !== value && other !== other);
	}

	/** Used for built-in method references. */
	var objectProto$5 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

	/**
	 * Assigns `value` to `key` of `object` if the existing value is not equivalent
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignValue(object, key, value) {
	  var objValue = object[key];
	  if (!(hasOwnProperty$4.call(object, key) && eq(objValue, value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}

	/**
	 * Copies properties of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy properties from.
	 * @param {Array} props The property identifiers to copy.
	 * @param {Object} [object={}] The object to copy properties to.
	 * @param {Function} [customizer] The function to customize copied values.
	 * @returns {Object} Returns `object`.
	 */
	function copyObject(source, props, object, customizer) {
	  var isNew = !object;
	  object || (object = {});

	  var index = -1,
	      length = props.length;

	  while (++index < length) {
	    var key = props[index];

	    var newValue = customizer
	      ? customizer(object[key], source[key], key, object, source)
	      : undefined;

	    if (newValue === undefined) {
	      newValue = source[key];
	    }
	    if (isNew) {
	      baseAssignValue(object, key, newValue);
	    } else {
	      assignValue(object, key, newValue);
	    }
	  }
	  return object;
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax$3 = Math.max;

	/**
	 * A specialized version of `baseRest` which transforms the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @param {Function} transform The rest array transform.
	 * @returns {Function} Returns the new function.
	 */
	function overRest(func, start, transform) {
	  start = nativeMax$3(start === undefined ? (func.length - 1) : start, 0);
	  return function() {
	    var args = arguments,
	        index = -1,
	        length = nativeMax$3(args.length - start, 0),
	        array = Array(length);

	    while (++index < length) {
	      array[index] = args[start + index];
	    }
	    index = -1;
	    var otherArgs = Array(start + 1);
	    while (++index < start) {
	      otherArgs[index] = args[index];
	    }
	    otherArgs[start] = transform(array);
	    return apply(func, this, otherArgs);
	  };
	}

	/**
	 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 */
	function baseRest(func, start) {
	  return setToString(overRest(func, start, identity), func + '');
	}

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER$1 = 9007199254740991;

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
	}

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	/**
	 * Checks if the given arguments are from an iteratee call.
	 *
	 * @private
	 * @param {*} value The potential iteratee value argument.
	 * @param {*} index The potential iteratee index or key argument.
	 * @param {*} object The potential iteratee object argument.
	 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	 *  else `false`.
	 */
	function isIterateeCall(value, index, object) {
	  if (!isObject(object)) {
	    return false;
	  }
	  var type = typeof index;
	  if (type == 'number'
	        ? (isArrayLike(object) && isIndex(index, object.length))
	        : (type == 'string' && index in object)
	      ) {
	    return eq(object[index], value);
	  }
	  return false;
	}

	/**
	 * Creates a function like `_.assign`.
	 *
	 * @private
	 * @param {Function} assigner The function to assign values.
	 * @returns {Function} Returns the new assigner function.
	 */
	function createAssigner(assigner) {
	  return baseRest(function(object, sources) {
	    var index = -1,
	        length = sources.length,
	        customizer = length > 1 ? sources[length - 1] : undefined,
	        guard = length > 2 ? sources[2] : undefined;

	    customizer = (assigner.length > 3 && typeof customizer == 'function')
	      ? (length--, customizer)
	      : undefined;

	    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	      customizer = length < 3 ? undefined : customizer;
	      length = 1;
	    }
	    object = Object(object);
	    while (++index < length) {
	      var source = sources[index];
	      if (source) {
	        assigner(object, source, index, customizer);
	      }
	    }
	    return object;
	  });
	}

	/** Used for built-in method references. */
	var objectProto$6 = Object.prototype;

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$6;

	  return value === proto;
	}

	/**
	 * The base implementation of `_.times` without support for iteratee shorthands
	 * or max array length checks.
	 *
	 * @private
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 */
	function baseTimes(n, iteratee) {
	  var index = -1,
	      result = Array(n);

	  while (++index < n) {
	    result[index] = iteratee(index);
	  }
	  return result;
	}

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}

	/** Used for built-in method references. */
	var objectProto$7 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$5 = objectProto$7.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto$7.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike(value) && hasOwnProperty$5.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	/** Detect free variable `exports`. */
	var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;

	/** `Object#toString` result references. */
	var argsTag$1 = '[object Arguments]',
	    arrayTag = '[object Array]',
	    boolTag = '[object Boolean]',
	    dateTag = '[object Date]',
	    errorTag = '[object Error]',
	    funcTag$1 = '[object Function]',
	    mapTag = '[object Map]',
	    numberTag = '[object Number]',
	    objectTag = '[object Object]',
	    regexpTag = '[object RegExp]',
	    setTag = '[object Set]',
	    stringTag = '[object String]',
	    weakMapTag = '[object WeakMap]';

	var arrayBufferTag = '[object ArrayBuffer]',
	    dataViewTag = '[object DataView]',
	    float32Tag = '[object Float32Array]',
	    float64Tag = '[object Float64Array]',
	    int8Tag = '[object Int8Array]',
	    int16Tag = '[object Int16Array]',
	    int32Tag = '[object Int32Array]',
	    uint8Tag = '[object Uint8Array]',
	    uint8ClampedTag = '[object Uint8ClampedArray]',
	    uint16Tag = '[object Uint16Array]',
	    uint32Tag = '[object Uint32Array]';

	/** Used to identify `toStringTag` values of typed arrays. */
	var typedArrayTags = {};
	typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	typedArrayTags[uint32Tag] = true;
	typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =
	typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	typedArrayTags[errorTag] = typedArrayTags[funcTag$1] =
	typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	typedArrayTags[setTag] = typedArrayTags[stringTag] =
	typedArrayTags[weakMapTag] = false;

	/**
	 * The base implementation of `_.isTypedArray` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 */
	function baseIsTypedArray(value) {
	  return isObjectLike(value) &&
	    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	}

	/**
	 * The base implementation of `_.unary` without support for storing metadata.
	 *
	 * @private
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 */
	function baseUnary(func) {
	  return function(value) {
	    return func(value);
	  };
	}

	/** Detect free variable `exports`. */
	var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

	/** Detect free variable `process` from Node.js. */
	var freeProcess = moduleExports$1 && freeGlobal.process;

	/** Used to access faster Node.js helpers. */
	var nodeUtil = (function() {
	  try {
	    // Use `util.types` for Node.js 10+.
	    var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;

	    if (types) {
	      return types;
	    }

	    // Legacy `process.binding('util')` for Node.js < 10.
	    return freeProcess && freeProcess.binding && freeProcess.binding('util');
	  } catch (e) {}
	}());

	/* Node.js helper references. */
	var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	/**
	 * Checks if `value` is classified as a typed array.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	 * @example
	 *
	 * _.isTypedArray(new Uint8Array);
	 * // => true
	 *
	 * _.isTypedArray([]);
	 * // => false
	 */
	var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	/** Used for built-in method references. */
	var objectProto$8 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$6 = objectProto$8.hasOwnProperty;

	/**
	 * Creates an array of the enumerable property names of the array-like `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @param {boolean} inherited Specify returning inherited property names.
	 * @returns {Array} Returns the array of property names.
	 */
	function arrayLikeKeys(value, inherited) {
	  var isArr = isArray(value),
	      isArg = !isArr && isArguments(value),
	      isBuff = !isArr && !isArg && isBuffer(value),
	      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	      skipIndexes = isArr || isArg || isBuff || isType,
	      result = skipIndexes ? baseTimes(value.length, String) : [],
	      length = result.length;

	  for (var key in value) {
	    if ((inherited || hasOwnProperty$6.call(value, key)) &&
	        !(skipIndexes && (
	           // Safari 9 has enumerable `arguments.length` in strict mode.
	           key == 'length' ||
	           // Node.js 0.10 has enumerable non-index properties on buffers.
	           (isBuff && (key == 'offset' || key == 'parent')) ||
	           // PhantomJS 2 has enumerable non-index properties on typed arrays.
	           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	           // Skip index properties.
	           isIndex(key, length)
	        ))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeKeys = overArg(Object.keys, Object);

	/** Used for built-in method references. */
	var objectProto$9 = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

	/**
	 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeys(object) {
	  if (!isPrototype(object)) {
	    return nativeKeys(object);
	  }
	  var result = [];
	  for (var key in Object(object)) {
	    if (hasOwnProperty$7.call(object, key) && key != 'constructor') {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Creates an array of the own enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects. See the
	 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * for more details.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keys(new Foo);
	 * // => ['a', 'b'] (iteration order is not guaranteed)
	 *
	 * _.keys('hi');
	 * // => ['0', '1']
	 */
	function keys(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	}

	/** Used for built-in method references. */
	var objectProto$a = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$8 = objectProto$a.hasOwnProperty;

	/**
	 * Assigns own enumerable string keyed properties of source objects to the
	 * destination object. Source objects are applied from left to right.
	 * Subsequent sources overwrite property assignments of previous sources.
	 *
	 * **Note:** This method mutates `object` and is loosely based on
	 * [`Object.assign`](https://mdn.io/Object/assign).
	 *
	 * @static
	 * @memberOf _
	 * @since 0.10.0
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @see _.assignIn
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * function Bar() {
	 *   this.c = 3;
	 * }
	 *
	 * Foo.prototype.b = 2;
	 * Bar.prototype.d = 4;
	 *
	 * _.assign({ 'a': 0 }, new Foo, new Bar);
	 * // => { 'a': 1, 'c': 3 }
	 */
	var assign = createAssigner(function(object, source) {
	  if (isPrototype(source) || isArrayLike(source)) {
	    copyObject(source, keys(source), object);
	    return;
	  }
	  for (var key in source) {
	    if (hasOwnProperty$8.call(source, key)) {
	      assignValue(object, key, source[key]);
	    }
	  }
	});

	/**
	 * This function is like
	 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	 * except that it includes inherited enumerable properties.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function nativeKeysIn(object) {
	  var result = [];
	  if (object != null) {
	    for (var key in Object(object)) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/** Used for built-in method references. */
	var objectProto$b = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$9 = objectProto$b.hasOwnProperty;

	/**
	 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 */
	function baseKeysIn(object) {
	  if (!isObject(object)) {
	    return nativeKeysIn(object);
	  }
	  var isProto = isPrototype(object),
	      result = [];

	  for (var key in object) {
	    if (!(key == 'constructor' && (isProto || !hasOwnProperty$9.call(object, key)))) {
	      result.push(key);
	    }
	  }
	  return result;
	}

	/**
	 * Creates an array of the own and inherited enumerable property names of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.keysIn(new Foo);
	 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	 */
	function keysIn$1(object) {
	  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	}

	/**
	 * This method is like `_.assign` except that it iterates over own and
	 * inherited source properties.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @alias extend
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @see _.assign
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * function Bar() {
	 *   this.c = 3;
	 * }
	 *
	 * Foo.prototype.b = 2;
	 * Bar.prototype.d = 4;
	 *
	 * _.assignIn({ 'a': 0 }, new Foo, new Bar);
	 * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
	 */
	var assignIn = createAssigner(function(object, source) {
	  copyObject(source, keysIn$1(source), object);
	});

	/**
	 * This method is like `_.assignIn` except that it accepts `customizer`
	 * which is invoked to produce the assigned values. If `customizer` returns
	 * `undefined`, assignment is handled by the method instead. The `customizer`
	 * is invoked with five arguments: (objValue, srcValue, key, object, source).
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @alias extendWith
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} sources The source objects.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @returns {Object} Returns `object`.
	 * @see _.assignWith
	 * @example
	 *
	 * function customizer(objValue, srcValue) {
	 *   return _.isUndefined(objValue) ? srcValue : objValue;
	 * }
	 *
	 * var defaults = _.partialRight(_.assignInWith, customizer);
	 *
	 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	 * // => { 'a': 1, 'b': 2 }
	 */
	var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
	  copyObject(source, keysIn$1(source), object, customizer);
	});

	/**
	 * This method is like `_.assign` except that it accepts `customizer`
	 * which is invoked to produce the assigned values. If `customizer` returns
	 * `undefined`, assignment is handled by the method instead. The `customizer`
	 * is invoked with five arguments: (objValue, srcValue, key, object, source).
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} sources The source objects.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @returns {Object} Returns `object`.
	 * @see _.assignInWith
	 * @example
	 *
	 * function customizer(objValue, srcValue) {
	 *   return _.isUndefined(objValue) ? srcValue : objValue;
	 * }
	 *
	 * var defaults = _.partialRight(_.assignWith, customizer);
	 *
	 * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	 * // => { 'a': 1, 'b': 2 }
	 */
	var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
	  copyObject(source, keys(source), object, customizer);
	});

	/** Used to match property names within property paths. */
	var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	    reIsPlainProp = /^\w*$/;

	/**
	 * Checks if `value` is a property name and not a property path.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	 */
	function isKey(value, object) {
	  if (isArray(value)) {
	    return false;
	  }
	  var type = typeof value;
	  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	      value == null || isSymbol(value)) {
	    return true;
	  }
	  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	    (object != null && value in Object(object));
	}

	/* Built-in method references that are verified to be native. */
	var nativeCreate = getNative(Object, 'create');

	/**
	 * Removes all key-value entries from the hash.
	 *
	 * @private
	 * @name clear
	 * @memberOf Hash
	 */
	function hashClear() {
	  this.__data__ = nativeCreate ? nativeCreate(null) : {};
	  this.size = 0;
	}

	/**
	 * Removes `key` and its value from the hash.
	 *
	 * @private
	 * @name delete
	 * @memberOf Hash
	 * @param {Object} hash The hash to modify.
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function hashDelete(key) {
	  var result = this.has(key) && delete this.__data__[key];
	  this.size -= result ? 1 : 0;
	  return result;
	}

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED = '__lodash_hash_undefined__';

	/** Used for built-in method references. */
	var objectProto$c = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$a = objectProto$c.hasOwnProperty;

	/**
	 * Gets the hash value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Hash
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function hashGet(key) {
	  var data = this.__data__;
	  if (nativeCreate) {
	    var result = data[key];
	    return result === HASH_UNDEFINED ? undefined : result;
	  }
	  return hasOwnProperty$a.call(data, key) ? data[key] : undefined;
	}

	/** Used for built-in method references. */
	var objectProto$d = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$b = objectProto$d.hasOwnProperty;

	/**
	 * Checks if a hash value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Hash
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function hashHas(key) {
	  var data = this.__data__;
	  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty$b.call(data, key);
	}

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

	/**
	 * Sets the hash `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Hash
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the hash instance.
	 */
	function hashSet(key, value) {
	  var data = this.__data__;
	  this.size += this.has(key) ? 0 : 1;
	  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
	  return this;
	}

	/**
	 * Creates a hash object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Hash(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `Hash`.
	Hash.prototype.clear = hashClear;
	Hash.prototype['delete'] = hashDelete;
	Hash.prototype.get = hashGet;
	Hash.prototype.has = hashHas;
	Hash.prototype.set = hashSet;

	/**
	 * Removes all key-value entries from the list cache.
	 *
	 * @private
	 * @name clear
	 * @memberOf ListCache
	 */
	function listCacheClear() {
	  this.__data__ = [];
	  this.size = 0;
	}

	/**
	 * Gets the index at which the `key` is found in `array` of key-value pairs.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} key The key to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function assocIndexOf(array, key) {
	  var length = array.length;
	  while (length--) {
	    if (eq(array[length][0], key)) {
	      return length;
	    }
	  }
	  return -1;
	}

	/** Used for built-in method references. */
	var arrayProto = Array.prototype;

	/** Built-in value references. */
	var splice = arrayProto.splice;

	/**
	 * Removes `key` and its value from the list cache.
	 *
	 * @private
	 * @name delete
	 * @memberOf ListCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function listCacheDelete(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    return false;
	  }
	  var lastIndex = data.length - 1;
	  if (index == lastIndex) {
	    data.pop();
	  } else {
	    splice.call(data, index, 1);
	  }
	  --this.size;
	  return true;
	}

	/**
	 * Gets the list cache value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf ListCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function listCacheGet(key) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  return index < 0 ? undefined : data[index][1];
	}

	/**
	 * Checks if a list cache value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf ListCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function listCacheHas(key) {
	  return assocIndexOf(this.__data__, key) > -1;
	}

	/**
	 * Sets the list cache `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf ListCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the list cache instance.
	 */
	function listCacheSet(key, value) {
	  var data = this.__data__,
	      index = assocIndexOf(data, key);

	  if (index < 0) {
	    ++this.size;
	    data.push([key, value]);
	  } else {
	    data[index][1] = value;
	  }
	  return this;
	}

	/**
	 * Creates an list cache object.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function ListCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `ListCache`.
	ListCache.prototype.clear = listCacheClear;
	ListCache.prototype['delete'] = listCacheDelete;
	ListCache.prototype.get = listCacheGet;
	ListCache.prototype.has = listCacheHas;
	ListCache.prototype.set = listCacheSet;

	/* Built-in method references that are verified to be native. */
	var Map$1 = getNative(root, 'Map');

	/**
	 * Removes all key-value entries from the map.
	 *
	 * @private
	 * @name clear
	 * @memberOf MapCache
	 */
	function mapCacheClear() {
	  this.size = 0;
	  this.__data__ = {
	    'hash': new Hash,
	    'map': new (Map$1 || ListCache),
	    'string': new Hash
	  };
	}

	/**
	 * Checks if `value` is suitable for use as unique object key.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	 */
	function isKeyable(value) {
	  var type = typeof value;
	  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	    ? (value !== '__proto__')
	    : (value === null);
	}

	/**
	 * Gets the data for `map`.
	 *
	 * @private
	 * @param {Object} map The map to query.
	 * @param {string} key The reference key.
	 * @returns {*} Returns the map data.
	 */
	function getMapData(map, key) {
	  var data = map.__data__;
	  return isKeyable(key)
	    ? data[typeof key == 'string' ? 'string' : 'hash']
	    : data.map;
	}

	/**
	 * Removes `key` and its value from the map.
	 *
	 * @private
	 * @name delete
	 * @memberOf MapCache
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function mapCacheDelete(key) {
	  var result = getMapData(this, key)['delete'](key);
	  this.size -= result ? 1 : 0;
	  return result;
	}

	/**
	 * Gets the map value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf MapCache
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function mapCacheGet(key) {
	  return getMapData(this, key).get(key);
	}

	/**
	 * Checks if a map value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf MapCache
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function mapCacheHas(key) {
	  return getMapData(this, key).has(key);
	}

	/**
	 * Sets the map `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf MapCache
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the map cache instance.
	 */
	function mapCacheSet(key, value) {
	  var data = getMapData(this, key),
	      size = data.size;

	  data.set(key, value);
	  this.size += data.size == size ? 0 : 1;
	  return this;
	}

	/**
	 * Creates a map cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function MapCache(entries) {
	  var index = -1,
	      length = entries == null ? 0 : entries.length;

	  this.clear();
	  while (++index < length) {
	    var entry = entries[index];
	    this.set(entry[0], entry[1]);
	  }
	}

	// Add methods to `MapCache`.
	MapCache.prototype.clear = mapCacheClear;
	MapCache.prototype['delete'] = mapCacheDelete;
	MapCache.prototype.get = mapCacheGet;
	MapCache.prototype.has = mapCacheHas;
	MapCache.prototype.set = mapCacheSet;

	/** Error message constants. */
	var FUNC_ERROR_TEXT$2 = 'Expected a function';

	/**
	 * Creates a function that memoizes the result of `func`. If `resolver` is
	 * provided, it determines the cache key for storing the result based on the
	 * arguments provided to the memoized function. By default, the first argument
	 * provided to the memoized function is used as the map cache key. The `func`
	 * is invoked with the `this` binding of the memoized function.
	 *
	 * **Note:** The cache is exposed as the `cache` property on the memoized
	 * function. Its creation may be customized by replacing the `_.memoize.Cache`
	 * constructor with one whose instances implement the
	 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to have its output memoized.
	 * @param {Function} [resolver] The function to resolve the cache key.
	 * @returns {Function} Returns the new memoized function.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 * var other = { 'c': 3, 'd': 4 };
	 *
	 * var values = _.memoize(_.values);
	 * values(object);
	 * // => [1, 2]
	 *
	 * values(other);
	 * // => [3, 4]
	 *
	 * object.a = 2;
	 * values(object);
	 * // => [1, 2]
	 *
	 * // Modify the result cache.
	 * values.cache.set(object, ['a', 'b']);
	 * values(object);
	 * // => ['a', 'b']
	 *
	 * // Replace `_.memoize.Cache`.
	 * _.memoize.Cache = WeakMap;
	 */
	function memoize(func, resolver) {
	  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	    throw new TypeError(FUNC_ERROR_TEXT$2);
	  }
	  var memoized = function() {
	    var args = arguments,
	        key = resolver ? resolver.apply(this, args) : args[0],
	        cache = memoized.cache;

	    if (cache.has(key)) {
	      return cache.get(key);
	    }
	    var result = func.apply(this, args);
	    memoized.cache = cache.set(key, result) || cache;
	    return result;
	  };
	  memoized.cache = new (memoize.Cache || MapCache);
	  return memoized;
	}

	// Expose `MapCache`.
	memoize.Cache = MapCache;

	/** Used as the maximum memoize cache size. */
	var MAX_MEMOIZE_SIZE = 500;

	/**
	 * A specialized version of `_.memoize` which clears the memoized function's
	 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	 *
	 * @private
	 * @param {Function} func The function to have its output memoized.
	 * @returns {Function} Returns the new memoized function.
	 */
	function memoizeCapped(func) {
	  var result = memoize(func, function(key) {
	    if (cache.size === MAX_MEMOIZE_SIZE) {
	      cache.clear();
	    }
	    return key;
	  });

	  var cache = result.cache;
	  return result;
	}

	/** Used to match property names within property paths. */
	var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	/** Used to match backslashes in property paths. */
	var reEscapeChar = /\\(\\)?/g;

	/**
	 * Converts `string` to a property path array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the property path array.
	 */
	var stringToPath = memoizeCapped(function(string) {
	  var result = [];
	  if (string.charCodeAt(0) === 46 /* . */) {
	    result.push('');
	  }
	  string.replace(rePropName, function(match, number, quote, subString) {
	    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
	  });
	  return result;
	});

	/**
	 * Converts `value` to a string. An empty string is returned for `null`
	 * and `undefined` values. The sign of `-0` is preserved.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.toString(null);
	 * // => ''
	 *
	 * _.toString(-0);
	 * // => '-0'
	 *
	 * _.toString([1, 2, 3]);
	 * // => '1,2,3'
	 */
	function toString(value) {
	  return value == null ? '' : baseToString(value);
	}

	/**
	 * Casts `value` to a path array if it's not one.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {Object} [object] The object to query keys on.
	 * @returns {Array} Returns the cast property path array.
	 */
	function castPath(value, object) {
	  if (isArray(value)) {
	    return value;
	  }
	  return isKey(value, object) ? [value] : stringToPath(toString(value));
	}

	/** Used as references for various `Number` constants. */
	var INFINITY$2 = 1 / 0;

	/**
	 * Converts `value` to a string key if it's not a string or symbol.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {string|symbol} Returns the key.
	 */
	function toKey(value) {
	  if (typeof value == 'string' || isSymbol(value)) {
	    return value;
	  }
	  var result = (value + '');
	  return (result == '0' && (1 / value) == -INFINITY$2) ? '-0' : result;
	}

	/**
	 * The base implementation of `_.get` without support for default values.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @returns {*} Returns the resolved value.
	 */
	function baseGet(object, path) {
	  path = castPath(path, object);

	  var index = 0,
	      length = path.length;

	  while (object != null && index < length) {
	    object = object[toKey(path[index++])];
	  }
	  return (index && index == length) ? object : undefined;
	}

	/**
	 * Gets the value at `path` of `object`. If the resolved value is
	 * `undefined`, the `defaultValue` is returned in its place.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.get(object, 'a[0].b.c');
	 * // => 3
	 *
	 * _.get(object, ['a', '0', 'b', 'c']);
	 * // => 3
	 *
	 * _.get(object, 'a.b.c', 'default');
	 * // => 'default'
	 */
	function get(object, path, defaultValue) {
	  var result = object == null ? undefined : baseGet(object, path);
	  return result === undefined ? defaultValue : result;
	}

	/**
	 * The base implementation of `_.at` without support for individual paths.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {string[]} paths The property paths to pick.
	 * @returns {Array} Returns the picked elements.
	 */
	function baseAt(object, paths) {
	  var index = -1,
	      length = paths.length,
	      result = Array(length),
	      skip = object == null;

	  while (++index < length) {
	    result[index] = skip ? undefined : get(object, paths[index]);
	  }
	  return result;
	}

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	/** Built-in value references. */
	var spreadableSymbol = Symbol$1 ? Symbol$1.isConcatSpreadable : undefined;

	/**
	 * Checks if `value` is a flattenable `arguments` object or array.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	 */
	function isFlattenable(value) {
	  return isArray(value) || isArguments(value) ||
	    !!(spreadableSymbol && value && value[spreadableSymbol]);
	}

	/**
	 * The base implementation of `_.flatten` with support for restricting flattening.
	 *
	 * @private
	 * @param {Array} array The array to flatten.
	 * @param {number} depth The maximum recursion depth.
	 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
	 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
	 * @param {Array} [result=[]] The initial result value.
	 * @returns {Array} Returns the new flattened array.
	 */
	function baseFlatten(array, depth, predicate, isStrict, result) {
	  var index = -1,
	      length = array.length;

	  predicate || (predicate = isFlattenable);
	  result || (result = []);

	  while (++index < length) {
	    var value = array[index];
	    if (depth > 0 && predicate(value)) {
	      if (depth > 1) {
	        // Recursively flatten arrays (susceptible to call stack limits).
	        baseFlatten(value, depth - 1, predicate, isStrict, result);
	      } else {
	        arrayPush(result, value);
	      }
	    } else if (!isStrict) {
	      result[result.length] = value;
	    }
	  }
	  return result;
	}

	/**
	 * Flattens `array` a single level deep.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to flatten.
	 * @returns {Array} Returns the new flattened array.
	 * @example
	 *
	 * _.flatten([1, [2, [3, [4]], 5]]);
	 * // => [1, 2, [3, [4]], 5]
	 */
	function flatten$1(array) {
	  var length = array == null ? 0 : array.length;
	  return length ? baseFlatten(array, 1) : [];
	}

	/**
	 * A specialized version of `baseRest` which flattens the rest array.
	 *
	 * @private
	 * @param {Function} func The function to apply a rest parameter to.
	 * @returns {Function} Returns the new function.
	 */
	function flatRest(func) {
	  return setToString(overRest(func, undefined, flatten$1), func + '');
	}

	/**
	 * Creates an array of values corresponding to `paths` of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.0.0
	 * @category Object
	 * @param {Object} object The object to iterate over.
	 * @param {...(string|string[])} [paths] The property paths to pick.
	 * @returns {Array} Returns the picked values.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
	 *
	 * _.at(object, ['a[0].b.c', 'a[1]']);
	 * // => [3, 4]
	 */
	var at = flatRest(baseAt);

	/** Built-in value references. */
	var getPrototype = overArg(Object.getPrototypeOf, Object);

	/** `Object#toString` result references. */
	var objectTag$1 = '[object Object]';

	/** Used for built-in method references. */
	var funcProto$2 = Function.prototype,
	    objectProto$e = Object.prototype;

	/** Used to resolve the decompiled source of functions. */
	var funcToString$2 = funcProto$2.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty$c = objectProto$e.hasOwnProperty;

	/** Used to infer the `Object` constructor. */
	var objectCtorString = funcToString$2.call(Object);

	/**
	 * Checks if `value` is a plain object, that is, an object created by the
	 * `Object` constructor or one with a `[[Prototype]]` of `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.8.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 * }
	 *
	 * _.isPlainObject(new Foo);
	 * // => false
	 *
	 * _.isPlainObject([1, 2, 3]);
	 * // => false
	 *
	 * _.isPlainObject({ 'x': 0, 'y': 0 });
	 * // => true
	 *
	 * _.isPlainObject(Object.create(null));
	 * // => true
	 */
	function isPlainObject(value) {
	  if (!isObjectLike(value) || baseGetTag(value) != objectTag$1) {
	    return false;
	  }
	  var proto = getPrototype(value);
	  if (proto === null) {
	    return true;
	  }
	  var Ctor = hasOwnProperty$c.call(proto, 'constructor') && proto.constructor;
	  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	    funcToString$2.call(Ctor) == objectCtorString;
	}

	/** `Object#toString` result references. */
	var domExcTag = '[object DOMException]',
	    errorTag$1 = '[object Error]';

	/**
	 * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
	 * `SyntaxError`, `TypeError`, or `URIError` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
	 * @example
	 *
	 * _.isError(new Error);
	 * // => true
	 *
	 * _.isError(Error);
	 * // => false
	 */
	function isError(value) {
	  if (!isObjectLike(value)) {
	    return false;
	  }
	  var tag = baseGetTag(value);
	  return tag == errorTag$1 || tag == domExcTag ||
	    (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
	}

	/**
	 * Attempts to invoke `func`, returning either the result or the caught error
	 * object. Any additional arguments are provided to `func` when it's invoked.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Util
	 * @param {Function} func The function to attempt.
	 * @param {...*} [args] The arguments to invoke `func` with.
	 * @returns {*} Returns the `func` result or error object.
	 * @example
	 *
	 * // Avoid throwing errors for invalid selectors.
	 * var elements = _.attempt(function(selector) {
	 *   return document.querySelectorAll(selector);
	 * }, '>_>');
	 *
	 * if (_.isError(elements)) {
	 *   elements = [];
	 * }
	 */
	var attempt = baseRest(function(func, args) {
	  try {
	    return apply(func, undefined, args);
	  } catch (e) {
	    return isError(e) ? e : new Error(e);
	  }
	});

	/** Error message constants. */
	var FUNC_ERROR_TEXT$3 = 'Expected a function';

	/**
	 * Creates a function that invokes `func`, with the `this` binding and arguments
	 * of the created function, while it's called less than `n` times. Subsequent
	 * calls to the created function return the result of the last `func` invocation.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Function
	 * @param {number} n The number of calls at which `func` is no longer invoked.
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new restricted function.
	 * @example
	 *
	 * jQuery(element).on('click', _.before(5, addContactToList));
	 * // => Allows adding up to 4 contacts to the list.
	 */
	function before(n, func) {
	  var result;
	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT$3);
	  }
	  n = toInteger(n);
	  return function() {
	    if (--n > 0) {
	      result = func.apply(this, arguments);
	    }
	    if (n <= 1) {
	      func = undefined;
	    }
	    return result;
	  };
	}

	/** Used to compose bitmasks for function metadata. */
	var WRAP_BIND_FLAG$7 = 1,
	    WRAP_PARTIAL_FLAG$3 = 32;

	/**
	 * Creates a function that invokes `func` with the `this` binding of `thisArg`
	 * and `partials` prepended to the arguments it receives.
	 *
	 * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
	 * may be used as a placeholder for partially applied arguments.
	 *
	 * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
	 * property of bound functions.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to bind.
	 * @param {*} thisArg The `this` binding of `func`.
	 * @param {...*} [partials] The arguments to be partially applied.
	 * @returns {Function} Returns the new bound function.
	 * @example
	 *
	 * function greet(greeting, punctuation) {
	 *   return greeting + ' ' + this.user + punctuation;
	 * }
	 *
	 * var object = { 'user': 'fred' };
	 *
	 * var bound = _.bind(greet, object, 'hi');
	 * bound('!');
	 * // => 'hi fred!'
	 *
	 * // Bound with placeholders.
	 * var bound = _.bind(greet, object, _, '!');
	 * bound('hi');
	 * // => 'hi fred!'
	 */
	var bind = baseRest(function(func, thisArg, partials) {
	  var bitmask = WRAP_BIND_FLAG$7;
	  if (partials.length) {
	    var holders = replaceHolders(partials, getHolder(bind));
	    bitmask |= WRAP_PARTIAL_FLAG$3;
	  }
	  return createWrap(func, bitmask, thisArg, partials, holders);
	});

	// Assign default placeholders.
	bind.placeholder = {};

	/**
	 * Binds methods of an object to the object itself, overwriting the existing
	 * method.
	 *
	 * **Note:** This method doesn't set the "length" property of bound functions.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {Object} object The object to bind and assign the bound methods to.
	 * @param {...(string|string[])} methodNames The object method names to bind.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var view = {
	 *   'label': 'docs',
	 *   'click': function() {
	 *     console.log('clicked ' + this.label);
	 *   }
	 * };
	 *
	 * _.bindAll(view, ['click']);
	 * jQuery(element).on('click', view.click);
	 * // => Logs 'clicked docs' when clicked.
	 */
	var bindAll = flatRest(function(object, methodNames) {
	  arrayEach(methodNames, function(key) {
	    key = toKey(key);
	    baseAssignValue(object, key, bind(object[key], object));
	  });
	  return object;
	});

	/** Used to compose bitmasks for function metadata. */
	var WRAP_BIND_FLAG$8 = 1,
	    WRAP_BIND_KEY_FLAG$5 = 2,
	    WRAP_PARTIAL_FLAG$4 = 32;

	/**
	 * Creates a function that invokes the method at `object[key]` with `partials`
	 * prepended to the arguments it receives.
	 *
	 * This method differs from `_.bind` by allowing bound functions to reference
	 * methods that may be redefined or don't yet exist. See
	 * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
	 * for more details.
	 *
	 * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
	 * builds, may be used as a placeholder for partially applied arguments.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.10.0
	 * @category Function
	 * @param {Object} object The object to invoke the method on.
	 * @param {string} key The key of the method.
	 * @param {...*} [partials] The arguments to be partially applied.
	 * @returns {Function} Returns the new bound function.
	 * @example
	 *
	 * var object = {
	 *   'user': 'fred',
	 *   'greet': function(greeting, punctuation) {
	 *     return greeting + ' ' + this.user + punctuation;
	 *   }
	 * };
	 *
	 * var bound = _.bindKey(object, 'greet', 'hi');
	 * bound('!');
	 * // => 'hi fred!'
	 *
	 * object.greet = function(greeting, punctuation) {
	 *   return greeting + 'ya ' + this.user + punctuation;
	 * };
	 *
	 * bound('!');
	 * // => 'hiya fred!'
	 *
	 * // Bound with placeholders.
	 * var bound = _.bindKey(object, 'greet', _, '!');
	 * bound('hi');
	 * // => 'hiya fred!'
	 */
	var bindKey = baseRest(function(object, key, partials) {
	  var bitmask = WRAP_BIND_FLAG$8 | WRAP_BIND_KEY_FLAG$5;
	  if (partials.length) {
	    var holders = replaceHolders(partials, getHolder(bindKey));
	    bitmask |= WRAP_PARTIAL_FLAG$4;
	  }
	  return createWrap(key, bitmask, object, partials, holders);
	});

	// Assign default placeholders.
	bindKey.placeholder = {};

	/**
	 * The base implementation of `_.slice` without an iteratee call guard.
	 *
	 * @private
	 * @param {Array} array The array to slice.
	 * @param {number} [start=0] The start position.
	 * @param {number} [end=array.length] The end position.
	 * @returns {Array} Returns the slice of `array`.
	 */
	function baseSlice(array, start, end) {
	  var index = -1,
	      length = array.length;

	  if (start < 0) {
	    start = -start > length ? 0 : (length + start);
	  }
	  end = end > length ? length : end;
	  if (end < 0) {
	    end += length;
	  }
	  length = start > end ? 0 : ((end - start) >>> 0);
	  start >>>= 0;

	  var result = Array(length);
	  while (++index < length) {
	    result[index] = array[index + start];
	  }
	  return result;
	}

	/**
	 * Casts `array` to a slice if it's needed.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {number} start The start position.
	 * @param {number} [end=array.length] The end position.
	 * @returns {Array} Returns the cast slice.
	 */
	function castSlice(array, start, end) {
	  var length = array.length;
	  end = end === undefined ? length : end;
	  return (!start && end >= length) ? array : baseSlice(array, start, end);
	}

	/** Used to compose unicode character classes. */
	var rsAstralRange = '\\ud800-\\udfff',
	    rsComboMarksRange = '\\u0300-\\u036f',
	    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
	    rsComboSymbolsRange = '\\u20d0-\\u20ff',
	    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
	    rsVarRange = '\\ufe0e\\ufe0f';

	/** Used to compose unicode capture groups. */
	var rsZWJ = '\\u200d';

	/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
	var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

	/**
	 * Checks if `string` contains Unicode symbols.
	 *
	 * @private
	 * @param {string} string The string to inspect.
	 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
	 */
	function hasUnicode(string) {
	  return reHasUnicode.test(string);
	}

	/**
	 * Converts an ASCII `string` to an array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the converted array.
	 */
	function asciiToArray(string) {
	  return string.split('');
	}

	/** Used to compose unicode character classes. */
	var rsAstralRange$1 = '\\ud800-\\udfff',
	    rsComboMarksRange$1 = '\\u0300-\\u036f',
	    reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f',
	    rsComboSymbolsRange$1 = '\\u20d0-\\u20ff',
	    rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1,
	    rsVarRange$1 = '\\ufe0e\\ufe0f';

	/** Used to compose unicode capture groups. */
	var rsAstral = '[' + rsAstralRange$1 + ']',
	    rsCombo = '[' + rsComboRange$1 + ']',
	    rsFitz = '\\ud83c[\\udffb-\\udfff]',
	    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
	    rsNonAstral = '[^' + rsAstralRange$1 + ']',
	    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
	    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
	    rsZWJ$1 = '\\u200d';

	/** Used to compose unicode regexes. */
	var reOptMod = rsModifier + '?',
	    rsOptVar = '[' + rsVarRange$1 + ']?',
	    rsOptJoin = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
	    rsSeq = rsOptVar + reOptMod + rsOptJoin,
	    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

	/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
	var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

	/**
	 * Converts a Unicode `string` to an array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the converted array.
	 */
	function unicodeToArray(string) {
	  return string.match(reUnicode) || [];
	}

	/**
	 * Converts `string` to an array.
	 *
	 * @private
	 * @param {string} string The string to convert.
	 * @returns {Array} Returns the converted array.
	 */
	function stringToArray(string) {
	  return hasUnicode(string)
	    ? unicodeToArray(string)
	    : asciiToArray(string);
	}

	/**
	 * Creates a function like `_.lowerFirst`.
	 *
	 * @private
	 * @param {string} methodName The name of the `String` case method to use.
	 * @returns {Function} Returns the new case function.
	 */
	function createCaseFirst(methodName) {
	  return function(string) {
	    string = toString(string);

	    var strSymbols = hasUnicode(string)
	      ? stringToArray(string)
	      : undefined;

	    var chr = strSymbols
	      ? strSymbols[0]
	      : string.charAt(0);

	    var trailing = strSymbols
	      ? castSlice(strSymbols, 1).join('')
	      : string.slice(1);

	    return chr[methodName]() + trailing;
	  };
	}

	/**
	 * Converts the first character of `string` to upper case.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category String
	 * @param {string} [string=''] The string to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.upperFirst('fred');
	 * // => 'Fred'
	 *
	 * _.upperFirst('FRED');
	 * // => 'FRED'
	 */
	var upperFirst = createCaseFirst('toUpperCase');

	/**
	 * Converts the first character of `string` to upper case and the remaining
	 * to lower case.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to capitalize.
	 * @returns {string} Returns the capitalized string.
	 * @example
	 *
	 * _.capitalize('FRED');
	 * // => 'Fred'
	 */
	function capitalize(string) {
	  return upperFirst(toString(string).toLowerCase());
	}

	/**
	 * A specialized version of `_.reduce` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {*} [accumulator] The initial value.
	 * @param {boolean} [initAccum] Specify using the first element of `array` as
	 *  the initial value.
	 * @returns {*} Returns the accumulated value.
	 */
	function arrayReduce(array, iteratee, accumulator, initAccum) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  if (initAccum && length) {
	    accumulator = array[++index];
	  }
	  while (++index < length) {
	    accumulator = iteratee(accumulator, array[index], index, array);
	  }
	  return accumulator;
	}

	/**
	 * The base implementation of `_.propertyOf` without support for deep paths.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Function} Returns the new accessor function.
	 */
	function basePropertyOf(object) {
	  return function(key) {
	    return object == null ? undefined : object[key];
	  };
	}

	/** Used to map Latin Unicode letters to basic Latin letters. */
	var deburredLetters = {
	  // Latin-1 Supplement block.
	  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
	  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
	  '\xc7': 'C',  '\xe7': 'c',
	  '\xd0': 'D',  '\xf0': 'd',
	  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
	  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
	  '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
	  '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
	  '\xd1': 'N',  '\xf1': 'n',
	  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
	  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
	  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
	  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
	  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
	  '\xc6': 'Ae', '\xe6': 'ae',
	  '\xde': 'Th', '\xfe': 'th',
	  '\xdf': 'ss',
	  // Latin Extended-A block.
	  '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
	  '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
	  '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
	  '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
	  '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
	  '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
	  '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
	  '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
	  '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
	  '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
	  '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
	  '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
	  '\u0134': 'J',  '\u0135': 'j',
	  '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
	  '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
	  '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
	  '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
	  '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
	  '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
	  '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
	  '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
	  '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
	  '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
	  '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
	  '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
	  '\u0163': 't',  '\u0165': 't', '\u0167': 't',
	  '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
	  '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
	  '\u0174': 'W',  '\u0175': 'w',
	  '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
	  '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
	  '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
	  '\u0132': 'IJ', '\u0133': 'ij',
	  '\u0152': 'Oe', '\u0153': 'oe',
	  '\u0149': "'n", '\u017f': 's'
	};

	/**
	 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
	 * letters to basic Latin letters.
	 *
	 * @private
	 * @param {string} letter The matched letter to deburr.
	 * @returns {string} Returns the deburred letter.
	 */
	var deburrLetter = basePropertyOf(deburredLetters);

	/** Used to match Latin Unicode letters (excluding mathematical operators). */
	var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

	/** Used to compose unicode character classes. */
	var rsComboMarksRange$2 = '\\u0300-\\u036f',
	    reComboHalfMarksRange$2 = '\\ufe20-\\ufe2f',
	    rsComboSymbolsRange$2 = '\\u20d0-\\u20ff',
	    rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2;

	/** Used to compose unicode capture groups. */
	var rsCombo$1 = '[' + rsComboRange$2 + ']';

	/**
	 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
	 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
	 */
	var reComboMark = RegExp(rsCombo$1, 'g');

	/**
	 * Deburrs `string` by converting
	 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
	 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
	 * letters to basic Latin letters and removing
	 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to deburr.
	 * @returns {string} Returns the deburred string.
	 * @example
	 *
	 * _.deburr('déjà vu');
	 * // => 'deja vu'
	 */
	function deburr(string) {
	  string = toString(string);
	  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
	}

	/** Used to match words composed of alphanumeric characters. */
	var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

	/**
	 * Splits an ASCII `string` into an array of its words.
	 *
	 * @private
	 * @param {string} The string to inspect.
	 * @returns {Array} Returns the words of `string`.
	 */
	function asciiWords(string) {
	  return string.match(reAsciiWord) || [];
	}

	/** Used to detect strings that need a more robust regexp to match words. */
	var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

	/**
	 * Checks if `string` contains a word composed of Unicode symbols.
	 *
	 * @private
	 * @param {string} string The string to inspect.
	 * @returns {boolean} Returns `true` if a word is found, else `false`.
	 */
	function hasUnicodeWord(string) {
	  return reHasUnicodeWord.test(string);
	}

	/** Used to compose unicode character classes. */
	var rsAstralRange$2 = '\\ud800-\\udfff',
	    rsComboMarksRange$3 = '\\u0300-\\u036f',
	    reComboHalfMarksRange$3 = '\\ufe20-\\ufe2f',
	    rsComboSymbolsRange$3 = '\\u20d0-\\u20ff',
	    rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3,
	    rsDingbatRange = '\\u2700-\\u27bf',
	    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
	    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
	    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
	    rsPunctuationRange = '\\u2000-\\u206f',
	    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
	    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
	    rsVarRange$2 = '\\ufe0e\\ufe0f',
	    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

	/** Used to compose unicode capture groups. */
	var rsApos = "['\u2019]",
	    rsBreak = '[' + rsBreakRange + ']',
	    rsCombo$2 = '[' + rsComboRange$3 + ']',
	    rsDigits = '\\d+',
	    rsDingbat = '[' + rsDingbatRange + ']',
	    rsLower = '[' + rsLowerRange + ']',
	    rsMisc = '[^' + rsAstralRange$2 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
	    rsFitz$1 = '\\ud83c[\\udffb-\\udfff]',
	    rsModifier$1 = '(?:' + rsCombo$2 + '|' + rsFitz$1 + ')',
	    rsNonAstral$1 = '[^' + rsAstralRange$2 + ']',
	    rsRegional$1 = '(?:\\ud83c[\\udde6-\\uddff]){2}',
	    rsSurrPair$1 = '[\\ud800-\\udbff][\\udc00-\\udfff]',
	    rsUpper = '[' + rsUpperRange + ']',
	    rsZWJ$2 = '\\u200d';

	/** Used to compose unicode regexes. */
	var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
	    rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
	    rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
	    rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
	    reOptMod$1 = rsModifier$1 + '?',
	    rsOptVar$1 = '[' + rsVarRange$2 + ']?',
	    rsOptJoin$1 = '(?:' + rsZWJ$2 + '(?:' + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsOptVar$1 + reOptMod$1 + ')*',
	    rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
	    rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
	    rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1,
	    rsEmoji = '(?:' + [rsDingbat, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsSeq$1;

	/** Used to match complex or compound words. */
	var reUnicodeWord = RegExp([
	  rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
	  rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
	  rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
	  rsUpper + '+' + rsOptContrUpper,
	  rsOrdUpper,
	  rsOrdLower,
	  rsDigits,
	  rsEmoji
	].join('|'), 'g');

	/**
	 * Splits a Unicode `string` into an array of its words.
	 *
	 * @private
	 * @param {string} The string to inspect.
	 * @returns {Array} Returns the words of `string`.
	 */
	function unicodeWords(string) {
	  return string.match(reUnicodeWord) || [];
	}

	/**
	 * Splits `string` into an array of its words.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to inspect.
	 * @param {RegExp|string} [pattern] The pattern to match words.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {Array} Returns the words of `string`.
	 * @example
	 *
	 * _.words('fred, barney, & pebbles');
	 * // => ['fred', 'barney', 'pebbles']
	 *
	 * _.words('fred, barney, & pebbles', /[^, ]+/g);
	 * // => ['fred', 'barney', '&', 'pebbles']
	 */
	function words(string, pattern, guard) {
	  string = toString(string);
	  pattern = guard ? undefined : pattern;

	  if (pattern === undefined) {
	    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
	  }
	  return string.match(pattern) || [];
	}

	/** Used to compose unicode capture groups. */
	var rsApos$1 = "['\u2019]";

	/** Used to match apostrophes. */
	var reApos = RegExp(rsApos$1, 'g');

	/**
	 * Creates a function like `_.camelCase`.
	 *
	 * @private
	 * @param {Function} callback The function to combine each word.
	 * @returns {Function} Returns the new compounder function.
	 */
	function createCompounder(callback) {
	  return function(string) {
	    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
	  };
	}

	/**
	 * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to convert.
	 * @returns {string} Returns the camel cased string.
	 * @example
	 *
	 * _.camelCase('Foo Bar');
	 * // => 'fooBar'
	 *
	 * _.camelCase('--foo-bar--');
	 * // => 'fooBar'
	 *
	 * _.camelCase('__FOO_BAR__');
	 * // => 'fooBar'
	 */
	var camelCase = createCompounder(function(result, word, index) {
	  word = word.toLowerCase();
	  return result + (index ? capitalize(word) : word);
	});

	/**
	 * Casts `value` as an array if it's not one.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.4.0
	 * @category Lang
	 * @param {*} value The value to inspect.
	 * @returns {Array} Returns the cast array.
	 * @example
	 *
	 * _.castArray(1);
	 * // => [1]
	 *
	 * _.castArray({ 'a': 1 });
	 * // => [{ 'a': 1 }]
	 *
	 * _.castArray('abc');
	 * // => ['abc']
	 *
	 * _.castArray(null);
	 * // => [null]
	 *
	 * _.castArray(undefined);
	 * // => [undefined]
	 *
	 * _.castArray();
	 * // => []
	 *
	 * var array = [1, 2, 3];
	 * console.log(_.castArray(array) === array);
	 * // => true
	 */
	function castArray() {
	  if (!arguments.length) {
	    return [];
	  }
	  var value = arguments[0];
	  return isArray(value) ? value : [value];
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsFinite = root.isFinite,
	    nativeMin$2 = Math.min;

	/**
	 * Creates a function like `_.round`.
	 *
	 * @private
	 * @param {string} methodName The name of the `Math` method to use when rounding.
	 * @returns {Function} Returns the new round function.
	 */
	function createRound(methodName) {
	  var func = Math[methodName];
	  return function(number, precision) {
	    number = toNumber(number);
	    precision = precision == null ? 0 : nativeMin$2(toInteger(precision), 292);
	    if (precision && nativeIsFinite(number)) {
	      // Shift with exponential notation to avoid floating-point issues.
	      // See [MDN](https://mdn.io/round#Examples) for more details.
	      var pair = (toString(number) + 'e').split('e'),
	          value = func(pair[0] + 'e' + (+pair[1] + precision));

	      pair = (toString(value) + 'e').split('e');
	      return +(pair[0] + 'e' + (+pair[1] - precision));
	    }
	    return func(number);
	  };
	}

	/**
	 * Computes `number` rounded up to `precision`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.10.0
	 * @category Math
	 * @param {number} number The number to round up.
	 * @param {number} [precision=0] The precision to round up to.
	 * @returns {number} Returns the rounded up number.
	 * @example
	 *
	 * _.ceil(4.006);
	 * // => 5
	 *
	 * _.ceil(6.004, 2);
	 * // => 6.01
	 *
	 * _.ceil(6040, -2);
	 * // => 6100
	 */
	var ceil = createRound('ceil');

	/**
	 * Creates a `lodash` wrapper instance that wraps `value` with explicit method
	 * chain sequences enabled. The result of such sequences must be unwrapped
	 * with `_#value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.3.0
	 * @category Seq
	 * @param {*} value The value to wrap.
	 * @returns {Object} Returns the new `lodash` wrapper instance.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney',  'age': 36 },
	 *   { 'user': 'fred',    'age': 40 },
	 *   { 'user': 'pebbles', 'age': 1 }
	 * ];
	 *
	 * var youngest = _
	 *   .chain(users)
	 *   .sortBy('age')
	 *   .map(function(o) {
	 *     return o.user + ' is ' + o.age;
	 *   })
	 *   .head()
	 *   .value();
	 * // => 'pebbles is 1'
	 */
	function chain(value) {
	  var result = lodash(value);
	  result.__chain__ = true;
	  return result;
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeCeil = Math.ceil,
	    nativeMax$4 = Math.max;

	/**
	 * Creates an array of elements split into groups the length of `size`.
	 * If `array` can't be split evenly, the final chunk will be the remaining
	 * elements.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Array
	 * @param {Array} array The array to process.
	 * @param {number} [size=1] The length of each chunk
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {Array} Returns the new array of chunks.
	 * @example
	 *
	 * _.chunk(['a', 'b', 'c', 'd'], 2);
	 * // => [['a', 'b'], ['c', 'd']]
	 *
	 * _.chunk(['a', 'b', 'c', 'd'], 3);
	 * // => [['a', 'b', 'c'], ['d']]
	 */
	function chunk(array, size, guard) {
	  if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
	    size = 1;
	  } else {
	    size = nativeMax$4(toInteger(size), 0);
	  }
	  var length = array == null ? 0 : array.length;
	  if (!length || size < 1) {
	    return [];
	  }
	  var index = 0,
	      resIndex = 0,
	      result = Array(nativeCeil(length / size));

	  while (index < length) {
	    result[resIndex++] = baseSlice(array, index, (index += size));
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.clamp` which doesn't coerce arguments.
	 *
	 * @private
	 * @param {number} number The number to clamp.
	 * @param {number} [lower] The lower bound.
	 * @param {number} upper The upper bound.
	 * @returns {number} Returns the clamped number.
	 */
	function baseClamp(number, lower, upper) {
	  if (number === number) {
	    if (upper !== undefined) {
	      number = number <= upper ? number : upper;
	    }
	    if (lower !== undefined) {
	      number = number >= lower ? number : lower;
	    }
	  }
	  return number;
	}

	/**
	 * Clamps `number` within the inclusive `lower` and `upper` bounds.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Number
	 * @param {number} number The number to clamp.
	 * @param {number} [lower] The lower bound.
	 * @param {number} upper The upper bound.
	 * @returns {number} Returns the clamped number.
	 * @example
	 *
	 * _.clamp(-10, -5, 5);
	 * // => -5
	 *
	 * _.clamp(10, -5, 5);
	 * // => 5
	 */
	function clamp(number, lower, upper) {
	  if (upper === undefined) {
	    upper = lower;
	    lower = undefined;
	  }
	  if (upper !== undefined) {
	    upper = toNumber(upper);
	    upper = upper === upper ? upper : 0;
	  }
	  if (lower !== undefined) {
	    lower = toNumber(lower);
	    lower = lower === lower ? lower : 0;
	  }
	  return baseClamp(toNumber(number), lower, upper);
	}

	/**
	 * Removes all key-value entries from the stack.
	 *
	 * @private
	 * @name clear
	 * @memberOf Stack
	 */
	function stackClear() {
	  this.__data__ = new ListCache;
	  this.size = 0;
	}

	/**
	 * Removes `key` and its value from the stack.
	 *
	 * @private
	 * @name delete
	 * @memberOf Stack
	 * @param {string} key The key of the value to remove.
	 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	 */
	function stackDelete(key) {
	  var data = this.__data__,
	      result = data['delete'](key);

	  this.size = data.size;
	  return result;
	}

	/**
	 * Gets the stack value for `key`.
	 *
	 * @private
	 * @name get
	 * @memberOf Stack
	 * @param {string} key The key of the value to get.
	 * @returns {*} Returns the entry value.
	 */
	function stackGet(key) {
	  return this.__data__.get(key);
	}

	/**
	 * Checks if a stack value for `key` exists.
	 *
	 * @private
	 * @name has
	 * @memberOf Stack
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function stackHas(key) {
	  return this.__data__.has(key);
	}

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE = 200;

	/**
	 * Sets the stack `key` to `value`.
	 *
	 * @private
	 * @name set
	 * @memberOf Stack
	 * @param {string} key The key of the value to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns the stack cache instance.
	 */
	function stackSet(key, value) {
	  var data = this.__data__;
	  if (data instanceof ListCache) {
	    var pairs = data.__data__;
	    if (!Map$1 || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	      pairs.push([key, value]);
	      this.size = ++data.size;
	      return this;
	    }
	    data = this.__data__ = new MapCache(pairs);
	  }
	  data.set(key, value);
	  this.size = data.size;
	  return this;
	}

	/**
	 * Creates a stack cache object to store key-value pairs.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [entries] The key-value pairs to cache.
	 */
	function Stack(entries) {
	  var data = this.__data__ = new ListCache(entries);
	  this.size = data.size;
	}

	// Add methods to `Stack`.
	Stack.prototype.clear = stackClear;
	Stack.prototype['delete'] = stackDelete;
	Stack.prototype.get = stackGet;
	Stack.prototype.has = stackHas;
	Stack.prototype.set = stackSet;

	/**
	 * The base implementation of `_.assign` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssign(object, source) {
	  return object && copyObject(source, keys(source), object);
	}

	/**
	 * The base implementation of `_.assignIn` without support for multiple sources
	 * or `customizer` functions.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @returns {Object} Returns `object`.
	 */
	function baseAssignIn(object, source) {
	  return object && copyObject(source, keysIn$1(source), object);
	}

	/** Detect free variable `exports`. */
	var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;

	/** Built-in value references. */
	var Buffer$1 = moduleExports$2 ? root.Buffer : undefined,
	    allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : undefined;

	/**
	 * Creates a clone of  `buffer`.
	 *
	 * @private
	 * @param {Buffer} buffer The buffer to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Buffer} Returns the cloned buffer.
	 */
	function cloneBuffer(buffer, isDeep) {
	  if (isDeep) {
	    return buffer.slice();
	  }
	  var length = buffer.length,
	      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

	  buffer.copy(result);
	  return result;
	}

	/**
	 * A specialized version of `_.filter` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function arrayFilter(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	/**
	 * This method returns a new empty array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Array} Returns the new empty array.
	 * @example
	 *
	 * var arrays = _.times(2, _.stubArray);
	 *
	 * console.log(arrays);
	 * // => [[], []]
	 *
	 * console.log(arrays[0] === arrays[1]);
	 * // => false
	 */
	function stubArray() {
	  return [];
	}

	/** Used for built-in method references. */
	var objectProto$f = Object.prototype;

	/** Built-in value references. */
	var propertyIsEnumerable$1 = objectProto$f.propertyIsEnumerable;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
	  if (object == null) {
	    return [];
	  }
	  object = Object(object);
	  return arrayFilter(nativeGetSymbols(object), function(symbol) {
	    return propertyIsEnumerable$1.call(object, symbol);
	  });
	};

	/**
	 * Copies own symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbols(source, object) {
	  return copyObject(source, getSymbols(source), object);
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeGetSymbols$1 = Object.getOwnPropertySymbols;

	/**
	 * Creates an array of the own and inherited enumerable symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of symbols.
	 */
	var getSymbolsIn = !nativeGetSymbols$1 ? stubArray : function(object) {
	  var result = [];
	  while (object) {
	    arrayPush(result, getSymbols(object));
	    object = getPrototype(object);
	  }
	  return result;
	};

	/**
	 * Copies own and inherited symbols of `source` to `object`.
	 *
	 * @private
	 * @param {Object} source The object to copy symbols from.
	 * @param {Object} [object={}] The object to copy symbols to.
	 * @returns {Object} Returns `object`.
	 */
	function copySymbolsIn(source, object) {
	  return copyObject(source, getSymbolsIn(source), object);
	}

	/**
	 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @param {Function} symbolsFunc The function to get the symbols of `object`.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	  var result = keysFunc(object);
	  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	}

	/**
	 * Creates an array of own enumerable property names and symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeys(object) {
	  return baseGetAllKeys(object, keys, getSymbols);
	}

	/**
	 * Creates an array of own and inherited enumerable property names and
	 * symbols of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property names and symbols.
	 */
	function getAllKeysIn(object) {
	  return baseGetAllKeys(object, keysIn$1, getSymbolsIn);
	}

	/* Built-in method references that are verified to be native. */
	var DataView$1 = getNative(root, 'DataView');

	/* Built-in method references that are verified to be native. */
	var Promise = getNative(root, 'Promise');

	/* Built-in method references that are verified to be native. */
	var Set = getNative(root, 'Set');

	/** `Object#toString` result references. */
	var mapTag$1 = '[object Map]',
	    objectTag$2 = '[object Object]',
	    promiseTag = '[object Promise]',
	    setTag$1 = '[object Set]',
	    weakMapTag$1 = '[object WeakMap]';

	var dataViewTag$1 = '[object DataView]';

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView$1),
	    mapCtorString = toSource(Map$1),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap$1);

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	if ((DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$1) ||
	    (Map$1 && getTag(new Map$1) != mapTag$1) ||
	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag$1) ||
	    (WeakMap$1 && getTag(new WeakMap$1) != weakMapTag$1)) {
	  getTag = function(value) {
	    var result = baseGetTag(value),
	        Ctor = result == objectTag$2 ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : '';

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag$1;
	        case mapCtorString: return mapTag$1;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag$1;
	        case weakMapCtorString: return weakMapTag$1;
	      }
	    }
	    return result;
	  };
	}

	var getTag$1 = getTag;

	/** Used for built-in method references. */
	var objectProto$g = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$d = objectProto$g.hasOwnProperty;

	/**
	 * Initializes an array clone.
	 *
	 * @private
	 * @param {Array} array The array to clone.
	 * @returns {Array} Returns the initialized clone.
	 */
	function initCloneArray(array) {
	  var length = array.length,
	      result = new array.constructor(length);

	  // Add properties assigned by `RegExp#exec`.
	  if (length && typeof array[0] == 'string' && hasOwnProperty$d.call(array, 'index')) {
	    result.index = array.index;
	    result.input = array.input;
	  }
	  return result;
	}

	/** Built-in value references. */
	var Uint8Array$1 = root.Uint8Array;

	/**
	 * Creates a clone of `arrayBuffer`.
	 *
	 * @private
	 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	 * @returns {ArrayBuffer} Returns the cloned array buffer.
	 */
	function cloneArrayBuffer(arrayBuffer) {
	  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
	  return result;
	}

	/**
	 * Creates a clone of `dataView`.
	 *
	 * @private
	 * @param {Object} dataView The data view to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned data view.
	 */
	function cloneDataView(dataView, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
	  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
	}

	/** Used to match `RegExp` flags from their coerced string values. */
	var reFlags = /\w*$/;

	/**
	 * Creates a clone of `regexp`.
	 *
	 * @private
	 * @param {Object} regexp The regexp to clone.
	 * @returns {Object} Returns the cloned regexp.
	 */
	function cloneRegExp(regexp) {
	  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
	  result.lastIndex = regexp.lastIndex;
	  return result;
	}

	/** Used to convert symbols to primitives and strings. */
	var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : undefined,
	    symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : undefined;

	/**
	 * Creates a clone of the `symbol` object.
	 *
	 * @private
	 * @param {Object} symbol The symbol object to clone.
	 * @returns {Object} Returns the cloned symbol object.
	 */
	function cloneSymbol(symbol) {
	  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
	}

	/**
	 * Creates a clone of `typedArray`.
	 *
	 * @private
	 * @param {Object} typedArray The typed array to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the cloned typed array.
	 */
	function cloneTypedArray(typedArray, isDeep) {
	  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	}

	/** `Object#toString` result references. */
	var boolTag$1 = '[object Boolean]',
	    dateTag$1 = '[object Date]',
	    mapTag$2 = '[object Map]',
	    numberTag$1 = '[object Number]',
	    regexpTag$1 = '[object RegExp]',
	    setTag$2 = '[object Set]',
	    stringTag$1 = '[object String]',
	    symbolTag$1 = '[object Symbol]';

	var arrayBufferTag$1 = '[object ArrayBuffer]',
	    dataViewTag$2 = '[object DataView]',
	    float32Tag$1 = '[object Float32Array]',
	    float64Tag$1 = '[object Float64Array]',
	    int8Tag$1 = '[object Int8Array]',
	    int16Tag$1 = '[object Int16Array]',
	    int32Tag$1 = '[object Int32Array]',
	    uint8Tag$1 = '[object Uint8Array]',
	    uint8ClampedTag$1 = '[object Uint8ClampedArray]',
	    uint16Tag$1 = '[object Uint16Array]',
	    uint32Tag$1 = '[object Uint32Array]';

	/**
	 * Initializes an object clone based on its `toStringTag`.
	 *
	 * **Note:** This function only supports cloning values with tags of
	 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @param {string} tag The `toStringTag` of the object to clone.
	 * @param {boolean} [isDeep] Specify a deep clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneByTag(object, tag, isDeep) {
	  var Ctor = object.constructor;
	  switch (tag) {
	    case arrayBufferTag$1:
	      return cloneArrayBuffer(object);

	    case boolTag$1:
	    case dateTag$1:
	      return new Ctor(+object);

	    case dataViewTag$2:
	      return cloneDataView(object, isDeep);

	    case float32Tag$1: case float64Tag$1:
	    case int8Tag$1: case int16Tag$1: case int32Tag$1:
	    case uint8Tag$1: case uint8ClampedTag$1: case uint16Tag$1: case uint32Tag$1:
	      return cloneTypedArray(object, isDeep);

	    case mapTag$2:
	      return new Ctor;

	    case numberTag$1:
	    case stringTag$1:
	      return new Ctor(object);

	    case regexpTag$1:
	      return cloneRegExp(object);

	    case setTag$2:
	      return new Ctor;

	    case symbolTag$1:
	      return cloneSymbol(object);
	  }
	}

	/**
	 * Initializes an object clone.
	 *
	 * @private
	 * @param {Object} object The object to clone.
	 * @returns {Object} Returns the initialized clone.
	 */
	function initCloneObject(object) {
	  return (typeof object.constructor == 'function' && !isPrototype(object))
	    ? baseCreate(getPrototype(object))
	    : {};
	}

	/** `Object#toString` result references. */
	var mapTag$3 = '[object Map]';

	/**
	 * The base implementation of `_.isMap` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	 */
	function baseIsMap(value) {
	  return isObjectLike(value) && getTag$1(value) == mapTag$3;
	}

	/* Node.js helper references. */
	var nodeIsMap = nodeUtil && nodeUtil.isMap;

	/**
	 * Checks if `value` is classified as a `Map` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	 * @example
	 *
	 * _.isMap(new Map);
	 * // => true
	 *
	 * _.isMap(new WeakMap);
	 * // => false
	 */
	var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

	/** `Object#toString` result references. */
	var setTag$3 = '[object Set]';

	/**
	 * The base implementation of `_.isSet` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 */
	function baseIsSet(value) {
	  return isObjectLike(value) && getTag$1(value) == setTag$3;
	}

	/* Node.js helper references. */
	var nodeIsSet = nodeUtil && nodeUtil.isSet;

	/**
	 * Checks if `value` is classified as a `Set` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	 * @example
	 *
	 * _.isSet(new Set);
	 * // => true
	 *
	 * _.isSet(new WeakSet);
	 * // => false
	 */
	var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG = 1,
	    CLONE_FLAT_FLAG = 2,
	    CLONE_SYMBOLS_FLAG = 4;

	/** `Object#toString` result references. */
	var argsTag$2 = '[object Arguments]',
	    arrayTag$1 = '[object Array]',
	    boolTag$2 = '[object Boolean]',
	    dateTag$2 = '[object Date]',
	    errorTag$2 = '[object Error]',
	    funcTag$2 = '[object Function]',
	    genTag$1 = '[object GeneratorFunction]',
	    mapTag$4 = '[object Map]',
	    numberTag$2 = '[object Number]',
	    objectTag$3 = '[object Object]',
	    regexpTag$2 = '[object RegExp]',
	    setTag$4 = '[object Set]',
	    stringTag$2 = '[object String]',
	    symbolTag$2 = '[object Symbol]',
	    weakMapTag$2 = '[object WeakMap]';

	var arrayBufferTag$2 = '[object ArrayBuffer]',
	    dataViewTag$3 = '[object DataView]',
	    float32Tag$2 = '[object Float32Array]',
	    float64Tag$2 = '[object Float64Array]',
	    int8Tag$2 = '[object Int8Array]',
	    int16Tag$2 = '[object Int16Array]',
	    int32Tag$2 = '[object Int32Array]',
	    uint8Tag$2 = '[object Uint8Array]',
	    uint8ClampedTag$2 = '[object Uint8ClampedArray]',
	    uint16Tag$2 = '[object Uint16Array]',
	    uint32Tag$2 = '[object Uint32Array]';

	/** Used to identify `toStringTag` values supported by `_.clone`. */
	var cloneableTags = {};
	cloneableTags[argsTag$2] = cloneableTags[arrayTag$1] =
	cloneableTags[arrayBufferTag$2] = cloneableTags[dataViewTag$3] =
	cloneableTags[boolTag$2] = cloneableTags[dateTag$2] =
	cloneableTags[float32Tag$2] = cloneableTags[float64Tag$2] =
	cloneableTags[int8Tag$2] = cloneableTags[int16Tag$2] =
	cloneableTags[int32Tag$2] = cloneableTags[mapTag$4] =
	cloneableTags[numberTag$2] = cloneableTags[objectTag$3] =
	cloneableTags[regexpTag$2] = cloneableTags[setTag$4] =
	cloneableTags[stringTag$2] = cloneableTags[symbolTag$2] =
	cloneableTags[uint8Tag$2] = cloneableTags[uint8ClampedTag$2] =
	cloneableTags[uint16Tag$2] = cloneableTags[uint32Tag$2] = true;
	cloneableTags[errorTag$2] = cloneableTags[funcTag$2] =
	cloneableTags[weakMapTag$2] = false;

	/**
	 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
	 * traversed objects.
	 *
	 * @private
	 * @param {*} value The value to clone.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Deep clone
	 *  2 - Flatten inherited properties
	 *  4 - Clone symbols
	 * @param {Function} [customizer] The function to customize cloning.
	 * @param {string} [key] The key of `value`.
	 * @param {Object} [object] The parent object of `value`.
	 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
	 * @returns {*} Returns the cloned value.
	 */
	function baseClone(value, bitmask, customizer, key, object, stack) {
	  var result,
	      isDeep = bitmask & CLONE_DEEP_FLAG,
	      isFlat = bitmask & CLONE_FLAT_FLAG,
	      isFull = bitmask & CLONE_SYMBOLS_FLAG;

	  if (customizer) {
	    result = object ? customizer(value, key, object, stack) : customizer(value);
	  }
	  if (result !== undefined) {
	    return result;
	  }
	  if (!isObject(value)) {
	    return value;
	  }
	  var isArr = isArray(value);
	  if (isArr) {
	    result = initCloneArray(value);
	    if (!isDeep) {
	      return copyArray$1(value, result);
	    }
	  } else {
	    var tag = getTag$1(value),
	        isFunc = tag == funcTag$2 || tag == genTag$1;

	    if (isBuffer(value)) {
	      return cloneBuffer(value, isDeep);
	    }
	    if (tag == objectTag$3 || tag == argsTag$2 || (isFunc && !object)) {
	      result = (isFlat || isFunc) ? {} : initCloneObject(value);
	      if (!isDeep) {
	        return isFlat
	          ? copySymbolsIn(value, baseAssignIn(result, value))
	          : copySymbols(value, baseAssign(result, value));
	      }
	    } else {
	      if (!cloneableTags[tag]) {
	        return object ? value : {};
	      }
	      result = initCloneByTag(value, tag, isDeep);
	    }
	  }
	  // Check for circular references and return its corresponding clone.
	  stack || (stack = new Stack);
	  var stacked = stack.get(value);
	  if (stacked) {
	    return stacked;
	  }
	  stack.set(value, result);

	  if (isSet(value)) {
	    value.forEach(function(subValue) {
	      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
	    });
	  } else if (isMap(value)) {
	    value.forEach(function(subValue, key) {
	      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
	    });
	  }

	  var keysFunc = isFull
	    ? (isFlat ? getAllKeysIn : getAllKeys)
	    : (isFlat ? keysIn : keys);

	  var props = isArr ? undefined : keysFunc(value);
	  arrayEach(props || value, function(subValue, key) {
	    if (props) {
	      key = subValue;
	      subValue = value[key];
	    }
	    // Recursively populate clone (susceptible to call stack limits).
	    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
	  });
	  return result;
	}

	/** Used to compose bitmasks for cloning. */
	var CLONE_SYMBOLS_FLAG$1 = 4;

	/**
	 * Creates a shallow clone of `value`.
	 *
	 * **Note:** This method is loosely based on the
	 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
	 * and supports cloning arrays, array buffers, booleans, date objects, maps,
	 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
	 * arrays. The own enumerable properties of `arguments` objects are cloned
	 * as plain objects. An empty object is returned for uncloneable values such
	 * as error objects, functions, DOM nodes, and WeakMaps.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to clone.
	 * @returns {*} Returns the cloned value.
	 * @see _.cloneDeep
	 * @example
	 *
	 * var objects = [{ 'a': 1 }, { 'b': 2 }];
	 *
	 * var shallow = _.clone(objects);
	 * console.log(shallow[0] === objects[0]);
	 * // => true
	 */
	function clone(value) {
	  return baseClone(value, CLONE_SYMBOLS_FLAG$1);
	}

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG$1 = 1,
	    CLONE_SYMBOLS_FLAG$2 = 4;

	/**
	 * This method is like `_.clone` except that it recursively clones `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.0.0
	 * @category Lang
	 * @param {*} value The value to recursively clone.
	 * @returns {*} Returns the deep cloned value.
	 * @see _.clone
	 * @example
	 *
	 * var objects = [{ 'a': 1 }, { 'b': 2 }];
	 *
	 * var deep = _.cloneDeep(objects);
	 * console.log(deep[0] === objects[0]);
	 * // => false
	 */
	function cloneDeep(value) {
	  return baseClone(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$2);
	}

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG$2 = 1,
	    CLONE_SYMBOLS_FLAG$3 = 4;

	/**
	 * This method is like `_.cloneWith` except that it recursively clones `value`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to recursively clone.
	 * @param {Function} [customizer] The function to customize cloning.
	 * @returns {*} Returns the deep cloned value.
	 * @see _.cloneWith
	 * @example
	 *
	 * function customizer(value) {
	 *   if (_.isElement(value)) {
	 *     return value.cloneNode(true);
	 *   }
	 * }
	 *
	 * var el = _.cloneDeepWith(document.body, customizer);
	 *
	 * console.log(el === document.body);
	 * // => false
	 * console.log(el.nodeName);
	 * // => 'BODY'
	 * console.log(el.childNodes.length);
	 * // => 20
	 */
	function cloneDeepWith(value, customizer) {
	  customizer = typeof customizer == 'function' ? customizer : undefined;
	  return baseClone(value, CLONE_DEEP_FLAG$2 | CLONE_SYMBOLS_FLAG$3, customizer);
	}

	/** Used to compose bitmasks for cloning. */
	var CLONE_SYMBOLS_FLAG$4 = 4;

	/**
	 * This method is like `_.clone` except that it accepts `customizer` which
	 * is invoked to produce the cloned value. If `customizer` returns `undefined`,
	 * cloning is handled by the method instead. The `customizer` is invoked with
	 * up to four arguments; (value [, index|key, object, stack]).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to clone.
	 * @param {Function} [customizer] The function to customize cloning.
	 * @returns {*} Returns the cloned value.
	 * @see _.cloneDeepWith
	 * @example
	 *
	 * function customizer(value) {
	 *   if (_.isElement(value)) {
	 *     return value.cloneNode(false);
	 *   }
	 * }
	 *
	 * var el = _.cloneWith(document.body, customizer);
	 *
	 * console.log(el === document.body);
	 * // => false
	 * console.log(el.nodeName);
	 * // => 'BODY'
	 * console.log(el.childNodes.length);
	 * // => 0
	 */
	function cloneWith(value, customizer) {
	  customizer = typeof customizer == 'function' ? customizer : undefined;
	  return baseClone(value, CLONE_SYMBOLS_FLAG$4, customizer);
	}

	/**
	 * Executes the chain sequence and returns the wrapped result.
	 *
	 * @name commit
	 * @memberOf _
	 * @since 3.2.0
	 * @category Seq
	 * @returns {Object} Returns the new `lodash` wrapper instance.
	 * @example
	 *
	 * var array = [1, 2];
	 * var wrapped = _(array).push(3);
	 *
	 * console.log(array);
	 * // => [1, 2]
	 *
	 * wrapped = wrapped.commit();
	 * console.log(array);
	 * // => [1, 2, 3]
	 *
	 * wrapped.last();
	 * // => 3
	 *
	 * console.log(array);
	 * // => [1, 2, 3]
	 */
	function wrapperCommit() {
	  return new LodashWrapper(this.value(), this.__chain__);
	}

	/**
	 * Creates an array with all falsey values removed. The values `false`, `null`,
	 * `0`, `""`, `undefined`, and `NaN` are falsey.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to compact.
	 * @returns {Array} Returns the new array of filtered values.
	 * @example
	 *
	 * _.compact([0, 1, false, 2, '', 3]);
	 * // => [1, 2, 3]
	 */
	function compact(array) {
	  var index = -1,
	      length = array == null ? 0 : array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index];
	    if (value) {
	      result[resIndex++] = value;
	    }
	  }
	  return result;
	}

	/**
	 * Creates a new array concatenating `array` with any additional arrays
	 * and/or values.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Array
	 * @param {Array} array The array to concatenate.
	 * @param {...*} [values] The values to concatenate.
	 * @returns {Array} Returns the new concatenated array.
	 * @example
	 *
	 * var array = [1];
	 * var other = _.concat(array, 2, [3], [[4]]);
	 *
	 * console.log(other);
	 * // => [1, 2, 3, [4]]
	 *
	 * console.log(array);
	 * // => [1]
	 */
	function concat() {
	  var length = arguments.length;
	  if (!length) {
	    return [];
	  }
	  var args = Array(length - 1),
	      array = arguments[0],
	      index = length;

	  while (index--) {
	    args[index - 1] = arguments[index];
	  }
	  return arrayPush(isArray(array) ? copyArray$1(array) : [array], baseFlatten(args, 1));
	}

	/** Used to stand-in for `undefined` hash values. */
	var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

	/**
	 * Adds `value` to the array cache.
	 *
	 * @private
	 * @name add
	 * @memberOf SetCache
	 * @alias push
	 * @param {*} value The value to cache.
	 * @returns {Object} Returns the cache instance.
	 */
	function setCacheAdd(value) {
	  this.__data__.set(value, HASH_UNDEFINED$2);
	  return this;
	}

	/**
	 * Checks if `value` is in the array cache.
	 *
	 * @private
	 * @name has
	 * @memberOf SetCache
	 * @param {*} value The value to search for.
	 * @returns {number} Returns `true` if `value` is found, else `false`.
	 */
	function setCacheHas(value) {
	  return this.__data__.has(value);
	}

	/**
	 *
	 * Creates an array cache object to store unique values.
	 *
	 * @private
	 * @constructor
	 * @param {Array} [values] The values to cache.
	 */
	function SetCache(values) {
	  var index = -1,
	      length = values == null ? 0 : values.length;

	  this.__data__ = new MapCache;
	  while (++index < length) {
	    this.add(values[index]);
	  }
	}

	// Add methods to `SetCache`.
	SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	SetCache.prototype.has = setCacheHas;

	/**
	 * A specialized version of `_.some` for arrays without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function arraySome(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (predicate(array[index], index, array)) {
	      return true;
	    }
	  }
	  return false;
	}

	/**
	 * Checks if a `cache` value for `key` exists.
	 *
	 * @private
	 * @param {Object} cache The cache to query.
	 * @param {string} key The key of the entry to check.
	 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	 */
	function cacheHas(cache, key) {
	  return cache.has(key);
	}

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG = 1,
	    COMPARE_UNORDERED_FLAG = 2;

	/**
	 * A specialized version of `baseIsEqualDeep` for arrays with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Array} array The array to compare.
	 * @param {Array} other The other array to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `array` and `other` objects.
	 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	 */
	function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	      arrLength = array.length,
	      othLength = other.length;

	  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	    return false;
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(array);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var index = -1,
	      result = true,
	      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

	  stack.set(array, other);
	  stack.set(other, array);

	  // Ignore non-index properties.
	  while (++index < arrLength) {
	    var arrValue = array[index],
	        othValue = other[index];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, arrValue, index, other, array, stack)
	        : customizer(arrValue, othValue, index, array, other, stack);
	    }
	    if (compared !== undefined) {
	      if (compared) {
	        continue;
	      }
	      result = false;
	      break;
	    }
	    // Recursively compare arrays (susceptible to call stack limits).
	    if (seen) {
	      if (!arraySome(other, function(othValue, othIndex) {
	            if (!cacheHas(seen, othIndex) &&
	                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	              return seen.push(othIndex);
	            }
	          })) {
	        result = false;
	        break;
	      }
	    } else if (!(
	          arrValue === othValue ||
	            equalFunc(arrValue, othValue, bitmask, customizer, stack)
	        )) {
	      result = false;
	      break;
	    }
	  }
	  stack['delete'](array);
	  stack['delete'](other);
	  return result;
	}

	/**
	 * Converts `map` to its key-value pairs.
	 *
	 * @private
	 * @param {Object} map The map to convert.
	 * @returns {Array} Returns the key-value pairs.
	 */
	function mapToArray(map) {
	  var index = -1,
	      result = Array(map.size);

	  map.forEach(function(value, key) {
	    result[++index] = [key, value];
	  });
	  return result;
	}

	/**
	 * Converts `set` to an array of its values.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the values.
	 */
	function setToArray(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = value;
	  });
	  return result;
	}

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$1 = 1,
	    COMPARE_UNORDERED_FLAG$1 = 2;

	/** `Object#toString` result references. */
	var boolTag$3 = '[object Boolean]',
	    dateTag$3 = '[object Date]',
	    errorTag$3 = '[object Error]',
	    mapTag$5 = '[object Map]',
	    numberTag$3 = '[object Number]',
	    regexpTag$3 = '[object RegExp]',
	    setTag$5 = '[object Set]',
	    stringTag$3 = '[object String]',
	    symbolTag$3 = '[object Symbol]';

	var arrayBufferTag$3 = '[object ArrayBuffer]',
	    dataViewTag$4 = '[object DataView]';

	/** Used to convert symbols to primitives and strings. */
	var symbolProto$2 = Symbol$1 ? Symbol$1.prototype : undefined,
	    symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : undefined;

	/**
	 * A specialized version of `baseIsEqualDeep` for comparing objects of
	 * the same `toStringTag`.
	 *
	 * **Note:** This function only supports comparing values with tags of
	 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {string} tag The `toStringTag` of the objects to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	  switch (tag) {
	    case dataViewTag$4:
	      if ((object.byteLength != other.byteLength) ||
	          (object.byteOffset != other.byteOffset)) {
	        return false;
	      }
	      object = object.buffer;
	      other = other.buffer;

	    case arrayBufferTag$3:
	      if ((object.byteLength != other.byteLength) ||
	          !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
	        return false;
	      }
	      return true;

	    case boolTag$3:
	    case dateTag$3:
	    case numberTag$3:
	      // Coerce booleans to `1` or `0` and dates to milliseconds.
	      // Invalid dates are coerced to `NaN`.
	      return eq(+object, +other);

	    case errorTag$3:
	      return object.name == other.name && object.message == other.message;

	    case regexpTag$3:
	    case stringTag$3:
	      // Coerce regexes to strings and treat strings, primitives and objects,
	      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	      // for more details.
	      return object == (other + '');

	    case mapTag$5:
	      var convert = mapToArray;

	    case setTag$5:
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
	      convert || (convert = setToArray);

	      if (object.size != other.size && !isPartial) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked) {
	        return stacked == other;
	      }
	      bitmask |= COMPARE_UNORDERED_FLAG$1;

	      // Recursively compare objects (susceptible to call stack limits).
	      stack.set(object, other);
	      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	      stack['delete'](object);
	      return result;

	    case symbolTag$3:
	      if (symbolValueOf$1) {
	        return symbolValueOf$1.call(object) == symbolValueOf$1.call(other);
	      }
	  }
	  return false;
	}

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$2 = 1;

	/** Used for built-in method references. */
	var objectProto$h = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$e = objectProto$h.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqualDeep` for objects with support for
	 * partial deep comparisons.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} stack Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
	      objProps = getAllKeys(object),
	      objLength = objProps.length,
	      othProps = getAllKeys(other),
	      othLength = othProps.length;

	  if (objLength != othLength && !isPartial) {
	    return false;
	  }
	  var index = objLength;
	  while (index--) {
	    var key = objProps[index];
	    if (!(isPartial ? key in other : hasOwnProperty$e.call(other, key))) {
	      return false;
	    }
	  }
	  // Assume cyclic values are equal.
	  var stacked = stack.get(object);
	  if (stacked && stack.get(other)) {
	    return stacked == other;
	  }
	  var result = true;
	  stack.set(object, other);
	  stack.set(other, object);

	  var skipCtor = isPartial;
	  while (++index < objLength) {
	    key = objProps[index];
	    var objValue = object[key],
	        othValue = other[key];

	    if (customizer) {
	      var compared = isPartial
	        ? customizer(othValue, objValue, key, other, object, stack)
	        : customizer(objValue, othValue, key, object, other, stack);
	    }
	    // Recursively compare objects (susceptible to call stack limits).
	    if (!(compared === undefined
	          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	          : compared
	        )) {
	      result = false;
	      break;
	    }
	    skipCtor || (skipCtor = key == 'constructor');
	  }
	  if (result && !skipCtor) {
	    var objCtor = object.constructor,
	        othCtor = other.constructor;

	    // Non `Object` object instances with different constructors are not equal.
	    if (objCtor != othCtor &&
	        ('constructor' in object && 'constructor' in other) &&
	        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	      result = false;
	    }
	  }
	  stack['delete'](object);
	  stack['delete'](other);
	  return result;
	}

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$3 = 1;

	/** `Object#toString` result references. */
	var argsTag$3 = '[object Arguments]',
	    arrayTag$2 = '[object Array]',
	    objectTag$4 = '[object Object]';

	/** Used for built-in method references. */
	var objectProto$i = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$f = objectProto$i.hasOwnProperty;

	/**
	 * A specialized version of `baseIsEqual` for arrays and objects which performs
	 * deep comparisons and tracks traversed objects enabling objects with circular
	 * references to be compared.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	 * @param {Function} customizer The function to customize comparisons.
	 * @param {Function} equalFunc The function to determine equivalents of values.
	 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	 */
	function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	  var objIsArr = isArray(object),
	      othIsArr = isArray(other),
	      objTag = objIsArr ? arrayTag$2 : getTag$1(object),
	      othTag = othIsArr ? arrayTag$2 : getTag$1(other);

	  objTag = objTag == argsTag$3 ? objectTag$4 : objTag;
	  othTag = othTag == argsTag$3 ? objectTag$4 : othTag;

	  var objIsObj = objTag == objectTag$4,
	      othIsObj = othTag == objectTag$4,
	      isSameTag = objTag == othTag;

	  if (isSameTag && isBuffer(object)) {
	    if (!isBuffer(other)) {
	      return false;
	    }
	    objIsArr = true;
	    objIsObj = false;
	  }
	  if (isSameTag && !objIsObj) {
	    stack || (stack = new Stack);
	    return (objIsArr || isTypedArray(object))
	      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	  }
	  if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
	    var objIsWrapped = objIsObj && hasOwnProperty$f.call(object, '__wrapped__'),
	        othIsWrapped = othIsObj && hasOwnProperty$f.call(other, '__wrapped__');

	    if (objIsWrapped || othIsWrapped) {
	      var objUnwrapped = objIsWrapped ? object.value() : object,
	          othUnwrapped = othIsWrapped ? other.value() : other;

	      stack || (stack = new Stack);
	      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	    }
	  }
	  if (!isSameTag) {
	    return false;
	  }
	  stack || (stack = new Stack);
	  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	}

	/**
	 * The base implementation of `_.isEqual` which supports partial comparisons
	 * and tracks traversed objects.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {boolean} bitmask The bitmask flags.
	 *  1 - Unordered comparison
	 *  2 - Partial comparison
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 */
	function baseIsEqual(value, other, bitmask, customizer, stack) {
	  if (value === other) {
	    return true;
	  }
	  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
	    return value !== value && other !== other;
	  }
	  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	}

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$4 = 1,
	    COMPARE_UNORDERED_FLAG$2 = 2;

	/**
	 * The base implementation of `_.isMatch` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property values to match.
	 * @param {Array} matchData The property names, values, and compare flags to match.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 */
	function baseIsMatch(object, source, matchData, customizer) {
	  var index = matchData.length,
	      length = index,
	      noCustomizer = !customizer;

	  if (object == null) {
	    return !length;
	  }
	  object = Object(object);
	  while (index--) {
	    var data = matchData[index];
	    if ((noCustomizer && data[2])
	          ? data[1] !== object[data[0]]
	          : !(data[0] in object)
	        ) {
	      return false;
	    }
	  }
	  while (++index < length) {
	    data = matchData[index];
	    var key = data[0],
	        objValue = object[key],
	        srcValue = data[1];

	    if (noCustomizer && data[2]) {
	      if (objValue === undefined && !(key in object)) {
	        return false;
	      }
	    } else {
	      var stack = new Stack;
	      if (customizer) {
	        var result = customizer(objValue, srcValue, key, object, source, stack);
	      }
	      if (!(result === undefined
	            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack)
	            : result
	          )) {
	        return false;
	      }
	    }
	  }
	  return true;
	}

	/**
	 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` if suitable for strict
	 *  equality comparisons, else `false`.
	 */
	function isStrictComparable(value) {
	  return value === value && !isObject(value);
	}

	/**
	 * Gets the property names, values, and compare flags of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the match data of `object`.
	 */
	function getMatchData(object) {
	  var result = keys(object),
	      length = result.length;

	  while (length--) {
	    var key = result[length],
	        value = object[key];

	    result[length] = [key, value, isStrictComparable(value)];
	  }
	  return result;
	}

	/**
	 * A specialized version of `matchesProperty` for source values suitable
	 * for strict equality comparisons, i.e. `===`.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function matchesStrictComparable(key, srcValue) {
	  return function(object) {
	    if (object == null) {
	      return false;
	    }
	    return object[key] === srcValue &&
	      (srcValue !== undefined || (key in Object(object)));
	  };
	}

	/**
	 * The base implementation of `_.matches` which doesn't clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatches(source) {
	  var matchData = getMatchData(source);
	  if (matchData.length == 1 && matchData[0][2]) {
	    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	  }
	  return function(object) {
	    return object === source || baseIsMatch(object, source, matchData);
	  };
	}

	/**
	 * The base implementation of `_.hasIn` without support for deep paths.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {Array|string} key The key to check.
	 * @returns {boolean} Returns `true` if `key` exists, else `false`.
	 */
	function baseHasIn(object, key) {
	  return object != null && key in Object(object);
	}

	/**
	 * Checks if `path` exists on `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @param {Function} hasFunc The function to check properties.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 */
	function hasPath(object, path, hasFunc) {
	  path = castPath(path, object);

	  var index = -1,
	      length = path.length,
	      result = false;

	  while (++index < length) {
	    var key = toKey(path[index]);
	    if (!(result = object != null && hasFunc(object, key))) {
	      break;
	    }
	    object = object[key];
	  }
	  if (result || ++index != length) {
	    return result;
	  }
	  length = object == null ? 0 : object.length;
	  return !!length && isLength(length) && isIndex(key, length) &&
	    (isArray(object) || isArguments(object));
	}

	/**
	 * Checks if `path` is a direct or inherited property of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.hasIn(object, 'a');
	 * // => true
	 *
	 * _.hasIn(object, 'a.b');
	 * // => true
	 *
	 * _.hasIn(object, ['a', 'b']);
	 * // => true
	 *
	 * _.hasIn(object, 'b');
	 * // => false
	 */
	function hasIn(object, path) {
	  return object != null && hasPath(object, path, baseHasIn);
	}

	/** Used to compose bitmasks for value comparisons. */
	var COMPARE_PARTIAL_FLAG$5 = 1,
	    COMPARE_UNORDERED_FLAG$3 = 2;

	/**
	 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	 *
	 * @private
	 * @param {string} path The path of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseMatchesProperty(path, srcValue) {
	  if (isKey(path) && isStrictComparable(srcValue)) {
	    return matchesStrictComparable(toKey(path), srcValue);
	  }
	  return function(object) {
	    var objValue = get(object, path);
	    return (objValue === undefined && objValue === srcValue)
	      ? hasIn(object, path)
	      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);
	  };
	}

	/**
	 * The base implementation of `_.property` without support for deep paths.
	 *
	 * @private
	 * @param {string} key The key of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function baseProperty(key) {
	  return function(object) {
	    return object == null ? undefined : object[key];
	  };
	}

	/**
	 * A specialized version of `baseProperty` which supports deep paths.
	 *
	 * @private
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 */
	function basePropertyDeep(path) {
	  return function(object) {
	    return baseGet(object, path);
	  };
	}

	/**
	 * Creates a function that returns the value at `path` of a given object.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Util
	 * @param {Array|string} path The path of the property to get.
	 * @returns {Function} Returns the new accessor function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': 2 } },
	 *   { 'a': { 'b': 1 } }
	 * ];
	 *
	 * _.map(objects, _.property('a.b'));
	 * // => [2, 1]
	 *
	 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	 * // => [1, 2]
	 */
	function property(path) {
	  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	}

	/**
	 * The base implementation of `_.iteratee`.
	 *
	 * @private
	 * @param {*} [value=_.identity] The value to convert to an iteratee.
	 * @returns {Function} Returns the iteratee.
	 */
	function baseIteratee(value) {
	  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	  if (typeof value == 'function') {
	    return value;
	  }
	  if (value == null) {
	    return identity;
	  }
	  if (typeof value == 'object') {
	    return isArray(value)
	      ? baseMatchesProperty(value[0], value[1])
	      : baseMatches(value);
	  }
	  return property(value);
	}

	/** Error message constants. */
	var FUNC_ERROR_TEXT$4 = 'Expected a function';

	/**
	 * Creates a function that iterates over `pairs` and invokes the corresponding
	 * function of the first predicate to return truthy. The predicate-function
	 * pairs are invoked with the `this` binding and arguments of the created
	 * function.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Util
	 * @param {Array} pairs The predicate-function pairs.
	 * @returns {Function} Returns the new composite function.
	 * @example
	 *
	 * var func = _.cond([
	 *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
	 *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
	 *   [_.stubTrue,                      _.constant('no match')]
	 * ]);
	 *
	 * func({ 'a': 1, 'b': 2 });
	 * // => 'matches A'
	 *
	 * func({ 'a': 0, 'b': 1 });
	 * // => 'matches B'
	 *
	 * func({ 'a': '1', 'b': '2' });
	 * // => 'no match'
	 */
	function cond(pairs) {
	  var length = pairs == null ? 0 : pairs.length,
	      toIteratee = baseIteratee;

	  pairs = !length ? [] : arrayMap(pairs, function(pair) {
	    if (typeof pair[1] != 'function') {
	      throw new TypeError(FUNC_ERROR_TEXT$4);
	    }
	    return [toIteratee(pair[0]), pair[1]];
	  });

	  return baseRest(function(args) {
	    var index = -1;
	    while (++index < length) {
	      var pair = pairs[index];
	      if (apply(pair[0], this, args)) {
	        return apply(pair[1], this, args);
	      }
	    }
	  });
	}

	/**
	 * The base implementation of `_.conformsTo` which accepts `props` to check.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property predicates to conform to.
	 * @returns {boolean} Returns `true` if `object` conforms, else `false`.
	 */
	function baseConformsTo(object, source, props) {
	  var length = props.length;
	  if (object == null) {
	    return !length;
	  }
	  object = Object(object);
	  while (length--) {
	    var key = props[length],
	        predicate = source[key],
	        value = object[key];

	    if ((value === undefined && !(key in object)) || !predicate(value)) {
	      return false;
	    }
	  }
	  return true;
	}

	/**
	 * The base implementation of `_.conforms` which doesn't clone `source`.
	 *
	 * @private
	 * @param {Object} source The object of property predicates to conform to.
	 * @returns {Function} Returns the new spec function.
	 */
	function baseConforms(source) {
	  var props = keys(source);
	  return function(object) {
	    return baseConformsTo(object, source, props);
	  };
	}

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG$3 = 1;

	/**
	 * Creates a function that invokes the predicate properties of `source` with
	 * the corresponding property values of a given object, returning `true` if
	 * all predicates return truthy, else `false`.
	 *
	 * **Note:** The created function is equivalent to `_.conformsTo` with
	 * `source` partially applied.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Util
	 * @param {Object} source The object of property predicates to conform to.
	 * @returns {Function} Returns the new spec function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': 2, 'b': 1 },
	 *   { 'a': 1, 'b': 2 }
	 * ];
	 *
	 * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
	 * // => [{ 'a': 1, 'b': 2 }]
	 */
	function conforms(source) {
	  return baseConforms(baseClone(source, CLONE_DEEP_FLAG$3));
	}

	/**
	 * Checks if `object` conforms to `source` by invoking the predicate
	 * properties of `source` with the corresponding property values of `object`.
	 *
	 * **Note:** This method is equivalent to `_.conforms` when `source` is
	 * partially applied.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.14.0
	 * @category Lang
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property predicates to conform to.
	 * @returns {boolean} Returns `true` if `object` conforms, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 *
	 * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
	 * // => true
	 *
	 * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
	 * // => false
	 */
	function conformsTo(object, source) {
	  return source == null || baseConformsTo(object, source, keys(source));
	}

	/**
	 * A specialized version of `baseAggregator` for arrays.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} setter The function to set `accumulator` values.
	 * @param {Function} iteratee The iteratee to transform keys.
	 * @param {Object} accumulator The initial aggregated object.
	 * @returns {Function} Returns `accumulator`.
	 */
	function arrayAggregator(array, setter, iteratee, accumulator) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    var value = array[index];
	    setter(accumulator, value, iteratee(value), array);
	  }
	  return accumulator;
	}

	/**
	 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseFor(fromRight) {
	  return function(object, iteratee, keysFunc) {
	    var index = -1,
	        iterable = Object(object),
	        props = keysFunc(object),
	        length = props.length;

	    while (length--) {
	      var key = props[fromRight ? length : ++index];
	      if (iteratee(iterable[key], key, iterable) === false) {
	        break;
	      }
	    }
	    return object;
	  };
	}

	/**
	 * The base implementation of `baseForOwn` which iterates over `object`
	 * properties returned by `keysFunc` and invokes `iteratee` for each property.
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseFor = createBaseFor();

	/**
	 * The base implementation of `_.forOwn` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */
	function baseForOwn(object, iteratee) {
	  return object && baseFor(object, iteratee, keys);
	}

	/**
	 * Creates a `baseEach` or `baseEachRight` function.
	 *
	 * @private
	 * @param {Function} eachFunc The function to iterate over a collection.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new base function.
	 */
	function createBaseEach(eachFunc, fromRight) {
	  return function(collection, iteratee) {
	    if (collection == null) {
	      return collection;
	    }
	    if (!isArrayLike(collection)) {
	      return eachFunc(collection, iteratee);
	    }
	    var length = collection.length,
	        index = fromRight ? length : -1,
	        iterable = Object(collection);

	    while ((fromRight ? index-- : ++index < length)) {
	      if (iteratee(iterable[index], index, iterable) === false) {
	        break;
	      }
	    }
	    return collection;
	  };
	}

	/**
	 * The base implementation of `_.forEach` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array|Object} Returns `collection`.
	 */
	var baseEach = createBaseEach(baseForOwn);

	/**
	 * Aggregates elements of `collection` on `accumulator` with keys transformed
	 * by `iteratee` and values set by `setter`.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} setter The function to set `accumulator` values.
	 * @param {Function} iteratee The iteratee to transform keys.
	 * @param {Object} accumulator The initial aggregated object.
	 * @returns {Function} Returns `accumulator`.
	 */
	function baseAggregator(collection, setter, iteratee, accumulator) {
	  baseEach(collection, function(value, key, collection) {
	    setter(accumulator, value, iteratee(value), collection);
	  });
	  return accumulator;
	}

	/**
	 * Creates a function like `_.groupBy`.
	 *
	 * @private
	 * @param {Function} setter The function to set accumulator values.
	 * @param {Function} [initializer] The accumulator object initializer.
	 * @returns {Function} Returns the new aggregator function.
	 */
	function createAggregator(setter, initializer) {
	  return function(collection, iteratee) {
	    var func = isArray(collection) ? arrayAggregator : baseAggregator,
	        accumulator = initializer ? initializer() : {};

	    return func(collection, setter, baseIteratee(iteratee), accumulator);
	  };
	}

	/** Used for built-in method references. */
	var objectProto$j = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$g = objectProto$j.hasOwnProperty;

	/**
	 * Creates an object composed of keys generated from the results of running
	 * each element of `collection` thru `iteratee`. The corresponding value of
	 * each key is the number of times the key was returned by `iteratee`. The
	 * iteratee is invoked with one argument: (value).
	 *
	 * @static
	 * @memberOf _
	 * @since 0.5.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	 * @returns {Object} Returns the composed aggregate object.
	 * @example
	 *
	 * _.countBy([6.1, 4.2, 6.3], Math.floor);
	 * // => { '4': 1, '6': 2 }
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.countBy(['one', 'two', 'three'], 'length');
	 * // => { '3': 2, '5': 1 }
	 */
	var countBy = createAggregator(function(result, value, key) {
	  if (hasOwnProperty$g.call(result, key)) {
	    ++result[key];
	  } else {
	    baseAssignValue(result, key, 1);
	  }
	});

	/**
	 * Creates an object that inherits from the `prototype` object. If a
	 * `properties` object is given, its own enumerable string keyed properties
	 * are assigned to the created object.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.3.0
	 * @category Object
	 * @param {Object} prototype The object to inherit from.
	 * @param {Object} [properties] The properties to assign to the object.
	 * @returns {Object} Returns the new object.
	 * @example
	 *
	 * function Shape() {
	 *   this.x = 0;
	 *   this.y = 0;
	 * }
	 *
	 * function Circle() {
	 *   Shape.call(this);
	 * }
	 *
	 * Circle.prototype = _.create(Shape.prototype, {
	 *   'constructor': Circle
	 * });
	 *
	 * var circle = new Circle;
	 * circle instanceof Circle;
	 * // => true
	 *
	 * circle instanceof Shape;
	 * // => true
	 */
	function create(prototype, properties) {
	  var result = baseCreate(prototype);
	  return properties == null ? result : baseAssign(result, properties);
	}

	/** Used to compose bitmasks for function metadata. */
	var WRAP_CURRY_FLAG$5 = 8;

	/**
	 * Creates a function that accepts arguments of `func` and either invokes
	 * `func` returning its result, if at least `arity` number of arguments have
	 * been provided, or returns a function that accepts the remaining `func`
	 * arguments, and so on. The arity of `func` may be specified if `func.length`
	 * is not sufficient.
	 *
	 * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
	 * may be used as a placeholder for provided arguments.
	 *
	 * **Note:** This method doesn't set the "length" property of curried functions.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.0.0
	 * @category Function
	 * @param {Function} func The function to curry.
	 * @param {number} [arity=func.length] The arity of `func`.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {Function} Returns the new curried function.
	 * @example
	 *
	 * var abc = function(a, b, c) {
	 *   return [a, b, c];
	 * };
	 *
	 * var curried = _.curry(abc);
	 *
	 * curried(1)(2)(3);
	 * // => [1, 2, 3]
	 *
	 * curried(1, 2)(3);
	 * // => [1, 2, 3]
	 *
	 * curried(1, 2, 3);
	 * // => [1, 2, 3]
	 *
	 * // Curried with placeholders.
	 * curried(1)(_, 3)(2);
	 * // => [1, 2, 3]
	 */
	function curry(func, arity, guard) {
	  arity = guard ? undefined : arity;
	  var result = createWrap(func, WRAP_CURRY_FLAG$5, undefined, undefined, undefined, undefined, undefined, arity);
	  result.placeholder = curry.placeholder;
	  return result;
	}

	// Assign default placeholders.
	curry.placeholder = {};

	/** Used to compose bitmasks for function metadata. */
	var WRAP_CURRY_RIGHT_FLAG$3 = 16;

	/**
	 * This method is like `_.curry` except that arguments are applied to `func`
	 * in the manner of `_.partialRight` instead of `_.partial`.
	 *
	 * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
	 * builds, may be used as a placeholder for provided arguments.
	 *
	 * **Note:** This method doesn't set the "length" property of curried functions.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Function
	 * @param {Function} func The function to curry.
	 * @param {number} [arity=func.length] The arity of `func`.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {Function} Returns the new curried function.
	 * @example
	 *
	 * var abc = function(a, b, c) {
	 *   return [a, b, c];
	 * };
	 *
	 * var curried = _.curryRight(abc);
	 *
	 * curried(3)(2)(1);
	 * // => [1, 2, 3]
	 *
	 * curried(2, 3)(1);
	 * // => [1, 2, 3]
	 *
	 * curried(1, 2, 3);
	 * // => [1, 2, 3]
	 *
	 * // Curried with placeholders.
	 * curried(3)(1, _)(2);
	 * // => [1, 2, 3]
	 */
	function curryRight(func, arity, guard) {
	  arity = guard ? undefined : arity;
	  var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG$3, undefined, undefined, undefined, undefined, undefined, arity);
	  result.placeholder = curryRight.placeholder;
	  return result;
	}

	// Assign default placeholders.
	curryRight.placeholder = {};

	/**
	 * Gets the timestamp of the number of milliseconds that have elapsed since
	 * the Unix epoch (1 January 1970 00:00:00 UTC).
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Date
	 * @returns {number} Returns the timestamp.
	 * @example
	 *
	 * _.defer(function(stamp) {
	 *   console.log(_.now() - stamp);
	 * }, _.now());
	 * // => Logs the number of milliseconds it took for the deferred invocation.
	 */
	var now = function() {
	  return root.Date.now();
	};

	/** Error message constants. */
	var FUNC_ERROR_TEXT$5 = 'Expected a function';

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax$5 = Math.max,
	    nativeMin$3 = Math.min;

	/**
	 * Creates a debounced function that delays invoking `func` until after `wait`
	 * milliseconds have elapsed since the last time the debounced function was
	 * invoked. The debounced function comes with a `cancel` method to cancel
	 * delayed `func` invocations and a `flush` method to immediately invoke them.
	 * Provide `options` to indicate whether `func` should be invoked on the
	 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	 * with the last arguments provided to the debounced function. Subsequent
	 * calls to the debounced function return the result of the last `func`
	 * invocation.
	 *
	 * **Note:** If `leading` and `trailing` options are `true`, `func` is
	 * invoked on the trailing edge of the timeout only if the debounced function
	 * is invoked more than once during the `wait` timeout.
	 *
	 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	 *
	 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	 * for details over the differences between `_.debounce` and `_.throttle`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to debounce.
	 * @param {number} [wait=0] The number of milliseconds to delay.
	 * @param {Object} [options={}] The options object.
	 * @param {boolean} [options.leading=false]
	 *  Specify invoking on the leading edge of the timeout.
	 * @param {number} [options.maxWait]
	 *  The maximum time `func` is allowed to be delayed before it's invoked.
	 * @param {boolean} [options.trailing=true]
	 *  Specify invoking on the trailing edge of the timeout.
	 * @returns {Function} Returns the new debounced function.
	 * @example
	 *
	 * // Avoid costly calculations while the window size is in flux.
	 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	 *
	 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	 * jQuery(element).on('click', _.debounce(sendMail, 300, {
	 *   'leading': true,
	 *   'trailing': false
	 * }));
	 *
	 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	 * var source = new EventSource('/stream');
	 * jQuery(source).on('message', debounced);
	 *
	 * // Cancel the trailing debounced invocation.
	 * jQuery(window).on('popstate', debounced.cancel);
	 */
	function debounce(func, wait, options) {
	  var lastArgs,
	      lastThis,
	      maxWait,
	      result,
	      timerId,
	      lastCallTime,
	      lastInvokeTime = 0,
	      leading = false,
	      maxing = false,
	      trailing = true;

	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT$5);
	  }
	  wait = toNumber(wait) || 0;
	  if (isObject(options)) {
	    leading = !!options.leading;
	    maxing = 'maxWait' in options;
	    maxWait = maxing ? nativeMax$5(toNumber(options.maxWait) || 0, wait) : maxWait;
	    trailing = 'trailing' in options ? !!options.trailing : trailing;
	  }

	  function invokeFunc(time) {
	    var args = lastArgs,
	        thisArg = lastThis;

	    lastArgs = lastThis = undefined;
	    lastInvokeTime = time;
	    result = func.apply(thisArg, args);
	    return result;
	  }

	  function leadingEdge(time) {
	    // Reset any `maxWait` timer.
	    lastInvokeTime = time;
	    // Start the timer for the trailing edge.
	    timerId = setTimeout(timerExpired, wait);
	    // Invoke the leading edge.
	    return leading ? invokeFunc(time) : result;
	  }

	  function remainingWait(time) {
	    var timeSinceLastCall = time - lastCallTime,
	        timeSinceLastInvoke = time - lastInvokeTime,
	        timeWaiting = wait - timeSinceLastCall;

	    return maxing
	      ? nativeMin$3(timeWaiting, maxWait - timeSinceLastInvoke)
	      : timeWaiting;
	  }

	  function shouldInvoke(time) {
	    var timeSinceLastCall = time - lastCallTime,
	        timeSinceLastInvoke = time - lastInvokeTime;

	    // Either this is the first call, activity has stopped and we're at the
	    // trailing edge, the system time has gone backwards and we're treating
	    // it as the trailing edge, or we've hit the `maxWait` limit.
	    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
	      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
	  }

	  function timerExpired() {
	    var time = now();
	    if (shouldInvoke(time)) {
	      return trailingEdge(time);
	    }
	    // Restart the timer.
	    timerId = setTimeout(timerExpired, remainingWait(time));
	  }

	  function trailingEdge(time) {
	    timerId = undefined;

	    // Only invoke if we have `lastArgs` which means `func` has been
	    // debounced at least once.
	    if (trailing && lastArgs) {
	      return invokeFunc(time);
	    }
	    lastArgs = lastThis = undefined;
	    return result;
	  }

	  function cancel() {
	    if (timerId !== undefined) {
	      clearTimeout(timerId);
	    }
	    lastInvokeTime = 0;
	    lastArgs = lastCallTime = lastThis = timerId = undefined;
	  }

	  function flush() {
	    return timerId === undefined ? result : trailingEdge(now());
	  }

	  function debounced() {
	    var time = now(),
	        isInvoking = shouldInvoke(time);

	    lastArgs = arguments;
	    lastThis = this;
	    lastCallTime = time;

	    if (isInvoking) {
	      if (timerId === undefined) {
	        return leadingEdge(lastCallTime);
	      }
	      if (maxing) {
	        // Handle invocations in a tight loop.
	        clearTimeout(timerId);
	        timerId = setTimeout(timerExpired, wait);
	        return invokeFunc(lastCallTime);
	      }
	    }
	    if (timerId === undefined) {
	      timerId = setTimeout(timerExpired, wait);
	    }
	    return result;
	  }
	  debounced.cancel = cancel;
	  debounced.flush = flush;
	  return debounced;
	}

	/**
	 * Checks `value` to determine whether a default value should be returned in
	 * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
	 * or `undefined`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.14.0
	 * @category Util
	 * @param {*} value The value to check.
	 * @param {*} defaultValue The default value.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * _.defaultTo(1, 10);
	 * // => 1
	 *
	 * _.defaultTo(undefined, 10);
	 * // => 10
	 */
	function defaultTo(value, defaultValue) {
	  return (value == null || value !== value) ? defaultValue : value;
	}

	/** Used for built-in method references. */
	var objectProto$k = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$h = objectProto$k.hasOwnProperty;

	/**
	 * Assigns own and inherited enumerable string keyed properties of source
	 * objects to the destination object for all destination properties that
	 * resolve to `undefined`. Source objects are applied from left to right.
	 * Once a property is set, additional values of the same property are ignored.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @see _.defaultsDeep
	 * @example
	 *
	 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	 * // => { 'a': 1, 'b': 2 }
	 */
	var defaults = baseRest(function(object, sources) {
	  object = Object(object);

	  var index = -1;
	  var length = sources.length;
	  var guard = length > 2 ? sources[2] : undefined;

	  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	    length = 1;
	  }

	  while (++index < length) {
	    var source = sources[index];
	    var props = keysIn$1(source);
	    var propsIndex = -1;
	    var propsLength = props.length;

	    while (++propsIndex < propsLength) {
	      var key = props[propsIndex];
	      var value = object[key];

	      if (value === undefined ||
	          (eq(value, objectProto$k[key]) && !hasOwnProperty$h.call(object, key))) {
	        object[key] = source[key];
	      }
	    }
	  }

	  return object;
	});

	/**
	 * This function is like `assignValue` except that it doesn't assign
	 * `undefined` values.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {string} key The key of the property to assign.
	 * @param {*} value The value to assign.
	 */
	function assignMergeValue(object, key, value) {
	  if ((value !== undefined && !eq(object[key], value)) ||
	      (value === undefined && !(key in object))) {
	    baseAssignValue(object, key, value);
	  }
	}

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}

	/**
	 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function safeGet(object, key) {
	  if (key === 'constructor' && typeof object[key] === 'function') {
	    return;
	  }

	  if (key == '__proto__') {
	    return;
	  }

	  return object[key];
	}

	/**
	 * Converts `value` to a plain object flattening inherited enumerable string
	 * keyed properties of `value` to own properties of the plain object.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {Object} Returns the converted plain object.
	 * @example
	 *
	 * function Foo() {
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.assign({ 'a': 1 }, new Foo);
	 * // => { 'a': 1, 'b': 2 }
	 *
	 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	 * // => { 'a': 1, 'b': 2, 'c': 3 }
	 */
	function toPlainObject(value) {
	  return copyObject(value, keysIn$1(value));
	}

	/**
	 * A specialized version of `baseMerge` for arrays and objects which performs
	 * deep merges and tracks traversed objects enabling objects with circular
	 * references to be merged.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {string} key The key of the value to merge.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} mergeFunc The function to merge values.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
	  var objValue = safeGet(object, key),
	      srcValue = safeGet(source, key),
	      stacked = stack.get(srcValue);

	  if (stacked) {
	    assignMergeValue(object, key, stacked);
	    return;
	  }
	  var newValue = customizer
	    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
	    : undefined;

	  var isCommon = newValue === undefined;

	  if (isCommon) {
	    var isArr = isArray(srcValue),
	        isBuff = !isArr && isBuffer(srcValue),
	        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

	    newValue = srcValue;
	    if (isArr || isBuff || isTyped) {
	      if (isArray(objValue)) {
	        newValue = objValue;
	      }
	      else if (isArrayLikeObject(objValue)) {
	        newValue = copyArray$1(objValue);
	      }
	      else if (isBuff) {
	        isCommon = false;
	        newValue = cloneBuffer(srcValue, true);
	      }
	      else if (isTyped) {
	        isCommon = false;
	        newValue = cloneTypedArray(srcValue, true);
	      }
	      else {
	        newValue = [];
	      }
	    }
	    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	      newValue = objValue;
	      if (isArguments(objValue)) {
	        newValue = toPlainObject(objValue);
	      }
	      else if (!isObject(objValue) || isFunction(objValue)) {
	        newValue = initCloneObject(srcValue);
	      }
	    }
	    else {
	      isCommon = false;
	    }
	  }
	  if (isCommon) {
	    // Recursively merge objects and arrays (susceptible to call stack limits).
	    stack.set(srcValue, newValue);
	    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
	    stack['delete'](srcValue);
	  }
	  assignMergeValue(object, key, newValue);
	}

	/**
	 * The base implementation of `_.merge` without support for multiple sources.
	 *
	 * @private
	 * @param {Object} object The destination object.
	 * @param {Object} source The source object.
	 * @param {number} srcIndex The index of `source`.
	 * @param {Function} [customizer] The function to customize merged values.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 */
	function baseMerge(object, source, srcIndex, customizer, stack) {
	  if (object === source) {
	    return;
	  }
	  baseFor(source, function(srcValue, key) {
	    stack || (stack = new Stack);
	    if (isObject(srcValue)) {
	      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
	    }
	    else {
	      var newValue = customizer
	        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
	        : undefined;

	      if (newValue === undefined) {
	        newValue = srcValue;
	      }
	      assignMergeValue(object, key, newValue);
	    }
	  }, keysIn$1);
	}

	/**
	 * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
	 * objects into destination objects that are passed thru.
	 *
	 * @private
	 * @param {*} objValue The destination value.
	 * @param {*} srcValue The source value.
	 * @param {string} key The key of the property to merge.
	 * @param {Object} object The parent object of `objValue`.
	 * @param {Object} source The parent object of `srcValue`.
	 * @param {Object} [stack] Tracks traversed source values and their merged
	 *  counterparts.
	 * @returns {*} Returns the value to assign.
	 */
	function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
	  if (isObject(objValue) && isObject(srcValue)) {
	    // Recursively merge objects and arrays (susceptible to call stack limits).
	    stack.set(srcValue, objValue);
	    baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
	    stack['delete'](srcValue);
	  }
	  return objValue;
	}

	/**
	 * This method is like `_.merge` except that it accepts `customizer` which
	 * is invoked to produce the merged values of the destination and source
	 * properties. If `customizer` returns `undefined`, merging is handled by the
	 * method instead. The `customizer` is invoked with six arguments:
	 * (objValue, srcValue, key, object, source, stack).
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} sources The source objects.
	 * @param {Function} customizer The function to customize assigned values.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * function customizer(objValue, srcValue) {
	 *   if (_.isArray(objValue)) {
	 *     return objValue.concat(srcValue);
	 *   }
	 * }
	 *
	 * var object = { 'a': [1], 'b': [2] };
	 * var other = { 'a': [3], 'b': [4] };
	 *
	 * _.mergeWith(object, other, customizer);
	 * // => { 'a': [1, 3], 'b': [2, 4] }
	 */
	var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
	  baseMerge(object, source, srcIndex, customizer);
	});

	/**
	 * This method is like `_.defaults` except that it recursively assigns
	 * default properties.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.10.0
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @see _.defaults
	 * @example
	 *
	 * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
	 * // => { 'a': { 'b': 2, 'c': 3 } }
	 */
	var defaultsDeep = baseRest(function(args) {
	  args.push(undefined, customDefaultsMerge);
	  return apply(mergeWith, undefined, args);
	});

	/** Error message constants. */
	var FUNC_ERROR_TEXT$6 = 'Expected a function';

	/**
	 * The base implementation of `_.delay` and `_.defer` which accepts `args`
	 * to provide to `func`.
	 *
	 * @private
	 * @param {Function} func The function to delay.
	 * @param {number} wait The number of milliseconds to delay invocation.
	 * @param {Array} args The arguments to provide to `func`.
	 * @returns {number|Object} Returns the timer id or timeout object.
	 */
	function baseDelay(func, wait, args) {
	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT$6);
	  }
	  return setTimeout(function() { func.apply(undefined, args); }, wait);
	}

	/**
	 * Defers invoking the `func` until the current call stack has cleared. Any
	 * additional arguments are provided to `func` when it's invoked.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to defer.
	 * @param {...*} [args] The arguments to invoke `func` with.
	 * @returns {number} Returns the timer id.
	 * @example
	 *
	 * _.defer(function(text) {
	 *   console.log(text);
	 * }, 'deferred');
	 * // => Logs 'deferred' after one millisecond.
	 */
	var defer = baseRest(function(func, args) {
	  return baseDelay(func, 1, args);
	});

	/**
	 * Invokes `func` after `wait` milliseconds. Any additional arguments are
	 * provided to `func` when it's invoked.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to delay.
	 * @param {number} wait The number of milliseconds to delay invocation.
	 * @param {...*} [args] The arguments to invoke `func` with.
	 * @returns {number} Returns the timer id.
	 * @example
	 *
	 * _.delay(function(text) {
	 *   console.log(text);
	 * }, 1000, 'later');
	 * // => Logs 'later' after one second.
	 */
	var delay = baseRest(function(func, wait, args) {
	  return baseDelay(func, toNumber(wait) || 0, args);
	});

	/**
	 * This function is like `arrayIncludes` except that it accepts a comparator.
	 *
	 * @private
	 * @param {Array} [array] The array to inspect.
	 * @param {*} target The value to search for.
	 * @param {Function} comparator The comparator invoked per element.
	 * @returns {boolean} Returns `true` if `target` is found, else `false`.
	 */
	function arrayIncludesWith(array, value, comparator) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (comparator(value, array[index])) {
	      return true;
	    }
	  }
	  return false;
	}

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE$1 = 200;

	/**
	 * The base implementation of methods like `_.difference` without support
	 * for excluding multiple arrays or iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Array} values The values to exclude.
	 * @param {Function} [iteratee] The iteratee invoked per element.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new array of filtered values.
	 */
	function baseDifference(array, values, iteratee, comparator) {
	  var index = -1,
	      includes = arrayIncludes,
	      isCommon = true,
	      length = array.length,
	      result = [],
	      valuesLength = values.length;

	  if (!length) {
	    return result;
	  }
	  if (iteratee) {
	    values = arrayMap(values, baseUnary(iteratee));
	  }
	  if (comparator) {
	    includes = arrayIncludesWith;
	    isCommon = false;
	  }
	  else if (values.length >= LARGE_ARRAY_SIZE$1) {
	    includes = cacheHas;
	    isCommon = false;
	    values = new SetCache(values);
	  }
	  outer:
	  while (++index < length) {
	    var value = array[index],
	        computed = iteratee == null ? value : iteratee(value);

	    value = (comparator || value !== 0) ? value : 0;
	    if (isCommon && computed === computed) {
	      var valuesIndex = valuesLength;
	      while (valuesIndex--) {
	        if (values[valuesIndex] === computed) {
	          continue outer;
	        }
	      }
	      result.push(value);
	    }
	    else if (!includes(values, computed, comparator)) {
	      result.push(value);
	    }
	  }
	  return result;
	}

	/**
	 * Creates an array of `array` values not included in the other given arrays
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons. The order and references of result values are
	 * determined by the first array.
	 *
	 * **Note:** Unlike `_.pullAll`, this method returns a new array.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @param {...Array} [values] The values to exclude.
	 * @returns {Array} Returns the new array of filtered values.
	 * @see _.without, _.xor
	 * @example
	 *
	 * _.difference([2, 1], [2, 3]);
	 * // => [1]
	 */
	var difference = baseRest(function(array, values) {
	  return isArrayLikeObject(array)
	    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
	    : [];
	});

	/**
	 * Gets the last element of `array`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to query.
	 * @returns {*} Returns the last element of `array`.
	 * @example
	 *
	 * _.last([1, 2, 3]);
	 * // => 3
	 */
	function last(array) {
	  var length = array == null ? 0 : array.length;
	  return length ? array[length - 1] : undefined;
	}

	/**
	 * This method is like `_.difference` except that it accepts `iteratee` which
	 * is invoked for each element of `array` and `values` to generate the criterion
	 * by which they're compared. The order and references of result values are
	 * determined by the first array. The iteratee is invoked with one argument:
	 * (value).
	 *
	 * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @param {...Array} [values] The values to exclude.
	 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	 * @returns {Array} Returns the new array of filtered values.
	 * @example
	 *
	 * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	 * // => [1.2]
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
	 * // => [{ 'x': 2 }]
	 */
	var differenceBy = baseRest(function(array, values) {
	  var iteratee = last(values);
	  if (isArrayLikeObject(iteratee)) {
	    iteratee = undefined;
	  }
	  return isArrayLikeObject(array)
	    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), baseIteratee(iteratee))
	    : [];
	});

	/**
	 * This method is like `_.difference` except that it accepts `comparator`
	 * which is invoked to compare elements of `array` to `values`. The order and
	 * references of result values are determined by the first array. The comparator
	 * is invoked with two arguments: (arrVal, othVal).
	 *
	 * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @param {...Array} [values] The values to exclude.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new array of filtered values.
	 * @example
	 *
	 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	 *
	 * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
	 * // => [{ 'x': 2, 'y': 1 }]
	 */
	var differenceWith = baseRest(function(array, values) {
	  var comparator = last(values);
	  if (isArrayLikeObject(comparator)) {
	    comparator = undefined;
	  }
	  return isArrayLikeObject(array)
	    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
	    : [];
	});

	/**
	 * Divide two numbers.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.7.0
	 * @category Math
	 * @param {number} dividend The first number in a division.
	 * @param {number} divisor The second number in a division.
	 * @returns {number} Returns the quotient.
	 * @example
	 *
	 * _.divide(6, 4);
	 * // => 1.5
	 */
	var divide = createMathOperation(function(dividend, divisor) {
	  return dividend / divisor;
	}, 1);

	/**
	 * Creates a slice of `array` with `n` elements dropped from the beginning.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.5.0
	 * @category Array
	 * @param {Array} array The array to query.
	 * @param {number} [n=1] The number of elements to drop.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {Array} Returns the slice of `array`.
	 * @example
	 *
	 * _.drop([1, 2, 3]);
	 * // => [2, 3]
	 *
	 * _.drop([1, 2, 3], 2);
	 * // => [3]
	 *
	 * _.drop([1, 2, 3], 5);
	 * // => []
	 *
	 * _.drop([1, 2, 3], 0);
	 * // => [1, 2, 3]
	 */
	function drop(array, n, guard) {
	  var length = array == null ? 0 : array.length;
	  if (!length) {
	    return [];
	  }
	  n = (guard || n === undefined) ? 1 : toInteger(n);
	  return baseSlice(array, n < 0 ? 0 : n, length);
	}

	/**
	 * Creates a slice of `array` with `n` elements dropped from the end.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Array
	 * @param {Array} array The array to query.
	 * @param {number} [n=1] The number of elements to drop.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {Array} Returns the slice of `array`.
	 * @example
	 *
	 * _.dropRight([1, 2, 3]);
	 * // => [1, 2]
	 *
	 * _.dropRight([1, 2, 3], 2);
	 * // => [1]
	 *
	 * _.dropRight([1, 2, 3], 5);
	 * // => []
	 *
	 * _.dropRight([1, 2, 3], 0);
	 * // => [1, 2, 3]
	 */
	function dropRight(array, n, guard) {
	  var length = array == null ? 0 : array.length;
	  if (!length) {
	    return [];
	  }
	  n = (guard || n === undefined) ? 1 : toInteger(n);
	  n = length - n;
	  return baseSlice(array, 0, n < 0 ? 0 : n);
	}

	/**
	 * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
	 * without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to query.
	 * @param {Function} predicate The function invoked per iteration.
	 * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Array} Returns the slice of `array`.
	 */
	function baseWhile(array, predicate, isDrop, fromRight) {
	  var length = array.length,
	      index = fromRight ? length : -1;

	  while ((fromRight ? index-- : ++index < length) &&
	    predicate(array[index], index, array)) {}

	  return isDrop
	    ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
	    : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
	}

	/**
	 * Creates a slice of `array` excluding elements dropped from the end.
	 * Elements are dropped until `predicate` returns falsey. The predicate is
	 * invoked with three arguments: (value, index, array).
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Array
	 * @param {Array} array The array to query.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @returns {Array} Returns the slice of `array`.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney',  'active': true },
	 *   { 'user': 'fred',    'active': false },
	 *   { 'user': 'pebbles', 'active': false }
	 * ];
	 *
	 * _.dropRightWhile(users, function(o) { return !o.active; });
	 * // => objects for ['barney']
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
	 * // => objects for ['barney', 'fred']
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.dropRightWhile(users, ['active', false]);
	 * // => objects for ['barney']
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.dropRightWhile(users, 'active');
	 * // => objects for ['barney', 'fred', 'pebbles']
	 */
	function dropRightWhile(array, predicate) {
	  return (array && array.length)
	    ? baseWhile(array, baseIteratee(predicate), true, true)
	    : [];
	}

	/**
	 * Creates a slice of `array` excluding elements dropped from the beginning.
	 * Elements are dropped until `predicate` returns falsey. The predicate is
	 * invoked with three arguments: (value, index, array).
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Array
	 * @param {Array} array The array to query.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @returns {Array} Returns the slice of `array`.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney',  'active': false },
	 *   { 'user': 'fred',    'active': false },
	 *   { 'user': 'pebbles', 'active': true }
	 * ];
	 *
	 * _.dropWhile(users, function(o) { return !o.active; });
	 * // => objects for ['pebbles']
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.dropWhile(users, { 'user': 'barney', 'active': false });
	 * // => objects for ['fred', 'pebbles']
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.dropWhile(users, ['active', false]);
	 * // => objects for ['pebbles']
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.dropWhile(users, 'active');
	 * // => objects for ['barney', 'fred', 'pebbles']
	 */
	function dropWhile(array, predicate) {
	  return (array && array.length)
	    ? baseWhile(array, baseIteratee(predicate), true)
	    : [];
	}

	/**
	 * Casts `value` to `identity` if it's not a function.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {Function} Returns cast function.
	 */
	function castFunction(value) {
	  return typeof value == 'function' ? value : identity;
	}

	/**
	 * Iterates over elements of `collection` and invokes `iteratee` for each element.
	 * The iteratee is invoked with three arguments: (value, index|key, collection).
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * **Note:** As with other "Collections" methods, objects with a "length"
	 * property are iterated like arrays. To avoid this behavior use `_.forIn`
	 * or `_.forOwn` for object iteration.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @alias each
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Array|Object} Returns `collection`.
	 * @see _.forEachRight
	 * @example
	 *
	 * _.forEach([1, 2], function(value) {
	 *   console.log(value);
	 * });
	 * // => Logs `1` then `2`.
	 *
	 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
	 *   console.log(key);
	 * });
	 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
	 */
	function forEach(collection, iteratee) {
	  var func = isArray(collection) ? arrayEach : baseEach;
	  return func(collection, castFunction(iteratee));
	}

	/**
	 * A specialized version of `_.forEachRight` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns `array`.
	 */
	function arrayEachRight(array, iteratee) {
	  var length = array == null ? 0 : array.length;

	  while (length--) {
	    if (iteratee(array[length], length, array) === false) {
	      break;
	    }
	  }
	  return array;
	}

	/**
	 * This function is like `baseFor` except that it iterates over properties
	 * in the opposite order.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {Function} keysFunc The function to get the keys of `object`.
	 * @returns {Object} Returns `object`.
	 */
	var baseForRight = createBaseFor(true);

	/**
	 * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 */
	function baseForOwnRight(object, iteratee) {
	  return object && baseForRight(object, iteratee, keys);
	}

	/**
	 * The base implementation of `_.forEachRight` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array|Object} Returns `collection`.
	 */
	var baseEachRight = createBaseEach(baseForOwnRight, true);

	/**
	 * This method is like `_.forEach` except that it iterates over elements of
	 * `collection` from right to left.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.0.0
	 * @alias eachRight
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Array|Object} Returns `collection`.
	 * @see _.forEach
	 * @example
	 *
	 * _.forEachRight([1, 2], function(value) {
	 *   console.log(value);
	 * });
	 * // => Logs `2` then `1`.
	 */
	function forEachRight(collection, iteratee) {
	  var func = isArray(collection) ? arrayEachRight : baseEachRight;
	  return func(collection, castFunction(iteratee));
	}

	/**
	 * Checks if `string` ends with the given target string.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to inspect.
	 * @param {string} [target] The string to search for.
	 * @param {number} [position=string.length] The position to search up to.
	 * @returns {boolean} Returns `true` if `string` ends with `target`,
	 *  else `false`.
	 * @example
	 *
	 * _.endsWith('abc', 'c');
	 * // => true
	 *
	 * _.endsWith('abc', 'b');
	 * // => false
	 *
	 * _.endsWith('abc', 'b', 2);
	 * // => true
	 */
	function endsWith(string, target, position) {
	  string = toString(string);
	  target = baseToString(target);

	  var length = string.length;
	  position = position === undefined
	    ? length
	    : baseClamp(toInteger(position), 0, length);

	  var end = position;
	  position -= target.length;
	  return position >= 0 && string.slice(position, end) == target;
	}

	/**
	 * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
	 * of key-value pairs for `object` corresponding to the property names of `props`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array} props The property names to get values for.
	 * @returns {Object} Returns the key-value pairs.
	 */
	function baseToPairs(object, props) {
	  return arrayMap(props, function(key) {
	    return [key, object[key]];
	  });
	}

	/**
	 * Converts `set` to its value-value pairs.
	 *
	 * @private
	 * @param {Object} set The set to convert.
	 * @returns {Array} Returns the value-value pairs.
	 */
	function setToPairs(set) {
	  var index = -1,
	      result = Array(set.size);

	  set.forEach(function(value) {
	    result[++index] = [value, value];
	  });
	  return result;
	}

	/** `Object#toString` result references. */
	var mapTag$6 = '[object Map]',
	    setTag$6 = '[object Set]';

	/**
	 * Creates a `_.toPairs` or `_.toPairsIn` function.
	 *
	 * @private
	 * @param {Function} keysFunc The function to get the keys of a given object.
	 * @returns {Function} Returns the new pairs function.
	 */
	function createToPairs(keysFunc) {
	  return function(object) {
	    var tag = getTag$1(object);
	    if (tag == mapTag$6) {
	      return mapToArray(object);
	    }
	    if (tag == setTag$6) {
	      return setToPairs(object);
	    }
	    return baseToPairs(object, keysFunc(object));
	  };
	}

	/**
	 * Creates an array of own enumerable string keyed-value pairs for `object`
	 * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
	 * entries are returned.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @alias entries
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the key-value pairs.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.toPairs(new Foo);
	 * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
	 */
	var toPairs = createToPairs(keys);

	/**
	 * Creates an array of own and inherited enumerable string keyed-value pairs
	 * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
	 * or set, its entries are returned.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @alias entriesIn
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the key-value pairs.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.toPairsIn(new Foo);
	 * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
	 */
	var toPairsIn = createToPairs(keysIn$1);

	/** Used to map characters to HTML entities. */
	var htmlEscapes = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;',
	  "'": '&#39;'
	};

	/**
	 * Used by `_.escape` to convert characters to HTML entities.
	 *
	 * @private
	 * @param {string} chr The matched character to escape.
	 * @returns {string} Returns the escaped character.
	 */
	var escapeHtmlChar = basePropertyOf(htmlEscapes);

	/** Used to match HTML entities and HTML characters. */
	var reUnescapedHtml = /[&<>"']/g,
	    reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

	/**
	 * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
	 * corresponding HTML entities.
	 *
	 * **Note:** No other characters are escaped. To escape additional
	 * characters use a third-party library like [_he_](https://mths.be/he).
	 *
	 * Though the ">" character is escaped for symmetry, characters like
	 * ">" and "/" don't need escaping in HTML and have no special meaning
	 * unless they're part of a tag or unquoted attribute value. See
	 * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
	 * (under "semi-related fun fact") for more details.
	 *
	 * When working with HTML you should always
	 * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
	 * XSS vectors.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category String
	 * @param {string} [string=''] The string to escape.
	 * @returns {string} Returns the escaped string.
	 * @example
	 *
	 * _.escape('fred, barney, & pebbles');
	 * // => 'fred, barney, &amp; pebbles'
	 */
	function escape$1(string) {
	  string = toString(string);
	  return (string && reHasUnescapedHtml.test(string))
	    ? string.replace(reUnescapedHtml, escapeHtmlChar)
	    : string;
	}

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g,
	    reHasRegExpChar = RegExp(reRegExpChar$1.source);

	/**
	 * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
	 * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to escape.
	 * @returns {string} Returns the escaped string.
	 * @example
	 *
	 * _.escapeRegExp('[lodash](https://lodash.com/)');
	 * // => '\[lodash\]\(https://lodash\.com/\)'
	 */
	function escapeRegExp(string) {
	  string = toString(string);
	  return (string && reHasRegExpChar.test(string))
	    ? string.replace(reRegExpChar$1, '\\$&')
	    : string;
	}

	/**
	 * A specialized version of `_.every` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if all elements pass the predicate check,
	 *  else `false`.
	 */
	function arrayEvery(array, predicate) {
	  var index = -1,
	      length = array == null ? 0 : array.length;

	  while (++index < length) {
	    if (!predicate(array[index], index, array)) {
	      return false;
	    }
	  }
	  return true;
	}

	/**
	 * The base implementation of `_.every` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if all elements pass the predicate check,
	 *  else `false`
	 */
	function baseEvery(collection, predicate) {
	  var result = true;
	  baseEach(collection, function(value, index, collection) {
	    result = !!predicate(value, index, collection);
	    return result;
	  });
	  return result;
	}

	/**
	 * Checks if `predicate` returns truthy for **all** elements of `collection`.
	 * Iteration is stopped once `predicate` returns falsey. The predicate is
	 * invoked with three arguments: (value, index|key, collection).
	 *
	 * **Note:** This method returns `true` for
	 * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
	 * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
	 * elements of empty collections.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {boolean} Returns `true` if all elements pass the predicate check,
	 *  else `false`.
	 * @example
	 *
	 * _.every([true, 1, null, 'yes'], Boolean);
	 * // => false
	 *
	 * var users = [
	 *   { 'user': 'barney', 'age': 36, 'active': false },
	 *   { 'user': 'fred',   'age': 40, 'active': false }
	 * ];
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.every(users, { 'user': 'barney', 'active': false });
	 * // => false
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.every(users, ['active', false]);
	 * // => true
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.every(users, 'active');
	 * // => false
	 */
	function every(collection, predicate, guard) {
	  var func = isArray(collection) ? arrayEvery : baseEvery;
	  if (guard && isIterateeCall(collection, predicate, guard)) {
	    predicate = undefined;
	  }
	  return func(collection, baseIteratee(predicate));
	}

	/** Used as references for the maximum length and index of an array. */
	var MAX_ARRAY_LENGTH$1 = 4294967295;

	/**
	 * Converts `value` to an integer suitable for use as the length of an
	 * array-like object.
	 *
	 * **Note:** This method is based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted integer.
	 * @example
	 *
	 * _.toLength(3.2);
	 * // => 3
	 *
	 * _.toLength(Number.MIN_VALUE);
	 * // => 0
	 *
	 * _.toLength(Infinity);
	 * // => 4294967295
	 *
	 * _.toLength('3.2');
	 * // => 3
	 */
	function toLength(value) {
	  return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH$1) : 0;
	}

	/**
	 * The base implementation of `_.fill` without an iteratee call guard.
	 *
	 * @private
	 * @param {Array} array The array to fill.
	 * @param {*} value The value to fill `array` with.
	 * @param {number} [start=0] The start position.
	 * @param {number} [end=array.length] The end position.
	 * @returns {Array} Returns `array`.
	 */
	function baseFill(array, value, start, end) {
	  var length = array.length;

	  start = toInteger(start);
	  if (start < 0) {
	    start = -start > length ? 0 : (length + start);
	  }
	  end = (end === undefined || end > length) ? length : toInteger(end);
	  if (end < 0) {
	    end += length;
	  }
	  end = start > end ? 0 : toLength(end);
	  while (start < end) {
	    array[start++] = value;
	  }
	  return array;
	}

	/**
	 * Fills elements of `array` with `value` from `start` up to, but not
	 * including, `end`.
	 *
	 * **Note:** This method mutates `array`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.2.0
	 * @category Array
	 * @param {Array} array The array to fill.
	 * @param {*} value The value to fill `array` with.
	 * @param {number} [start=0] The start position.
	 * @param {number} [end=array.length] The end position.
	 * @returns {Array} Returns `array`.
	 * @example
	 *
	 * var array = [1, 2, 3];
	 *
	 * _.fill(array, 'a');
	 * console.log(array);
	 * // => ['a', 'a', 'a']
	 *
	 * _.fill(Array(3), 2);
	 * // => [2, 2, 2]
	 *
	 * _.fill([4, 6, 8, 10], '*', 1, 3);
	 * // => [4, '*', '*', 10]
	 */
	function fill(array, value, start, end) {
	  var length = array == null ? 0 : array.length;
	  if (!length) {
	    return [];
	  }
	  if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
	    start = 0;
	    end = length;
	  }
	  return baseFill(array, value, start, end);
	}

	/**
	 * The base implementation of `_.filter` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 */
	function baseFilter(collection, predicate) {
	  var result = [];
	  baseEach(collection, function(value, index, collection) {
	    if (predicate(value, index, collection)) {
	      result.push(value);
	    }
	  });
	  return result;
	}

	/**
	 * Iterates over elements of `collection`, returning an array of all elements
	 * `predicate` returns truthy for. The predicate is invoked with three
	 * arguments: (value, index|key, collection).
	 *
	 * **Note:** Unlike `_.remove`, this method returns a new array.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 * @see _.reject
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney', 'age': 36, 'active': true },
	 *   { 'user': 'fred',   'age': 40, 'active': false }
	 * ];
	 *
	 * _.filter(users, function(o) { return !o.active; });
	 * // => objects for ['fred']
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.filter(users, { 'age': 36, 'active': true });
	 * // => objects for ['barney']
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.filter(users, ['active', false]);
	 * // => objects for ['fred']
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.filter(users, 'active');
	 * // => objects for ['barney']
	 */
	function filter(collection, predicate) {
	  var func = isArray(collection) ? arrayFilter : baseFilter;
	  return func(collection, baseIteratee(predicate));
	}

	/**
	 * Creates a `_.find` or `_.findLast` function.
	 *
	 * @private
	 * @param {Function} findIndexFunc The function to find the collection index.
	 * @returns {Function} Returns the new find function.
	 */
	function createFind(findIndexFunc) {
	  return function(collection, predicate, fromIndex) {
	    var iterable = Object(collection);
	    if (!isArrayLike(collection)) {
	      var iteratee = baseIteratee(predicate);
	      collection = keys(collection);
	      predicate = function(key) { return iteratee(iterable[key], key, iterable); };
	    }
	    var index = findIndexFunc(collection, predicate, fromIndex);
	    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
	  };
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax$6 = Math.max;

	/**
	 * This method is like `_.find` except that it returns the index of the first
	 * element `predicate` returns truthy for instead of the element itself.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.1.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @param {number} [fromIndex=0] The index to search from.
	 * @returns {number} Returns the index of the found element, else `-1`.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney',  'active': false },
	 *   { 'user': 'fred',    'active': false },
	 *   { 'user': 'pebbles', 'active': true }
	 * ];
	 *
	 * _.findIndex(users, function(o) { return o.user == 'barney'; });
	 * // => 0
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.findIndex(users, { 'user': 'fred', 'active': false });
	 * // => 1
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.findIndex(users, ['active', false]);
	 * // => 0
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.findIndex(users, 'active');
	 * // => 2
	 */
	function findIndex(array, predicate, fromIndex) {
	  var length = array == null ? 0 : array.length;
	  if (!length) {
	    return -1;
	  }
	  var index = fromIndex == null ? 0 : toInteger(fromIndex);
	  if (index < 0) {
	    index = nativeMax$6(length + index, 0);
	  }
	  return baseFindIndex(array, baseIteratee(predicate), index);
	}

	/**
	 * Iterates over elements of `collection`, returning the first element
	 * `predicate` returns truthy for. The predicate is invoked with three
	 * arguments: (value, index|key, collection).
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to inspect.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @param {number} [fromIndex=0] The index to search from.
	 * @returns {*} Returns the matched element, else `undefined`.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney',  'age': 36, 'active': true },
	 *   { 'user': 'fred',    'age': 40, 'active': false },
	 *   { 'user': 'pebbles', 'age': 1,  'active': true }
	 * ];
	 *
	 * _.find(users, function(o) { return o.age < 40; });
	 * // => object for 'barney'
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.find(users, { 'age': 1, 'active': true });
	 * // => object for 'pebbles'
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.find(users, ['active', false]);
	 * // => object for 'fred'
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.find(users, 'active');
	 * // => object for 'barney'
	 */
	var find = createFind(findIndex);

	/**
	 * The base implementation of methods like `_.findKey` and `_.findLastKey`,
	 * without support for iteratee shorthands, which iterates over `collection`
	 * using `eachFunc`.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to inspect.
	 * @param {Function} predicate The function invoked per iteration.
	 * @param {Function} eachFunc The function to iterate over `collection`.
	 * @returns {*} Returns the found element or its key, else `undefined`.
	 */
	function baseFindKey(collection, predicate, eachFunc) {
	  var result;
	  eachFunc(collection, function(value, key, collection) {
	    if (predicate(value, key, collection)) {
	      result = key;
	      return false;
	    }
	  });
	  return result;
	}

	/**
	 * This method is like `_.find` except that it returns the key of the first
	 * element `predicate` returns truthy for instead of the element itself.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.1.0
	 * @category Object
	 * @param {Object} object The object to inspect.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @returns {string|undefined} Returns the key of the matched element,
	 *  else `undefined`.
	 * @example
	 *
	 * var users = {
	 *   'barney':  { 'age': 36, 'active': true },
	 *   'fred':    { 'age': 40, 'active': false },
	 *   'pebbles': { 'age': 1,  'active': true }
	 * };
	 *
	 * _.findKey(users, function(o) { return o.age < 40; });
	 * // => 'barney' (iteration order is not guaranteed)
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.findKey(users, { 'age': 1, 'active': true });
	 * // => 'pebbles'
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.findKey(users, ['active', false]);
	 * // => 'fred'
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.findKey(users, 'active');
	 * // => 'barney'
	 */
	function findKey(object, predicate) {
	  return baseFindKey(object, baseIteratee(predicate), baseForOwn);
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax$7 = Math.max,
	    nativeMin$4 = Math.min;

	/**
	 * This method is like `_.findIndex` except that it iterates over elements
	 * of `collection` from right to left.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.0.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @param {number} [fromIndex=array.length-1] The index to search from.
	 * @returns {number} Returns the index of the found element, else `-1`.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney',  'active': true },
	 *   { 'user': 'fred',    'active': false },
	 *   { 'user': 'pebbles', 'active': false }
	 * ];
	 *
	 * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
	 * // => 2
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.findLastIndex(users, { 'user': 'barney', 'active': true });
	 * // => 0
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.findLastIndex(users, ['active', false]);
	 * // => 2
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.findLastIndex(users, 'active');
	 * // => 0
	 */
	function findLastIndex(array, predicate, fromIndex) {
	  var length = array == null ? 0 : array.length;
	  if (!length) {
	    return -1;
	  }
	  var index = length - 1;
	  if (fromIndex !== undefined) {
	    index = toInteger(fromIndex);
	    index = fromIndex < 0
	      ? nativeMax$7(length + index, 0)
	      : nativeMin$4(index, length - 1);
	  }
	  return baseFindIndex(array, baseIteratee(predicate), index, true);
	}

	/**
	 * This method is like `_.find` except that it iterates over elements of
	 * `collection` from right to left.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.0.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to inspect.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @param {number} [fromIndex=collection.length-1] The index to search from.
	 * @returns {*} Returns the matched element, else `undefined`.
	 * @example
	 *
	 * _.findLast([1, 2, 3, 4], function(n) {
	 *   return n % 2 == 1;
	 * });
	 * // => 3
	 */
	var findLast = createFind(findLastIndex);

	/**
	 * This method is like `_.findKey` except that it iterates over elements of
	 * a collection in the opposite order.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.0.0
	 * @category Object
	 * @param {Object} object The object to inspect.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @returns {string|undefined} Returns the key of the matched element,
	 *  else `undefined`.
	 * @example
	 *
	 * var users = {
	 *   'barney':  { 'age': 36, 'active': true },
	 *   'fred':    { 'age': 40, 'active': false },
	 *   'pebbles': { 'age': 1,  'active': true }
	 * };
	 *
	 * _.findLastKey(users, function(o) { return o.age < 40; });
	 * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.findLastKey(users, { 'age': 36, 'active': true });
	 * // => 'barney'
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.findLastKey(users, ['active', false]);
	 * // => 'fred'
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.findLastKey(users, 'active');
	 * // => 'pebbles'
	 */
	function findLastKey(object, predicate) {
	  return baseFindKey(object, baseIteratee(predicate), baseForOwnRight);
	}

	/**
	 * Gets the first element of `array`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @alias first
	 * @category Array
	 * @param {Array} array The array to query.
	 * @returns {*} Returns the first element of `array`.
	 * @example
	 *
	 * _.head([1, 2, 3]);
	 * // => 1
	 *
	 * _.head([]);
	 * // => undefined
	 */
	function head(array) {
	  return (array && array.length) ? array[0] : undefined;
	}

	/**
	 * The base implementation of `_.map` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 */
	function baseMap(collection, iteratee) {
	  var index = -1,
	      result = isArrayLike(collection) ? Array(collection.length) : [];

	  baseEach(collection, function(value, key, collection) {
	    result[++index] = iteratee(value, key, collection);
	  });
	  return result;
	}

	/**
	 * Creates an array of values by running each element in `collection` thru
	 * `iteratee`. The iteratee is invoked with three arguments:
	 * (value, index|key, collection).
	 *
	 * Many lodash methods are guarded to work as iteratees for methods like
	 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
	 *
	 * The guarded methods are:
	 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
	 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
	 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
	 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Array} Returns the new mapped array.
	 * @example
	 *
	 * function square(n) {
	 *   return n * n;
	 * }
	 *
	 * _.map([4, 8], square);
	 * // => [16, 64]
	 *
	 * _.map({ 'a': 4, 'b': 8 }, square);
	 * // => [16, 64] (iteration order is not guaranteed)
	 *
	 * var users = [
	 *   { 'user': 'barney' },
	 *   { 'user': 'fred' }
	 * ];
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.map(users, 'user');
	 * // => ['barney', 'fred']
	 */
	function map(collection, iteratee) {
	  var func = isArray(collection) ? arrayMap : baseMap;
	  return func(collection, baseIteratee(iteratee));
	}

	/**
	 * Creates a flattened array of values by running each element in `collection`
	 * thru `iteratee` and flattening the mapped results. The iteratee is invoked
	 * with three arguments: (value, index|key, collection).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Array} Returns the new flattened array.
	 * @example
	 *
	 * function duplicate(n) {
	 *   return [n, n];
	 * }
	 *
	 * _.flatMap([1, 2], duplicate);
	 * // => [1, 1, 2, 2]
	 */
	function flatMap(collection, iteratee) {
	  return baseFlatten(map(collection, iteratee), 1);
	}

	/** Used as references for various `Number` constants. */
	var INFINITY$3 = 1 / 0;

	/**
	 * This method is like `_.flatMap` except that it recursively flattens the
	 * mapped results.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.7.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Array} Returns the new flattened array.
	 * @example
	 *
	 * function duplicate(n) {
	 *   return [[[n, n]]];
	 * }
	 *
	 * _.flatMapDeep([1, 2], duplicate);
	 * // => [1, 1, 2, 2]
	 */
	function flatMapDeep(collection, iteratee) {
	  return baseFlatten(map(collection, iteratee), INFINITY$3);
	}

	/**
	 * This method is like `_.flatMap` except that it recursively flattens the
	 * mapped results up to `depth` times.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.7.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @param {number} [depth=1] The maximum recursion depth.
	 * @returns {Array} Returns the new flattened array.
	 * @example
	 *
	 * function duplicate(n) {
	 *   return [[[n, n]]];
	 * }
	 *
	 * _.flatMapDepth([1, 2], duplicate, 2);
	 * // => [[1, 1], [2, 2]]
	 */
	function flatMapDepth(collection, iteratee, depth) {
	  depth = depth === undefined ? 1 : toInteger(depth);
	  return baseFlatten(map(collection, iteratee), depth);
	}

	/** Used as references for various `Number` constants. */
	var INFINITY$4 = 1 / 0;

	/**
	 * Recursively flattens `array`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Array
	 * @param {Array} array The array to flatten.
	 * @returns {Array} Returns the new flattened array.
	 * @example
	 *
	 * _.flattenDeep([1, [2, [3, [4]], 5]]);
	 * // => [1, 2, 3, 4, 5]
	 */
	function flattenDeep(array) {
	  var length = array == null ? 0 : array.length;
	  return length ? baseFlatten(array, INFINITY$4) : [];
	}

	/**
	 * Recursively flatten `array` up to `depth` times.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.4.0
	 * @category Array
	 * @param {Array} array The array to flatten.
	 * @param {number} [depth=1] The maximum recursion depth.
	 * @returns {Array} Returns the new flattened array.
	 * @example
	 *
	 * var array = [1, [2, [3, [4]], 5]];
	 *
	 * _.flattenDepth(array, 1);
	 * // => [1, 2, [3, [4]], 5]
	 *
	 * _.flattenDepth(array, 2);
	 * // => [1, 2, 3, [4], 5]
	 */
	function flattenDepth(array, depth) {
	  var length = array == null ? 0 : array.length;
	  if (!length) {
	    return [];
	  }
	  depth = depth === undefined ? 1 : toInteger(depth);
	  return baseFlatten(array, depth);
	}

	/** Used to compose bitmasks for function metadata. */
	var WRAP_FLIP_FLAG$2 = 512;

	/**
	 * Creates a function that invokes `func` with arguments reversed.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Function
	 * @param {Function} func The function to flip arguments for.
	 * @returns {Function} Returns the new flipped function.
	 * @example
	 *
	 * var flipped = _.flip(function() {
	 *   return _.toArray(arguments);
	 * });
	 *
	 * flipped('a', 'b', 'c', 'd');
	 * // => ['d', 'c', 'b', 'a']
	 */
	function flip(func) {
	  return createWrap(func, WRAP_FLIP_FLAG$2);
	}

	/**
	 * Computes `number` rounded down to `precision`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.10.0
	 * @category Math
	 * @param {number} number The number to round down.
	 * @param {number} [precision=0] The precision to round down to.
	 * @returns {number} Returns the rounded down number.
	 * @example
	 *
	 * _.floor(4.006);
	 * // => 4
	 *
	 * _.floor(0.046, 2);
	 * // => 0.04
	 *
	 * _.floor(4060, -2);
	 * // => 4000
	 */
	var floor = createRound('floor');

	/** Error message constants. */
	var FUNC_ERROR_TEXT$7 = 'Expected a function';

	/** Used to compose bitmasks for function metadata. */
	var WRAP_CURRY_FLAG$6 = 8,
	    WRAP_PARTIAL_FLAG$5 = 32,
	    WRAP_ARY_FLAG$4 = 128,
	    WRAP_REARG_FLAG$2 = 256;

	/**
	 * Creates a `_.flow` or `_.flowRight` function.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new flow function.
	 */
	function createFlow(fromRight) {
	  return flatRest(function(funcs) {
	    var length = funcs.length,
	        index = length,
	        prereq = LodashWrapper.prototype.thru;

	    if (fromRight) {
	      funcs.reverse();
	    }
	    while (index--) {
	      var func = funcs[index];
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT$7);
	      }
	      if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
	        var wrapper = new LodashWrapper([], true);
	      }
	    }
	    index = wrapper ? index : length;
	    while (++index < length) {
	      func = funcs[index];

	      var funcName = getFuncName(func),
	          data = funcName == 'wrapper' ? getData(func) : undefined;

	      if (data && isLaziable(data[0]) &&
	            data[1] == (WRAP_ARY_FLAG$4 | WRAP_CURRY_FLAG$6 | WRAP_PARTIAL_FLAG$5 | WRAP_REARG_FLAG$2) &&
	            !data[4].length && data[9] == 1
	          ) {
	        wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
	      } else {
	        wrapper = (func.length == 1 && isLaziable(func))
	          ? wrapper[funcName]()
	          : wrapper.thru(func);
	      }
	    }
	    return function() {
	      var args = arguments,
	          value = args[0];

	      if (wrapper && args.length == 1 && isArray(value)) {
	        return wrapper.plant(value).value();
	      }
	      var index = 0,
	          result = length ? funcs[index].apply(this, args) : value;

	      while (++index < length) {
	        result = funcs[index].call(this, result);
	      }
	      return result;
	    };
	  });
	}

	/**
	 * Creates a function that returns the result of invoking the given functions
	 * with the `this` binding of the created function, where each successive
	 * invocation is supplied the return value of the previous.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Util
	 * @param {...(Function|Function[])} [funcs] The functions to invoke.
	 * @returns {Function} Returns the new composite function.
	 * @see _.flowRight
	 * @example
	 *
	 * function square(n) {
	 *   return n * n;
	 * }
	 *
	 * var addSquare = _.flow([_.add, square]);
	 * addSquare(1, 2);
	 * // => 9
	 */
	var flow = createFlow();

	/**
	 * This method is like `_.flow` except that it creates a function that
	 * invokes the given functions from right to left.
	 *
	 * @static
	 * @since 3.0.0
	 * @memberOf _
	 * @category Util
	 * @param {...(Function|Function[])} [funcs] The functions to invoke.
	 * @returns {Function} Returns the new composite function.
	 * @see _.flow
	 * @example
	 *
	 * function square(n) {
	 *   return n * n;
	 * }
	 *
	 * var addSquare = _.flowRight([square, _.add]);
	 * addSquare(1, 2);
	 * // => 9
	 */
	var flowRight = createFlow(true);

	/**
	 * Iterates over own and inherited enumerable string keyed properties of an
	 * object and invokes `iteratee` for each property. The iteratee is invoked
	 * with three arguments: (value, key, object). Iteratee functions may exit
	 * iteration early by explicitly returning `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.3.0
	 * @category Object
	 * @param {Object} object The object to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 * @see _.forInRight
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.forIn(new Foo, function(value, key) {
	 *   console.log(key);
	 * });
	 * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
	 */
	function forIn(object, iteratee) {
	  return object == null
	    ? object
	    : baseFor(object, castFunction(iteratee), keysIn$1);
	}

	/**
	 * This method is like `_.forIn` except that it iterates over properties of
	 * `object` in the opposite order.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.0.0
	 * @category Object
	 * @param {Object} object The object to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 * @see _.forIn
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.forInRight(new Foo, function(value, key) {
	 *   console.log(key);
	 * });
	 * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
	 */
	function forInRight(object, iteratee) {
	  return object == null
	    ? object
	    : baseForRight(object, castFunction(iteratee), keysIn$1);
	}

	/**
	 * Iterates over own enumerable string keyed properties of an object and
	 * invokes `iteratee` for each property. The iteratee is invoked with three
	 * arguments: (value, key, object). Iteratee functions may exit iteration
	 * early by explicitly returning `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.3.0
	 * @category Object
	 * @param {Object} object The object to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 * @see _.forOwnRight
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.forOwn(new Foo, function(value, key) {
	 *   console.log(key);
	 * });
	 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
	 */
	function forOwn(object, iteratee) {
	  return object && baseForOwn(object, castFunction(iteratee));
	}

	/**
	 * This method is like `_.forOwn` except that it iterates over properties of
	 * `object` in the opposite order.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.0.0
	 * @category Object
	 * @param {Object} object The object to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Object} Returns `object`.
	 * @see _.forOwn
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.forOwnRight(new Foo, function(value, key) {
	 *   console.log(key);
	 * });
	 * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
	 */
	function forOwnRight(object, iteratee) {
	  return object && baseForOwnRight(object, castFunction(iteratee));
	}

	/**
	 * The inverse of `_.toPairs`; this method returns an object composed
	 * from key-value `pairs`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Array
	 * @param {Array} pairs The key-value pairs.
	 * @returns {Object} Returns the new object.
	 * @example
	 *
	 * _.fromPairs([['a', 1], ['b', 2]]);
	 * // => { 'a': 1, 'b': 2 }
	 */
	function fromPairs(pairs) {
	  var index = -1,
	      length = pairs == null ? 0 : pairs.length,
	      result = {};

	  while (++index < length) {
	    var pair = pairs[index];
	    result[pair[0]] = pair[1];
	  }
	  return result;
	}

	/**
	 * The base implementation of `_.functions` which creates an array of
	 * `object` function property names filtered from `props`.
	 *
	 * @private
	 * @param {Object} object The object to inspect.
	 * @param {Array} props The property names to filter.
	 * @returns {Array} Returns the function names.
	 */
	function baseFunctions(object, props) {
	  return arrayFilter(props, function(key) {
	    return isFunction(object[key]);
	  });
	}

	/**
	 * Creates an array of function property names from own enumerable properties
	 * of `object`.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to inspect.
	 * @returns {Array} Returns the function names.
	 * @see _.functionsIn
	 * @example
	 *
	 * function Foo() {
	 *   this.a = _.constant('a');
	 *   this.b = _.constant('b');
	 * }
	 *
	 * Foo.prototype.c = _.constant('c');
	 *
	 * _.functions(new Foo);
	 * // => ['a', 'b']
	 */
	function functions(object) {
	  return object == null ? [] : baseFunctions(object, keys(object));
	}

	/**
	 * Creates an array of function property names from own and inherited
	 * enumerable properties of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to inspect.
	 * @returns {Array} Returns the function names.
	 * @see _.functions
	 * @example
	 *
	 * function Foo() {
	 *   this.a = _.constant('a');
	 *   this.b = _.constant('b');
	 * }
	 *
	 * Foo.prototype.c = _.constant('c');
	 *
	 * _.functionsIn(new Foo);
	 * // => ['a', 'b', 'c']
	 */
	function functionsIn(object) {
	  return object == null ? [] : baseFunctions(object, keysIn$1(object));
	}

	/** Used for built-in method references. */
	var objectProto$l = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$i = objectProto$l.hasOwnProperty;

	/**
	 * Creates an object composed of keys generated from the results of running
	 * each element of `collection` thru `iteratee`. The order of grouped values
	 * is determined by the order they occur in `collection`. The corresponding
	 * value of each key is an array of elements responsible for generating the
	 * key. The iteratee is invoked with one argument: (value).
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	 * @returns {Object} Returns the composed aggregate object.
	 * @example
	 *
	 * _.groupBy([6.1, 4.2, 6.3], Math.floor);
	 * // => { '4': [4.2], '6': [6.1, 6.3] }
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.groupBy(['one', 'two', 'three'], 'length');
	 * // => { '3': ['one', 'two'], '5': ['three'] }
	 */
	var groupBy = createAggregator(function(result, value, key) {
	  if (hasOwnProperty$i.call(result, key)) {
	    result[key].push(value);
	  } else {
	    baseAssignValue(result, key, [value]);
	  }
	});

	/**
	 * The base implementation of `_.gt` which doesn't coerce arguments.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if `value` is greater than `other`,
	 *  else `false`.
	 */
	function baseGt(value, other) {
	  return value > other;
	}

	/**
	 * Creates a function that performs a relational operation on two values.
	 *
	 * @private
	 * @param {Function} operator The function to perform the operation.
	 * @returns {Function} Returns the new relational operation function.
	 */
	function createRelationalOperation(operator) {
	  return function(value, other) {
	    if (!(typeof value == 'string' && typeof other == 'string')) {
	      value = toNumber(value);
	      other = toNumber(other);
	    }
	    return operator(value, other);
	  };
	}

	/**
	 * Checks if `value` is greater than `other`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.9.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if `value` is greater than `other`,
	 *  else `false`.
	 * @see _.lt
	 * @example
	 *
	 * _.gt(3, 1);
	 * // => true
	 *
	 * _.gt(3, 3);
	 * // => false
	 *
	 * _.gt(1, 3);
	 * // => false
	 */
	var gt = createRelationalOperation(baseGt);

	/**
	 * Checks if `value` is greater than or equal to `other`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.9.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if `value` is greater than or equal to
	 *  `other`, else `false`.
	 * @see _.lte
	 * @example
	 *
	 * _.gte(3, 1);
	 * // => true
	 *
	 * _.gte(3, 3);
	 * // => true
	 *
	 * _.gte(1, 3);
	 * // => false
	 */
	var gte = createRelationalOperation(function(value, other) {
	  return value >= other;
	});

	/** Used for built-in method references. */
	var objectProto$m = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$j = objectProto$m.hasOwnProperty;

	/**
	 * The base implementation of `_.has` without support for deep paths.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {Array|string} key The key to check.
	 * @returns {boolean} Returns `true` if `key` exists, else `false`.
	 */
	function baseHas(object, key) {
	  return object != null && hasOwnProperty$j.call(object, key);
	}

	/**
	 * Checks if `path` is a direct property of `object`.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path to check.
	 * @returns {boolean} Returns `true` if `path` exists, else `false`.
	 * @example
	 *
	 * var object = { 'a': { 'b': 2 } };
	 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
	 *
	 * _.has(object, 'a');
	 * // => true
	 *
	 * _.has(object, 'a.b');
	 * // => true
	 *
	 * _.has(object, ['a', 'b']);
	 * // => true
	 *
	 * _.has(other, 'a');
	 * // => false
	 */
	function has(object, path) {
	  return object != null && hasPath(object, path, baseHas);
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax$8 = Math.max,
	    nativeMin$5 = Math.min;

	/**
	 * The base implementation of `_.inRange` which doesn't coerce arguments.
	 *
	 * @private
	 * @param {number} number The number to check.
	 * @param {number} start The start of the range.
	 * @param {number} end The end of the range.
	 * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
	 */
	function baseInRange(number, start, end) {
	  return number >= nativeMin$5(start, end) && number < nativeMax$8(start, end);
	}

	/**
	 * Checks if `n` is between `start` and up to, but not including, `end`. If
	 * `end` is not specified, it's set to `start` with `start` then set to `0`.
	 * If `start` is greater than `end` the params are swapped to support
	 * negative ranges.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.3.0
	 * @category Number
	 * @param {number} number The number to check.
	 * @param {number} [start=0] The start of the range.
	 * @param {number} end The end of the range.
	 * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
	 * @see _.range, _.rangeRight
	 * @example
	 *
	 * _.inRange(3, 2, 4);
	 * // => true
	 *
	 * _.inRange(4, 8);
	 * // => true
	 *
	 * _.inRange(4, 2);
	 * // => false
	 *
	 * _.inRange(2, 2);
	 * // => false
	 *
	 * _.inRange(1.2, 2);
	 * // => true
	 *
	 * _.inRange(5.2, 4);
	 * // => false
	 *
	 * _.inRange(-3, -2, -6);
	 * // => true
	 */
	function inRange(number, start, end) {
	  start = toFinite(start);
	  if (end === undefined) {
	    end = start;
	    start = 0;
	  } else {
	    end = toFinite(end);
	  }
	  number = toNumber(number);
	  return baseInRange(number, start, end);
	}

	/** `Object#toString` result references. */
	var stringTag$4 = '[object String]';

	/**
	 * Checks if `value` is classified as a `String` primitive or object.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
	 * @example
	 *
	 * _.isString('abc');
	 * // => true
	 *
	 * _.isString(1);
	 * // => false
	 */
	function isString(value) {
	  return typeof value == 'string' ||
	    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag$4);
	}

	/**
	 * The base implementation of `_.values` and `_.valuesIn` which creates an
	 * array of `object` property values corresponding to the property names
	 * of `props`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array} props The property names to get values for.
	 * @returns {Object} Returns the array of property values.
	 */
	function baseValues(object, props) {
	  return arrayMap(props, function(key) {
	    return object[key];
	  });
	}

	/**
	 * Creates an array of the own enumerable string keyed property values of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property values.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.values(new Foo);
	 * // => [1, 2] (iteration order is not guaranteed)
	 *
	 * _.values('hi');
	 * // => ['h', 'i']
	 */
	function values(object) {
	  return object == null ? [] : baseValues(object, keys(object));
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax$9 = Math.max;

	/**
	 * Checks if `value` is in `collection`. If `collection` is a string, it's
	 * checked for a substring of `value`, otherwise
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * is used for equality comparisons. If `fromIndex` is negative, it's used as
	 * the offset from the end of `collection`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object|string} collection The collection to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} [fromIndex=0] The index to search from.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
	 * @returns {boolean} Returns `true` if `value` is found, else `false`.
	 * @example
	 *
	 * _.includes([1, 2, 3], 1);
	 * // => true
	 *
	 * _.includes([1, 2, 3], 1, 2);
	 * // => false
	 *
	 * _.includes({ 'a': 1, 'b': 2 }, 1);
	 * // => true
	 *
	 * _.includes('abcd', 'bc');
	 * // => true
	 */
	function includes(collection, value, fromIndex, guard) {
	  collection = isArrayLike(collection) ? collection : values(collection);
	  fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

	  var length = collection.length;
	  if (fromIndex < 0) {
	    fromIndex = nativeMax$9(length + fromIndex, 0);
	  }
	  return isString(collection)
	    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
	    : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax$a = Math.max;

	/**
	 * Gets the index at which the first occurrence of `value` is found in `array`
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons. If `fromIndex` is negative, it's used as the
	 * offset from the end of `array`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} [fromIndex=0] The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 * @example
	 *
	 * _.indexOf([1, 2, 1, 2], 2);
	 * // => 1
	 *
	 * // Search from the `fromIndex`.
	 * _.indexOf([1, 2, 1, 2], 2, 2);
	 * // => 3
	 */
	function indexOf(array, value, fromIndex) {
	  var length = array == null ? 0 : array.length;
	  if (!length) {
	    return -1;
	  }
	  var index = fromIndex == null ? 0 : toInteger(fromIndex);
	  if (index < 0) {
	    index = nativeMax$a(length + index, 0);
	  }
	  return baseIndexOf(array, value, index);
	}

	/**
	 * Gets all but the last element of `array`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to query.
	 * @returns {Array} Returns the slice of `array`.
	 * @example
	 *
	 * _.initial([1, 2, 3]);
	 * // => [1, 2]
	 */
	function initial(array) {
	  var length = array == null ? 0 : array.length;
	  return length ? baseSlice(array, 0, -1) : [];
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMin$6 = Math.min;

	/**
	 * The base implementation of methods like `_.intersection`, without support
	 * for iteratee shorthands, that accepts an array of arrays to inspect.
	 *
	 * @private
	 * @param {Array} arrays The arrays to inspect.
	 * @param {Function} [iteratee] The iteratee invoked per element.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new array of shared values.
	 */
	function baseIntersection(arrays, iteratee, comparator) {
	  var includes = comparator ? arrayIncludesWith : arrayIncludes,
	      length = arrays[0].length,
	      othLength = arrays.length,
	      othIndex = othLength,
	      caches = Array(othLength),
	      maxLength = Infinity,
	      result = [];

	  while (othIndex--) {
	    var array = arrays[othIndex];
	    if (othIndex && iteratee) {
	      array = arrayMap(array, baseUnary(iteratee));
	    }
	    maxLength = nativeMin$6(array.length, maxLength);
	    caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
	      ? new SetCache(othIndex && array)
	      : undefined;
	  }
	  array = arrays[0];

	  var index = -1,
	      seen = caches[0];

	  outer:
	  while (++index < length && result.length < maxLength) {
	    var value = array[index],
	        computed = iteratee ? iteratee(value) : value;

	    value = (comparator || value !== 0) ? value : 0;
	    if (!(seen
	          ? cacheHas(seen, computed)
	          : includes(result, computed, comparator)
	        )) {
	      othIndex = othLength;
	      while (--othIndex) {
	        var cache = caches[othIndex];
	        if (!(cache
	              ? cacheHas(cache, computed)
	              : includes(arrays[othIndex], computed, comparator))
	            ) {
	          continue outer;
	        }
	      }
	      if (seen) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	  }
	  return result;
	}

	/**
	 * Casts `value` to an empty array if it's not an array like object.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @returns {Array|Object} Returns the cast array-like object.
	 */
	function castArrayLikeObject(value) {
	  return isArrayLikeObject(value) ? value : [];
	}

	/**
	 * Creates an array of unique values that are included in all given arrays
	 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons. The order and references of result values are
	 * determined by the first array.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {...Array} [arrays] The arrays to inspect.
	 * @returns {Array} Returns the new array of intersecting values.
	 * @example
	 *
	 * _.intersection([2, 1], [2, 3]);
	 * // => [2]
	 */
	var intersection = baseRest(function(arrays) {
	  var mapped = arrayMap(arrays, castArrayLikeObject);
	  return (mapped.length && mapped[0] === arrays[0])
	    ? baseIntersection(mapped)
	    : [];
	});

	/**
	 * This method is like `_.intersection` except that it accepts `iteratee`
	 * which is invoked for each element of each `arrays` to generate the criterion
	 * by which they're compared. The order and references of result values are
	 * determined by the first array. The iteratee is invoked with one argument:
	 * (value).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Array
	 * @param {...Array} [arrays] The arrays to inspect.
	 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	 * @returns {Array} Returns the new array of intersecting values.
	 * @example
	 *
	 * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	 * // => [2.1]
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	 * // => [{ 'x': 1 }]
	 */
	var intersectionBy = baseRest(function(arrays) {
	  var iteratee = last(arrays),
	      mapped = arrayMap(arrays, castArrayLikeObject);

	  if (iteratee === last(mapped)) {
	    iteratee = undefined;
	  } else {
	    mapped.pop();
	  }
	  return (mapped.length && mapped[0] === arrays[0])
	    ? baseIntersection(mapped, baseIteratee(iteratee))
	    : [];
	});

	/**
	 * This method is like `_.intersection` except that it accepts `comparator`
	 * which is invoked to compare elements of `arrays`. The order and references
	 * of result values are determined by the first array. The comparator is
	 * invoked with two arguments: (arrVal, othVal).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Array
	 * @param {...Array} [arrays] The arrays to inspect.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new array of intersecting values.
	 * @example
	 *
	 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	 * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	 *
	 * _.intersectionWith(objects, others, _.isEqual);
	 * // => [{ 'x': 1, 'y': 2 }]
	 */
	var intersectionWith = baseRest(function(arrays) {
	  var comparator = last(arrays),
	      mapped = arrayMap(arrays, castArrayLikeObject);

	  comparator = typeof comparator == 'function' ? comparator : undefined;
	  if (comparator) {
	    mapped.pop();
	  }
	  return (mapped.length && mapped[0] === arrays[0])
	    ? baseIntersection(mapped, undefined, comparator)
	    : [];
	});

	/**
	 * The base implementation of `_.invert` and `_.invertBy` which inverts
	 * `object` with values transformed by `iteratee` and set by `setter`.
	 *
	 * @private
	 * @param {Object} object The object to iterate over.
	 * @param {Function} setter The function to set `accumulator` values.
	 * @param {Function} iteratee The iteratee to transform values.
	 * @param {Object} accumulator The initial inverted object.
	 * @returns {Function} Returns `accumulator`.
	 */
	function baseInverter(object, setter, iteratee, accumulator) {
	  baseForOwn(object, function(value, key, object) {
	    setter(accumulator, iteratee(value), key, object);
	  });
	  return accumulator;
	}

	/**
	 * Creates a function like `_.invertBy`.
	 *
	 * @private
	 * @param {Function} setter The function to set accumulator values.
	 * @param {Function} toIteratee The function to resolve iteratees.
	 * @returns {Function} Returns the new inverter function.
	 */
	function createInverter(setter, toIteratee) {
	  return function(object, iteratee) {
	    return baseInverter(object, setter, toIteratee(iteratee), {});
	  };
	}

	/** Used for built-in method references. */
	var objectProto$n = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString$2 = objectProto$n.toString;

	/**
	 * Creates an object composed of the inverted keys and values of `object`.
	 * If `object` contains duplicate values, subsequent values overwrite
	 * property assignments of previous values.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.7.0
	 * @category Object
	 * @param {Object} object The object to invert.
	 * @returns {Object} Returns the new inverted object.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2, 'c': 1 };
	 *
	 * _.invert(object);
	 * // => { '1': 'c', '2': 'b' }
	 */
	var invert = createInverter(function(result, value, key) {
	  if (value != null &&
	      typeof value.toString != 'function') {
	    value = nativeObjectToString$2.call(value);
	  }

	  result[value] = key;
	}, constant(identity));

	/** Used for built-in method references. */
	var objectProto$o = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$k = objectProto$o.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString$3 = objectProto$o.toString;

	/**
	 * This method is like `_.invert` except that the inverted object is generated
	 * from the results of running each element of `object` thru `iteratee`. The
	 * corresponding inverted value of each inverted key is an array of keys
	 * responsible for generating the inverted value. The iteratee is invoked
	 * with one argument: (value).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.1.0
	 * @category Object
	 * @param {Object} object The object to invert.
	 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	 * @returns {Object} Returns the new inverted object.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2, 'c': 1 };
	 *
	 * _.invertBy(object);
	 * // => { '1': ['a', 'c'], '2': ['b'] }
	 *
	 * _.invertBy(object, function(value) {
	 *   return 'group' + value;
	 * });
	 * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
	 */
	var invertBy = createInverter(function(result, value, key) {
	  if (value != null &&
	      typeof value.toString != 'function') {
	    value = nativeObjectToString$3.call(value);
	  }

	  if (hasOwnProperty$k.call(result, value)) {
	    result[value].push(key);
	  } else {
	    result[value] = [key];
	  }
	}, baseIteratee);

	/**
	 * Gets the parent value at `path` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array} path The path to get the parent value of.
	 * @returns {*} Returns the parent value.
	 */
	function parent(object, path) {
	  return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
	}

	/**
	 * The base implementation of `_.invoke` without support for individual
	 * method arguments.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the method to invoke.
	 * @param {Array} args The arguments to invoke the method with.
	 * @returns {*} Returns the result of the invoked method.
	 */
	function baseInvoke(object, path, args) {
	  path = castPath(path, object);
	  object = parent(object, path);
	  var func = object == null ? object : object[toKey(last(path))];
	  return func == null ? undefined : apply(func, object, args);
	}

	/**
	 * Invokes the method at `path` of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the method to invoke.
	 * @param {...*} [args] The arguments to invoke the method with.
	 * @returns {*} Returns the result of the invoked method.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
	 *
	 * _.invoke(object, 'a[0].b.c.slice', 1, 3);
	 * // => [2, 3]
	 */
	var invoke = baseRest(baseInvoke);

	/**
	 * Invokes the method at `path` of each element in `collection`, returning
	 * an array of the results of each invoked method. Any additional arguments
	 * are provided to each invoked method. If `path` is a function, it's invoked
	 * for, and `this` bound to, each element in `collection`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Array|Function|string} path The path of the method to invoke or
	 *  the function invoked per iteration.
	 * @param {...*} [args] The arguments to invoke each method with.
	 * @returns {Array} Returns the array of results.
	 * @example
	 *
	 * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
	 * // => [[1, 5, 7], [1, 2, 3]]
	 *
	 * _.invokeMap([123, 456], String.prototype.split, '');
	 * // => [['1', '2', '3'], ['4', '5', '6']]
	 */
	var invokeMap = baseRest(function(collection, path, args) {
	  var index = -1,
	      isFunc = typeof path == 'function',
	      result = isArrayLike(collection) ? Array(collection.length) : [];

	  baseEach(collection, function(value) {
	    result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
	  });
	  return result;
	});

	var arrayBufferTag$4 = '[object ArrayBuffer]';

	/**
	 * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
	 */
	function baseIsArrayBuffer(value) {
	  return isObjectLike(value) && baseGetTag(value) == arrayBufferTag$4;
	}

	/* Node.js helper references. */
	var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer;

	/**
	 * Checks if `value` is classified as an `ArrayBuffer` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
	 * @example
	 *
	 * _.isArrayBuffer(new ArrayBuffer(2));
	 * // => true
	 *
	 * _.isArrayBuffer(new Array(2));
	 * // => false
	 */
	var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

	/** `Object#toString` result references. */
	var boolTag$4 = '[object Boolean]';

	/**
	 * Checks if `value` is classified as a boolean primitive or object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
	 * @example
	 *
	 * _.isBoolean(false);
	 * // => true
	 *
	 * _.isBoolean(null);
	 * // => false
	 */
	function isBoolean(value) {
	  return value === true || value === false ||
	    (isObjectLike(value) && baseGetTag(value) == boolTag$4);
	}

	/** `Object#toString` result references. */
	var dateTag$4 = '[object Date]';

	/**
	 * The base implementation of `_.isDate` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
	 */
	function baseIsDate(value) {
	  return isObjectLike(value) && baseGetTag(value) == dateTag$4;
	}

	/* Node.js helper references. */
	var nodeIsDate = nodeUtil && nodeUtil.isDate;

	/**
	 * Checks if `value` is classified as a `Date` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
	 * @example
	 *
	 * _.isDate(new Date);
	 * // => true
	 *
	 * _.isDate('Mon April 23 2012');
	 * // => false
	 */
	var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

	/**
	 * Checks if `value` is likely a DOM element.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
	 * @example
	 *
	 * _.isElement(document.body);
	 * // => true
	 *
	 * _.isElement('<body>');
	 * // => false
	 */
	function isElement(value) {
	  return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
	}

	/** `Object#toString` result references. */
	var mapTag$7 = '[object Map]',
	    setTag$7 = '[object Set]';

	/** Used for built-in method references. */
	var objectProto$p = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$l = objectProto$p.hasOwnProperty;

	/**
	 * Checks if `value` is an empty object, collection, map, or set.
	 *
	 * Objects are considered empty if they have no own enumerable string keyed
	 * properties.
	 *
	 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
	 * jQuery-like collections are considered empty if they have a `length` of `0`.
	 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
	 * @example
	 *
	 * _.isEmpty(null);
	 * // => true
	 *
	 * _.isEmpty(true);
	 * // => true
	 *
	 * _.isEmpty(1);
	 * // => true
	 *
	 * _.isEmpty([1, 2, 3]);
	 * // => false
	 *
	 * _.isEmpty({ 'a': 1 });
	 * // => false
	 */
	function isEmpty(value) {
	  if (value == null) {
	    return true;
	  }
	  if (isArrayLike(value) &&
	      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
	        isBuffer(value) || isTypedArray(value) || isArguments(value))) {
	    return !value.length;
	  }
	  var tag = getTag$1(value);
	  if (tag == mapTag$7 || tag == setTag$7) {
	    return !value.size;
	  }
	  if (isPrototype(value)) {
	    return !baseKeys(value).length;
	  }
	  for (var key in value) {
	    if (hasOwnProperty$l.call(value, key)) {
	      return false;
	    }
	  }
	  return true;
	}

	/**
	 * Performs a deep comparison between two values to determine if they are
	 * equivalent.
	 *
	 * **Note:** This method supports comparing arrays, array buffers, booleans,
	 * date objects, error objects, maps, numbers, `Object` objects, regexes,
	 * sets, strings, symbols, and typed arrays. `Object` objects are compared
	 * by their own, not inherited, enumerable properties. Functions and DOM
	 * nodes are compared by strict equality, i.e. `===`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1 };
	 * var other = { 'a': 1 };
	 *
	 * _.isEqual(object, other);
	 * // => true
	 *
	 * object === other;
	 * // => false
	 */
	function isEqual(value, other) {
	  return baseIsEqual(value, other);
	}

	/**
	 * This method is like `_.isEqual` except that it accepts `customizer` which
	 * is invoked to compare values. If `customizer` returns `undefined`, comparisons
	 * are handled by the method instead. The `customizer` is invoked with up to
	 * six arguments: (objValue, othValue [, index|key, object, other, stack]).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	 * @example
	 *
	 * function isGreeting(value) {
	 *   return /^h(?:i|ello)$/.test(value);
	 * }
	 *
	 * function customizer(objValue, othValue) {
	 *   if (isGreeting(objValue) && isGreeting(othValue)) {
	 *     return true;
	 *   }
	 * }
	 *
	 * var array = ['hello', 'goodbye'];
	 * var other = ['hi', 'goodbye'];
	 *
	 * _.isEqualWith(array, other, customizer);
	 * // => true
	 */
	function isEqualWith(value, other, customizer) {
	  customizer = typeof customizer == 'function' ? customizer : undefined;
	  var result = customizer ? customizer(value, other) : undefined;
	  return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsFinite$1 = root.isFinite;

	/**
	 * Checks if `value` is a finite primitive number.
	 *
	 * **Note:** This method is based on
	 * [`Number.isFinite`](https://mdn.io/Number/isFinite).
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
	 * @example
	 *
	 * _.isFinite(3);
	 * // => true
	 *
	 * _.isFinite(Number.MIN_VALUE);
	 * // => true
	 *
	 * _.isFinite(Infinity);
	 * // => false
	 *
	 * _.isFinite('3');
	 * // => false
	 */
	function isFinite$1(value) {
	  return typeof value == 'number' && nativeIsFinite$1(value);
	}

	/**
	 * Checks if `value` is an integer.
	 *
	 * **Note:** This method is based on
	 * [`Number.isInteger`](https://mdn.io/Number/isInteger).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
	 * @example
	 *
	 * _.isInteger(3);
	 * // => true
	 *
	 * _.isInteger(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isInteger(Infinity);
	 * // => false
	 *
	 * _.isInteger('3');
	 * // => false
	 */
	function isInteger(value) {
	  return typeof value == 'number' && value == toInteger(value);
	}

	/**
	 * Performs a partial deep comparison between `object` and `source` to
	 * determine if `object` contains equivalent property values.
	 *
	 * **Note:** This method is equivalent to `_.matches` when `source` is
	 * partially applied.
	 *
	 * Partial comparisons will match empty array and empty object `source`
	 * values against any array or object value, respectively. See `_.isEqual`
	 * for a list of supported value comparisons.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property values to match.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': 2 };
	 *
	 * _.isMatch(object, { 'b': 2 });
	 * // => true
	 *
	 * _.isMatch(object, { 'b': 1 });
	 * // => false
	 */
	function isMatch(object, source) {
	  return object === source || baseIsMatch(object, source, getMatchData(source));
	}

	/**
	 * This method is like `_.isMatch` except that it accepts `customizer` which
	 * is invoked to compare values. If `customizer` returns `undefined`, comparisons
	 * are handled by the method instead. The `customizer` is invoked with five
	 * arguments: (objValue, srcValue, index|key, object, source).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {Object} object The object to inspect.
	 * @param {Object} source The object of property values to match.
	 * @param {Function} [customizer] The function to customize comparisons.
	 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	 * @example
	 *
	 * function isGreeting(value) {
	 *   return /^h(?:i|ello)$/.test(value);
	 * }
	 *
	 * function customizer(objValue, srcValue) {
	 *   if (isGreeting(objValue) && isGreeting(srcValue)) {
	 *     return true;
	 *   }
	 * }
	 *
	 * var object = { 'greeting': 'hello' };
	 * var source = { 'greeting': 'hi' };
	 *
	 * _.isMatchWith(object, source, customizer);
	 * // => true
	 */
	function isMatchWith(object, source, customizer) {
	  customizer = typeof customizer == 'function' ? customizer : undefined;
	  return baseIsMatch(object, source, getMatchData(source), customizer);
	}

	/** `Object#toString` result references. */
	var numberTag$4 = '[object Number]';

	/**
	 * Checks if `value` is classified as a `Number` primitive or object.
	 *
	 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
	 * classified as numbers, use the `_.isFinite` method.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a number, else `false`.
	 * @example
	 *
	 * _.isNumber(3);
	 * // => true
	 *
	 * _.isNumber(Number.MIN_VALUE);
	 * // => true
	 *
	 * _.isNumber(Infinity);
	 * // => true
	 *
	 * _.isNumber('3');
	 * // => false
	 */
	function isNumber(value) {
	  return typeof value == 'number' ||
	    (isObjectLike(value) && baseGetTag(value) == numberTag$4);
	}

	/**
	 * Checks if `value` is `NaN`.
	 *
	 * **Note:** This method is based on
	 * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
	 * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
	 * `undefined` and other non-number values.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	 * @example
	 *
	 * _.isNaN(NaN);
	 * // => true
	 *
	 * _.isNaN(new Number(NaN));
	 * // => true
	 *
	 * isNaN(undefined);
	 * // => true
	 *
	 * _.isNaN(undefined);
	 * // => false
	 */
	function isNaN$1(value) {
	  // An `NaN` primitive is the only value that is not equal to itself.
	  // Perform the `toStringTag` check first to avoid errors with some
	  // ActiveX objects in IE.
	  return isNumber(value) && value != +value;
	}

	/**
	 * Checks if `func` is capable of being masked.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
	 */
	var isMaskable = coreJsData ? isFunction : stubFalse;

	/** Error message constants. */
	var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.';

	/**
	 * Checks if `value` is a pristine native function.
	 *
	 * **Note:** This method can't reliably detect native functions in the presence
	 * of the core-js package because core-js circumvents this kind of detection.
	 * Despite multiple requests, the core-js maintainer has made it clear: any
	 * attempt to fix the detection will be obstructed. As a result, we're left
	 * with little choice but to throw an error. Unfortunately, this also affects
	 * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
	 * which rely on core-js.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 * @example
	 *
	 * _.isNative(Array.prototype.push);
	 * // => true
	 *
	 * _.isNative(_);
	 * // => false
	 */
	function isNative(value) {
	  if (isMaskable(value)) {
	    throw new Error(CORE_ERROR_TEXT);
	  }
	  return baseIsNative(value);
	}

	/**
	 * Checks if `value` is `null` or `undefined`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
	 * @example
	 *
	 * _.isNil(null);
	 * // => true
	 *
	 * _.isNil(void 0);
	 * // => true
	 *
	 * _.isNil(NaN);
	 * // => false
	 */
	function isNil(value) {
	  return value == null;
	}

	/**
	 * Checks if `value` is `null`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
	 * @example
	 *
	 * _.isNull(null);
	 * // => true
	 *
	 * _.isNull(void 0);
	 * // => false
	 */
	function isNull(value) {
	  return value === null;
	}

	/** `Object#toString` result references. */
	var regexpTag$4 = '[object RegExp]';

	/**
	 * The base implementation of `_.isRegExp` without Node.js optimizations.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
	 */
	function baseIsRegExp(value) {
	  return isObjectLike(value) && baseGetTag(value) == regexpTag$4;
	}

	/* Node.js helper references. */
	var nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;

	/**
	 * Checks if `value` is classified as a `RegExp` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
	 * @example
	 *
	 * _.isRegExp(/abc/);
	 * // => true
	 *
	 * _.isRegExp('/abc/');
	 * // => false
	 */
	var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER$2 = 9007199254740991;

	/**
	 * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
	 * double precision number which isn't the result of a rounded unsafe integer.
	 *
	 * **Note:** This method is based on
	 * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
	 * @example
	 *
	 * _.isSafeInteger(3);
	 * // => true
	 *
	 * _.isSafeInteger(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isSafeInteger(Infinity);
	 * // => false
	 *
	 * _.isSafeInteger('3');
	 * // => false
	 */
	function isSafeInteger(value) {
	  return isInteger(value) && value >= -MAX_SAFE_INTEGER$2 && value <= MAX_SAFE_INTEGER$2;
	}

	/**
	 * Checks if `value` is `undefined`.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
	 * @example
	 *
	 * _.isUndefined(void 0);
	 * // => true
	 *
	 * _.isUndefined(null);
	 * // => false
	 */
	function isUndefined(value) {
	  return value === undefined;
	}

	/** `Object#toString` result references. */
	var weakMapTag$3 = '[object WeakMap]';

	/**
	 * Checks if `value` is classified as a `WeakMap` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
	 * @example
	 *
	 * _.isWeakMap(new WeakMap);
	 * // => true
	 *
	 * _.isWeakMap(new Map);
	 * // => false
	 */
	function isWeakMap(value) {
	  return isObjectLike(value) && getTag$1(value) == weakMapTag$3;
	}

	/** `Object#toString` result references. */
	var weakSetTag = '[object WeakSet]';

	/**
	 * Checks if `value` is classified as a `WeakSet` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
	 * @example
	 *
	 * _.isWeakSet(new WeakSet);
	 * // => true
	 *
	 * _.isWeakSet(new Set);
	 * // => false
	 */
	function isWeakSet(value) {
	  return isObjectLike(value) && baseGetTag(value) == weakSetTag;
	}

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG$4 = 1;

	/**
	 * Creates a function that invokes `func` with the arguments of the created
	 * function. If `func` is a property name, the created function returns the
	 * property value for a given element. If `func` is an array or object, the
	 * created function returns `true` for elements that contain the equivalent
	 * source properties, otherwise it returns `false`.
	 *
	 * @static
	 * @since 4.0.0
	 * @memberOf _
	 * @category Util
	 * @param {*} [func=_.identity] The value to convert to a callback.
	 * @returns {Function} Returns the callback.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney', 'age': 36, 'active': true },
	 *   { 'user': 'fred',   'age': 40, 'active': false }
	 * ];
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
	 * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.filter(users, _.iteratee(['user', 'fred']));
	 * // => [{ 'user': 'fred', 'age': 40 }]
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.map(users, _.iteratee('user'));
	 * // => ['barney', 'fred']
	 *
	 * // Create custom iteratee shorthands.
	 * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
	 *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
	 *     return func.test(string);
	 *   };
	 * });
	 *
	 * _.filter(['abc', 'def'], /ef/);
	 * // => ['def']
	 */
	function iteratee(func) {
	  return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG$4));
	}

	/** Used for built-in method references. */
	var arrayProto$1 = Array.prototype;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeJoin = arrayProto$1.join;

	/**
	 * Converts all elements in `array` into a string separated by `separator`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Array
	 * @param {Array} array The array to convert.
	 * @param {string} [separator=','] The element separator.
	 * @returns {string} Returns the joined string.
	 * @example
	 *
	 * _.join(['a', 'b', 'c'], '~');
	 * // => 'a~b~c'
	 */
	function join(array, separator) {
	  return array == null ? '' : nativeJoin.call(array, separator);
	}

	/**
	 * Converts `string` to
	 * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to convert.
	 * @returns {string} Returns the kebab cased string.
	 * @example
	 *
	 * _.kebabCase('Foo Bar');
	 * // => 'foo-bar'
	 *
	 * _.kebabCase('fooBar');
	 * // => 'foo-bar'
	 *
	 * _.kebabCase('__FOO_BAR__');
	 * // => 'foo-bar'
	 */
	var kebabCase = createCompounder(function(result, word, index) {
	  return result + (index ? '-' : '') + word.toLowerCase();
	});

	/**
	 * Creates an object composed of keys generated from the results of running
	 * each element of `collection` thru `iteratee`. The corresponding value of
	 * each key is the last element responsible for generating the key. The
	 * iteratee is invoked with one argument: (value).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	 * @returns {Object} Returns the composed aggregate object.
	 * @example
	 *
	 * var array = [
	 *   { 'dir': 'left', 'code': 97 },
	 *   { 'dir': 'right', 'code': 100 }
	 * ];
	 *
	 * _.keyBy(array, function(o) {
	 *   return String.fromCharCode(o.code);
	 * });
	 * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	 *
	 * _.keyBy(array, 'dir');
	 * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
	 */
	var keyBy = createAggregator(function(result, value, key) {
	  baseAssignValue(result, key, value);
	});

	/**
	 * A specialized version of `_.lastIndexOf` which performs strict equality
	 * comparisons of values, i.e. `===`.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function strictLastIndexOf(array, value, fromIndex) {
	  var index = fromIndex + 1;
	  while (index--) {
	    if (array[index] === value) {
	      return index;
	    }
	  }
	  return index;
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax$b = Math.max,
	    nativeMin$7 = Math.min;

	/**
	 * This method is like `_.indexOf` except that it iterates over elements of
	 * `array` from right to left.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} [fromIndex=array.length-1] The index to search from.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 * @example
	 *
	 * _.lastIndexOf([1, 2, 1, 2], 2);
	 * // => 3
	 *
	 * // Search from the `fromIndex`.
	 * _.lastIndexOf([1, 2, 1, 2], 2, 2);
	 * // => 1
	 */
	function lastIndexOf(array, value, fromIndex) {
	  var length = array == null ? 0 : array.length;
	  if (!length) {
	    return -1;
	  }
	  var index = length;
	  if (fromIndex !== undefined) {
	    index = toInteger(fromIndex);
	    index = index < 0 ? nativeMax$b(length + index, 0) : nativeMin$7(index, length - 1);
	  }
	  return value === value
	    ? strictLastIndexOf(array, value, index)
	    : baseFindIndex(array, baseIsNaN, index, true);
	}

	/**
	 * Converts `string`, as space separated words, to lower case.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category String
	 * @param {string} [string=''] The string to convert.
	 * @returns {string} Returns the lower cased string.
	 * @example
	 *
	 * _.lowerCase('--Foo-Bar--');
	 * // => 'foo bar'
	 *
	 * _.lowerCase('fooBar');
	 * // => 'foo bar'
	 *
	 * _.lowerCase('__FOO_BAR__');
	 * // => 'foo bar'
	 */
	var lowerCase = createCompounder(function(result, word, index) {
	  return result + (index ? ' ' : '') + word.toLowerCase();
	});

	/**
	 * Converts the first character of `string` to lower case.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category String
	 * @param {string} [string=''] The string to convert.
	 * @returns {string} Returns the converted string.
	 * @example
	 *
	 * _.lowerFirst('Fred');
	 * // => 'fred'
	 *
	 * _.lowerFirst('FRED');
	 * // => 'fRED'
	 */
	var lowerFirst = createCaseFirst('toLowerCase');

	/**
	 * The base implementation of `_.lt` which doesn't coerce arguments.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if `value` is less than `other`,
	 *  else `false`.
	 */
	function baseLt(value, other) {
	  return value < other;
	}

	/**
	 * Checks if `value` is less than `other`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.9.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if `value` is less than `other`,
	 *  else `false`.
	 * @see _.gt
	 * @example
	 *
	 * _.lt(1, 3);
	 * // => true
	 *
	 * _.lt(3, 3);
	 * // => false
	 *
	 * _.lt(3, 1);
	 * // => false
	 */
	var lt = createRelationalOperation(baseLt);

	/**
	 * Checks if `value` is less than or equal to `other`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.9.0
	 * @category Lang
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {boolean} Returns `true` if `value` is less than or equal to
	 *  `other`, else `false`.
	 * @see _.gte
	 * @example
	 *
	 * _.lte(1, 3);
	 * // => true
	 *
	 * _.lte(3, 3);
	 * // => true
	 *
	 * _.lte(3, 1);
	 * // => false
	 */
	var lte = createRelationalOperation(function(value, other) {
	  return value <= other;
	});

	/**
	 * The opposite of `_.mapValues`; this method creates an object with the
	 * same values as `object` and keys generated by running each own enumerable
	 * string keyed property of `object` thru `iteratee`. The iteratee is invoked
	 * with three arguments: (value, key, object).
	 *
	 * @static
	 * @memberOf _
	 * @since 3.8.0
	 * @category Object
	 * @param {Object} object The object to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Object} Returns the new mapped object.
	 * @see _.mapValues
	 * @example
	 *
	 * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
	 *   return key + value;
	 * });
	 * // => { 'a1': 1, 'b2': 2 }
	 */
	function mapKeys(object, iteratee) {
	  var result = {};
	  iteratee = baseIteratee(iteratee);

	  baseForOwn(object, function(value, key, object) {
	    baseAssignValue(result, iteratee(value, key, object), value);
	  });
	  return result;
	}

	/**
	 * Creates an object with the same keys as `object` and values generated
	 * by running each own enumerable string keyed property of `object` thru
	 * `iteratee`. The iteratee is invoked with three arguments:
	 * (value, key, object).
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Object
	 * @param {Object} object The object to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Object} Returns the new mapped object.
	 * @see _.mapKeys
	 * @example
	 *
	 * var users = {
	 *   'fred':    { 'user': 'fred',    'age': 40 },
	 *   'pebbles': { 'user': 'pebbles', 'age': 1 }
	 * };
	 *
	 * _.mapValues(users, function(o) { return o.age; });
	 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.mapValues(users, 'age');
	 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	 */
	function mapValues(object, iteratee) {
	  var result = {};
	  iteratee = baseIteratee(iteratee);

	  baseForOwn(object, function(value, key, object) {
	    baseAssignValue(result, key, iteratee(value, key, object));
	  });
	  return result;
	}

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG$5 = 1;

	/**
	 * Creates a function that performs a partial deep comparison between a given
	 * object and `source`, returning `true` if the given object has equivalent
	 * property values, else `false`.
	 *
	 * **Note:** The created function is equivalent to `_.isMatch` with `source`
	 * partially applied.
	 *
	 * Partial comparisons will match empty array and empty object `source`
	 * values against any array or object value, respectively. See `_.isEqual`
	 * for a list of supported value comparisons.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Util
	 * @param {Object} source The object of property values to match.
	 * @returns {Function} Returns the new spec function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': 1, 'b': 2, 'c': 3 },
	 *   { 'a': 4, 'b': 5, 'c': 6 }
	 * ];
	 *
	 * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
	 * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
	 */
	function matches(source) {
	  return baseMatches(baseClone(source, CLONE_DEEP_FLAG$5));
	}

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG$6 = 1;

	/**
	 * Creates a function that performs a partial deep comparison between the
	 * value at `path` of a given object to `srcValue`, returning `true` if the
	 * object value is equivalent, else `false`.
	 *
	 * **Note:** Partial comparisons will match empty array and empty object
	 * `srcValue` values against any array or object value, respectively. See
	 * `_.isEqual` for a list of supported value comparisons.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.2.0
	 * @category Util
	 * @param {Array|string} path The path of the property to get.
	 * @param {*} srcValue The value to match.
	 * @returns {Function} Returns the new spec function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': 1, 'b': 2, 'c': 3 },
	 *   { 'a': 4, 'b': 5, 'c': 6 }
	 * ];
	 *
	 * _.find(objects, _.matchesProperty('a', 4));
	 * // => { 'a': 4, 'b': 5, 'c': 6 }
	 */
	function matchesProperty(path, srcValue) {
	  return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG$6));
	}

	/**
	 * The base implementation of methods like `_.max` and `_.min` which accepts a
	 * `comparator` to determine the extremum value.
	 *
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} iteratee The iteratee invoked per iteration.
	 * @param {Function} comparator The comparator used to compare values.
	 * @returns {*} Returns the extremum value.
	 */
	function baseExtremum(array, iteratee, comparator) {
	  var index = -1,
	      length = array.length;

	  while (++index < length) {
	    var value = array[index],
	        current = iteratee(value);

	    if (current != null && (computed === undefined
	          ? (current === current && !isSymbol(current))
	          : comparator(current, computed)
	        )) {
	      var computed = current,
	          result = value;
	    }
	  }
	  return result;
	}

	/**
	 * Computes the maximum value of `array`. If `array` is empty or falsey,
	 * `undefined` is returned.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Math
	 * @param {Array} array The array to iterate over.
	 * @returns {*} Returns the maximum value.
	 * @example
	 *
	 * _.max([4, 2, 8, 6]);
	 * // => 8
	 *
	 * _.max([]);
	 * // => undefined
	 */
	function max(array) {
	  return (array && array.length)
	    ? baseExtremum(array, identity, baseGt)
	    : undefined;
	}

	/**
	 * This method is like `_.max` except that it accepts `iteratee` which is
	 * invoked for each element in `array` to generate the criterion by which
	 * the value is ranked. The iteratee is invoked with one argument: (value).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Math
	 * @param {Array} array The array to iterate over.
	 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	 * @returns {*} Returns the maximum value.
	 * @example
	 *
	 * var objects = [{ 'n': 1 }, { 'n': 2 }];
	 *
	 * _.maxBy(objects, function(o) { return o.n; });
	 * // => { 'n': 2 }
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.maxBy(objects, 'n');
	 * // => { 'n': 2 }
	 */
	function maxBy(array, iteratee) {
	  return (array && array.length)
	    ? baseExtremum(array, baseIteratee(iteratee), baseGt)
	    : undefined;
	}

	/**
	 * The base implementation of `_.sum` and `_.sumBy` without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {number} Returns the sum.
	 */
	function baseSum(array, iteratee) {
	  var result,
	      index = -1,
	      length = array.length;

	  while (++index < length) {
	    var current = iteratee(array[index]);
	    if (current !== undefined) {
	      result = result === undefined ? current : (result + current);
	    }
	  }
	  return result;
	}

	/** Used as references for various `Number` constants. */
	var NAN$2 = 0 / 0;

	/**
	 * The base implementation of `_.mean` and `_.meanBy` without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @returns {number} Returns the mean.
	 */
	function baseMean(array, iteratee) {
	  var length = array == null ? 0 : array.length;
	  return length ? (baseSum(array, iteratee) / length) : NAN$2;
	}

	/**
	 * Computes the mean of the values in `array`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Math
	 * @param {Array} array The array to iterate over.
	 * @returns {number} Returns the mean.
	 * @example
	 *
	 * _.mean([4, 2, 8, 6]);
	 * // => 5
	 */
	function mean(array) {
	  return baseMean(array, identity);
	}

	/**
	 * This method is like `_.mean` except that it accepts `iteratee` which is
	 * invoked for each element in `array` to generate the value to be averaged.
	 * The iteratee is invoked with one argument: (value).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.7.0
	 * @category Math
	 * @param {Array} array The array to iterate over.
	 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	 * @returns {number} Returns the mean.
	 * @example
	 *
	 * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
	 *
	 * _.meanBy(objects, function(o) { return o.n; });
	 * // => 5
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.meanBy(objects, 'n');
	 * // => 5
	 */
	function meanBy(array, iteratee) {
	  return baseMean(array, baseIteratee(iteratee));
	}

	/**
	 * This method is like `_.assign` except that it recursively merges own and
	 * inherited enumerable string keyed properties of source objects into the
	 * destination object. Source properties that resolve to `undefined` are
	 * skipped if a destination value exists. Array and plain object properties
	 * are merged recursively. Other objects and value types are overridden by
	 * assignment. Source objects are applied from left to right. Subsequent
	 * sources overwrite property assignments of previous sources.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.5.0
	 * @category Object
	 * @param {Object} object The destination object.
	 * @param {...Object} [sources] The source objects.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var object = {
	 *   'a': [{ 'b': 2 }, { 'd': 4 }]
	 * };
	 *
	 * var other = {
	 *   'a': [{ 'c': 3 }, { 'e': 5 }]
	 * };
	 *
	 * _.merge(object, other);
	 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
	 */
	var merge = createAssigner(function(object, source, srcIndex) {
	  baseMerge(object, source, srcIndex);
	});

	/**
	 * Creates a function that invokes the method at `path` of a given object.
	 * Any additional arguments are provided to the invoked method.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Util
	 * @param {Array|string} path The path of the method to invoke.
	 * @param {...*} [args] The arguments to invoke the method with.
	 * @returns {Function} Returns the new invoker function.
	 * @example
	 *
	 * var objects = [
	 *   { 'a': { 'b': _.constant(2) } },
	 *   { 'a': { 'b': _.constant(1) } }
	 * ];
	 *
	 * _.map(objects, _.method('a.b'));
	 * // => [2, 1]
	 *
	 * _.map(objects, _.method(['a', 'b']));
	 * // => [2, 1]
	 */
	var method = baseRest(function(path, args) {
	  return function(object) {
	    return baseInvoke(object, path, args);
	  };
	});

	/**
	 * The opposite of `_.method`; this method creates a function that invokes
	 * the method at a given path of `object`. Any additional arguments are
	 * provided to the invoked method.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Util
	 * @param {Object} object The object to query.
	 * @param {...*} [args] The arguments to invoke the method with.
	 * @returns {Function} Returns the new invoker function.
	 * @example
	 *
	 * var array = _.times(3, _.constant),
	 *     object = { 'a': array, 'b': array, 'c': array };
	 *
	 * _.map(['a[2]', 'c[0]'], _.methodOf(object));
	 * // => [2, 0]
	 *
	 * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
	 * // => [2, 0]
	 */
	var methodOf = baseRest(function(object, args) {
	  return function(path) {
	    return baseInvoke(object, path, args);
	  };
	});

	/**
	 * Computes the minimum value of `array`. If `array` is empty or falsey,
	 * `undefined` is returned.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Math
	 * @param {Array} array The array to iterate over.
	 * @returns {*} Returns the minimum value.
	 * @example
	 *
	 * _.min([4, 2, 8, 6]);
	 * // => 2
	 *
	 * _.min([]);
	 * // => undefined
	 */
	function min(array) {
	  return (array && array.length)
	    ? baseExtremum(array, identity, baseLt)
	    : undefined;
	}

	/**
	 * This method is like `_.min` except that it accepts `iteratee` which is
	 * invoked for each element in `array` to generate the criterion by which
	 * the value is ranked. The iteratee is invoked with one argument: (value).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Math
	 * @param {Array} array The array to iterate over.
	 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	 * @returns {*} Returns the minimum value.
	 * @example
	 *
	 * var objects = [{ 'n': 1 }, { 'n': 2 }];
	 *
	 * _.minBy(objects, function(o) { return o.n; });
	 * // => { 'n': 1 }
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.minBy(objects, 'n');
	 * // => { 'n': 1 }
	 */
	function minBy(array, iteratee) {
	  return (array && array.length)
	    ? baseExtremum(array, baseIteratee(iteratee), baseLt)
	    : undefined;
	}

	/**
	 * Adds all own enumerable string keyed function properties of a source
	 * object to the destination object. If `object` is a function, then methods
	 * are added to its prototype as well.
	 *
	 * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
	 * avoid conflicts caused by modifying the original.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {Function|Object} [object=lodash] The destination object.
	 * @param {Object} source The object of functions to add.
	 * @param {Object} [options={}] The options object.
	 * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
	 * @returns {Function|Object} Returns `object`.
	 * @example
	 *
	 * function vowels(string) {
	 *   return _.filter(string, function(v) {
	 *     return /[aeiou]/i.test(v);
	 *   });
	 * }
	 *
	 * _.mixin({ 'vowels': vowels });
	 * _.vowels('fred');
	 * // => ['e']
	 *
	 * _('fred').vowels().value();
	 * // => ['e']
	 *
	 * _.mixin({ 'vowels': vowels }, { 'chain': false });
	 * _('fred').vowels();
	 * // => ['e']
	 */
	function mixin(object, source, options) {
	  var props = keys(source),
	      methodNames = baseFunctions(source, props);

	  var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
	      isFunc = isFunction(object);

	  arrayEach(methodNames, function(methodName) {
	    var func = source[methodName];
	    object[methodName] = func;
	    if (isFunc) {
	      object.prototype[methodName] = function() {
	        var chainAll = this.__chain__;
	        if (chain || chainAll) {
	          var result = object(this.__wrapped__),
	              actions = result.__actions__ = copyArray$1(this.__actions__);

	          actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
	          result.__chain__ = chainAll;
	          return result;
	        }
	        return func.apply(object, arrayPush([this.value()], arguments));
	      };
	    }
	  });

	  return object;
	}

	/**
	 * Multiply two numbers.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.7.0
	 * @category Math
	 * @param {number} multiplier The first number in a multiplication.
	 * @param {number} multiplicand The second number in a multiplication.
	 * @returns {number} Returns the product.
	 * @example
	 *
	 * _.multiply(6, 4);
	 * // => 24
	 */
	var multiply = createMathOperation(function(multiplier, multiplicand) {
	  return multiplier * multiplicand;
	}, 1);

	/** Error message constants. */
	var FUNC_ERROR_TEXT$8 = 'Expected a function';

	/**
	 * Creates a function that negates the result of the predicate `func`. The
	 * `func` predicate is invoked with the `this` binding and arguments of the
	 * created function.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Function
	 * @param {Function} predicate The predicate to negate.
	 * @returns {Function} Returns the new negated function.
	 * @example
	 *
	 * function isEven(n) {
	 *   return n % 2 == 0;
	 * }
	 *
	 * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
	 * // => [1, 3, 5]
	 */
	function negate(predicate) {
	  if (typeof predicate != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT$8);
	  }
	  return function() {
	    var args = arguments;
	    switch (args.length) {
	      case 0: return !predicate.call(this);
	      case 1: return !predicate.call(this, args[0]);
	      case 2: return !predicate.call(this, args[0], args[1]);
	      case 3: return !predicate.call(this, args[0], args[1], args[2]);
	    }
	    return !predicate.apply(this, args);
	  };
	}

	/**
	 * Converts `iterator` to an array.
	 *
	 * @private
	 * @param {Object} iterator The iterator to convert.
	 * @returns {Array} Returns the converted array.
	 */
	function iteratorToArray(iterator) {
	  var data,
	      result = [];

	  while (!(data = iterator.next()).done) {
	    result.push(data.value);
	  }
	  return result;
	}

	/** `Object#toString` result references. */
	var mapTag$8 = '[object Map]',
	    setTag$8 = '[object Set]';

	/** Built-in value references. */
	var symIterator = Symbol$1 ? Symbol$1.iterator : undefined;

	/**
	 * Converts `value` to an array.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {Array} Returns the converted array.
	 * @example
	 *
	 * _.toArray({ 'a': 1, 'b': 2 });
	 * // => [1, 2]
	 *
	 * _.toArray('abc');
	 * // => ['a', 'b', 'c']
	 *
	 * _.toArray(1);
	 * // => []
	 *
	 * _.toArray(null);
	 * // => []
	 */
	function toArray(value) {
	  if (!value) {
	    return [];
	  }
	  if (isArrayLike(value)) {
	    return isString(value) ? stringToArray(value) : copyArray$1(value);
	  }
	  if (symIterator && value[symIterator]) {
	    return iteratorToArray(value[symIterator]());
	  }
	  var tag = getTag$1(value),
	      func = tag == mapTag$8 ? mapToArray : (tag == setTag$8 ? setToArray : values);

	  return func(value);
	}

	/**
	 * Gets the next value on a wrapped object following the
	 * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
	 *
	 * @name next
	 * @memberOf _
	 * @since 4.0.0
	 * @category Seq
	 * @returns {Object} Returns the next iterator value.
	 * @example
	 *
	 * var wrapped = _([1, 2]);
	 *
	 * wrapped.next();
	 * // => { 'done': false, 'value': 1 }
	 *
	 * wrapped.next();
	 * // => { 'done': false, 'value': 2 }
	 *
	 * wrapped.next();
	 * // => { 'done': true, 'value': undefined }
	 */
	function wrapperNext() {
	  if (this.__values__ === undefined) {
	    this.__values__ = toArray(this.value());
	  }
	  var done = this.__index__ >= this.__values__.length,
	      value = done ? undefined : this.__values__[this.__index__++];

	  return { 'done': done, 'value': value };
	}

	/**
	 * The base implementation of `_.nth` which doesn't coerce arguments.
	 *
	 * @private
	 * @param {Array} array The array to query.
	 * @param {number} n The index of the element to return.
	 * @returns {*} Returns the nth element of `array`.
	 */
	function baseNth(array, n) {
	  var length = array.length;
	  if (!length) {
	    return;
	  }
	  n += n < 0 ? length : 0;
	  return isIndex(n, length) ? array[n] : undefined;
	}

	/**
	 * Gets the element at index `n` of `array`. If `n` is negative, the nth
	 * element from the end is returned.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.11.0
	 * @category Array
	 * @param {Array} array The array to query.
	 * @param {number} [n=0] The index of the element to return.
	 * @returns {*} Returns the nth element of `array`.
	 * @example
	 *
	 * var array = ['a', 'b', 'c', 'd'];
	 *
	 * _.nth(array, 1);
	 * // => 'b'
	 *
	 * _.nth(array, -2);
	 * // => 'c';
	 */
	function nth(array, n) {
	  return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
	}

	/**
	 * Creates a function that gets the argument at index `n`. If `n` is negative,
	 * the nth argument from the end is returned.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Util
	 * @param {number} [n=0] The index of the argument to return.
	 * @returns {Function} Returns the new pass-thru function.
	 * @example
	 *
	 * var func = _.nthArg(1);
	 * func('a', 'b', 'c', 'd');
	 * // => 'b'
	 *
	 * var func = _.nthArg(-2);
	 * func('a', 'b', 'c', 'd');
	 * // => 'c'
	 */
	function nthArg(n) {
	  n = toInteger(n);
	  return baseRest(function(args) {
	    return baseNth(args, n);
	  });
	}

	/**
	 * The base implementation of `_.unset`.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The property path to unset.
	 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
	 */
	function baseUnset(object, path) {
	  path = castPath(path, object);
	  object = parent(object, path);
	  return object == null || delete object[toKey(last(path))];
	}

	/**
	 * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
	 * objects.
	 *
	 * @private
	 * @param {*} value The value to inspect.
	 * @param {string} key The key of the property to inspect.
	 * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
	 */
	function customOmitClone(value) {
	  return isPlainObject(value) ? undefined : value;
	}

	/** Used to compose bitmasks for cloning. */
	var CLONE_DEEP_FLAG$7 = 1,
	    CLONE_FLAT_FLAG$1 = 2,
	    CLONE_SYMBOLS_FLAG$5 = 4;

	/**
	 * The opposite of `_.pick`; this method creates an object composed of the
	 * own and inherited enumerable property paths of `object` that are not omitted.
	 *
	 * **Note:** This method is considerably slower than `_.pick`.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The source object.
	 * @param {...(string|string[])} [paths] The property paths to omit.
	 * @returns {Object} Returns the new object.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': '2', 'c': 3 };
	 *
	 * _.omit(object, ['a', 'c']);
	 * // => { 'b': '2' }
	 */
	var omit = flatRest(function(object, paths) {
	  var result = {};
	  if (object == null) {
	    return result;
	  }
	  var isDeep = false;
	  paths = arrayMap(paths, function(path) {
	    path = castPath(path, object);
	    isDeep || (isDeep = path.length > 1);
	    return path;
	  });
	  copyObject(object, getAllKeysIn(object), result);
	  if (isDeep) {
	    result = baseClone(result, CLONE_DEEP_FLAG$7 | CLONE_FLAT_FLAG$1 | CLONE_SYMBOLS_FLAG$5, customOmitClone);
	  }
	  var length = paths.length;
	  while (length--) {
	    baseUnset(result, paths[length]);
	  }
	  return result;
	});

	/**
	 * The base implementation of `_.set`.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The path of the property to set.
	 * @param {*} value The value to set.
	 * @param {Function} [customizer] The function to customize path creation.
	 * @returns {Object} Returns `object`.
	 */
	function baseSet(object, path, value, customizer) {
	  if (!isObject(object)) {
	    return object;
	  }
	  path = castPath(path, object);

	  var index = -1,
	      length = path.length,
	      lastIndex = length - 1,
	      nested = object;

	  while (nested != null && ++index < length) {
	    var key = toKey(path[index]),
	        newValue = value;

	    if (index != lastIndex) {
	      var objValue = nested[key];
	      newValue = customizer ? customizer(objValue, key, nested) : undefined;
	      if (newValue === undefined) {
	        newValue = isObject(objValue)
	          ? objValue
	          : (isIndex(path[index + 1]) ? [] : {});
	      }
	    }
	    assignValue(nested, key, newValue);
	    nested = nested[key];
	  }
	  return object;
	}

	/**
	 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Object} object The source object.
	 * @param {string[]} paths The property paths to pick.
	 * @param {Function} predicate The function invoked per property.
	 * @returns {Object} Returns the new object.
	 */
	function basePickBy(object, paths, predicate) {
	  var index = -1,
	      length = paths.length,
	      result = {};

	  while (++index < length) {
	    var path = paths[index],
	        value = baseGet(object, path);

	    if (predicate(value, path)) {
	      baseSet(result, castPath(path, object), value);
	    }
	  }
	  return result;
	}

	/**
	 * Creates an object composed of the `object` properties `predicate` returns
	 * truthy for. The predicate is invoked with two arguments: (value, key).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The source object.
	 * @param {Function} [predicate=_.identity] The function invoked per property.
	 * @returns {Object} Returns the new object.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': '2', 'c': 3 };
	 *
	 * _.pickBy(object, _.isNumber);
	 * // => { 'a': 1, 'c': 3 }
	 */
	function pickBy(object, predicate) {
	  if (object == null) {
	    return {};
	  }
	  var props = arrayMap(getAllKeysIn(object), function(prop) {
	    return [prop];
	  });
	  predicate = baseIteratee(predicate);
	  return basePickBy(object, props, function(value, path) {
	    return predicate(value, path[0]);
	  });
	}

	/**
	 * The opposite of `_.pickBy`; this method creates an object composed of
	 * the own and inherited enumerable string keyed properties of `object` that
	 * `predicate` doesn't return truthy for. The predicate is invoked with two
	 * arguments: (value, key).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The source object.
	 * @param {Function} [predicate=_.identity] The function invoked per property.
	 * @returns {Object} Returns the new object.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': '2', 'c': 3 };
	 *
	 * _.omitBy(object, _.isNumber);
	 * // => { 'b': '2' }
	 */
	function omitBy(object, predicate) {
	  return pickBy(object, negate(baseIteratee(predicate)));
	}

	/**
	 * Creates a function that is restricted to invoking `func` once. Repeat calls
	 * to the function return the value of the first invocation. The `func` is
	 * invoked with the `this` binding and arguments of the created function.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to restrict.
	 * @returns {Function} Returns the new restricted function.
	 * @example
	 *
	 * var initialize = _.once(createApplication);
	 * initialize();
	 * initialize();
	 * // => `createApplication` is invoked once
	 */
	function once(func) {
	  return before(2, func);
	}

	function baseSortBy(array, comparer) {
	  var length = array.length;
	  array.sort(comparer);
	  while (length--) {
	    array[length] = array[length].value;
	  }
	  return array;
	}

	/**
	 * Compares values to sort them in ascending order.
	 *
	 * @private
	 * @param {*} value The value to compare.
	 * @param {*} other The other value to compare.
	 * @returns {number} Returns the sort order indicator for `value`.
	 */
	function compareAscending(value, other) {
	  if (value !== other) {
	    var valIsDefined = value !== undefined,
	        valIsNull = value === null,
	        valIsReflexive = value === value,
	        valIsSymbol = isSymbol(value);

	    var othIsDefined = other !== undefined,
	        othIsNull = other === null,
	        othIsReflexive = other === other,
	        othIsSymbol = isSymbol(other);

	    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
	        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
	        (valIsNull && othIsDefined && othIsReflexive) ||
	        (!valIsDefined && othIsReflexive) ||
	        !valIsReflexive) {
	      return 1;
	    }
	    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
	        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
	        (othIsNull && valIsDefined && valIsReflexive) ||
	        (!othIsDefined && valIsReflexive) ||
	        !othIsReflexive) {
	      return -1;
	    }
	  }
	  return 0;
	}

	/**
	 * Used by `_.orderBy` to compare multiple properties of a value to another
	 * and stable sort them.
	 *
	 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
	 * specify an order of "desc" for descending or "asc" for ascending sort order
	 * of corresponding values.
	 *
	 * @private
	 * @param {Object} object The object to compare.
	 * @param {Object} other The other object to compare.
	 * @param {boolean[]|string[]} orders The order to sort by for each property.
	 * @returns {number} Returns the sort order indicator for `object`.
	 */
	function compareMultiple(object, other, orders) {
	  var index = -1,
	      objCriteria = object.criteria,
	      othCriteria = other.criteria,
	      length = objCriteria.length,
	      ordersLength = orders.length;

	  while (++index < length) {
	    var result = compareAscending(objCriteria[index], othCriteria[index]);
	    if (result) {
	      if (index >= ordersLength) {
	        return result;
	      }
	      var order = orders[index];
	      return result * (order == 'desc' ? -1 : 1);
	    }
	  }
	  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
	  // that causes it, under certain circumstances, to provide the same value for
	  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
	  // for more details.
	  //
	  // This also ensures a stable sort in V8 and other engines.
	  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
	  return object.index - other.index;
	}

	/**
	 * The base implementation of `_.orderBy` without param guards.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
	 * @param {string[]} orders The sort orders of `iteratees`.
	 * @returns {Array} Returns the new sorted array.
	 */
	function baseOrderBy(collection, iteratees, orders) {
	  var index = -1;
	  iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));

	  var result = baseMap(collection, function(value, key, collection) {
	    var criteria = arrayMap(iteratees, function(iteratee) {
	      return iteratee(value);
	    });
	    return { 'criteria': criteria, 'index': ++index, 'value': value };
	  });

	  return baseSortBy(result, function(object, other) {
	    return compareMultiple(object, other, orders);
	  });
	}

	/**
	 * This method is like `_.sortBy` except that it allows specifying the sort
	 * orders of the iteratees to sort by. If `orders` is unspecified, all values
	 * are sorted in ascending order. Otherwise, specify an order of "desc" for
	 * descending or "asc" for ascending sort order of corresponding values.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
	 *  The iteratees to sort by.
	 * @param {string[]} [orders] The sort orders of `iteratees`.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
	 * @returns {Array} Returns the new sorted array.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'fred',   'age': 48 },
	 *   { 'user': 'barney', 'age': 34 },
	 *   { 'user': 'fred',   'age': 40 },
	 *   { 'user': 'barney', 'age': 36 }
	 * ];
	 *
	 * // Sort by `user` in ascending order and by `age` in descending order.
	 * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
	 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
	 */
	function orderBy(collection, iteratees, orders, guard) {
	  if (collection == null) {
	    return [];
	  }
	  if (!isArray(iteratees)) {
	    iteratees = iteratees == null ? [] : [iteratees];
	  }
	  orders = guard ? undefined : orders;
	  if (!isArray(orders)) {
	    orders = orders == null ? [] : [orders];
	  }
	  return baseOrderBy(collection, iteratees, orders);
	}

	/**
	 * Creates a function like `_.over`.
	 *
	 * @private
	 * @param {Function} arrayFunc The function to iterate over iteratees.
	 * @returns {Function} Returns the new over function.
	 */
	function createOver(arrayFunc) {
	  return flatRest(function(iteratees) {
	    iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
	    return baseRest(function(args) {
	      var thisArg = this;
	      return arrayFunc(iteratees, function(iteratee) {
	        return apply(iteratee, thisArg, args);
	      });
	    });
	  });
	}

	/**
	 * Creates a function that invokes `iteratees` with the arguments it receives
	 * and returns their results.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Util
	 * @param {...(Function|Function[])} [iteratees=[_.identity]]
	 *  The iteratees to invoke.
	 * @returns {Function} Returns the new function.
	 * @example
	 *
	 * var func = _.over([Math.max, Math.min]);
	 *
	 * func(1, 2, 3, 4);
	 * // => [4, 1]
	 */
	var over = createOver(arrayMap);

	/**
	 * A `baseRest` alias which can be replaced with `identity` by module
	 * replacement plugins.
	 *
	 * @private
	 * @type {Function}
	 * @param {Function} func The function to apply a rest parameter to.
	 * @returns {Function} Returns the new function.
	 */
	var castRest = baseRest;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMin$8 = Math.min;

	/**
	 * Creates a function that invokes `func` with its arguments transformed.
	 *
	 * @static
	 * @since 4.0.0
	 * @memberOf _
	 * @category Function
	 * @param {Function} func The function to wrap.
	 * @param {...(Function|Function[])} [transforms=[_.identity]]
	 *  The argument transforms.
	 * @returns {Function} Returns the new function.
	 * @example
	 *
	 * function doubled(n) {
	 *   return n * 2;
	 * }
	 *
	 * function square(n) {
	 *   return n * n;
	 * }
	 *
	 * var func = _.overArgs(function(x, y) {
	 *   return [x, y];
	 * }, [square, doubled]);
	 *
	 * func(9, 3);
	 * // => [81, 6]
	 *
	 * func(10, 5);
	 * // => [100, 10]
	 */
	var overArgs = castRest(function(func, transforms) {
	  transforms = (transforms.length == 1 && isArray(transforms[0]))
	    ? arrayMap(transforms[0], baseUnary(baseIteratee))
	    : arrayMap(baseFlatten(transforms, 1), baseUnary(baseIteratee));

	  var funcsLength = transforms.length;
	  return baseRest(function(args) {
	    var index = -1,
	        length = nativeMin$8(args.length, funcsLength);

	    while (++index < length) {
	      args[index] = transforms[index].call(this, args[index]);
	    }
	    return apply(func, this, args);
	  });
	});

	/**
	 * Creates a function that checks if **all** of the `predicates` return
	 * truthy when invoked with the arguments it receives.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Util
	 * @param {...(Function|Function[])} [predicates=[_.identity]]
	 *  The predicates to check.
	 * @returns {Function} Returns the new function.
	 * @example
	 *
	 * var func = _.overEvery([Boolean, isFinite]);
	 *
	 * func('1');
	 * // => true
	 *
	 * func(null);
	 * // => false
	 *
	 * func(NaN);
	 * // => false
	 */
	var overEvery = createOver(arrayEvery);

	/**
	 * Creates a function that checks if **any** of the `predicates` return
	 * truthy when invoked with the arguments it receives.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Util
	 * @param {...(Function|Function[])} [predicates=[_.identity]]
	 *  The predicates to check.
	 * @returns {Function} Returns the new function.
	 * @example
	 *
	 * var func = _.overSome([Boolean, isFinite]);
	 *
	 * func('1');
	 * // => true
	 *
	 * func(null);
	 * // => true
	 *
	 * func(NaN);
	 * // => false
	 */
	var overSome = createOver(arraySome);

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER$3 = 9007199254740991;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeFloor = Math.floor;

	/**
	 * The base implementation of `_.repeat` which doesn't coerce arguments.
	 *
	 * @private
	 * @param {string} string The string to repeat.
	 * @param {number} n The number of times to repeat the string.
	 * @returns {string} Returns the repeated string.
	 */
	function baseRepeat(string, n) {
	  var result = '';
	  if (!string || n < 1 || n > MAX_SAFE_INTEGER$3) {
	    return result;
	  }
	  // Leverage the exponentiation by squaring algorithm for a faster repeat.
	  // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
	  do {
	    if (n % 2) {
	      result += string;
	    }
	    n = nativeFloor(n / 2);
	    if (n) {
	      string += string;
	    }
	  } while (n);

	  return result;
	}

	/**
	 * Gets the size of an ASCII `string`.
	 *
	 * @private
	 * @param {string} string The string inspect.
	 * @returns {number} Returns the string size.
	 */
	var asciiSize = baseProperty('length');

	/** Used to compose unicode character classes. */
	var rsAstralRange$3 = '\\ud800-\\udfff',
	    rsComboMarksRange$4 = '\\u0300-\\u036f',
	    reComboHalfMarksRange$4 = '\\ufe20-\\ufe2f',
	    rsComboSymbolsRange$4 = '\\u20d0-\\u20ff',
	    rsComboRange$4 = rsComboMarksRange$4 + reComboHalfMarksRange$4 + rsComboSymbolsRange$4,
	    rsVarRange$3 = '\\ufe0e\\ufe0f';

	/** Used to compose unicode capture groups. */
	var rsAstral$1 = '[' + rsAstralRange$3 + ']',
	    rsCombo$3 = '[' + rsComboRange$4 + ']',
	    rsFitz$2 = '\\ud83c[\\udffb-\\udfff]',
	    rsModifier$2 = '(?:' + rsCombo$3 + '|' + rsFitz$2 + ')',
	    rsNonAstral$2 = '[^' + rsAstralRange$3 + ']',
	    rsRegional$2 = '(?:\\ud83c[\\udde6-\\uddff]){2}',
	    rsSurrPair$2 = '[\\ud800-\\udbff][\\udc00-\\udfff]',
	    rsZWJ$3 = '\\u200d';

	/** Used to compose unicode regexes. */
	var reOptMod$2 = rsModifier$2 + '?',
	    rsOptVar$2 = '[' + rsVarRange$3 + ']?',
	    rsOptJoin$2 = '(?:' + rsZWJ$3 + '(?:' + [rsNonAstral$2, rsRegional$2, rsSurrPair$2].join('|') + ')' + rsOptVar$2 + reOptMod$2 + ')*',
	    rsSeq$2 = rsOptVar$2 + reOptMod$2 + rsOptJoin$2,
	    rsSymbol$1 = '(?:' + [rsNonAstral$2 + rsCombo$3 + '?', rsCombo$3, rsRegional$2, rsSurrPair$2, rsAstral$1].join('|') + ')';

	/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
	var reUnicode$1 = RegExp(rsFitz$2 + '(?=' + rsFitz$2 + ')|' + rsSymbol$1 + rsSeq$2, 'g');

	/**
	 * Gets the size of a Unicode `string`.
	 *
	 * @private
	 * @param {string} string The string inspect.
	 * @returns {number} Returns the string size.
	 */
	function unicodeSize(string) {
	  var result = reUnicode$1.lastIndex = 0;
	  while (reUnicode$1.test(string)) {
	    ++result;
	  }
	  return result;
	}

	/**
	 * Gets the number of symbols in `string`.
	 *
	 * @private
	 * @param {string} string The string to inspect.
	 * @returns {number} Returns the string size.
	 */
	function stringSize(string) {
	  return hasUnicode(string)
	    ? unicodeSize(string)
	    : asciiSize(string);
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeCeil$1 = Math.ceil;

	/**
	 * Creates the padding for `string` based on `length`. The `chars` string
	 * is truncated if the number of characters exceeds `length`.
	 *
	 * @private
	 * @param {number} length The padding length.
	 * @param {string} [chars=' '] The string used as padding.
	 * @returns {string} Returns the padding for `string`.
	 */
	function createPadding(length, chars) {
	  chars = chars === undefined ? ' ' : baseToString(chars);

	  var charsLength = chars.length;
	  if (charsLength < 2) {
	    return charsLength ? baseRepeat(chars, length) : chars;
	  }
	  var result = baseRepeat(chars, nativeCeil$1(length / stringSize(chars)));
	  return hasUnicode(chars)
	    ? castSlice(stringToArray(result), 0, length).join('')
	    : result.slice(0, length);
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeCeil$2 = Math.ceil,
	    nativeFloor$1 = Math.floor;

	/**
	 * Pads `string` on the left and right sides if it's shorter than `length`.
	 * Padding characters are truncated if they can't be evenly divided by `length`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to pad.
	 * @param {number} [length=0] The padding length.
	 * @param {string} [chars=' '] The string used as padding.
	 * @returns {string} Returns the padded string.
	 * @example
	 *
	 * _.pad('abc', 8);
	 * // => '  abc   '
	 *
	 * _.pad('abc', 8, '_-');
	 * // => '_-abc_-_'
	 *
	 * _.pad('abc', 3);
	 * // => 'abc'
	 */
	function pad(string, length, chars) {
	  string = toString(string);
	  length = toInteger(length);

	  var strLength = length ? stringSize(string) : 0;
	  if (!length || strLength >= length) {
	    return string;
	  }
	  var mid = (length - strLength) / 2;
	  return (
	    createPadding(nativeFloor$1(mid), chars) +
	    string +
	    createPadding(nativeCeil$2(mid), chars)
	  );
	}

	/**
	 * Pads `string` on the right side if it's shorter than `length`. Padding
	 * characters are truncated if they exceed `length`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category String
	 * @param {string} [string=''] The string to pad.
	 * @param {number} [length=0] The padding length.
	 * @param {string} [chars=' '] The string used as padding.
	 * @returns {string} Returns the padded string.
	 * @example
	 *
	 * _.padEnd('abc', 6);
	 * // => 'abc   '
	 *
	 * _.padEnd('abc', 6, '_-');
	 * // => 'abc_-_'
	 *
	 * _.padEnd('abc', 3);
	 * // => 'abc'
	 */
	function padEnd(string, length, chars) {
	  string = toString(string);
	  length = toInteger(length);

	  var strLength = length ? stringSize(string) : 0;
	  return (length && strLength < length)
	    ? (string + createPadding(length - strLength, chars))
	    : string;
	}

	/**
	 * Pads `string` on the left side if it's shorter than `length`. Padding
	 * characters are truncated if they exceed `length`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category String
	 * @param {string} [string=''] The string to pad.
	 * @param {number} [length=0] The padding length.
	 * @param {string} [chars=' '] The string used as padding.
	 * @returns {string} Returns the padded string.
	 * @example
	 *
	 * _.padStart('abc', 6);
	 * // => '   abc'
	 *
	 * _.padStart('abc', 6, '_-');
	 * // => '_-_abc'
	 *
	 * _.padStart('abc', 3);
	 * // => 'abc'
	 */
	function padStart(string, length, chars) {
	  string = toString(string);
	  length = toInteger(length);

	  var strLength = length ? stringSize(string) : 0;
	  return (length && strLength < length)
	    ? (createPadding(length - strLength, chars) + string)
	    : string;
	}

	/** Used to match leading and trailing whitespace. */
	var reTrimStart = /^\s+/;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeParseInt = root.parseInt;

	/**
	 * Converts `string` to an integer of the specified radix. If `radix` is
	 * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
	 * hexadecimal, in which case a `radix` of `16` is used.
	 *
	 * **Note:** This method aligns with the
	 * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.1.0
	 * @category String
	 * @param {string} string The string to convert.
	 * @param {number} [radix=10] The radix to interpret `value` by.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {number} Returns the converted integer.
	 * @example
	 *
	 * _.parseInt('08');
	 * // => 8
	 *
	 * _.map(['6', '08', '10'], _.parseInt);
	 * // => [6, 8, 10]
	 */
	function parseInt$1(string, radix, guard) {
	  if (guard || radix == null) {
	    radix = 0;
	  } else if (radix) {
	    radix = +radix;
	  }
	  return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
	}

	/** Used to compose bitmasks for function metadata. */
	var WRAP_PARTIAL_FLAG$6 = 32;

	/**
	 * Creates a function that invokes `func` with `partials` prepended to the
	 * arguments it receives. This method is like `_.bind` except it does **not**
	 * alter the `this` binding.
	 *
	 * The `_.partial.placeholder` value, which defaults to `_` in monolithic
	 * builds, may be used as a placeholder for partially applied arguments.
	 *
	 * **Note:** This method doesn't set the "length" property of partially
	 * applied functions.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.2.0
	 * @category Function
	 * @param {Function} func The function to partially apply arguments to.
	 * @param {...*} [partials] The arguments to be partially applied.
	 * @returns {Function} Returns the new partially applied function.
	 * @example
	 *
	 * function greet(greeting, name) {
	 *   return greeting + ' ' + name;
	 * }
	 *
	 * var sayHelloTo = _.partial(greet, 'hello');
	 * sayHelloTo('fred');
	 * // => 'hello fred'
	 *
	 * // Partially applied with placeholders.
	 * var greetFred = _.partial(greet, _, 'fred');
	 * greetFred('hi');
	 * // => 'hi fred'
	 */
	var partial = baseRest(function(func, partials) {
	  var holders = replaceHolders(partials, getHolder(partial));
	  return createWrap(func, WRAP_PARTIAL_FLAG$6, undefined, partials, holders);
	});

	// Assign default placeholders.
	partial.placeholder = {};

	/** Used to compose bitmasks for function metadata. */
	var WRAP_PARTIAL_RIGHT_FLAG$3 = 64;

	/**
	 * This method is like `_.partial` except that partially applied arguments
	 * are appended to the arguments it receives.
	 *
	 * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
	 * builds, may be used as a placeholder for partially applied arguments.
	 *
	 * **Note:** This method doesn't set the "length" property of partially
	 * applied functions.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.0.0
	 * @category Function
	 * @param {Function} func The function to partially apply arguments to.
	 * @param {...*} [partials] The arguments to be partially applied.
	 * @returns {Function} Returns the new partially applied function.
	 * @example
	 *
	 * function greet(greeting, name) {
	 *   return greeting + ' ' + name;
	 * }
	 *
	 * var greetFred = _.partialRight(greet, 'fred');
	 * greetFred('hi');
	 * // => 'hi fred'
	 *
	 * // Partially applied with placeholders.
	 * var sayHelloTo = _.partialRight(greet, 'hello', _);
	 * sayHelloTo('fred');
	 * // => 'hello fred'
	 */
	var partialRight = baseRest(function(func, partials) {
	  var holders = replaceHolders(partials, getHolder(partialRight));
	  return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG$3, undefined, partials, holders);
	});

	// Assign default placeholders.
	partialRight.placeholder = {};

	/**
	 * Creates an array of elements split into two groups, the first of which
	 * contains elements `predicate` returns truthy for, the second of which
	 * contains elements `predicate` returns falsey for. The predicate is
	 * invoked with one argument: (value).
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @returns {Array} Returns the array of grouped elements.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney',  'age': 36, 'active': false },
	 *   { 'user': 'fred',    'age': 40, 'active': true },
	 *   { 'user': 'pebbles', 'age': 1,  'active': false }
	 * ];
	 *
	 * _.partition(users, function(o) { return o.active; });
	 * // => objects for [['fred'], ['barney', 'pebbles']]
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.partition(users, { 'age': 1, 'active': false });
	 * // => objects for [['pebbles'], ['barney', 'fred']]
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.partition(users, ['active', false]);
	 * // => objects for [['barney', 'pebbles'], ['fred']]
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.partition(users, 'active');
	 * // => objects for [['fred'], ['barney', 'pebbles']]
	 */
	var partition = createAggregator(function(result, value, key) {
	  result[key ? 0 : 1].push(value);
	}, function() { return [[], []]; });

	/**
	 * The base implementation of `_.pick` without support for individual
	 * property identifiers.
	 *
	 * @private
	 * @param {Object} object The source object.
	 * @param {string[]} paths The property paths to pick.
	 * @returns {Object} Returns the new object.
	 */
	function basePick(object, paths) {
	  return basePickBy(object, paths, function(value, path) {
	    return hasIn(object, path);
	  });
	}

	/**
	 * Creates an object composed of the picked `object` properties.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The source object.
	 * @param {...(string|string[])} [paths] The property paths to pick.
	 * @returns {Object} Returns the new object.
	 * @example
	 *
	 * var object = { 'a': 1, 'b': '2', 'c': 3 };
	 *
	 * _.pick(object, ['a', 'c']);
	 * // => { 'a': 1, 'c': 3 }
	 */
	var pick = flatRest(function(object, paths) {
	  return object == null ? {} : basePick(object, paths);
	});

	/**
	 * Creates a clone of the chain sequence planting `value` as the wrapped value.
	 *
	 * @name plant
	 * @memberOf _
	 * @since 3.2.0
	 * @category Seq
	 * @param {*} value The value to plant.
	 * @returns {Object} Returns the new `lodash` wrapper instance.
	 * @example
	 *
	 * function square(n) {
	 *   return n * n;
	 * }
	 *
	 * var wrapped = _([1, 2]).map(square);
	 * var other = wrapped.plant([3, 4]);
	 *
	 * other.value();
	 * // => [9, 16]
	 *
	 * wrapped.value();
	 * // => [1, 4]
	 */
	function wrapperPlant(value) {
	  var result,
	      parent = this;

	  while (parent instanceof baseLodash) {
	    var clone = wrapperClone(parent);
	    clone.__index__ = 0;
	    clone.__values__ = undefined;
	    if (result) {
	      previous.__wrapped__ = clone;
	    } else {
	      result = clone;
	    }
	    var previous = clone;
	    parent = parent.__wrapped__;
	  }
	  previous.__wrapped__ = value;
	  return result;
	}

	/**
	 * The opposite of `_.property`; this method creates a function that returns
	 * the value at a given path of `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Util
	 * @param {Object} object The object to query.
	 * @returns {Function} Returns the new accessor function.
	 * @example
	 *
	 * var array = [0, 1, 2],
	 *     object = { 'a': array, 'b': array, 'c': array };
	 *
	 * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
	 * // => [2, 0]
	 *
	 * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
	 * // => [2, 0]
	 */
	function propertyOf(object) {
	  return function(path) {
	    return object == null ? undefined : baseGet(object, path);
	  };
	}

	/**
	 * This function is like `baseIndexOf` except that it accepts a comparator.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @param {number} fromIndex The index to search from.
	 * @param {Function} comparator The comparator invoked per element.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 */
	function baseIndexOfWith(array, value, fromIndex, comparator) {
	  var index = fromIndex - 1,
	      length = array.length;

	  while (++index < length) {
	    if (comparator(array[index], value)) {
	      return index;
	    }
	  }
	  return -1;
	}

	/** Used for built-in method references. */
	var arrayProto$2 = Array.prototype;

	/** Built-in value references. */
	var splice$1 = arrayProto$2.splice;

	/**
	 * The base implementation of `_.pullAllBy` without support for iteratee
	 * shorthands.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to remove.
	 * @param {Function} [iteratee] The iteratee invoked per element.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns `array`.
	 */
	function basePullAll(array, values, iteratee, comparator) {
	  var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
	      index = -1,
	      length = values.length,
	      seen = array;

	  if (array === values) {
	    values = copyArray$1(values);
	  }
	  if (iteratee) {
	    seen = arrayMap(array, baseUnary(iteratee));
	  }
	  while (++index < length) {
	    var fromIndex = 0,
	        value = values[index],
	        computed = iteratee ? iteratee(value) : value;

	    while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
	      if (seen !== array) {
	        splice$1.call(seen, fromIndex, 1);
	      }
	      splice$1.call(array, fromIndex, 1);
	    }
	  }
	  return array;
	}

	/**
	 * This method is like `_.pull` except that it accepts an array of values to remove.
	 *
	 * **Note:** Unlike `_.difference`, this method mutates `array`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Array
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to remove.
	 * @returns {Array} Returns `array`.
	 * @example
	 *
	 * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
	 *
	 * _.pullAll(array, ['a', 'c']);
	 * console.log(array);
	 * // => ['b', 'b']
	 */
	function pullAll(array, values) {
	  return (array && array.length && values && values.length)
	    ? basePullAll(array, values)
	    : array;
	}

	/**
	 * Removes all given values from `array` using
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
	 * to remove elements from an array by predicate.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.0.0
	 * @category Array
	 * @param {Array} array The array to modify.
	 * @param {...*} [values] The values to remove.
	 * @returns {Array} Returns `array`.
	 * @example
	 *
	 * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
	 *
	 * _.pull(array, 'a', 'c');
	 * console.log(array);
	 * // => ['b', 'b']
	 */
	var pull = baseRest(pullAll);

	/**
	 * This method is like `_.pullAll` except that it accepts `iteratee` which is
	 * invoked for each element of `array` and `values` to generate the criterion
	 * by which they're compared. The iteratee is invoked with one argument: (value).
	 *
	 * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Array
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to remove.
	 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	 * @returns {Array} Returns `array`.
	 * @example
	 *
	 * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
	 *
	 * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
	 * console.log(array);
	 * // => [{ 'x': 2 }]
	 */
	function pullAllBy(array, values, iteratee) {
	  return (array && array.length && values && values.length)
	    ? basePullAll(array, values, baseIteratee(iteratee))
	    : array;
	}

	/**
	 * This method is like `_.pullAll` except that it accepts `comparator` which
	 * is invoked to compare elements of `array` to `values`. The comparator is
	 * invoked with two arguments: (arrVal, othVal).
	 *
	 * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.6.0
	 * @category Array
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to remove.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns `array`.
	 * @example
	 *
	 * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
	 *
	 * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
	 * console.log(array);
	 * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
	 */
	function pullAllWith(array, values, comparator) {
	  return (array && array.length && values && values.length)
	    ? basePullAll(array, values, undefined, comparator)
	    : array;
	}

	/** Used for built-in method references. */
	var arrayProto$3 = Array.prototype;

	/** Built-in value references. */
	var splice$2 = arrayProto$3.splice;

	/**
	 * The base implementation of `_.pullAt` without support for individual
	 * indexes or capturing the removed elements.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {number[]} indexes The indexes of elements to remove.
	 * @returns {Array} Returns `array`.
	 */
	function basePullAt(array, indexes) {
	  var length = array ? indexes.length : 0,
	      lastIndex = length - 1;

	  while (length--) {
	    var index = indexes[length];
	    if (length == lastIndex || index !== previous) {
	      var previous = index;
	      if (isIndex(index)) {
	        splice$2.call(array, index, 1);
	      } else {
	        baseUnset(array, index);
	      }
	    }
	  }
	  return array;
	}

	/**
	 * Removes elements from `array` corresponding to `indexes` and returns an
	 * array of removed elements.
	 *
	 * **Note:** Unlike `_.at`, this method mutates `array`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Array
	 * @param {Array} array The array to modify.
	 * @param {...(number|number[])} [indexes] The indexes of elements to remove.
	 * @returns {Array} Returns the new array of removed elements.
	 * @example
	 *
	 * var array = ['a', 'b', 'c', 'd'];
	 * var pulled = _.pullAt(array, [1, 3]);
	 *
	 * console.log(array);
	 * // => ['a', 'c']
	 *
	 * console.log(pulled);
	 * // => ['b', 'd']
	 */
	var pullAt = flatRest(function(array, indexes) {
	  var length = array == null ? 0 : array.length,
	      result = baseAt(array, indexes);

	  basePullAt(array, arrayMap(indexes, function(index) {
	    return isIndex(index, length) ? +index : index;
	  }).sort(compareAscending));

	  return result;
	});

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeFloor$2 = Math.floor,
	    nativeRandom = Math.random;

	/**
	 * The base implementation of `_.random` without support for returning
	 * floating-point numbers.
	 *
	 * @private
	 * @param {number} lower The lower bound.
	 * @param {number} upper The upper bound.
	 * @returns {number} Returns the random number.
	 */
	function baseRandom(lower, upper) {
	  return lower + nativeFloor$2(nativeRandom() * (upper - lower + 1));
	}

	/** Built-in method references without a dependency on `root`. */
	var freeParseFloat = parseFloat;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMin$9 = Math.min,
	    nativeRandom$1 = Math.random;

	/**
	 * Produces a random number between the inclusive `lower` and `upper` bounds.
	 * If only one argument is provided a number between `0` and the given number
	 * is returned. If `floating` is `true`, or either `lower` or `upper` are
	 * floats, a floating-point number is returned instead of an integer.
	 *
	 * **Note:** JavaScript follows the IEEE-754 standard for resolving
	 * floating-point values which can produce unexpected results.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.7.0
	 * @category Number
	 * @param {number} [lower=0] The lower bound.
	 * @param {number} [upper=1] The upper bound.
	 * @param {boolean} [floating] Specify returning a floating-point number.
	 * @returns {number} Returns the random number.
	 * @example
	 *
	 * _.random(0, 5);
	 * // => an integer between 0 and 5
	 *
	 * _.random(5);
	 * // => also an integer between 0 and 5
	 *
	 * _.random(5, true);
	 * // => a floating-point number between 0 and 5
	 *
	 * _.random(1.2, 5.2);
	 * // => a floating-point number between 1.2 and 5.2
	 */
	function random(lower, upper, floating) {
	  if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
	    upper = floating = undefined;
	  }
	  if (floating === undefined) {
	    if (typeof upper == 'boolean') {
	      floating = upper;
	      upper = undefined;
	    }
	    else if (typeof lower == 'boolean') {
	      floating = lower;
	      lower = undefined;
	    }
	  }
	  if (lower === undefined && upper === undefined) {
	    lower = 0;
	    upper = 1;
	  }
	  else {
	    lower = toFinite(lower);
	    if (upper === undefined) {
	      upper = lower;
	      lower = 0;
	    } else {
	      upper = toFinite(upper);
	    }
	  }
	  if (lower > upper) {
	    var temp = lower;
	    lower = upper;
	    upper = temp;
	  }
	  if (floating || lower % 1 || upper % 1) {
	    var rand = nativeRandom$1();
	    return nativeMin$9(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
	  }
	  return baseRandom(lower, upper);
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeCeil$3 = Math.ceil,
	    nativeMax$c = Math.max;

	/**
	 * The base implementation of `_.range` and `_.rangeRight` which doesn't
	 * coerce arguments.
	 *
	 * @private
	 * @param {number} start The start of the range.
	 * @param {number} end The end of the range.
	 * @param {number} step The value to increment or decrement by.
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Array} Returns the range of numbers.
	 */
	function baseRange(start, end, step, fromRight) {
	  var index = -1,
	      length = nativeMax$c(nativeCeil$3((end - start) / (step || 1)), 0),
	      result = Array(length);

	  while (length--) {
	    result[fromRight ? length : ++index] = start;
	    start += step;
	  }
	  return result;
	}

	/**
	 * Creates a `_.range` or `_.rangeRight` function.
	 *
	 * @private
	 * @param {boolean} [fromRight] Specify iterating from right to left.
	 * @returns {Function} Returns the new range function.
	 */
	function createRange(fromRight) {
	  return function(start, end, step) {
	    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
	      end = step = undefined;
	    }
	    // Ensure the sign of `-0` is preserved.
	    start = toFinite(start);
	    if (end === undefined) {
	      end = start;
	      start = 0;
	    } else {
	      end = toFinite(end);
	    }
	    step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
	    return baseRange(start, end, step, fromRight);
	  };
	}

	/**
	 * Creates an array of numbers (positive and/or negative) progressing from
	 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
	 * `start` is specified without an `end` or `step`. If `end` is not specified,
	 * it's set to `start` with `start` then set to `0`.
	 *
	 * **Note:** JavaScript follows the IEEE-754 standard for resolving
	 * floating-point values which can produce unexpected results.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {number} [start=0] The start of the range.
	 * @param {number} end The end of the range.
	 * @param {number} [step=1] The value to increment or decrement by.
	 * @returns {Array} Returns the range of numbers.
	 * @see _.inRange, _.rangeRight
	 * @example
	 *
	 * _.range(4);
	 * // => [0, 1, 2, 3]
	 *
	 * _.range(-4);
	 * // => [0, -1, -2, -3]
	 *
	 * _.range(1, 5);
	 * // => [1, 2, 3, 4]
	 *
	 * _.range(0, 20, 5);
	 * // => [0, 5, 10, 15]
	 *
	 * _.range(0, -4, -1);
	 * // => [0, -1, -2, -3]
	 *
	 * _.range(1, 4, 0);
	 * // => [1, 1, 1]
	 *
	 * _.range(0);
	 * // => []
	 */
	var range = createRange();

	/**
	 * This method is like `_.range` except that it populates values in
	 * descending order.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Util
	 * @param {number} [start=0] The start of the range.
	 * @param {number} end The end of the range.
	 * @param {number} [step=1] The value to increment or decrement by.
	 * @returns {Array} Returns the range of numbers.
	 * @see _.inRange, _.range
	 * @example
	 *
	 * _.rangeRight(4);
	 * // => [3, 2, 1, 0]
	 *
	 * _.rangeRight(-4);
	 * // => [-3, -2, -1, 0]
	 *
	 * _.rangeRight(1, 5);
	 * // => [4, 3, 2, 1]
	 *
	 * _.rangeRight(0, 20, 5);
	 * // => [15, 10, 5, 0]
	 *
	 * _.rangeRight(0, -4, -1);
	 * // => [-3, -2, -1, 0]
	 *
	 * _.rangeRight(1, 4, 0);
	 * // => [1, 1, 1]
	 *
	 * _.rangeRight(0);
	 * // => []
	 */
	var rangeRight = createRange(true);

	/** Used to compose bitmasks for function metadata. */
	var WRAP_REARG_FLAG$3 = 256;

	/**
	 * Creates a function that invokes `func` with arguments arranged according
	 * to the specified `indexes` where the argument value at the first index is
	 * provided as the first argument, the argument value at the second index is
	 * provided as the second argument, and so on.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Function
	 * @param {Function} func The function to rearrange arguments for.
	 * @param {...(number|number[])} indexes The arranged argument indexes.
	 * @returns {Function} Returns the new function.
	 * @example
	 *
	 * var rearged = _.rearg(function(a, b, c) {
	 *   return [a, b, c];
	 * }, [2, 0, 1]);
	 *
	 * rearged('b', 'c', 'a')
	 * // => ['a', 'b', 'c']
	 */
	var rearg = flatRest(function(func, indexes) {
	  return createWrap(func, WRAP_REARG_FLAG$3, undefined, undefined, undefined, indexes);
	});

	/**
	 * The base implementation of `_.reduce` and `_.reduceRight`, without support
	 * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {*} accumulator The initial value.
	 * @param {boolean} initAccum Specify using the first or last element of
	 *  `collection` as the initial value.
	 * @param {Function} eachFunc The function to iterate over `collection`.
	 * @returns {*} Returns the accumulated value.
	 */
	function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
	  eachFunc(collection, function(value, index, collection) {
	    accumulator = initAccum
	      ? (initAccum = false, value)
	      : iteratee(accumulator, value, index, collection);
	  });
	  return accumulator;
	}

	/**
	 * Reduces `collection` to a value which is the accumulated result of running
	 * each element in `collection` thru `iteratee`, where each successive
	 * invocation is supplied the return value of the previous. If `accumulator`
	 * is not given, the first element of `collection` is used as the initial
	 * value. The iteratee is invoked with four arguments:
	 * (accumulator, value, index|key, collection).
	 *
	 * Many lodash methods are guarded to work as iteratees for methods like
	 * `_.reduce`, `_.reduceRight`, and `_.transform`.
	 *
	 * The guarded methods are:
	 * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
	 * and `sortBy`
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @param {*} [accumulator] The initial value.
	 * @returns {*} Returns the accumulated value.
	 * @see _.reduceRight
	 * @example
	 *
	 * _.reduce([1, 2], function(sum, n) {
	 *   return sum + n;
	 * }, 0);
	 * // => 3
	 *
	 * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	 *   (result[value] || (result[value] = [])).push(key);
	 *   return result;
	 * }, {});
	 * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
	 */
	function reduce(collection, iteratee, accumulator) {
	  var func = isArray(collection) ? arrayReduce : baseReduce,
	      initAccum = arguments.length < 3;

	  return func(collection, baseIteratee(iteratee), accumulator, initAccum, baseEach);
	}

	/**
	 * A specialized version of `_.reduceRight` for arrays without support for
	 * iteratee shorthands.
	 *
	 * @private
	 * @param {Array} [array] The array to iterate over.
	 * @param {Function} iteratee The function invoked per iteration.
	 * @param {*} [accumulator] The initial value.
	 * @param {boolean} [initAccum] Specify using the last element of `array` as
	 *  the initial value.
	 * @returns {*} Returns the accumulated value.
	 */
	function arrayReduceRight(array, iteratee, accumulator, initAccum) {
	  var length = array == null ? 0 : array.length;
	  if (initAccum && length) {
	    accumulator = array[--length];
	  }
	  while (length--) {
	    accumulator = iteratee(accumulator, array[length], length, array);
	  }
	  return accumulator;
	}

	/**
	 * This method is like `_.reduce` except that it iterates over elements of
	 * `collection` from right to left.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @param {*} [accumulator] The initial value.
	 * @returns {*} Returns the accumulated value.
	 * @see _.reduce
	 * @example
	 *
	 * var array = [[0, 1], [2, 3], [4, 5]];
	 *
	 * _.reduceRight(array, function(flattened, other) {
	 *   return flattened.concat(other);
	 * }, []);
	 * // => [4, 5, 2, 3, 0, 1]
	 */
	function reduceRight(collection, iteratee, accumulator) {
	  var func = isArray(collection) ? arrayReduceRight : baseReduce,
	      initAccum = arguments.length < 3;

	  return func(collection, baseIteratee(iteratee), accumulator, initAccum, baseEachRight);
	}

	/**
	 * The opposite of `_.filter`; this method returns the elements of `collection`
	 * that `predicate` does **not** return truthy for.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @returns {Array} Returns the new filtered array.
	 * @see _.filter
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney', 'age': 36, 'active': false },
	 *   { 'user': 'fred',   'age': 40, 'active': true }
	 * ];
	 *
	 * _.reject(users, function(o) { return !o.active; });
	 * // => objects for ['fred']
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.reject(users, { 'age': 40, 'active': true });
	 * // => objects for ['barney']
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.reject(users, ['active', false]);
	 * // => objects for ['fred']
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.reject(users, 'active');
	 * // => objects for ['barney']
	 */
	function reject(collection, predicate) {
	  var func = isArray(collection) ? arrayFilter : baseFilter;
	  return func(collection, negate(baseIteratee(predicate)));
	}

	/**
	 * Removes all elements from `array` that `predicate` returns truthy for
	 * and returns an array of the removed elements. The predicate is invoked
	 * with three arguments: (value, index, array).
	 *
	 * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
	 * to pull elements from an array by value.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.0.0
	 * @category Array
	 * @param {Array} array The array to modify.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @returns {Array} Returns the new array of removed elements.
	 * @example
	 *
	 * var array = [1, 2, 3, 4];
	 * var evens = _.remove(array, function(n) {
	 *   return n % 2 == 0;
	 * });
	 *
	 * console.log(array);
	 * // => [1, 3]
	 *
	 * console.log(evens);
	 * // => [2, 4]
	 */
	function remove(array, predicate) {
	  var result = [];
	  if (!(array && array.length)) {
	    return result;
	  }
	  var index = -1,
	      indexes = [],
	      length = array.length;

	  predicate = baseIteratee(predicate);
	  while (++index < length) {
	    var value = array[index];
	    if (predicate(value, index, array)) {
	      result.push(value);
	      indexes.push(index);
	    }
	  }
	  basePullAt(array, indexes);
	  return result;
	}

	/**
	 * Repeats the given string `n` times.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to repeat.
	 * @param {number} [n=1] The number of times to repeat the string.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {string} Returns the repeated string.
	 * @example
	 *
	 * _.repeat('*', 3);
	 * // => '***'
	 *
	 * _.repeat('abc', 2);
	 * // => 'abcabc'
	 *
	 * _.repeat('abc', 0);
	 * // => ''
	 */
	function repeat(string, n, guard) {
	  if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
	    n = 1;
	  } else {
	    n = toInteger(n);
	  }
	  return baseRepeat(toString(string), n);
	}

	/**
	 * Replaces matches for `pattern` in `string` with `replacement`.
	 *
	 * **Note:** This method is based on
	 * [`String#replace`](https://mdn.io/String/replace).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category String
	 * @param {string} [string=''] The string to modify.
	 * @param {RegExp|string} pattern The pattern to replace.
	 * @param {Function|string} replacement The match replacement.
	 * @returns {string} Returns the modified string.
	 * @example
	 *
	 * _.replace('Hi Fred', 'Fred', 'Barney');
	 * // => 'Hi Barney'
	 */
	function replace() {
	  var args = arguments,
	      string = toString(args[0]);

	  return args.length < 3 ? string : string.replace(args[1], args[2]);
	}

	/** Error message constants. */
	var FUNC_ERROR_TEXT$9 = 'Expected a function';

	/**
	 * Creates a function that invokes `func` with the `this` binding of the
	 * created function and arguments from `start` and beyond provided as
	 * an array.
	 *
	 * **Note:** This method is based on the
	 * [rest parameter](https://mdn.io/rest_parameters).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Function
	 * @param {Function} func The function to apply a rest parameter to.
	 * @param {number} [start=func.length-1] The start position of the rest parameter.
	 * @returns {Function} Returns the new function.
	 * @example
	 *
	 * var say = _.rest(function(what, names) {
	 *   return what + ' ' + _.initial(names).join(', ') +
	 *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
	 * });
	 *
	 * say('hello', 'fred', 'barney', 'pebbles');
	 * // => 'hello fred, barney, & pebbles'
	 */
	function rest(func, start) {
	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT$9);
	  }
	  start = start === undefined ? start : toInteger(start);
	  return baseRest(func, start);
	}

	/**
	 * This method is like `_.get` except that if the resolved value is a
	 * function it's invoked with the `this` binding of its parent object and
	 * its result is returned.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Object
	 * @param {Object} object The object to query.
	 * @param {Array|string} path The path of the property to resolve.
	 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	 * @returns {*} Returns the resolved value.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
	 *
	 * _.result(object, 'a[0].b.c1');
	 * // => 3
	 *
	 * _.result(object, 'a[0].b.c2');
	 * // => 4
	 *
	 * _.result(object, 'a[0].b.c3', 'default');
	 * // => 'default'
	 *
	 * _.result(object, 'a[0].b.c3', _.constant('default'));
	 * // => 'default'
	 */
	function result(object, path, defaultValue) {
	  path = castPath(path, object);

	  var index = -1,
	      length = path.length;

	  // Ensure the loop is entered when path is empty.
	  if (!length) {
	    length = 1;
	    object = undefined;
	  }
	  while (++index < length) {
	    var value = object == null ? undefined : object[toKey(path[index])];
	    if (value === undefined) {
	      index = length;
	      value = defaultValue;
	    }
	    object = isFunction(value) ? value.call(object) : value;
	  }
	  return object;
	}

	/** Used for built-in method references. */
	var arrayProto$4 = Array.prototype;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeReverse = arrayProto$4.reverse;

	/**
	 * Reverses `array` so that the first element becomes the last, the second
	 * element becomes the second to last, and so on.
	 *
	 * **Note:** This method mutates `array` and is based on
	 * [`Array#reverse`](https://mdn.io/Array/reverse).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Array
	 * @param {Array} array The array to modify.
	 * @returns {Array} Returns `array`.
	 * @example
	 *
	 * var array = [1, 2, 3];
	 *
	 * _.reverse(array);
	 * // => [3, 2, 1]
	 *
	 * console.log(array);
	 * // => [3, 2, 1]
	 */
	function reverse(array) {
	  return array == null ? array : nativeReverse.call(array);
	}

	/**
	 * Computes `number` rounded to `precision`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.10.0
	 * @category Math
	 * @param {number} number The number to round.
	 * @param {number} [precision=0] The precision to round to.
	 * @returns {number} Returns the rounded number.
	 * @example
	 *
	 * _.round(4.006);
	 * // => 4
	 *
	 * _.round(4.006, 2);
	 * // => 4.01
	 *
	 * _.round(4060, -2);
	 * // => 4100
	 */
	var round = createRound('round');

	/**
	 * A specialized version of `_.sample` for arrays.
	 *
	 * @private
	 * @param {Array} array The array to sample.
	 * @returns {*} Returns the random element.
	 */
	function arraySample(array) {
	  var length = array.length;
	  return length ? array[baseRandom(0, length - 1)] : undefined;
	}

	/**
	 * The base implementation of `_.sample`.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to sample.
	 * @returns {*} Returns the random element.
	 */
	function baseSample(collection) {
	  return arraySample(values(collection));
	}

	/**
	 * Gets a random element from `collection`.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.0.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to sample.
	 * @returns {*} Returns the random element.
	 * @example
	 *
	 * _.sample([1, 2, 3, 4]);
	 * // => 2
	 */
	function sample(collection) {
	  var func = isArray(collection) ? arraySample : baseSample;
	  return func(collection);
	}

	/**
	 * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
	 *
	 * @private
	 * @param {Array} array The array to shuffle.
	 * @param {number} [size=array.length] The size of `array`.
	 * @returns {Array} Returns `array`.
	 */
	function shuffleSelf(array, size) {
	  var index = -1,
	      length = array.length,
	      lastIndex = length - 1;

	  size = size === undefined ? length : size;
	  while (++index < size) {
	    var rand = baseRandom(index, lastIndex),
	        value = array[rand];

	    array[rand] = array[index];
	    array[index] = value;
	  }
	  array.length = size;
	  return array;
	}

	/**
	 * A specialized version of `_.sampleSize` for arrays.
	 *
	 * @private
	 * @param {Array} array The array to sample.
	 * @param {number} n The number of elements to sample.
	 * @returns {Array} Returns the random elements.
	 */
	function arraySampleSize(array, n) {
	  return shuffleSelf(copyArray$1(array), baseClamp(n, 0, array.length));
	}

	/**
	 * The base implementation of `_.sampleSize` without param guards.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to sample.
	 * @param {number} n The number of elements to sample.
	 * @returns {Array} Returns the random elements.
	 */
	function baseSampleSize(collection, n) {
	  var array = values(collection);
	  return shuffleSelf(array, baseClamp(n, 0, array.length));
	}

	/**
	 * Gets `n` random elements at unique keys from `collection` up to the
	 * size of `collection`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to sample.
	 * @param {number} [n=1] The number of elements to sample.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {Array} Returns the random elements.
	 * @example
	 *
	 * _.sampleSize([1, 2, 3], 2);
	 * // => [3, 1]
	 *
	 * _.sampleSize([1, 2, 3], 4);
	 * // => [2, 3, 1]
	 */
	function sampleSize(collection, n, guard) {
	  if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
	    n = 1;
	  } else {
	    n = toInteger(n);
	  }
	  var func = isArray(collection) ? arraySampleSize : baseSampleSize;
	  return func(collection, n);
	}

	/**
	 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
	 * it's created. Arrays are created for missing index properties while objects
	 * are created for all other missing properties. Use `_.setWith` to customize
	 * `path` creation.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.7.0
	 * @category Object
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The path of the property to set.
	 * @param {*} value The value to set.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.set(object, 'a[0].b.c', 4);
	 * console.log(object.a[0].b.c);
	 * // => 4
	 *
	 * _.set(object, ['x', '0', 'y', 'z'], 5);
	 * console.log(object.x[0].y.z);
	 * // => 5
	 */
	function set(object, path, value) {
	  return object == null ? object : baseSet(object, path, value);
	}

	/**
	 * This method is like `_.set` except that it accepts `customizer` which is
	 * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
	 * path creation is handled by the method instead. The `customizer` is invoked
	 * with three arguments: (nsValue, key, nsObject).
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The path of the property to set.
	 * @param {*} value The value to set.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var object = {};
	 *
	 * _.setWith(object, '[0][1]', 'a', Object);
	 * // => { '0': { '1': 'a' } }
	 */
	function setWith(object, path, value, customizer) {
	  customizer = typeof customizer == 'function' ? customizer : undefined;
	  return object == null ? object : baseSet(object, path, value, customizer);
	}

	/**
	 * A specialized version of `_.shuffle` for arrays.
	 *
	 * @private
	 * @param {Array} array The array to shuffle.
	 * @returns {Array} Returns the new shuffled array.
	 */
	function arrayShuffle(array) {
	  return shuffleSelf(copyArray$1(array));
	}

	/**
	 * The base implementation of `_.shuffle`.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to shuffle.
	 * @returns {Array} Returns the new shuffled array.
	 */
	function baseShuffle(collection) {
	  return shuffleSelf(values(collection));
	}

	/**
	 * Creates an array of shuffled values, using a version of the
	 * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to shuffle.
	 * @returns {Array} Returns the new shuffled array.
	 * @example
	 *
	 * _.shuffle([1, 2, 3, 4]);
	 * // => [4, 1, 3, 2]
	 */
	function shuffle(collection) {
	  var func = isArray(collection) ? arrayShuffle : baseShuffle;
	  return func(collection);
	}

	/** `Object#toString` result references. */
	var mapTag$9 = '[object Map]',
	    setTag$9 = '[object Set]';

	/**
	 * Gets the size of `collection` by returning its length for array-like
	 * values or the number of own enumerable string keyed properties for objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object|string} collection The collection to inspect.
	 * @returns {number} Returns the collection size.
	 * @example
	 *
	 * _.size([1, 2, 3]);
	 * // => 3
	 *
	 * _.size({ 'a': 1, 'b': 2 });
	 * // => 2
	 *
	 * _.size('pebbles');
	 * // => 7
	 */
	function size(collection) {
	  if (collection == null) {
	    return 0;
	  }
	  if (isArrayLike(collection)) {
	    return isString(collection) ? stringSize(collection) : collection.length;
	  }
	  var tag = getTag$1(collection);
	  if (tag == mapTag$9 || tag == setTag$9) {
	    return collection.size;
	  }
	  return baseKeys(collection).length;
	}

	/**
	 * Creates a slice of `array` from `start` up to, but not including, `end`.
	 *
	 * **Note:** This method is used instead of
	 * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
	 * returned.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Array
	 * @param {Array} array The array to slice.
	 * @param {number} [start=0] The start position.
	 * @param {number} [end=array.length] The end position.
	 * @returns {Array} Returns the slice of `array`.
	 */
	function slice(array, start, end) {
	  var length = array == null ? 0 : array.length;
	  if (!length) {
	    return [];
	  }
	  if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
	    start = 0;
	    end = length;
	  }
	  else {
	    start = start == null ? 0 : toInteger(start);
	    end = end === undefined ? length : toInteger(end);
	  }
	  return baseSlice(array, start, end);
	}

	/**
	 * Converts `string` to
	 * [snake case](https://en.wikipedia.org/wiki/Snake_case).
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to convert.
	 * @returns {string} Returns the snake cased string.
	 * @example
	 *
	 * _.snakeCase('Foo Bar');
	 * // => 'foo_bar'
	 *
	 * _.snakeCase('fooBar');
	 * // => 'foo_bar'
	 *
	 * _.snakeCase('--FOO-BAR--');
	 * // => 'foo_bar'
	 */
	var snakeCase = createCompounder(function(result, word, index) {
	  return result + (index ? '_' : '') + word.toLowerCase();
	});

	/**
	 * The base implementation of `_.some` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} predicate The function invoked per iteration.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 */
	function baseSome(collection, predicate) {
	  var result;

	  baseEach(collection, function(value, index, collection) {
	    result = predicate(value, index, collection);
	    return !result;
	  });
	  return !!result;
	}

	/**
	 * Checks if `predicate` returns truthy for **any** element of `collection`.
	 * Iteration is stopped once `predicate` returns truthy. The predicate is
	 * invoked with three arguments: (value, index|key, collection).
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {boolean} Returns `true` if any element passes the predicate check,
	 *  else `false`.
	 * @example
	 *
	 * _.some([null, 0, 'yes', false], Boolean);
	 * // => true
	 *
	 * var users = [
	 *   { 'user': 'barney', 'active': true },
	 *   { 'user': 'fred',   'active': false }
	 * ];
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.some(users, { 'user': 'barney', 'active': false });
	 * // => false
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.some(users, ['active', false]);
	 * // => true
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.some(users, 'active');
	 * // => true
	 */
	function some(collection, predicate, guard) {
	  var func = isArray(collection) ? arraySome : baseSome;
	  if (guard && isIterateeCall(collection, predicate, guard)) {
	    predicate = undefined;
	  }
	  return func(collection, baseIteratee(predicate));
	}

	/**
	 * Creates an array of elements, sorted in ascending order by the results of
	 * running each element in a collection thru each iteratee. This method
	 * performs a stable sort, that is, it preserves the original sort order of
	 * equal elements. The iteratees are invoked with one argument: (value).
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Collection
	 * @param {Array|Object} collection The collection to iterate over.
	 * @param {...(Function|Function[])} [iteratees=[_.identity]]
	 *  The iteratees to sort by.
	 * @returns {Array} Returns the new sorted array.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'fred',   'age': 48 },
	 *   { 'user': 'barney', 'age': 36 },
	 *   { 'user': 'fred',   'age': 40 },
	 *   { 'user': 'barney', 'age': 34 }
	 * ];
	 *
	 * _.sortBy(users, [function(o) { return o.user; }]);
	 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
	 *
	 * _.sortBy(users, ['user', 'age']);
	 * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
	 */
	var sortBy = baseRest(function(collection, iteratees) {
	  if (collection == null) {
	    return [];
	  }
	  var length = iteratees.length;
	  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
	    iteratees = [];
	  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
	    iteratees = [iteratees[0]];
	  }
	  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
	});

	/** Used as references for the maximum length and index of an array. */
	var MAX_ARRAY_LENGTH$2 = 4294967295,
	    MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH$2 - 1;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeFloor$3 = Math.floor,
	    nativeMin$a = Math.min;

	/**
	 * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
	 * which invokes `iteratee` for `value` and each element of `array` to compute
	 * their sort ranking. The iteratee is invoked with one argument; (value).
	 *
	 * @private
	 * @param {Array} array The sorted array to inspect.
	 * @param {*} value The value to evaluate.
	 * @param {Function} iteratee The iteratee invoked per element.
	 * @param {boolean} [retHighest] Specify returning the highest qualified index.
	 * @returns {number} Returns the index at which `value` should be inserted
	 *  into `array`.
	 */
	function baseSortedIndexBy(array, value, iteratee, retHighest) {
	  value = iteratee(value);

	  var low = 0,
	      high = array == null ? 0 : array.length,
	      valIsNaN = value !== value,
	      valIsNull = value === null,
	      valIsSymbol = isSymbol(value),
	      valIsUndefined = value === undefined;

	  while (low < high) {
	    var mid = nativeFloor$3((low + high) / 2),
	        computed = iteratee(array[mid]),
	        othIsDefined = computed !== undefined,
	        othIsNull = computed === null,
	        othIsReflexive = computed === computed,
	        othIsSymbol = isSymbol(computed);

	    if (valIsNaN) {
	      var setLow = retHighest || othIsReflexive;
	    } else if (valIsUndefined) {
	      setLow = othIsReflexive && (retHighest || othIsDefined);
	    } else if (valIsNull) {
	      setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
	    } else if (valIsSymbol) {
	      setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
	    } else if (othIsNull || othIsSymbol) {
	      setLow = false;
	    } else {
	      setLow = retHighest ? (computed <= value) : (computed < value);
	    }
	    if (setLow) {
	      low = mid + 1;
	    } else {
	      high = mid;
	    }
	  }
	  return nativeMin$a(high, MAX_ARRAY_INDEX);
	}

	/** Used as references for the maximum length and index of an array. */
	var MAX_ARRAY_LENGTH$3 = 4294967295,
	    HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH$3 >>> 1;

	/**
	 * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
	 * performs a binary search of `array` to determine the index at which `value`
	 * should be inserted into `array` in order to maintain its sort order.
	 *
	 * @private
	 * @param {Array} array The sorted array to inspect.
	 * @param {*} value The value to evaluate.
	 * @param {boolean} [retHighest] Specify returning the highest qualified index.
	 * @returns {number} Returns the index at which `value` should be inserted
	 *  into `array`.
	 */
	function baseSortedIndex(array, value, retHighest) {
	  var low = 0,
	      high = array == null ? low : array.length;

	  if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
	    while (low < high) {
	      var mid = (low + high) >>> 1,
	          computed = array[mid];

	      if (computed !== null && !isSymbol(computed) &&
	          (retHighest ? (computed <= value) : (computed < value))) {
	        low = mid + 1;
	      } else {
	        high = mid;
	      }
	    }
	    return high;
	  }
	  return baseSortedIndexBy(array, value, identity, retHighest);
	}

	/**
	 * Uses a binary search to determine the lowest index at which `value`
	 * should be inserted into `array` in order to maintain its sort order.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The sorted array to inspect.
	 * @param {*} value The value to evaluate.
	 * @returns {number} Returns the index at which `value` should be inserted
	 *  into `array`.
	 * @example
	 *
	 * _.sortedIndex([30, 50], 40);
	 * // => 1
	 */
	function sortedIndex(array, value) {
	  return baseSortedIndex(array, value);
	}

	/**
	 * This method is like `_.sortedIndex` except that it accepts `iteratee`
	 * which is invoked for `value` and each element of `array` to compute their
	 * sort ranking. The iteratee is invoked with one argument: (value).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Array
	 * @param {Array} array The sorted array to inspect.
	 * @param {*} value The value to evaluate.
	 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	 * @returns {number} Returns the index at which `value` should be inserted
	 *  into `array`.
	 * @example
	 *
	 * var objects = [{ 'x': 4 }, { 'x': 5 }];
	 *
	 * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
	 * // => 0
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
	 * // => 0
	 */
	function sortedIndexBy(array, value, iteratee) {
	  return baseSortedIndexBy(array, value, baseIteratee(iteratee));
	}

	/**
	 * This method is like `_.indexOf` except that it performs a binary
	 * search on a sorted `array`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 * @example
	 *
	 * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
	 * // => 1
	 */
	function sortedIndexOf(array, value) {
	  var length = array == null ? 0 : array.length;
	  if (length) {
	    var index = baseSortedIndex(array, value);
	    if (index < length && eq(array[index], value)) {
	      return index;
	    }
	  }
	  return -1;
	}

	/**
	 * This method is like `_.sortedIndex` except that it returns the highest
	 * index at which `value` should be inserted into `array` in order to
	 * maintain its sort order.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Array
	 * @param {Array} array The sorted array to inspect.
	 * @param {*} value The value to evaluate.
	 * @returns {number} Returns the index at which `value` should be inserted
	 *  into `array`.
	 * @example
	 *
	 * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
	 * // => 4
	 */
	function sortedLastIndex(array, value) {
	  return baseSortedIndex(array, value, true);
	}

	/**
	 * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
	 * which is invoked for `value` and each element of `array` to compute their
	 * sort ranking. The iteratee is invoked with one argument: (value).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Array
	 * @param {Array} array The sorted array to inspect.
	 * @param {*} value The value to evaluate.
	 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	 * @returns {number} Returns the index at which `value` should be inserted
	 *  into `array`.
	 * @example
	 *
	 * var objects = [{ 'x': 4 }, { 'x': 5 }];
	 *
	 * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
	 * // => 1
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
	 * // => 1
	 */
	function sortedLastIndexBy(array, value, iteratee) {
	  return baseSortedIndexBy(array, value, baseIteratee(iteratee), true);
	}

	/**
	 * This method is like `_.lastIndexOf` except that it performs a binary
	 * search on a sorted `array`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @param {*} value The value to search for.
	 * @returns {number} Returns the index of the matched value, else `-1`.
	 * @example
	 *
	 * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
	 * // => 3
	 */
	function sortedLastIndexOf(array, value) {
	  var length = array == null ? 0 : array.length;
	  if (length) {
	    var index = baseSortedIndex(array, value, true) - 1;
	    if (eq(array[index], value)) {
	      return index;
	    }
	  }
	  return -1;
	}

	/**
	 * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
	 * support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} [iteratee] The iteratee invoked per element.
	 * @returns {Array} Returns the new duplicate free array.
	 */
	function baseSortedUniq(array, iteratee) {
	  var index = -1,
	      length = array.length,
	      resIndex = 0,
	      result = [];

	  while (++index < length) {
	    var value = array[index],
	        computed = iteratee ? iteratee(value) : value;

	    if (!index || !eq(computed, seen)) {
	      var seen = computed;
	      result[resIndex++] = value === 0 ? 0 : value;
	    }
	  }
	  return result;
	}

	/**
	 * This method is like `_.uniq` except that it's designed and optimized
	 * for sorted arrays.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @returns {Array} Returns the new duplicate free array.
	 * @example
	 *
	 * _.sortedUniq([1, 1, 2]);
	 * // => [1, 2]
	 */
	function sortedUniq(array) {
	  return (array && array.length)
	    ? baseSortedUniq(array)
	    : [];
	}

	/**
	 * This method is like `_.uniqBy` except that it's designed and optimized
	 * for sorted arrays.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @param {Function} [iteratee] The iteratee invoked per element.
	 * @returns {Array} Returns the new duplicate free array.
	 * @example
	 *
	 * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
	 * // => [1.1, 2.3]
	 */
	function sortedUniqBy(array, iteratee) {
	  return (array && array.length)
	    ? baseSortedUniq(array, baseIteratee(iteratee))
	    : [];
	}

	/** Used as references for the maximum length and index of an array. */
	var MAX_ARRAY_LENGTH$4 = 4294967295;

	/**
	 * Splits `string` by `separator`.
	 *
	 * **Note:** This method is based on
	 * [`String#split`](https://mdn.io/String/split).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category String
	 * @param {string} [string=''] The string to split.
	 * @param {RegExp|string} separator The separator pattern to split by.
	 * @param {number} [limit] The length to truncate results to.
	 * @returns {Array} Returns the string segments.
	 * @example
	 *
	 * _.split('a-b-c', '-', 2);
	 * // => ['a', 'b']
	 */
	function split(string, separator, limit) {
	  if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
	    separator = limit = undefined;
	  }
	  limit = limit === undefined ? MAX_ARRAY_LENGTH$4 : limit >>> 0;
	  if (!limit) {
	    return [];
	  }
	  string = toString(string);
	  if (string && (
	        typeof separator == 'string' ||
	        (separator != null && !isRegExp(separator))
	      )) {
	    separator = baseToString(separator);
	    if (!separator && hasUnicode(string)) {
	      return castSlice(stringToArray(string), 0, limit);
	    }
	  }
	  return string.split(separator, limit);
	}

	/** Error message constants. */
	var FUNC_ERROR_TEXT$a = 'Expected a function';

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax$d = Math.max;

	/**
	 * Creates a function that invokes `func` with the `this` binding of the
	 * create function and an array of arguments much like
	 * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
	 *
	 * **Note:** This method is based on the
	 * [spread operator](https://mdn.io/spread_operator).
	 *
	 * @static
	 * @memberOf _
	 * @since 3.2.0
	 * @category Function
	 * @param {Function} func The function to spread arguments over.
	 * @param {number} [start=0] The start position of the spread.
	 * @returns {Function} Returns the new function.
	 * @example
	 *
	 * var say = _.spread(function(who, what) {
	 *   return who + ' says ' + what;
	 * });
	 *
	 * say(['fred', 'hello']);
	 * // => 'fred says hello'
	 *
	 * var numbers = Promise.all([
	 *   Promise.resolve(40),
	 *   Promise.resolve(36)
	 * ]);
	 *
	 * numbers.then(_.spread(function(x, y) {
	 *   return x + y;
	 * }));
	 * // => a Promise of 76
	 */
	function spread(func, start) {
	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT$a);
	  }
	  start = start == null ? 0 : nativeMax$d(toInteger(start), 0);
	  return baseRest(function(args) {
	    var array = args[start],
	        otherArgs = castSlice(args, 0, start);

	    if (array) {
	      arrayPush(otherArgs, array);
	    }
	    return apply(func, this, otherArgs);
	  });
	}

	/**
	 * Converts `string` to
	 * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
	 *
	 * @static
	 * @memberOf _
	 * @since 3.1.0
	 * @category String
	 * @param {string} [string=''] The string to convert.
	 * @returns {string} Returns the start cased string.
	 * @example
	 *
	 * _.startCase('--foo-bar--');
	 * // => 'Foo Bar'
	 *
	 * _.startCase('fooBar');
	 * // => 'Foo Bar'
	 *
	 * _.startCase('__FOO_BAR__');
	 * // => 'FOO BAR'
	 */
	var startCase = createCompounder(function(result, word, index) {
	  return result + (index ? ' ' : '') + upperFirst(word);
	});

	/**
	 * Checks if `string` starts with the given target string.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to inspect.
	 * @param {string} [target] The string to search for.
	 * @param {number} [position=0] The position to search from.
	 * @returns {boolean} Returns `true` if `string` starts with `target`,
	 *  else `false`.
	 * @example
	 *
	 * _.startsWith('abc', 'a');
	 * // => true
	 *
	 * _.startsWith('abc', 'b');
	 * // => false
	 *
	 * _.startsWith('abc', 'b', 1);
	 * // => true
	 */
	function startsWith(string, target, position) {
	  string = toString(string);
	  position = position == null
	    ? 0
	    : baseClamp(toInteger(position), 0, string.length);

	  target = baseToString(target);
	  return string.slice(position, position + target.length) == target;
	}

	/**
	 * This method returns a new empty object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {Object} Returns the new empty object.
	 * @example
	 *
	 * var objects = _.times(2, _.stubObject);
	 *
	 * console.log(objects);
	 * // => [{}, {}]
	 *
	 * console.log(objects[0] === objects[1]);
	 * // => false
	 */
	function stubObject() {
	  return {};
	}

	/**
	 * This method returns an empty string.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {string} Returns the empty string.
	 * @example
	 *
	 * _.times(2, _.stubString);
	 * // => ['', '']
	 */
	function stubString() {
	  return '';
	}

	/**
	 * This method returns `true`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `true`.
	 * @example
	 *
	 * _.times(2, _.stubTrue);
	 * // => [true, true]
	 */
	function stubTrue() {
	  return true;
	}

	/**
	 * Subtract two numbers.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Math
	 * @param {number} minuend The first number in a subtraction.
	 * @param {number} subtrahend The second number in a subtraction.
	 * @returns {number} Returns the difference.
	 * @example
	 *
	 * _.subtract(6, 4);
	 * // => 2
	 */
	var subtract = createMathOperation(function(minuend, subtrahend) {
	  return minuend - subtrahend;
	}, 0);

	/**
	 * Computes the sum of the values in `array`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.4.0
	 * @category Math
	 * @param {Array} array The array to iterate over.
	 * @returns {number} Returns the sum.
	 * @example
	 *
	 * _.sum([4, 2, 8, 6]);
	 * // => 20
	 */
	function sum(array) {
	  return (array && array.length)
	    ? baseSum(array, identity)
	    : 0;
	}

	/**
	 * This method is like `_.sum` except that it accepts `iteratee` which is
	 * invoked for each element in `array` to generate the value to be summed.
	 * The iteratee is invoked with one argument: (value).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Math
	 * @param {Array} array The array to iterate over.
	 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	 * @returns {number} Returns the sum.
	 * @example
	 *
	 * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
	 *
	 * _.sumBy(objects, function(o) { return o.n; });
	 * // => 20
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.sumBy(objects, 'n');
	 * // => 20
	 */
	function sumBy(array, iteratee) {
	  return (array && array.length)
	    ? baseSum(array, baseIteratee(iteratee))
	    : 0;
	}

	/**
	 * Gets all but the first element of `array`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Array
	 * @param {Array} array The array to query.
	 * @returns {Array} Returns the slice of `array`.
	 * @example
	 *
	 * _.tail([1, 2, 3]);
	 * // => [2, 3]
	 */
	function tail(array) {
	  var length = array == null ? 0 : array.length;
	  return length ? baseSlice(array, 1, length) : [];
	}

	/**
	 * Creates a slice of `array` with `n` elements taken from the beginning.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to query.
	 * @param {number} [n=1] The number of elements to take.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {Array} Returns the slice of `array`.
	 * @example
	 *
	 * _.take([1, 2, 3]);
	 * // => [1]
	 *
	 * _.take([1, 2, 3], 2);
	 * // => [1, 2]
	 *
	 * _.take([1, 2, 3], 5);
	 * // => [1, 2, 3]
	 *
	 * _.take([1, 2, 3], 0);
	 * // => []
	 */
	function take(array, n, guard) {
	  if (!(array && array.length)) {
	    return [];
	  }
	  n = (guard || n === undefined) ? 1 : toInteger(n);
	  return baseSlice(array, 0, n < 0 ? 0 : n);
	}

	/**
	 * Creates a slice of `array` with `n` elements taken from the end.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Array
	 * @param {Array} array The array to query.
	 * @param {number} [n=1] The number of elements to take.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {Array} Returns the slice of `array`.
	 * @example
	 *
	 * _.takeRight([1, 2, 3]);
	 * // => [3]
	 *
	 * _.takeRight([1, 2, 3], 2);
	 * // => [2, 3]
	 *
	 * _.takeRight([1, 2, 3], 5);
	 * // => [1, 2, 3]
	 *
	 * _.takeRight([1, 2, 3], 0);
	 * // => []
	 */
	function takeRight(array, n, guard) {
	  var length = array == null ? 0 : array.length;
	  if (!length) {
	    return [];
	  }
	  n = (guard || n === undefined) ? 1 : toInteger(n);
	  n = length - n;
	  return baseSlice(array, n < 0 ? 0 : n, length);
	}

	/**
	 * Creates a slice of `array` with elements taken from the end. Elements are
	 * taken until `predicate` returns falsey. The predicate is invoked with
	 * three arguments: (value, index, array).
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Array
	 * @param {Array} array The array to query.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @returns {Array} Returns the slice of `array`.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney',  'active': true },
	 *   { 'user': 'fred',    'active': false },
	 *   { 'user': 'pebbles', 'active': false }
	 * ];
	 *
	 * _.takeRightWhile(users, function(o) { return !o.active; });
	 * // => objects for ['fred', 'pebbles']
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
	 * // => objects for ['pebbles']
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.takeRightWhile(users, ['active', false]);
	 * // => objects for ['fred', 'pebbles']
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.takeRightWhile(users, 'active');
	 * // => []
	 */
	function takeRightWhile(array, predicate) {
	  return (array && array.length)
	    ? baseWhile(array, baseIteratee(predicate), false, true)
	    : [];
	}

	/**
	 * Creates a slice of `array` with elements taken from the beginning. Elements
	 * are taken until `predicate` returns falsey. The predicate is invoked with
	 * three arguments: (value, index, array).
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Array
	 * @param {Array} array The array to query.
	 * @param {Function} [predicate=_.identity] The function invoked per iteration.
	 * @returns {Array} Returns the slice of `array`.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney',  'active': false },
	 *   { 'user': 'fred',    'active': false },
	 *   { 'user': 'pebbles', 'active': true }
	 * ];
	 *
	 * _.takeWhile(users, function(o) { return !o.active; });
	 * // => objects for ['barney', 'fred']
	 *
	 * // The `_.matches` iteratee shorthand.
	 * _.takeWhile(users, { 'user': 'barney', 'active': false });
	 * // => objects for ['barney']
	 *
	 * // The `_.matchesProperty` iteratee shorthand.
	 * _.takeWhile(users, ['active', false]);
	 * // => objects for ['barney', 'fred']
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.takeWhile(users, 'active');
	 * // => []
	 */
	function takeWhile(array, predicate) {
	  return (array && array.length)
	    ? baseWhile(array, baseIteratee(predicate))
	    : [];
	}

	/**
	 * This method invokes `interceptor` and returns `value`. The interceptor
	 * is invoked with one argument; (value). The purpose of this method is to
	 * "tap into" a method chain sequence in order to modify intermediate results.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Seq
	 * @param {*} value The value to provide to `interceptor`.
	 * @param {Function} interceptor The function to invoke.
	 * @returns {*} Returns `value`.
	 * @example
	 *
	 * _([1, 2, 3])
	 *  .tap(function(array) {
	 *    // Mutate input array.
	 *    array.pop();
	 *  })
	 *  .reverse()
	 *  .value();
	 * // => [2, 1]
	 */
	function tap(value, interceptor) {
	  interceptor(value);
	  return value;
	}

	/** Used for built-in method references. */
	var objectProto$q = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$m = objectProto$q.hasOwnProperty;

	/**
	 * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
	 * of source objects to the destination object for all destination properties
	 * that resolve to `undefined`.
	 *
	 * @private
	 * @param {*} objValue The destination value.
	 * @param {*} srcValue The source value.
	 * @param {string} key The key of the property to assign.
	 * @param {Object} object The parent object of `objValue`.
	 * @returns {*} Returns the value to assign.
	 */
	function customDefaultsAssignIn(objValue, srcValue, key, object) {
	  if (objValue === undefined ||
	      (eq(objValue, objectProto$q[key]) && !hasOwnProperty$m.call(object, key))) {
	    return srcValue;
	  }
	  return objValue;
	}

	/** Used to escape characters for inclusion in compiled string literals. */
	var stringEscapes = {
	  '\\': '\\',
	  "'": "'",
	  '\n': 'n',
	  '\r': 'r',
	  '\u2028': 'u2028',
	  '\u2029': 'u2029'
	};

	/**
	 * Used by `_.template` to escape characters for inclusion in compiled string literals.
	 *
	 * @private
	 * @param {string} chr The matched character to escape.
	 * @returns {string} Returns the escaped character.
	 */
	function escapeStringChar(chr) {
	  return '\\' + stringEscapes[chr];
	}

	/** Used to match template delimiters. */
	var reInterpolate = /<%=([\s\S]+?)%>/g;

	/** Used to match template delimiters. */
	var reEscape = /<%-([\s\S]+?)%>/g;

	/** Used to match template delimiters. */
	var reEvaluate = /<%([\s\S]+?)%>/g;

	/**
	 * By default, the template delimiters used by lodash are like those in
	 * embedded Ruby (ERB) as well as ES2015 template strings. Change the
	 * following template settings to use alternative delimiters.
	 *
	 * @static
	 * @memberOf _
	 * @type {Object}
	 */
	var templateSettings = {

	  /**
	   * Used to detect `data` property values to be HTML-escaped.
	   *
	   * @memberOf _.templateSettings
	   * @type {RegExp}
	   */
	  'escape': reEscape,

	  /**
	   * Used to detect code to be evaluated.
	   *
	   * @memberOf _.templateSettings
	   * @type {RegExp}
	   */
	  'evaluate': reEvaluate,

	  /**
	   * Used to detect `data` property values to inject.
	   *
	   * @memberOf _.templateSettings
	   * @type {RegExp}
	   */
	  'interpolate': reInterpolate,

	  /**
	   * Used to reference the data object in the template text.
	   *
	   * @memberOf _.templateSettings
	   * @type {string}
	   */
	  'variable': '',

	  /**
	   * Used to import variables into the compiled template.
	   *
	   * @memberOf _.templateSettings
	   * @type {Object}
	   */
	  'imports': {

	    /**
	     * A reference to the `lodash` function.
	     *
	     * @memberOf _.templateSettings.imports
	     * @type {Function}
	     */
	    '_': { 'escape': escape$1 }
	  }
	};

	/** Used to match empty string literals in compiled template source. */
	var reEmptyStringLeading = /\b__p \+= '';/g,
	    reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
	    reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

	/**
	 * Used to match
	 * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
	 */
	var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

	/** Used to ensure capturing order of template delimiters. */
	var reNoMatch = /($^)/;

	/** Used to match unescaped characters in compiled string literals. */
	var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

	/** Used for built-in method references. */
	var objectProto$r = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$n = objectProto$r.hasOwnProperty;

	/**
	 * Creates a compiled template function that can interpolate data properties
	 * in "interpolate" delimiters, HTML-escape interpolated data properties in
	 * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
	 * properties may be accessed as free variables in the template. If a setting
	 * object is given, it takes precedence over `_.templateSettings` values.
	 *
	 * **Note:** In the development build `_.template` utilizes
	 * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
	 * for easier debugging.
	 *
	 * For more information on precompiling templates see
	 * [lodash's custom builds documentation](https://lodash.com/custom-builds).
	 *
	 * For more information on Chrome extension sandboxes see
	 * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category String
	 * @param {string} [string=''] The template string.
	 * @param {Object} [options={}] The options object.
	 * @param {RegExp} [options.escape=_.templateSettings.escape]
	 *  The HTML "escape" delimiter.
	 * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
	 *  The "evaluate" delimiter.
	 * @param {Object} [options.imports=_.templateSettings.imports]
	 *  An object to import into the template as free variables.
	 * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
	 *  The "interpolate" delimiter.
	 * @param {string} [options.sourceURL='templateSources[n]']
	 *  The sourceURL of the compiled template.
	 * @param {string} [options.variable='obj']
	 *  The data object variable name.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {Function} Returns the compiled template function.
	 * @example
	 *
	 * // Use the "interpolate" delimiter to create a compiled template.
	 * var compiled = _.template('hello <%= user %>!');
	 * compiled({ 'user': 'fred' });
	 * // => 'hello fred!'
	 *
	 * // Use the HTML "escape" delimiter to escape data property values.
	 * var compiled = _.template('<b><%- value %></b>');
	 * compiled({ 'value': '<script>' });
	 * // => '<b>&lt;script&gt;</b>'
	 *
	 * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
	 * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
	 * compiled({ 'users': ['fred', 'barney'] });
	 * // => '<li>fred</li><li>barney</li>'
	 *
	 * // Use the internal `print` function in "evaluate" delimiters.
	 * var compiled = _.template('<% print("hello " + user); %>!');
	 * compiled({ 'user': 'barney' });
	 * // => 'hello barney!'
	 *
	 * // Use the ES template literal delimiter as an "interpolate" delimiter.
	 * // Disable support by replacing the "interpolate" delimiter.
	 * var compiled = _.template('hello ${ user }!');
	 * compiled({ 'user': 'pebbles' });
	 * // => 'hello pebbles!'
	 *
	 * // Use backslashes to treat delimiters as plain text.
	 * var compiled = _.template('<%= "\\<%- value %\\>" %>');
	 * compiled({ 'value': 'ignored' });
	 * // => '<%- value %>'
	 *
	 * // Use the `imports` option to import `jQuery` as `jq`.
	 * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
	 * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
	 * compiled({ 'users': ['fred', 'barney'] });
	 * // => '<li>fred</li><li>barney</li>'
	 *
	 * // Use the `sourceURL` option to specify a custom sourceURL for the template.
	 * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
	 * compiled(data);
	 * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
	 *
	 * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
	 * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
	 * compiled.source;
	 * // => function(data) {
	 * //   var __t, __p = '';
	 * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
	 * //   return __p;
	 * // }
	 *
	 * // Use custom template delimiters.
	 * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
	 * var compiled = _.template('hello {{ user }}!');
	 * compiled({ 'user': 'mustache' });
	 * // => 'hello mustache!'
	 *
	 * // Use the `source` property to inline compiled templates for meaningful
	 * // line numbers in error messages and stack traces.
	 * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
	 *   var JST = {\
	 *     "main": ' + _.template(mainText).source + '\
	 *   };\
	 * ');
	 */
	function template(string, options, guard) {
	  // Based on John Resig's `tmpl` implementation
	  // (http://ejohn.org/blog/javascript-micro-templating/)
	  // and Laura Doktorova's doT.js (https://github.com/olado/doT).
	  var settings = templateSettings.imports._.templateSettings || templateSettings;

	  if (guard && isIterateeCall(string, options, guard)) {
	    options = undefined;
	  }
	  string = toString(string);
	  options = assignInWith({}, options, settings, customDefaultsAssignIn);

	  var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
	      importsKeys = keys(imports),
	      importsValues = baseValues(imports, importsKeys);

	  var isEscaping,
	      isEvaluating,
	      index = 0,
	      interpolate = options.interpolate || reNoMatch,
	      source = "__p += '";

	  // Compile the regexp to match each delimiter.
	  var reDelimiters = RegExp(
	    (options.escape || reNoMatch).source + '|' +
	    interpolate.source + '|' +
	    (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
	    (options.evaluate || reNoMatch).source + '|$'
	  , 'g');

	  // Use a sourceURL for easier debugging.
	  // The sourceURL gets injected into the source that's eval-ed, so be careful
	  // with lookup (in case of e.g. prototype pollution), and strip newlines if any.
	  // A newline wouldn't be a valid sourceURL anyway, and it'd enable code injection.
	  var sourceURL = hasOwnProperty$n.call(options, 'sourceURL')
	    ? ('//# sourceURL=' +
	       (options.sourceURL + '').replace(/[\r\n]/g, ' ') +
	       '\n')
	    : '';

	  string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
	    interpolateValue || (interpolateValue = esTemplateValue);

	    // Escape characters that can't be included in string literals.
	    source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

	    // Replace delimiters with snippets.
	    if (escapeValue) {
	      isEscaping = true;
	      source += "' +\n__e(" + escapeValue + ") +\n'";
	    }
	    if (evaluateValue) {
	      isEvaluating = true;
	      source += "';\n" + evaluateValue + ";\n__p += '";
	    }
	    if (interpolateValue) {
	      source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
	    }
	    index = offset + match.length;

	    // The JS engine embedded in Adobe products needs `match` returned in
	    // order to produce the correct `offset` value.
	    return match;
	  });

	  source += "';\n";

	  // If `variable` is not specified wrap a with-statement around the generated
	  // code to add the data object to the top of the scope chain.
	  // Like with sourceURL, we take care to not check the option's prototype,
	  // as this configuration is a code injection vector.
	  var variable = hasOwnProperty$n.call(options, 'variable') && options.variable;
	  if (!variable) {
	    source = 'with (obj) {\n' + source + '\n}\n';
	  }
	  // Cleanup code by stripping empty strings.
	  source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
	    .replace(reEmptyStringMiddle, '$1')
	    .replace(reEmptyStringTrailing, '$1;');

	  // Frame code as the function body.
	  source = 'function(' + (variable || 'obj') + ') {\n' +
	    (variable
	      ? ''
	      : 'obj || (obj = {});\n'
	    ) +
	    "var __t, __p = ''" +
	    (isEscaping
	       ? ', __e = _.escape'
	       : ''
	    ) +
	    (isEvaluating
	      ? ', __j = Array.prototype.join;\n' +
	        "function print() { __p += __j.call(arguments, '') }\n"
	      : ';\n'
	    ) +
	    source +
	    'return __p\n}';

	  var result = attempt(function() {
	    return Function(importsKeys, sourceURL + 'return ' + source)
	      .apply(undefined, importsValues);
	  });

	  // Provide the compiled function's source by its `toString` method or
	  // the `source` property as a convenience for inlining compiled templates.
	  result.source = source;
	  if (isError(result)) {
	    throw result;
	  }
	  return result;
	}

	/** Error message constants. */
	var FUNC_ERROR_TEXT$b = 'Expected a function';

	/**
	 * Creates a throttled function that only invokes `func` at most once per
	 * every `wait` milliseconds. The throttled function comes with a `cancel`
	 * method to cancel delayed `func` invocations and a `flush` method to
	 * immediately invoke them. Provide `options` to indicate whether `func`
	 * should be invoked on the leading and/or trailing edge of the `wait`
	 * timeout. The `func` is invoked with the last arguments provided to the
	 * throttled function. Subsequent calls to the throttled function return the
	 * result of the last `func` invocation.
	 *
	 * **Note:** If `leading` and `trailing` options are `true`, `func` is
	 * invoked on the trailing edge of the timeout only if the throttled function
	 * is invoked more than once during the `wait` timeout.
	 *
	 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	 *
	 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	 * for details over the differences between `_.throttle` and `_.debounce`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {Function} func The function to throttle.
	 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
	 * @param {Object} [options={}] The options object.
	 * @param {boolean} [options.leading=true]
	 *  Specify invoking on the leading edge of the timeout.
	 * @param {boolean} [options.trailing=true]
	 *  Specify invoking on the trailing edge of the timeout.
	 * @returns {Function} Returns the new throttled function.
	 * @example
	 *
	 * // Avoid excessively updating the position while scrolling.
	 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
	 *
	 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
	 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
	 * jQuery(element).on('click', throttled);
	 *
	 * // Cancel the trailing throttled invocation.
	 * jQuery(window).on('popstate', throttled.cancel);
	 */
	function throttle(func, wait, options) {
	  var leading = true,
	      trailing = true;

	  if (typeof func != 'function') {
	    throw new TypeError(FUNC_ERROR_TEXT$b);
	  }
	  if (isObject(options)) {
	    leading = 'leading' in options ? !!options.leading : leading;
	    trailing = 'trailing' in options ? !!options.trailing : trailing;
	  }
	  return debounce(func, wait, {
	    'leading': leading,
	    'maxWait': wait,
	    'trailing': trailing
	  });
	}

	/**
	 * This method is like `_.tap` except that it returns the result of `interceptor`.
	 * The purpose of this method is to "pass thru" values replacing intermediate
	 * results in a method chain sequence.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Seq
	 * @param {*} value The value to provide to `interceptor`.
	 * @param {Function} interceptor The function to invoke.
	 * @returns {*} Returns the result of `interceptor`.
	 * @example
	 *
	 * _('  abc  ')
	 *  .chain()
	 *  .trim()
	 *  .thru(function(value) {
	 *    return [value];
	 *  })
	 *  .value();
	 * // => ['abc']
	 */
	function thru(value, interceptor) {
	  return interceptor(value);
	}

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER$4 = 9007199254740991;

	/** Used as references for the maximum length and index of an array. */
	var MAX_ARRAY_LENGTH$5 = 4294967295;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMin$b = Math.min;

	/**
	 * Invokes the iteratee `n` times, returning an array of the results of
	 * each invocation. The iteratee is invoked with one argument; (index).
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {number} n The number of times to invoke `iteratee`.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @returns {Array} Returns the array of results.
	 * @example
	 *
	 * _.times(3, String);
	 * // => ['0', '1', '2']
	 *
	 *  _.times(4, _.constant(0));
	 * // => [0, 0, 0, 0]
	 */
	function times(n, iteratee) {
	  n = toInteger(n);
	  if (n < 1 || n > MAX_SAFE_INTEGER$4) {
	    return [];
	  }
	  var index = MAX_ARRAY_LENGTH$5,
	      length = nativeMin$b(n, MAX_ARRAY_LENGTH$5);

	  iteratee = castFunction(iteratee);
	  n -= MAX_ARRAY_LENGTH$5;

	  var result = baseTimes(length, iteratee);
	  while (++index < n) {
	    iteratee(index);
	  }
	  return result;
	}

	/**
	 * Enables the wrapper to be iterable.
	 *
	 * @name Symbol.iterator
	 * @memberOf _
	 * @since 4.0.0
	 * @category Seq
	 * @returns {Object} Returns the wrapper object.
	 * @example
	 *
	 * var wrapped = _([1, 2]);
	 *
	 * wrapped[Symbol.iterator]() === wrapped;
	 * // => true
	 *
	 * Array.from(wrapped);
	 * // => [1, 2]
	 */
	function wrapperToIterator() {
	  return this;
	}

	/**
	 * The base implementation of `wrapperValue` which returns the result of
	 * performing a sequence of actions on the unwrapped `value`, where each
	 * successive action is supplied the return value of the previous.
	 *
	 * @private
	 * @param {*} value The unwrapped value.
	 * @param {Array} actions Actions to perform to resolve the unwrapped value.
	 * @returns {*} Returns the resolved value.
	 */
	function baseWrapperValue(value, actions) {
	  var result = value;
	  if (result instanceof LazyWrapper) {
	    result = result.value();
	  }
	  return arrayReduce(actions, function(result, action) {
	    return action.func.apply(action.thisArg, arrayPush([result], action.args));
	  }, result);
	}

	/**
	 * Executes the chain sequence to resolve the unwrapped value.
	 *
	 * @name value
	 * @memberOf _
	 * @since 0.1.0
	 * @alias toJSON, valueOf
	 * @category Seq
	 * @returns {*} Returns the resolved unwrapped value.
	 * @example
	 *
	 * _([1, 2, 3]).value();
	 * // => [1, 2, 3]
	 */
	function wrapperValue() {
	  return baseWrapperValue(this.__wrapped__, this.__actions__);
	}

	/**
	 * Converts `string`, as a whole, to lower case just like
	 * [String#toLowerCase](https://mdn.io/toLowerCase).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category String
	 * @param {string} [string=''] The string to convert.
	 * @returns {string} Returns the lower cased string.
	 * @example
	 *
	 * _.toLower('--Foo-Bar--');
	 * // => '--foo-bar--'
	 *
	 * _.toLower('fooBar');
	 * // => 'foobar'
	 *
	 * _.toLower('__FOO_BAR__');
	 * // => '__foo_bar__'
	 */
	function toLower(value) {
	  return toString(value).toLowerCase();
	}

	/**
	 * Converts `value` to a property path array.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Util
	 * @param {*} value The value to convert.
	 * @returns {Array} Returns the new property path array.
	 * @example
	 *
	 * _.toPath('a.b.c');
	 * // => ['a', 'b', 'c']
	 *
	 * _.toPath('a[0].b.c');
	 * // => ['a', '0', 'b', 'c']
	 */
	function toPath(value) {
	  if (isArray(value)) {
	    return arrayMap(value, toKey);
	  }
	  return isSymbol(value) ? [value] : copyArray$1(stringToPath(toString(value)));
	}

	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER$5 = 9007199254740991;

	/**
	 * Converts `value` to a safe integer. A safe integer can be compared and
	 * represented correctly.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to convert.
	 * @returns {number} Returns the converted integer.
	 * @example
	 *
	 * _.toSafeInteger(3.2);
	 * // => 3
	 *
	 * _.toSafeInteger(Number.MIN_VALUE);
	 * // => 0
	 *
	 * _.toSafeInteger(Infinity);
	 * // => 9007199254740991
	 *
	 * _.toSafeInteger('3.2');
	 * // => 3
	 */
	function toSafeInteger(value) {
	  return value
	    ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER$5, MAX_SAFE_INTEGER$5)
	    : (value === 0 ? value : 0);
	}

	/**
	 * Converts `string`, as a whole, to upper case just like
	 * [String#toUpperCase](https://mdn.io/toUpperCase).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category String
	 * @param {string} [string=''] The string to convert.
	 * @returns {string} Returns the upper cased string.
	 * @example
	 *
	 * _.toUpper('--foo-bar--');
	 * // => '--FOO-BAR--'
	 *
	 * _.toUpper('fooBar');
	 * // => 'FOOBAR'
	 *
	 * _.toUpper('__foo_bar__');
	 * // => '__FOO_BAR__'
	 */
	function toUpper(value) {
	  return toString(value).toUpperCase();
	}

	/**
	 * An alternative to `_.reduce`; this method transforms `object` to a new
	 * `accumulator` object which is the result of running each of its own
	 * enumerable string keyed properties thru `iteratee`, with each invocation
	 * potentially mutating the `accumulator` object. If `accumulator` is not
	 * provided, a new object with the same `[[Prototype]]` will be used. The
	 * iteratee is invoked with four arguments: (accumulator, value, key, object).
	 * Iteratee functions may exit iteration early by explicitly returning `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.3.0
	 * @category Object
	 * @param {Object} object The object to iterate over.
	 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	 * @param {*} [accumulator] The custom accumulator value.
	 * @returns {*} Returns the accumulated value.
	 * @example
	 *
	 * _.transform([2, 3, 4], function(result, n) {
	 *   result.push(n *= n);
	 *   return n % 2 == 0;
	 * }, []);
	 * // => [4, 9]
	 *
	 * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	 *   (result[value] || (result[value] = [])).push(key);
	 * }, {});
	 * // => { '1': ['a', 'c'], '2': ['b'] }
	 */
	function transform(object, iteratee, accumulator) {
	  var isArr = isArray(object),
	      isArrLike = isArr || isBuffer(object) || isTypedArray(object);

	  iteratee = baseIteratee(iteratee);
	  if (accumulator == null) {
	    var Ctor = object && object.constructor;
	    if (isArrLike) {
	      accumulator = isArr ? new Ctor : [];
	    }
	    else if (isObject(object)) {
	      accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
	    }
	    else {
	      accumulator = {};
	    }
	  }
	  (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
	    return iteratee(accumulator, value, index, object);
	  });
	  return accumulator;
	}

	/**
	 * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
	 * that is not found in the character symbols.
	 *
	 * @private
	 * @param {Array} strSymbols The string symbols to inspect.
	 * @param {Array} chrSymbols The character symbols to find.
	 * @returns {number} Returns the index of the last unmatched string symbol.
	 */
	function charsEndIndex(strSymbols, chrSymbols) {
	  var index = strSymbols.length;

	  while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	  return index;
	}

	/**
	 * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
	 * that is not found in the character symbols.
	 *
	 * @private
	 * @param {Array} strSymbols The string symbols to inspect.
	 * @param {Array} chrSymbols The character symbols to find.
	 * @returns {number} Returns the index of the first unmatched string symbol.
	 */
	function charsStartIndex(strSymbols, chrSymbols) {
	  var index = -1,
	      length = strSymbols.length;

	  while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	  return index;
	}

	/** Used to match leading and trailing whitespace. */
	var reTrim$1 = /^\s+|\s+$/g;

	/**
	 * Removes leading and trailing whitespace or specified characters from `string`.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category String
	 * @param {string} [string=''] The string to trim.
	 * @param {string} [chars=whitespace] The characters to trim.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {string} Returns the trimmed string.
	 * @example
	 *
	 * _.trim('  abc  ');
	 * // => 'abc'
	 *
	 * _.trim('-_-abc-_-', '_-');
	 * // => 'abc'
	 *
	 * _.map(['  foo  ', '  bar  '], _.trim);
	 * // => ['foo', 'bar']
	 */
	function trim(string, chars, guard) {
	  string = toString(string);
	  if (string && (guard || chars === undefined)) {
	    return string.replace(reTrim$1, '');
	  }
	  if (!string || !(chars = baseToString(chars))) {
	    return string;
	  }
	  var strSymbols = stringToArray(string),
	      chrSymbols = stringToArray(chars),
	      start = charsStartIndex(strSymbols, chrSymbols),
	      end = charsEndIndex(strSymbols, chrSymbols) + 1;

	  return castSlice(strSymbols, start, end).join('');
	}

	/** Used to match leading and trailing whitespace. */
	var reTrimEnd = /\s+$/;

	/**
	 * Removes trailing whitespace or specified characters from `string`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category String
	 * @param {string} [string=''] The string to trim.
	 * @param {string} [chars=whitespace] The characters to trim.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {string} Returns the trimmed string.
	 * @example
	 *
	 * _.trimEnd('  abc  ');
	 * // => '  abc'
	 *
	 * _.trimEnd('-_-abc-_-', '_-');
	 * // => '-_-abc'
	 */
	function trimEnd(string, chars, guard) {
	  string = toString(string);
	  if (string && (guard || chars === undefined)) {
	    return string.replace(reTrimEnd, '');
	  }
	  if (!string || !(chars = baseToString(chars))) {
	    return string;
	  }
	  var strSymbols = stringToArray(string),
	      end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

	  return castSlice(strSymbols, 0, end).join('');
	}

	/** Used to match leading and trailing whitespace. */
	var reTrimStart$1 = /^\s+/;

	/**
	 * Removes leading whitespace or specified characters from `string`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category String
	 * @param {string} [string=''] The string to trim.
	 * @param {string} [chars=whitespace] The characters to trim.
	 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	 * @returns {string} Returns the trimmed string.
	 * @example
	 *
	 * _.trimStart('  abc  ');
	 * // => 'abc  '
	 *
	 * _.trimStart('-_-abc-_-', '_-');
	 * // => 'abc-_-'
	 */
	function trimStart(string, chars, guard) {
	  string = toString(string);
	  if (string && (guard || chars === undefined)) {
	    return string.replace(reTrimStart$1, '');
	  }
	  if (!string || !(chars = baseToString(chars))) {
	    return string;
	  }
	  var strSymbols = stringToArray(string),
	      start = charsStartIndex(strSymbols, stringToArray(chars));

	  return castSlice(strSymbols, start).join('');
	}

	/** Used as default options for `_.truncate`. */
	var DEFAULT_TRUNC_LENGTH = 30,
	    DEFAULT_TRUNC_OMISSION = '...';

	/** Used to match `RegExp` flags from their coerced string values. */
	var reFlags$1 = /\w*$/;

	/**
	 * Truncates `string` if it's longer than the given maximum string length.
	 * The last characters of the truncated string are replaced with the omission
	 * string which defaults to "...".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category String
	 * @param {string} [string=''] The string to truncate.
	 * @param {Object} [options={}] The options object.
	 * @param {number} [options.length=30] The maximum string length.
	 * @param {string} [options.omission='...'] The string to indicate text is omitted.
	 * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
	 * @returns {string} Returns the truncated string.
	 * @example
	 *
	 * _.truncate('hi-diddly-ho there, neighborino');
	 * // => 'hi-diddly-ho there, neighbo...'
	 *
	 * _.truncate('hi-diddly-ho there, neighborino', {
	 *   'length': 24,
	 *   'separator': ' '
	 * });
	 * // => 'hi-diddly-ho there,...'
	 *
	 * _.truncate('hi-diddly-ho there, neighborino', {
	 *   'length': 24,
	 *   'separator': /,? +/
	 * });
	 * // => 'hi-diddly-ho there...'
	 *
	 * _.truncate('hi-diddly-ho there, neighborino', {
	 *   'omission': ' [...]'
	 * });
	 * // => 'hi-diddly-ho there, neig [...]'
	 */
	function truncate(string, options) {
	  var length = DEFAULT_TRUNC_LENGTH,
	      omission = DEFAULT_TRUNC_OMISSION;

	  if (isObject(options)) {
	    var separator = 'separator' in options ? options.separator : separator;
	    length = 'length' in options ? toInteger(options.length) : length;
	    omission = 'omission' in options ? baseToString(options.omission) : omission;
	  }
	  string = toString(string);

	  var strLength = string.length;
	  if (hasUnicode(string)) {
	    var strSymbols = stringToArray(string);
	    strLength = strSymbols.length;
	  }
	  if (length >= strLength) {
	    return string;
	  }
	  var end = length - stringSize(omission);
	  if (end < 1) {
	    return omission;
	  }
	  var result = strSymbols
	    ? castSlice(strSymbols, 0, end).join('')
	    : string.slice(0, end);

	  if (separator === undefined) {
	    return result + omission;
	  }
	  if (strSymbols) {
	    end += (result.length - end);
	  }
	  if (isRegExp(separator)) {
	    if (string.slice(end).search(separator)) {
	      var match,
	          substring = result;

	      if (!separator.global) {
	        separator = RegExp(separator.source, toString(reFlags$1.exec(separator)) + 'g');
	      }
	      separator.lastIndex = 0;
	      while ((match = separator.exec(substring))) {
	        var newEnd = match.index;
	      }
	      result = result.slice(0, newEnd === undefined ? end : newEnd);
	    }
	  } else if (string.indexOf(baseToString(separator), end) != end) {
	    var index = result.lastIndexOf(separator);
	    if (index > -1) {
	      result = result.slice(0, index);
	    }
	  }
	  return result + omission;
	}

	/**
	 * Creates a function that accepts up to one argument, ignoring any
	 * additional arguments.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Function
	 * @param {Function} func The function to cap arguments for.
	 * @returns {Function} Returns the new capped function.
	 * @example
	 *
	 * _.map(['6', '8', '10'], _.unary(parseInt));
	 * // => [6, 8, 10]
	 */
	function unary(func) {
	  return ary(func, 1);
	}

	/** Used to map HTML entities to characters. */
	var htmlUnescapes = {
	  '&amp;': '&',
	  '&lt;': '<',
	  '&gt;': '>',
	  '&quot;': '"',
	  '&#39;': "'"
	};

	/**
	 * Used by `_.unescape` to convert HTML entities to characters.
	 *
	 * @private
	 * @param {string} chr The matched character to unescape.
	 * @returns {string} Returns the unescaped character.
	 */
	var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

	/** Used to match HTML entities and HTML characters. */
	var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
	    reHasEscapedHtml = RegExp(reEscapedHtml.source);

	/**
	 * The inverse of `_.escape`; this method converts the HTML entities
	 * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
	 * their corresponding characters.
	 *
	 * **Note:** No other HTML entities are unescaped. To unescape additional
	 * HTML entities use a third-party library like [_he_](https://mths.be/he).
	 *
	 * @static
	 * @memberOf _
	 * @since 0.6.0
	 * @category String
	 * @param {string} [string=''] The string to unescape.
	 * @returns {string} Returns the unescaped string.
	 * @example
	 *
	 * _.unescape('fred, barney, &amp; pebbles');
	 * // => 'fred, barney, & pebbles'
	 */
	function unescape(string) {
	  string = toString(string);
	  return (string && reHasEscapedHtml.test(string))
	    ? string.replace(reEscapedHtml, unescapeHtmlChar)
	    : string;
	}

	/** Used as references for various `Number` constants. */
	var INFINITY$5 = 1 / 0;

	/**
	 * Creates a set object of `values`.
	 *
	 * @private
	 * @param {Array} values The values to add to the set.
	 * @returns {Object} Returns the new set.
	 */
	var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY$5) ? noop : function(values) {
	  return new Set(values);
	};

	/** Used as the size to enable large array optimizations. */
	var LARGE_ARRAY_SIZE$2 = 200;

	/**
	 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
	 *
	 * @private
	 * @param {Array} array The array to inspect.
	 * @param {Function} [iteratee] The iteratee invoked per element.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new duplicate free array.
	 */
	function baseUniq(array, iteratee, comparator) {
	  var index = -1,
	      includes = arrayIncludes,
	      length = array.length,
	      isCommon = true,
	      result = [],
	      seen = result;

	  if (comparator) {
	    isCommon = false;
	    includes = arrayIncludesWith;
	  }
	  else if (length >= LARGE_ARRAY_SIZE$2) {
	    var set = iteratee ? null : createSet(array);
	    if (set) {
	      return setToArray(set);
	    }
	    isCommon = false;
	    includes = cacheHas;
	    seen = new SetCache;
	  }
	  else {
	    seen = iteratee ? [] : result;
	  }
	  outer:
	  while (++index < length) {
	    var value = array[index],
	        computed = iteratee ? iteratee(value) : value;

	    value = (comparator || value !== 0) ? value : 0;
	    if (isCommon && computed === computed) {
	      var seenIndex = seen.length;
	      while (seenIndex--) {
	        if (seen[seenIndex] === computed) {
	          continue outer;
	        }
	      }
	      if (iteratee) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	    else if (!includes(seen, computed, comparator)) {
	      if (seen !== result) {
	        seen.push(computed);
	      }
	      result.push(value);
	    }
	  }
	  return result;
	}

	/**
	 * Creates an array of unique values, in order, from all given arrays using
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {...Array} [arrays] The arrays to inspect.
	 * @returns {Array} Returns the new array of combined values.
	 * @example
	 *
	 * _.union([2], [1, 2]);
	 * // => [2, 1]
	 */
	var union = baseRest(function(arrays) {
	  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
	});

	/**
	 * This method is like `_.union` except that it accepts `iteratee` which is
	 * invoked for each element of each `arrays` to generate the criterion by
	 * which uniqueness is computed. Result values are chosen from the first
	 * array in which the value occurs. The iteratee is invoked with one argument:
	 * (value).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Array
	 * @param {...Array} [arrays] The arrays to inspect.
	 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	 * @returns {Array} Returns the new array of combined values.
	 * @example
	 *
	 * _.unionBy([2.1], [1.2, 2.3], Math.floor);
	 * // => [2.1, 1.2]
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	 * // => [{ 'x': 1 }, { 'x': 2 }]
	 */
	var unionBy = baseRest(function(arrays) {
	  var iteratee = last(arrays);
	  if (isArrayLikeObject(iteratee)) {
	    iteratee = undefined;
	  }
	  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), baseIteratee(iteratee));
	});

	/**
	 * This method is like `_.union` except that it accepts `comparator` which
	 * is invoked to compare elements of `arrays`. Result values are chosen from
	 * the first array in which the value occurs. The comparator is invoked
	 * with two arguments: (arrVal, othVal).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Array
	 * @param {...Array} [arrays] The arrays to inspect.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new array of combined values.
	 * @example
	 *
	 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	 * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	 *
	 * _.unionWith(objects, others, _.isEqual);
	 * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
	 */
	var unionWith = baseRest(function(arrays) {
	  var comparator = last(arrays);
	  comparator = typeof comparator == 'function' ? comparator : undefined;
	  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
	});

	/**
	 * Creates a duplicate-free version of an array, using
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons, in which only the first occurrence of each element
	 * is kept. The order of result values is determined by the order they occur
	 * in the array.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @returns {Array} Returns the new duplicate free array.
	 * @example
	 *
	 * _.uniq([2, 1, 2]);
	 * // => [2, 1]
	 */
	function uniq(array) {
	  return (array && array.length) ? baseUniq(array) : [];
	}

	/**
	 * This method is like `_.uniq` except that it accepts `iteratee` which is
	 * invoked for each element in `array` to generate the criterion by which
	 * uniqueness is computed. The order of result values is determined by the
	 * order they occur in the array. The iteratee is invoked with one argument:
	 * (value).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	 * @returns {Array} Returns the new duplicate free array.
	 * @example
	 *
	 * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
	 * // => [2.1, 1.2]
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
	 * // => [{ 'x': 1 }, { 'x': 2 }]
	 */
	function uniqBy(array, iteratee) {
	  return (array && array.length) ? baseUniq(array, baseIteratee(iteratee)) : [];
	}

	/**
	 * This method is like `_.uniq` except that it accepts `comparator` which
	 * is invoked to compare elements of `array`. The order of result values is
	 * determined by the order they occur in the array.The comparator is invoked
	 * with two arguments: (arrVal, othVal).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new duplicate free array.
	 * @example
	 *
	 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
	 *
	 * _.uniqWith(objects, _.isEqual);
	 * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
	 */
	function uniqWith(array, comparator) {
	  comparator = typeof comparator == 'function' ? comparator : undefined;
	  return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
	}

	/** Used to generate unique IDs. */
	var idCounter = 0;

	/**
	 * Generates a unique ID. If `prefix` is given, the ID is appended to it.
	 *
	 * @static
	 * @since 0.1.0
	 * @memberOf _
	 * @category Util
	 * @param {string} [prefix=''] The value to prefix the ID with.
	 * @returns {string} Returns the unique ID.
	 * @example
	 *
	 * _.uniqueId('contact_');
	 * // => 'contact_104'
	 *
	 * _.uniqueId();
	 * // => '105'
	 */
	function uniqueId(prefix) {
	  var id = ++idCounter;
	  return toString(prefix) + id;
	}

	/**
	 * Removes the property at `path` of `object`.
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Object
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The path of the property to unset.
	 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 7 } }] };
	 * _.unset(object, 'a[0].b.c');
	 * // => true
	 *
	 * console.log(object);
	 * // => { 'a': [{ 'b': {} }] };
	 *
	 * _.unset(object, ['a', '0', 'b', 'c']);
	 * // => true
	 *
	 * console.log(object);
	 * // => { 'a': [{ 'b': {} }] };
	 */
	function unset(object, path) {
	  return object == null ? true : baseUnset(object, path);
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax$e = Math.max;

	/**
	 * This method is like `_.zip` except that it accepts an array of grouped
	 * elements and creates an array regrouping the elements to their pre-zip
	 * configuration.
	 *
	 * @static
	 * @memberOf _
	 * @since 1.2.0
	 * @category Array
	 * @param {Array} array The array of grouped elements to process.
	 * @returns {Array} Returns the new array of regrouped elements.
	 * @example
	 *
	 * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
	 * // => [['a', 1, true], ['b', 2, false]]
	 *
	 * _.unzip(zipped);
	 * // => [['a', 'b'], [1, 2], [true, false]]
	 */
	function unzip(array) {
	  if (!(array && array.length)) {
	    return [];
	  }
	  var length = 0;
	  array = arrayFilter(array, function(group) {
	    if (isArrayLikeObject(group)) {
	      length = nativeMax$e(group.length, length);
	      return true;
	    }
	  });
	  return baseTimes(length, function(index) {
	    return arrayMap(array, baseProperty(index));
	  });
	}

	/**
	 * This method is like `_.unzip` except that it accepts `iteratee` to specify
	 * how regrouped values should be combined. The iteratee is invoked with the
	 * elements of each group: (...group).
	 *
	 * @static
	 * @memberOf _
	 * @since 3.8.0
	 * @category Array
	 * @param {Array} array The array of grouped elements to process.
	 * @param {Function} [iteratee=_.identity] The function to combine
	 *  regrouped values.
	 * @returns {Array} Returns the new array of regrouped elements.
	 * @example
	 *
	 * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
	 * // => [[1, 10, 100], [2, 20, 200]]
	 *
	 * _.unzipWith(zipped, _.add);
	 * // => [3, 30, 300]
	 */
	function unzipWith(array, iteratee) {
	  if (!(array && array.length)) {
	    return [];
	  }
	  var result = unzip(array);
	  if (iteratee == null) {
	    return result;
	  }
	  return arrayMap(result, function(group) {
	    return apply(iteratee, undefined, group);
	  });
	}

	/**
	 * The base implementation of `_.update`.
	 *
	 * @private
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The path of the property to update.
	 * @param {Function} updater The function to produce the updated value.
	 * @param {Function} [customizer] The function to customize path creation.
	 * @returns {Object} Returns `object`.
	 */
	function baseUpdate(object, path, updater, customizer) {
	  return baseSet(object, path, updater(baseGet(object, path)), customizer);
	}

	/**
	 * This method is like `_.set` except that accepts `updater` to produce the
	 * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
	 * is invoked with one argument: (value).
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.6.0
	 * @category Object
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The path of the property to set.
	 * @param {Function} updater The function to produce the updated value.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	 *
	 * _.update(object, 'a[0].b.c', function(n) { return n * n; });
	 * console.log(object.a[0].b.c);
	 * // => 9
	 *
	 * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
	 * console.log(object.x[0].y.z);
	 * // => 0
	 */
	function update(object, path, updater) {
	  return object == null ? object : baseUpdate(object, path, castFunction(updater));
	}

	/**
	 * This method is like `_.update` except that it accepts `customizer` which is
	 * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
	 * path creation is handled by the method instead. The `customizer` is invoked
	 * with three arguments: (nsValue, key, nsObject).
	 *
	 * **Note:** This method mutates `object`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.6.0
	 * @category Object
	 * @param {Object} object The object to modify.
	 * @param {Array|string} path The path of the property to set.
	 * @param {Function} updater The function to produce the updated value.
	 * @param {Function} [customizer] The function to customize assigned values.
	 * @returns {Object} Returns `object`.
	 * @example
	 *
	 * var object = {};
	 *
	 * _.updateWith(object, '[0][1]', _.constant('a'), Object);
	 * // => { '0': { '1': 'a' } }
	 */
	function updateWith(object, path, updater, customizer) {
	  customizer = typeof customizer == 'function' ? customizer : undefined;
	  return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
	}

	/**
	 * Converts `string`, as space separated words, to upper case.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category String
	 * @param {string} [string=''] The string to convert.
	 * @returns {string} Returns the upper cased string.
	 * @example
	 *
	 * _.upperCase('--foo-bar');
	 * // => 'FOO BAR'
	 *
	 * _.upperCase('fooBar');
	 * // => 'FOO BAR'
	 *
	 * _.upperCase('__foo_bar__');
	 * // => 'FOO BAR'
	 */
	var upperCase = createCompounder(function(result, word, index) {
	  return result + (index ? ' ' : '') + word.toUpperCase();
	});

	/**
	 * Creates an array of the own and inherited enumerable string keyed property
	 * values of `object`.
	 *
	 * **Note:** Non-object values are coerced to objects.
	 *
	 * @static
	 * @memberOf _
	 * @since 3.0.0
	 * @category Object
	 * @param {Object} object The object to query.
	 * @returns {Array} Returns the array of property values.
	 * @example
	 *
	 * function Foo() {
	 *   this.a = 1;
	 *   this.b = 2;
	 * }
	 *
	 * Foo.prototype.c = 3;
	 *
	 * _.valuesIn(new Foo);
	 * // => [1, 2, 3] (iteration order is not guaranteed)
	 */
	function valuesIn(object) {
	  return object == null ? [] : baseValues(object, keysIn$1(object));
	}

	/**
	 * Creates an array excluding all given values using
	 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	 * for equality comparisons.
	 *
	 * **Note:** Unlike `_.pull`, this method returns a new array.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to inspect.
	 * @param {...*} [values] The values to exclude.
	 * @returns {Array} Returns the new array of filtered values.
	 * @see _.difference, _.xor
	 * @example
	 *
	 * _.without([2, 1, 2, 3], 1, 2);
	 * // => [3]
	 */
	var without = baseRest(function(array, values) {
	  return isArrayLikeObject(array)
	    ? baseDifference(array, values)
	    : [];
	});

	/**
	 * Creates a function that provides `value` to `wrapper` as its first
	 * argument. Any additional arguments provided to the function are appended
	 * to those provided to the `wrapper`. The wrapper is invoked with the `this`
	 * binding of the created function.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Function
	 * @param {*} value The value to wrap.
	 * @param {Function} [wrapper=identity] The wrapper function.
	 * @returns {Function} Returns the new function.
	 * @example
	 *
	 * var p = _.wrap(_.escape, function(func, text) {
	 *   return '<p>' + func(text) + '</p>';
	 * });
	 *
	 * p('fred, barney, & pebbles');
	 * // => '<p>fred, barney, &amp; pebbles</p>'
	 */
	function wrap(value, wrapper) {
	  return partial(castFunction(wrapper), value);
	}

	/**
	 * This method is the wrapper version of `_.at`.
	 *
	 * @name at
	 * @memberOf _
	 * @since 1.0.0
	 * @category Seq
	 * @param {...(string|string[])} [paths] The property paths to pick.
	 * @returns {Object} Returns the new `lodash` wrapper instance.
	 * @example
	 *
	 * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
	 *
	 * _(object).at(['a[0].b.c', 'a[1]']).value();
	 * // => [3, 4]
	 */
	var wrapperAt = flatRest(function(paths) {
	  var length = paths.length,
	      start = length ? paths[0] : 0,
	      value = this.__wrapped__,
	      interceptor = function(object) { return baseAt(object, paths); };

	  if (length > 1 || this.__actions__.length ||
	      !(value instanceof LazyWrapper) || !isIndex(start)) {
	    return this.thru(interceptor);
	  }
	  value = value.slice(start, +start + (length ? 1 : 0));
	  value.__actions__.push({
	    'func': thru,
	    'args': [interceptor],
	    'thisArg': undefined
	  });
	  return new LodashWrapper(value, this.__chain__).thru(function(array) {
	    if (length && !array.length) {
	      array.push(undefined);
	    }
	    return array;
	  });
	});

	/**
	 * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
	 *
	 * @name chain
	 * @memberOf _
	 * @since 0.1.0
	 * @category Seq
	 * @returns {Object} Returns the new `lodash` wrapper instance.
	 * @example
	 *
	 * var users = [
	 *   { 'user': 'barney', 'age': 36 },
	 *   { 'user': 'fred',   'age': 40 }
	 * ];
	 *
	 * // A sequence without explicit chaining.
	 * _(users).head();
	 * // => { 'user': 'barney', 'age': 36 }
	 *
	 * // A sequence with explicit chaining.
	 * _(users)
	 *   .chain()
	 *   .head()
	 *   .pick('user')
	 *   .value();
	 * // => { 'user': 'barney' }
	 */
	function wrapperChain() {
	  return chain(this);
	}

	/**
	 * This method is the wrapper version of `_.reverse`.
	 *
	 * **Note:** This method mutates the wrapped array.
	 *
	 * @name reverse
	 * @memberOf _
	 * @since 0.1.0
	 * @category Seq
	 * @returns {Object} Returns the new `lodash` wrapper instance.
	 * @example
	 *
	 * var array = [1, 2, 3];
	 *
	 * _(array).reverse().value()
	 * // => [3, 2, 1]
	 *
	 * console.log(array);
	 * // => [3, 2, 1]
	 */
	function wrapperReverse() {
	  var value = this.__wrapped__;
	  if (value instanceof LazyWrapper) {
	    var wrapped = value;
	    if (this.__actions__.length) {
	      wrapped = new LazyWrapper(this);
	    }
	    wrapped = wrapped.reverse();
	    wrapped.__actions__.push({
	      'func': thru,
	      'args': [reverse],
	      'thisArg': undefined
	    });
	    return new LodashWrapper(wrapped, this.__chain__);
	  }
	  return this.thru(reverse);
	}

	/**
	 * The base implementation of methods like `_.xor`, without support for
	 * iteratee shorthands, that accepts an array of arrays to inspect.
	 *
	 * @private
	 * @param {Array} arrays The arrays to inspect.
	 * @param {Function} [iteratee] The iteratee invoked per element.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new array of values.
	 */
	function baseXor(arrays, iteratee, comparator) {
	  var length = arrays.length;
	  if (length < 2) {
	    return length ? baseUniq(arrays[0]) : [];
	  }
	  var index = -1,
	      result = Array(length);

	  while (++index < length) {
	    var array = arrays[index],
	        othIndex = -1;

	    while (++othIndex < length) {
	      if (othIndex != index) {
	        result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
	      }
	    }
	  }
	  return baseUniq(baseFlatten(result, 1), iteratee, comparator);
	}

	/**
	 * Creates an array of unique values that is the
	 * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
	 * of the given arrays. The order of result values is determined by the order
	 * they occur in the arrays.
	 *
	 * @static
	 * @memberOf _
	 * @since 2.4.0
	 * @category Array
	 * @param {...Array} [arrays] The arrays to inspect.
	 * @returns {Array} Returns the new array of filtered values.
	 * @see _.difference, _.without
	 * @example
	 *
	 * _.xor([2, 1], [2, 3]);
	 * // => [1, 3]
	 */
	var xor = baseRest(function(arrays) {
	  return baseXor(arrayFilter(arrays, isArrayLikeObject));
	});

	/**
	 * This method is like `_.xor` except that it accepts `iteratee` which is
	 * invoked for each element of each `arrays` to generate the criterion by
	 * which by which they're compared. The order of result values is determined
	 * by the order they occur in the arrays. The iteratee is invoked with one
	 * argument: (value).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Array
	 * @param {...Array} [arrays] The arrays to inspect.
	 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	 * @returns {Array} Returns the new array of filtered values.
	 * @example
	 *
	 * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	 * // => [1.2, 3.4]
	 *
	 * // The `_.property` iteratee shorthand.
	 * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	 * // => [{ 'x': 2 }]
	 */
	var xorBy = baseRest(function(arrays) {
	  var iteratee = last(arrays);
	  if (isArrayLikeObject(iteratee)) {
	    iteratee = undefined;
	  }
	  return baseXor(arrayFilter(arrays, isArrayLikeObject), baseIteratee(iteratee));
	});

	/**
	 * This method is like `_.xor` except that it accepts `comparator` which is
	 * invoked to compare elements of `arrays`. The order of result values is
	 * determined by the order they occur in the arrays. The comparator is invoked
	 * with two arguments: (arrVal, othVal).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Array
	 * @param {...Array} [arrays] The arrays to inspect.
	 * @param {Function} [comparator] The comparator invoked per element.
	 * @returns {Array} Returns the new array of filtered values.
	 * @example
	 *
	 * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	 * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	 *
	 * _.xorWith(objects, others, _.isEqual);
	 * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
	 */
	var xorWith = baseRest(function(arrays) {
	  var comparator = last(arrays);
	  comparator = typeof comparator == 'function' ? comparator : undefined;
	  return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
	});

	/**
	 * Creates an array of grouped elements, the first of which contains the
	 * first elements of the given arrays, the second of which contains the
	 * second elements of the given arrays, and so on.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {...Array} [arrays] The arrays to process.
	 * @returns {Array} Returns the new array of grouped elements.
	 * @example
	 *
	 * _.zip(['a', 'b'], [1, 2], [true, false]);
	 * // => [['a', 1, true], ['b', 2, false]]
	 */
	var zip = baseRest(unzip);

	/**
	 * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
	 *
	 * @private
	 * @param {Array} props The property identifiers.
	 * @param {Array} values The property values.
	 * @param {Function} assignFunc The function to assign values.
	 * @returns {Object} Returns the new object.
	 */
	function baseZipObject(props, values, assignFunc) {
	  var index = -1,
	      length = props.length,
	      valsLength = values.length,
	      result = {};

	  while (++index < length) {
	    var value = index < valsLength ? values[index] : undefined;
	    assignFunc(result, props[index], value);
	  }
	  return result;
	}

	/**
	 * This method is like `_.fromPairs` except that it accepts two arrays,
	 * one of property identifiers and one of corresponding values.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.4.0
	 * @category Array
	 * @param {Array} [props=[]] The property identifiers.
	 * @param {Array} [values=[]] The property values.
	 * @returns {Object} Returns the new object.
	 * @example
	 *
	 * _.zipObject(['a', 'b'], [1, 2]);
	 * // => { 'a': 1, 'b': 2 }
	 */
	function zipObject(props, values) {
	  return baseZipObject(props || [], values || [], assignValue);
	}

	/**
	 * This method is like `_.zipObject` except that it supports property paths.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.1.0
	 * @category Array
	 * @param {Array} [props=[]] The property identifiers.
	 * @param {Array} [values=[]] The property values.
	 * @returns {Object} Returns the new object.
	 * @example
	 *
	 * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
	 * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
	 */
	function zipObjectDeep(props, values) {
	  return baseZipObject(props || [], values || [], baseSet);
	}

	/**
	 * This method is like `_.zip` except that it accepts `iteratee` to specify
	 * how grouped values should be combined. The iteratee is invoked with the
	 * elements of each group: (...group).
	 *
	 * @static
	 * @memberOf _
	 * @since 3.8.0
	 * @category Array
	 * @param {...Array} [arrays] The arrays to process.
	 * @param {Function} [iteratee=_.identity] The function to combine
	 *  grouped values.
	 * @returns {Array} Returns the new array of grouped elements.
	 * @example
	 *
	 * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
	 *   return a + b + c;
	 * });
	 * // => [111, 222]
	 */
	var zipWith = baseRest(function(arrays) {
	  var length = arrays.length,
	      iteratee = length > 1 ? arrays[length - 1] : undefined;

	  iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
	  return unzipWith(arrays, iteratee);
	});

	var array = {
	  chunk, compact, concat, difference, differenceBy,
	  differenceWith, drop, dropRight, dropRightWhile, dropWhile,
	  fill, findIndex, findLastIndex, first: head, flatten: flatten$1,
	  flattenDeep, flattenDepth, fromPairs, head, indexOf,
	  initial, intersection, intersectionBy, intersectionWith, join,
	  last, lastIndexOf, nth, pull, pullAll,
	  pullAllBy, pullAllWith, pullAt, remove, reverse,
	  slice, sortedIndex, sortedIndexBy, sortedIndexOf, sortedLastIndex,
	  sortedLastIndexBy, sortedLastIndexOf, sortedUniq, sortedUniqBy, tail,
	  take, takeRight, takeRightWhile, takeWhile, union,
	  unionBy, unionWith, uniq, uniqBy, uniqWith,
	  unzip, unzipWith, without, xor, xorBy,
	  xorWith, zip, zipObject, zipObjectDeep, zipWith
	};

	var collection = {
	  countBy, each: forEach, eachRight: forEachRight, every, filter,
	  find, findLast, flatMap, flatMapDeep, flatMapDepth,
	  forEach, forEachRight, groupBy, includes, invokeMap,
	  keyBy, map, orderBy, partition, reduce,
	  reduceRight, reject, sample, sampleSize, shuffle,
	  size, some, sortBy
	};

	var date = {
	  now
	};

	var func = {
	  after, ary, before, bind, bindKey,
	  curry, curryRight, debounce, defer, delay,
	  flip, memoize, negate, once, overArgs,
	  partial, partialRight, rearg, rest, spread,
	  throttle, unary, wrap
	};

	var lang = {
	  castArray, clone, cloneDeep, cloneDeepWith, cloneWith,
	  conformsTo, eq, gt, gte, isArguments,
	  isArray, isArrayBuffer, isArrayLike, isArrayLikeObject, isBoolean,
	  isBuffer, isDate, isElement, isEmpty, isEqual,
	  isEqualWith, isError, isFinite: isFinite$1, isFunction, isInteger,
	  isLength, isMap, isMatch, isMatchWith, isNaN: isNaN$1,
	  isNative, isNil, isNull, isNumber, isObject,
	  isObjectLike, isPlainObject, isRegExp, isSafeInteger, isSet,
	  isString, isSymbol, isTypedArray, isUndefined, isWeakMap,
	  isWeakSet, lt, lte, toArray, toFinite,
	  toInteger, toLength, toNumber, toPlainObject, toSafeInteger,
	  toString
	};

	var math = {
	  add, ceil, divide, floor, max,
	  maxBy, mean, meanBy, min, minBy,
	  multiply, round, subtract, sum, sumBy
	};

	var number = {
	  clamp, inRange, random
	};

	var object = {
	  assign, assignIn, assignInWith, assignWith, at,
	  create, defaults, defaultsDeep, entries: toPairs, entriesIn: toPairsIn,
	  extend: assignIn, extendWith: assignInWith, findKey, findLastKey, forIn,
	  forInRight, forOwn, forOwnRight, functions, functionsIn,
	  get, has, hasIn, invert, invertBy,
	  invoke, keys, keysIn: keysIn$1, mapKeys, mapValues,
	  merge, mergeWith, omit, omitBy, pick,
	  pickBy, result, set, setWith, toPairs,
	  toPairsIn, transform, unset, update, updateWith,
	  values, valuesIn
	};

	var seq = {
	  at: wrapperAt, chain, commit: wrapperCommit, lodash, next: wrapperNext,
	  plant: wrapperPlant, reverse: wrapperReverse, tap, thru, toIterator: wrapperToIterator,
	  toJSON: wrapperValue, value: wrapperValue, valueOf: wrapperValue, wrapperChain
	};

	var string = {
	  camelCase, capitalize, deburr, endsWith, escape: escape$1,
	  escapeRegExp, kebabCase, lowerCase, lowerFirst, pad,
	  padEnd, padStart, parseInt: parseInt$1, repeat, replace,
	  snakeCase, split, startCase, startsWith, template,
	  templateSettings, toLower, toUpper, trim, trimEnd,
	  trimStart, truncate, unescape, upperCase, upperFirst,
	  words
	};

	var util = {
	  attempt, bindAll, cond, conforms, constant,
	  defaultTo, flow, flowRight, identity, iteratee,
	  matches, matchesProperty, method, methodOf, mixin,
	  noop, nthArg, over, overEvery, overSome,
	  property, propertyOf, range, rangeRight, stubArray,
	  stubFalse, stubObject, stubString, stubTrue, times,
	  toPath, uniqueId
	};

	/**
	 * Creates a clone of the lazy wrapper object.
	 *
	 * @private
	 * @name clone
	 * @memberOf LazyWrapper
	 * @returns {Object} Returns the cloned `LazyWrapper` object.
	 */
	function lazyClone() {
	  var result = new LazyWrapper(this.__wrapped__);
	  result.__actions__ = copyArray$1(this.__actions__);
	  result.__dir__ = this.__dir__;
	  result.__filtered__ = this.__filtered__;
	  result.__iteratees__ = copyArray$1(this.__iteratees__);
	  result.__takeCount__ = this.__takeCount__;
	  result.__views__ = copyArray$1(this.__views__);
	  return result;
	}

	/**
	 * Reverses the direction of lazy iteration.
	 *
	 * @private
	 * @name reverse
	 * @memberOf LazyWrapper
	 * @returns {Object} Returns the new reversed `LazyWrapper` object.
	 */
	function lazyReverse() {
	  if (this.__filtered__) {
	    var result = new LazyWrapper(this);
	    result.__dir__ = -1;
	    result.__filtered__ = true;
	  } else {
	    result = this.clone();
	    result.__dir__ *= -1;
	  }
	  return result;
	}

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax$f = Math.max,
	    nativeMin$c = Math.min;

	/**
	 * Gets the view, applying any `transforms` to the `start` and `end` positions.
	 *
	 * @private
	 * @param {number} start The start of the view.
	 * @param {number} end The end of the view.
	 * @param {Array} transforms The transformations to apply to the view.
	 * @returns {Object} Returns an object containing the `start` and `end`
	 *  positions of the view.
	 */
	function getView(start, end, transforms) {
	  var index = -1,
	      length = transforms.length;

	  while (++index < length) {
	    var data = transforms[index],
	        size = data.size;

	    switch (data.type) {
	      case 'drop':      start += size; break;
	      case 'dropRight': end -= size; break;
	      case 'take':      end = nativeMin$c(end, start + size); break;
	      case 'takeRight': start = nativeMax$f(start, end - size); break;
	    }
	  }
	  return { 'start': start, 'end': end };
	}

	/** Used to indicate the type of lazy iteratees. */
	var LAZY_FILTER_FLAG = 1,
	    LAZY_MAP_FLAG = 2;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMin$d = Math.min;

	/**
	 * Extracts the unwrapped value from its lazy wrapper.
	 *
	 * @private
	 * @name value
	 * @memberOf LazyWrapper
	 * @returns {*} Returns the unwrapped value.
	 */
	function lazyValue() {
	  var array = this.__wrapped__.value(),
	      dir = this.__dir__,
	      isArr = isArray(array),
	      isRight = dir < 0,
	      arrLength = isArr ? array.length : 0,
	      view = getView(0, arrLength, this.__views__),
	      start = view.start,
	      end = view.end,
	      length = end - start,
	      index = isRight ? end : (start - 1),
	      iteratees = this.__iteratees__,
	      iterLength = iteratees.length,
	      resIndex = 0,
	      takeCount = nativeMin$d(length, this.__takeCount__);

	  if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
	    return baseWrapperValue(array, this.__actions__);
	  }
	  var result = [];

	  outer:
	  while (length-- && resIndex < takeCount) {
	    index += dir;

	    var iterIndex = -1,
	        value = array[index];

	    while (++iterIndex < iterLength) {
	      var data = iteratees[iterIndex],
	          iteratee = data.iteratee,
	          type = data.type,
	          computed = iteratee(value);

	      if (type == LAZY_MAP_FLAG) {
	        value = computed;
	      } else if (!computed) {
	        if (type == LAZY_FILTER_FLAG) {
	          continue outer;
	        } else {
	          break outer;
	        }
	      }
	    }
	    result[resIndex++] = value;
	  }
	  return result;
	}

	/**
	 * @license
	 * Lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="es" -o ./`
	 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */

	/** Used as the semantic version number. */
	var VERSION = '4.17.15';

	/** Used to compose bitmasks for function metadata. */
	var WRAP_BIND_KEY_FLAG$6 = 2;

	/** Used to indicate the type of lazy iteratees. */
	var LAZY_FILTER_FLAG$1 = 1,
	    LAZY_WHILE_FLAG = 3;

	/** Used as references for the maximum length and index of an array. */
	var MAX_ARRAY_LENGTH$6 = 4294967295;

	/** Used for built-in method references. */
	var arrayProto$5 = Array.prototype,
	    objectProto$s = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty$o = objectProto$s.hasOwnProperty;

	/** Built-in value references. */
	var symIterator$1 = Symbol$1 ? Symbol$1.iterator : undefined;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeMax$g = Math.max,
	    nativeMin$e = Math.min;

	// wrap `_.mixin` so it works when provided only one argument
	var mixin$1 = (function(func) {
	  return function(object, source, options) {
	    if (options == null) {
	      var isObj = isObject(source),
	          props = isObj && keys(source),
	          methodNames = props && props.length && baseFunctions(source, props);

	      if (!(methodNames ? methodNames.length : isObj)) {
	        options = source;
	        source = object;
	        object = this;
	      }
	    }
	    return func(object, source, options);
	  };
	}(mixin));

	// Add methods that return wrapped values in chain sequences.
	lodash.after = func.after;
	lodash.ary = func.ary;
	lodash.assign = object.assign;
	lodash.assignIn = object.assignIn;
	lodash.assignInWith = object.assignInWith;
	lodash.assignWith = object.assignWith;
	lodash.at = object.at;
	lodash.before = func.before;
	lodash.bind = func.bind;
	lodash.bindAll = util.bindAll;
	lodash.bindKey = func.bindKey;
	lodash.castArray = lang.castArray;
	lodash.chain = seq.chain;
	lodash.chunk = array.chunk;
	lodash.compact = array.compact;
	lodash.concat = array.concat;
	lodash.cond = util.cond;
	lodash.conforms = util.conforms;
	lodash.constant = util.constant;
	lodash.countBy = collection.countBy;
	lodash.create = object.create;
	lodash.curry = func.curry;
	lodash.curryRight = func.curryRight;
	lodash.debounce = func.debounce;
	lodash.defaults = object.defaults;
	lodash.defaultsDeep = object.defaultsDeep;
	lodash.defer = func.defer;
	lodash.delay = func.delay;
	lodash.difference = array.difference;
	lodash.differenceBy = array.differenceBy;
	lodash.differenceWith = array.differenceWith;
	lodash.drop = array.drop;
	lodash.dropRight = array.dropRight;
	lodash.dropRightWhile = array.dropRightWhile;
	lodash.dropWhile = array.dropWhile;
	lodash.fill = array.fill;
	lodash.filter = collection.filter;
	lodash.flatMap = collection.flatMap;
	lodash.flatMapDeep = collection.flatMapDeep;
	lodash.flatMapDepth = collection.flatMapDepth;
	lodash.flatten = array.flatten;
	lodash.flattenDeep = array.flattenDeep;
	lodash.flattenDepth = array.flattenDepth;
	lodash.flip = func.flip;
	lodash.flow = util.flow;
	lodash.flowRight = util.flowRight;
	lodash.fromPairs = array.fromPairs;
	lodash.functions = object.functions;
	lodash.functionsIn = object.functionsIn;
	lodash.groupBy = collection.groupBy;
	lodash.initial = array.initial;
	lodash.intersection = array.intersection;
	lodash.intersectionBy = array.intersectionBy;
	lodash.intersectionWith = array.intersectionWith;
	lodash.invert = object.invert;
	lodash.invertBy = object.invertBy;
	lodash.invokeMap = collection.invokeMap;
	lodash.iteratee = util.iteratee;
	lodash.keyBy = collection.keyBy;
	lodash.keys = keys;
	lodash.keysIn = object.keysIn;
	lodash.map = collection.map;
	lodash.mapKeys = object.mapKeys;
	lodash.mapValues = object.mapValues;
	lodash.matches = util.matches;
	lodash.matchesProperty = util.matchesProperty;
	lodash.memoize = func.memoize;
	lodash.merge = object.merge;
	lodash.mergeWith = object.mergeWith;
	lodash.method = util.method;
	lodash.methodOf = util.methodOf;
	lodash.mixin = mixin$1;
	lodash.negate = negate;
	lodash.nthArg = util.nthArg;
	lodash.omit = object.omit;
	lodash.omitBy = object.omitBy;
	lodash.once = func.once;
	lodash.orderBy = collection.orderBy;
	lodash.over = util.over;
	lodash.overArgs = func.overArgs;
	lodash.overEvery = util.overEvery;
	lodash.overSome = util.overSome;
	lodash.partial = func.partial;
	lodash.partialRight = func.partialRight;
	lodash.partition = collection.partition;
	lodash.pick = object.pick;
	lodash.pickBy = object.pickBy;
	lodash.property = util.property;
	lodash.propertyOf = util.propertyOf;
	lodash.pull = array.pull;
	lodash.pullAll = array.pullAll;
	lodash.pullAllBy = array.pullAllBy;
	lodash.pullAllWith = array.pullAllWith;
	lodash.pullAt = array.pullAt;
	lodash.range = util.range;
	lodash.rangeRight = util.rangeRight;
	lodash.rearg = func.rearg;
	lodash.reject = collection.reject;
	lodash.remove = array.remove;
	lodash.rest = func.rest;
	lodash.reverse = array.reverse;
	lodash.sampleSize = collection.sampleSize;
	lodash.set = object.set;
	lodash.setWith = object.setWith;
	lodash.shuffle = collection.shuffle;
	lodash.slice = array.slice;
	lodash.sortBy = collection.sortBy;
	lodash.sortedUniq = array.sortedUniq;
	lodash.sortedUniqBy = array.sortedUniqBy;
	lodash.split = string.split;
	lodash.spread = func.spread;
	lodash.tail = array.tail;
	lodash.take = array.take;
	lodash.takeRight = array.takeRight;
	lodash.takeRightWhile = array.takeRightWhile;
	lodash.takeWhile = array.takeWhile;
	lodash.tap = seq.tap;
	lodash.throttle = func.throttle;
	lodash.thru = thru;
	lodash.toArray = lang.toArray;
	lodash.toPairs = object.toPairs;
	lodash.toPairsIn = object.toPairsIn;
	lodash.toPath = util.toPath;
	lodash.toPlainObject = lang.toPlainObject;
	lodash.transform = object.transform;
	lodash.unary = func.unary;
	lodash.union = array.union;
	lodash.unionBy = array.unionBy;
	lodash.unionWith = array.unionWith;
	lodash.uniq = array.uniq;
	lodash.uniqBy = array.uniqBy;
	lodash.uniqWith = array.uniqWith;
	lodash.unset = object.unset;
	lodash.unzip = array.unzip;
	lodash.unzipWith = array.unzipWith;
	lodash.update = object.update;
	lodash.updateWith = object.updateWith;
	lodash.values = object.values;
	lodash.valuesIn = object.valuesIn;
	lodash.without = array.without;
	lodash.words = string.words;
	lodash.wrap = func.wrap;
	lodash.xor = array.xor;
	lodash.xorBy = array.xorBy;
	lodash.xorWith = array.xorWith;
	lodash.zip = array.zip;
	lodash.zipObject = array.zipObject;
	lodash.zipObjectDeep = array.zipObjectDeep;
	lodash.zipWith = array.zipWith;

	// Add aliases.
	lodash.entries = object.toPairs;
	lodash.entriesIn = object.toPairsIn;
	lodash.extend = object.assignIn;
	lodash.extendWith = object.assignInWith;

	// Add methods to `lodash.prototype`.
	mixin$1(lodash, lodash);

	// Add methods that return unwrapped values in chain sequences.
	lodash.add = math.add;
	lodash.attempt = util.attempt;
	lodash.camelCase = string.camelCase;
	lodash.capitalize = string.capitalize;
	lodash.ceil = math.ceil;
	lodash.clamp = number.clamp;
	lodash.clone = lang.clone;
	lodash.cloneDeep = lang.cloneDeep;
	lodash.cloneDeepWith = lang.cloneDeepWith;
	lodash.cloneWith = lang.cloneWith;
	lodash.conformsTo = lang.conformsTo;
	lodash.deburr = string.deburr;
	lodash.defaultTo = util.defaultTo;
	lodash.divide = math.divide;
	lodash.endsWith = string.endsWith;
	lodash.eq = lang.eq;
	lodash.escape = string.escape;
	lodash.escapeRegExp = string.escapeRegExp;
	lodash.every = collection.every;
	lodash.find = collection.find;
	lodash.findIndex = array.findIndex;
	lodash.findKey = object.findKey;
	lodash.findLast = collection.findLast;
	lodash.findLastIndex = array.findLastIndex;
	lodash.findLastKey = object.findLastKey;
	lodash.floor = math.floor;
	lodash.forEach = collection.forEach;
	lodash.forEachRight = collection.forEachRight;
	lodash.forIn = object.forIn;
	lodash.forInRight = object.forInRight;
	lodash.forOwn = object.forOwn;
	lodash.forOwnRight = object.forOwnRight;
	lodash.get = object.get;
	lodash.gt = lang.gt;
	lodash.gte = lang.gte;
	lodash.has = object.has;
	lodash.hasIn = object.hasIn;
	lodash.head = array.head;
	lodash.identity = identity;
	lodash.includes = collection.includes;
	lodash.indexOf = array.indexOf;
	lodash.inRange = number.inRange;
	lodash.invoke = object.invoke;
	lodash.isArguments = lang.isArguments;
	lodash.isArray = isArray;
	lodash.isArrayBuffer = lang.isArrayBuffer;
	lodash.isArrayLike = lang.isArrayLike;
	lodash.isArrayLikeObject = lang.isArrayLikeObject;
	lodash.isBoolean = lang.isBoolean;
	lodash.isBuffer = lang.isBuffer;
	lodash.isDate = lang.isDate;
	lodash.isElement = lang.isElement;
	lodash.isEmpty = lang.isEmpty;
	lodash.isEqual = lang.isEqual;
	lodash.isEqualWith = lang.isEqualWith;
	lodash.isError = lang.isError;
	lodash.isFinite = lang.isFinite;
	lodash.isFunction = lang.isFunction;
	lodash.isInteger = lang.isInteger;
	lodash.isLength = lang.isLength;
	lodash.isMap = lang.isMap;
	lodash.isMatch = lang.isMatch;
	lodash.isMatchWith = lang.isMatchWith;
	lodash.isNaN = lang.isNaN;
	lodash.isNative = lang.isNative;
	lodash.isNil = lang.isNil;
	lodash.isNull = lang.isNull;
	lodash.isNumber = lang.isNumber;
	lodash.isObject = isObject;
	lodash.isObjectLike = lang.isObjectLike;
	lodash.isPlainObject = lang.isPlainObject;
	lodash.isRegExp = lang.isRegExp;
	lodash.isSafeInteger = lang.isSafeInteger;
	lodash.isSet = lang.isSet;
	lodash.isString = lang.isString;
	lodash.isSymbol = lang.isSymbol;
	lodash.isTypedArray = lang.isTypedArray;
	lodash.isUndefined = lang.isUndefined;
	lodash.isWeakMap = lang.isWeakMap;
	lodash.isWeakSet = lang.isWeakSet;
	lodash.join = array.join;
	lodash.kebabCase = string.kebabCase;
	lodash.last = last;
	lodash.lastIndexOf = array.lastIndexOf;
	lodash.lowerCase = string.lowerCase;
	lodash.lowerFirst = string.lowerFirst;
	lodash.lt = lang.lt;
	lodash.lte = lang.lte;
	lodash.max = math.max;
	lodash.maxBy = math.maxBy;
	lodash.mean = math.mean;
	lodash.meanBy = math.meanBy;
	lodash.min = math.min;
	lodash.minBy = math.minBy;
	lodash.stubArray = util.stubArray;
	lodash.stubFalse = util.stubFalse;
	lodash.stubObject = util.stubObject;
	lodash.stubString = util.stubString;
	lodash.stubTrue = util.stubTrue;
	lodash.multiply = math.multiply;
	lodash.nth = array.nth;
	lodash.noop = util.noop;
	lodash.now = date.now;
	lodash.pad = string.pad;
	lodash.padEnd = string.padEnd;
	lodash.padStart = string.padStart;
	lodash.parseInt = string.parseInt;
	lodash.random = number.random;
	lodash.reduce = collection.reduce;
	lodash.reduceRight = collection.reduceRight;
	lodash.repeat = string.repeat;
	lodash.replace = string.replace;
	lodash.result = object.result;
	lodash.round = math.round;
	lodash.sample = collection.sample;
	lodash.size = collection.size;
	lodash.snakeCase = string.snakeCase;
	lodash.some = collection.some;
	lodash.sortedIndex = array.sortedIndex;
	lodash.sortedIndexBy = array.sortedIndexBy;
	lodash.sortedIndexOf = array.sortedIndexOf;
	lodash.sortedLastIndex = array.sortedLastIndex;
	lodash.sortedLastIndexBy = array.sortedLastIndexBy;
	lodash.sortedLastIndexOf = array.sortedLastIndexOf;
	lodash.startCase = string.startCase;
	lodash.startsWith = string.startsWith;
	lodash.subtract = math.subtract;
	lodash.sum = math.sum;
	lodash.sumBy = math.sumBy;
	lodash.template = string.template;
	lodash.times = util.times;
	lodash.toFinite = lang.toFinite;
	lodash.toInteger = toInteger;
	lodash.toLength = lang.toLength;
	lodash.toLower = string.toLower;
	lodash.toNumber = lang.toNumber;
	lodash.toSafeInteger = lang.toSafeInteger;
	lodash.toString = lang.toString;
	lodash.toUpper = string.toUpper;
	lodash.trim = string.trim;
	lodash.trimEnd = string.trimEnd;
	lodash.trimStart = string.trimStart;
	lodash.truncate = string.truncate;
	lodash.unescape = string.unescape;
	lodash.uniqueId = util.uniqueId;
	lodash.upperCase = string.upperCase;
	lodash.upperFirst = string.upperFirst;

	// Add aliases.
	lodash.each = collection.forEach;
	lodash.eachRight = collection.forEachRight;
	lodash.first = array.head;

	mixin$1(lodash, (function() {
	  var source = {};
	  baseForOwn(lodash, function(func, methodName) {
	    if (!hasOwnProperty$o.call(lodash.prototype, methodName)) {
	      source[methodName] = func;
	    }
	  });
	  return source;
	}()), { 'chain': false });

	/**
	 * The semantic version number.
	 *
	 * @static
	 * @memberOf _
	 * @type {string}
	 */
	lodash.VERSION = VERSION;
	(lodash.templateSettings = string.templateSettings).imports._ = lodash;

	// Assign default placeholders.
	arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
	  lodash[methodName].placeholder = lodash;
	});

	// Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
	arrayEach(['drop', 'take'], function(methodName, index) {
	  LazyWrapper.prototype[methodName] = function(n) {
	    n = n === undefined ? 1 : nativeMax$g(toInteger(n), 0);

	    var result = (this.__filtered__ && !index)
	      ? new LazyWrapper(this)
	      : this.clone();

	    if (result.__filtered__) {
	      result.__takeCount__ = nativeMin$e(n, result.__takeCount__);
	    } else {
	      result.__views__.push({
	        'size': nativeMin$e(n, MAX_ARRAY_LENGTH$6),
	        'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
	      });
	    }
	    return result;
	  };

	  LazyWrapper.prototype[methodName + 'Right'] = function(n) {
	    return this.reverse()[methodName](n).reverse();
	  };
	});

	// Add `LazyWrapper` methods that accept an `iteratee` value.
	arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
	  var type = index + 1,
	      isFilter = type == LAZY_FILTER_FLAG$1 || type == LAZY_WHILE_FLAG;

	  LazyWrapper.prototype[methodName] = function(iteratee) {
	    var result = this.clone();
	    result.__iteratees__.push({
	      'iteratee': baseIteratee(iteratee),
	      'type': type
	    });
	    result.__filtered__ = result.__filtered__ || isFilter;
	    return result;
	  };
	});

	// Add `LazyWrapper` methods for `_.head` and `_.last`.
	arrayEach(['head', 'last'], function(methodName, index) {
	  var takeName = 'take' + (index ? 'Right' : '');

	  LazyWrapper.prototype[methodName] = function() {
	    return this[takeName](1).value()[0];
	  };
	});

	// Add `LazyWrapper` methods for `_.initial` and `_.tail`.
	arrayEach(['initial', 'tail'], function(methodName, index) {
	  var dropName = 'drop' + (index ? '' : 'Right');

	  LazyWrapper.prototype[methodName] = function() {
	    return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
	  };
	});

	LazyWrapper.prototype.compact = function() {
	  return this.filter(identity);
	};

	LazyWrapper.prototype.find = function(predicate) {
	  return this.filter(predicate).head();
	};

	LazyWrapper.prototype.findLast = function(predicate) {
	  return this.reverse().find(predicate);
	};

	LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
	  if (typeof path == 'function') {
	    return new LazyWrapper(this);
	  }
	  return this.map(function(value) {
	    return baseInvoke(value, path, args);
	  });
	});

	LazyWrapper.prototype.reject = function(predicate) {
	  return this.filter(negate(baseIteratee(predicate)));
	};

	LazyWrapper.prototype.slice = function(start, end) {
	  start = toInteger(start);

	  var result = this;
	  if (result.__filtered__ && (start > 0 || end < 0)) {
	    return new LazyWrapper(result);
	  }
	  if (start < 0) {
	    result = result.takeRight(-start);
	  } else if (start) {
	    result = result.drop(start);
	  }
	  if (end !== undefined) {
	    end = toInteger(end);
	    result = end < 0 ? result.dropRight(-end) : result.take(end - start);
	  }
	  return result;
	};

	LazyWrapper.prototype.takeRightWhile = function(predicate) {
	  return this.reverse().takeWhile(predicate).reverse();
	};

	LazyWrapper.prototype.toArray = function() {
	  return this.take(MAX_ARRAY_LENGTH$6);
	};

	// Add `LazyWrapper` methods to `lodash.prototype`.
	baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	  var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
	      isTaker = /^(?:head|last)$/.test(methodName),
	      lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
	      retUnwrapped = isTaker || /^find/.test(methodName);

	  if (!lodashFunc) {
	    return;
	  }
	  lodash.prototype[methodName] = function() {
	    var value = this.__wrapped__,
	        args = isTaker ? [1] : arguments,
	        isLazy = value instanceof LazyWrapper,
	        iteratee = args[0],
	        useLazy = isLazy || isArray(value);

	    var interceptor = function(value) {
	      var result = lodashFunc.apply(lodash, arrayPush([value], args));
	      return (isTaker && chainAll) ? result[0] : result;
	    };

	    if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
	      // Avoid lazy use if the iteratee has a "length" value other than `1`.
	      isLazy = useLazy = false;
	    }
	    var chainAll = this.__chain__,
	        isHybrid = !!this.__actions__.length,
	        isUnwrapped = retUnwrapped && !chainAll,
	        onlyLazy = isLazy && !isHybrid;

	    if (!retUnwrapped && useLazy) {
	      value = onlyLazy ? value : new LazyWrapper(this);
	      var result = func.apply(value, args);
	      result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
	      return new LodashWrapper(result, chainAll);
	    }
	    if (isUnwrapped && onlyLazy) {
	      return func.apply(this, args);
	    }
	    result = this.thru(interceptor);
	    return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
	  };
	});

	// Add `Array` methods to `lodash.prototype`.
	arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
	  var func = arrayProto$5[methodName],
	      chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
	      retUnwrapped = /^(?:pop|shift)$/.test(methodName);

	  lodash.prototype[methodName] = function() {
	    var args = arguments;
	    if (retUnwrapped && !this.__chain__) {
	      var value = this.value();
	      return func.apply(isArray(value) ? value : [], args);
	    }
	    return this[chainName](function(value) {
	      return func.apply(isArray(value) ? value : [], args);
	    });
	  };
	});

	// Map minified method names to their real names.
	baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	  var lodashFunc = lodash[methodName];
	  if (lodashFunc) {
	    var key = lodashFunc.name + '';
	    if (!hasOwnProperty$o.call(realNames, key)) {
	      realNames[key] = [];
	    }
	    realNames[key].push({ 'name': methodName, 'func': lodashFunc });
	  }
	});

	realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG$6).name] = [{
	  'name': 'wrapper',
	  'func': undefined
	}];

	// Add methods to `LazyWrapper`.
	LazyWrapper.prototype.clone = lazyClone;
	LazyWrapper.prototype.reverse = lazyReverse;
	LazyWrapper.prototype.value = lazyValue;

	// Add chain sequence methods to the `lodash` wrapper.
	lodash.prototype.at = seq.at;
	lodash.prototype.chain = seq.wrapperChain;
	lodash.prototype.commit = seq.commit;
	lodash.prototype.next = seq.next;
	lodash.prototype.plant = seq.plant;
	lodash.prototype.reverse = seq.reverse;
	lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = seq.value;

	// Add lazy aliases.
	lodash.prototype.first = lodash.prototype.head;

	if (symIterator$1) {
	  lodash.prototype[symIterator$1] = seq.toIterator;
	}

	/**
	 * @license
	 * Lodash (Custom Build) <https://lodash.com/>
	 * Build: `lodash modularize exports="es" -o ./`
	 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */

	var _ = /*#__PURE__*/Object.freeze({
		__proto__: null,
		add: add,
		after: after,
		ary: ary,
		assign: assign,
		assignIn: assignIn,
		assignInWith: assignInWith,
		assignWith: assignWith,
		at: at,
		attempt: attempt,
		before: before,
		bind: bind,
		bindAll: bindAll,
		bindKey: bindKey,
		camelCase: camelCase,
		capitalize: capitalize,
		castArray: castArray,
		ceil: ceil,
		chain: chain,
		chunk: chunk,
		clamp: clamp,
		clone: clone,
		cloneDeep: cloneDeep,
		cloneDeepWith: cloneDeepWith,
		cloneWith: cloneWith,
		commit: wrapperCommit,
		compact: compact,
		concat: concat,
		cond: cond,
		conforms: conforms,
		conformsTo: conformsTo,
		constant: constant,
		countBy: countBy,
		create: create,
		curry: curry,
		curryRight: curryRight,
		debounce: debounce,
		deburr: deburr,
		defaultTo: defaultTo,
		defaults: defaults,
		defaultsDeep: defaultsDeep,
		defer: defer,
		delay: delay,
		difference: difference,
		differenceBy: differenceBy,
		differenceWith: differenceWith,
		divide: divide,
		drop: drop,
		dropRight: dropRight,
		dropRightWhile: dropRightWhile,
		dropWhile: dropWhile,
		each: forEach,
		eachRight: forEachRight,
		endsWith: endsWith,
		entries: toPairs,
		entriesIn: toPairsIn,
		eq: eq,
		escape: escape$1,
		escapeRegExp: escapeRegExp,
		every: every,
		extend: assignIn,
		extendWith: assignInWith,
		fill: fill,
		filter: filter,
		find: find,
		findIndex: findIndex,
		findKey: findKey,
		findLast: findLast,
		findLastIndex: findLastIndex,
		findLastKey: findLastKey,
		first: head,
		flatMap: flatMap,
		flatMapDeep: flatMapDeep,
		flatMapDepth: flatMapDepth,
		flatten: flatten$1,
		flattenDeep: flattenDeep,
		flattenDepth: flattenDepth,
		flip: flip,
		floor: floor,
		flow: flow,
		flowRight: flowRight,
		forEach: forEach,
		forEachRight: forEachRight,
		forIn: forIn,
		forInRight: forInRight,
		forOwn: forOwn,
		forOwnRight: forOwnRight,
		fromPairs: fromPairs,
		functions: functions,
		functionsIn: functionsIn,
		get: get,
		groupBy: groupBy,
		gt: gt,
		gte: gte,
		has: has,
		hasIn: hasIn,
		head: head,
		identity: identity,
		inRange: inRange,
		includes: includes,
		indexOf: indexOf,
		initial: initial,
		intersection: intersection,
		intersectionBy: intersectionBy,
		intersectionWith: intersectionWith,
		invert: invert,
		invertBy: invertBy,
		invoke: invoke,
		invokeMap: invokeMap,
		isArguments: isArguments,
		isArray: isArray,
		isArrayBuffer: isArrayBuffer,
		isArrayLike: isArrayLike,
		isArrayLikeObject: isArrayLikeObject,
		isBoolean: isBoolean,
		isBuffer: isBuffer,
		isDate: isDate,
		isElement: isElement,
		isEmpty: isEmpty,
		isEqual: isEqual,
		isEqualWith: isEqualWith,
		isError: isError,
		isFinite: isFinite$1,
		isFunction: isFunction,
		isInteger: isInteger,
		isLength: isLength,
		isMap: isMap,
		isMatch: isMatch,
		isMatchWith: isMatchWith,
		isNaN: isNaN$1,
		isNative: isNative,
		isNil: isNil,
		isNull: isNull,
		isNumber: isNumber,
		isObject: isObject,
		isObjectLike: isObjectLike,
		isPlainObject: isPlainObject,
		isRegExp: isRegExp,
		isSafeInteger: isSafeInteger,
		isSet: isSet,
		isString: isString,
		isSymbol: isSymbol,
		isTypedArray: isTypedArray,
		isUndefined: isUndefined,
		isWeakMap: isWeakMap,
		isWeakSet: isWeakSet,
		iteratee: iteratee,
		join: join,
		kebabCase: kebabCase,
		keyBy: keyBy,
		keys: keys,
		keysIn: keysIn$1,
		last: last,
		lastIndexOf: lastIndexOf,
		lodash: lodash,
		lowerCase: lowerCase,
		lowerFirst: lowerFirst,
		lt: lt,
		lte: lte,
		map: map,
		mapKeys: mapKeys,
		mapValues: mapValues,
		matches: matches,
		matchesProperty: matchesProperty,
		max: max,
		maxBy: maxBy,
		mean: mean,
		meanBy: meanBy,
		memoize: memoize,
		merge: merge,
		mergeWith: mergeWith,
		method: method,
		methodOf: methodOf,
		min: min,
		minBy: minBy,
		mixin: mixin,
		multiply: multiply,
		negate: negate,
		next: wrapperNext,
		noop: noop,
		now: now,
		nth: nth,
		nthArg: nthArg,
		omit: omit,
		omitBy: omitBy,
		once: once,
		orderBy: orderBy,
		over: over,
		overArgs: overArgs,
		overEvery: overEvery,
		overSome: overSome,
		pad: pad,
		padEnd: padEnd,
		padStart: padStart,
		parseInt: parseInt$1,
		partial: partial,
		partialRight: partialRight,
		partition: partition,
		pick: pick,
		pickBy: pickBy,
		plant: wrapperPlant,
		property: property,
		propertyOf: propertyOf,
		pull: pull,
		pullAll: pullAll,
		pullAllBy: pullAllBy,
		pullAllWith: pullAllWith,
		pullAt: pullAt,
		random: random,
		range: range,
		rangeRight: rangeRight,
		rearg: rearg,
		reduce: reduce,
		reduceRight: reduceRight,
		reject: reject,
		remove: remove,
		repeat: repeat,
		replace: replace,
		rest: rest,
		result: result,
		reverse: reverse,
		round: round,
		sample: sample,
		sampleSize: sampleSize,
		set: set,
		setWith: setWith,
		shuffle: shuffle,
		size: size,
		slice: slice,
		snakeCase: snakeCase,
		some: some,
		sortBy: sortBy,
		sortedIndex: sortedIndex,
		sortedIndexBy: sortedIndexBy,
		sortedIndexOf: sortedIndexOf,
		sortedLastIndex: sortedLastIndex,
		sortedLastIndexBy: sortedLastIndexBy,
		sortedLastIndexOf: sortedLastIndexOf,
		sortedUniq: sortedUniq,
		sortedUniqBy: sortedUniqBy,
		split: split,
		spread: spread,
		startCase: startCase,
		startsWith: startsWith,
		stubArray: stubArray,
		stubFalse: stubFalse,
		stubObject: stubObject,
		stubString: stubString,
		stubTrue: stubTrue,
		subtract: subtract,
		sum: sum,
		sumBy: sumBy,
		tail: tail,
		take: take,
		takeRight: takeRight,
		takeRightWhile: takeRightWhile,
		takeWhile: takeWhile,
		tap: tap,
		template: template,
		templateSettings: templateSettings,
		throttle: throttle,
		thru: thru,
		times: times,
		toArray: toArray,
		toFinite: toFinite,
		toInteger: toInteger,
		toIterator: wrapperToIterator,
		toJSON: wrapperValue,
		toLength: toLength,
		toLower: toLower,
		toNumber: toNumber,
		toPairs: toPairs,
		toPairsIn: toPairsIn,
		toPath: toPath,
		toPlainObject: toPlainObject,
		toSafeInteger: toSafeInteger,
		toString: toString,
		toUpper: toUpper,
		transform: transform,
		trim: trim,
		trimEnd: trimEnd,
		trimStart: trimStart,
		truncate: truncate,
		unary: unary,
		unescape: unescape,
		union: union,
		unionBy: unionBy,
		unionWith: unionWith,
		uniq: uniq,
		uniqBy: uniqBy,
		uniqWith: uniqWith,
		uniqueId: uniqueId,
		unset: unset,
		unzip: unzip,
		unzipWith: unzipWith,
		update: update,
		updateWith: updateWith,
		upperCase: upperCase,
		upperFirst: upperFirst,
		value: wrapperValue,
		valueOf: wrapperValue,
		values: values,
		valuesIn: valuesIn,
		without: without,
		words: words,
		wrap: wrap,
		wrapperAt: wrapperAt,
		wrapperChain: wrapperChain,
		wrapperCommit: wrapperCommit,
		wrapperLodash: lodash,
		wrapperNext: wrapperNext,
		wrapperPlant: wrapperPlant,
		wrapperReverse: wrapperReverse,
		wrapperToIterator: wrapperToIterator,
		wrapperValue: wrapperValue,
		xor: xor,
		xorBy: xorBy,
		xorWith: xorWith,
		zip: zip,
		zipObject: zipObject,
		zipObjectDeep: zipObjectDeep,
		zipWith: zipWith,
		'default': lodash
	});

	var arr = [];

	var getProto = Object.getPrototypeOf;

	var slice$1 = arr.slice;

	// Support: IE 11+, Edge 18+
	// Provide fallback for browsers without Array#flat.
	var flat = arr.flat ? function( array ) {
		return arr.flat.call( array );
	} : function( array ) {
		return arr.concat.apply( [], array );
	};

	var push = arr.push;

	var indexOf$1 = arr.indexOf;

	// [[Class]] -> type pairs
	var class2type = {};

	var toString$1 = class2type.toString;

	var hasOwn = class2type.hasOwnProperty;

	var fnToString = hasOwn.toString;

	var ObjectFunctionString = fnToString.call( Object );

	// All support tests are defined in their respective modules.
	var support = {};

	function isWindow( obj ) {
		return obj != null && obj === obj.window;
	}

	var document$1 = window.document;

	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document$1;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox <=64 - 66+, Edge <=18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}

	function toType( obj ) {
		if ( obj == null ) {
			return obj + "";
		}

		return typeof obj === "object" ?
			class2type[ toString$1.call( obj ) ] || "object" :
			typeof obj;
	}

	// When custom compilation is used, the version string can get large.
	// eslint-disable-next-line max-len
	var version = "@VERSION",

		rhtmlSuffix = /HTML$/i,

		// Define a local copy of jQuery
		jQuery$1 = function( selector, context ) {

			// The jQuery object is actually just the init constructor 'enhanced'
			// Need init if jQuery is called (just allow error to be thrown if not included)
			return new jQuery$1.fn.init( selector, context );
		};

	jQuery$1.fn = jQuery$1.prototype = {

		// The current version of jQuery being used
		jquery: version,

		constructor: jQuery$1,

		// The default length of a jQuery object is 0
		length: 0,

		toArray: function() {
			return slice$1.call( this );
		},

		// Get the Nth element in the matched element set OR
		// Get the whole matched element set as a clean array
		get: function( num ) {

			// Return all the elements in a clean array
			if ( num == null ) {
				return slice$1.call( this );
			}

			// Return just the one element from the set
			return num < 0 ? this[ num + this.length ] : this[ num ];
		},

		// Take an array of elements and push it onto the stack
		// (returning the new matched element set)
		pushStack: function( elems ) {

			// Build a new jQuery matched element set
			var ret = jQuery$1.merge( this.constructor(), elems );

			// Add the old object onto the stack (as a reference)
			ret.prevObject = this;

			// Return the newly-formed element set
			return ret;
		},

		// Execute a callback for every element in the matched set.
		each: function( callback ) {
			return jQuery$1.each( this, callback );
		},

		map: function( callback ) {
			return this.pushStack( jQuery$1.map( this, function( elem, i ) {
				return callback.call( elem, i, elem );
			} ) );
		},

		slice: function() {
			return this.pushStack( slice$1.apply( this, arguments ) );
		},

		first: function() {
			return this.eq( 0 );
		},

		last: function() {
			return this.eq( -1 );
		},

		even: function() {
			return this.pushStack( jQuery$1.grep( this, function( _elem, i ) {
				return ( i + 1 ) % 2;
			} ) );
		},

		odd: function() {
			return this.pushStack( jQuery$1.grep( this, function( _elem, i ) {
				return i % 2;
			} ) );
		},

		eq: function( i ) {
			var len = this.length,
				j = +i + ( i < 0 ? len : 0 );
			return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
		},

		end: function() {
			return this.prevObject || this.constructor();
		}
	};

	jQuery$1.extend = jQuery$1.fn.extend = function() {
		var options, name, src, copy, copyIsArray, clone,
			target = arguments[ 0 ] || {},
			i = 1,
			length = arguments.length,
			deep = false;

		// Handle a deep copy situation
		if ( typeof target === "boolean" ) {
			deep = target;

			// Skip the boolean and the target
			target = arguments[ i ] || {};
			i++;
		}

		// Handle case when target is a string or something (possible in deep copy)
		if ( typeof target !== "object" && typeof target !== "function" ) {
			target = {};
		}

		// Extend jQuery itself if only one argument is passed
		if ( i === length ) {
			target = this;
			i--;
		}

		for ( ; i < length; i++ ) {

			// Only deal with non-null/undefined values
			if ( ( options = arguments[ i ] ) != null ) {

				// Extend the base object
				for ( name in options ) {
					copy = options[ name ];

					// Prevent Object.prototype pollution
					// Prevent never-ending loop
					if ( name === "__proto__" || target === copy ) {
						continue;
					}

					// Recurse if we're merging plain objects or arrays
					if ( deep && copy && ( jQuery$1.isPlainObject( copy ) ||
						( copyIsArray = Array.isArray( copy ) ) ) ) {
						src = target[ name ];

						// Ensure proper type for the source value
						if ( copyIsArray && !Array.isArray( src ) ) {
							clone = [];
						} else if ( !copyIsArray && !jQuery$1.isPlainObject( src ) ) {
							clone = {};
						} else {
							clone = src;
						}
						copyIsArray = false;

						// Never move original objects, clone them
						target[ name ] = jQuery$1.extend( deep, clone, copy );

					// Don't bring in undefined values
					} else if ( copy !== undefined ) {
						target[ name ] = copy;
					}
				}
			}
		}

		// Return the modified object
		return target;
	};

	jQuery$1.extend( {

		// Unique for each copy of jQuery on the page
		expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

		// Assume jQuery is ready without the ready module
		isReady: true,

		error: function( msg ) {
			throw new Error( msg );
		},

		noop: function() {},

		isPlainObject: function( obj ) {
			var proto, Ctor;

			// Detect obvious negatives
			// Use toString instead of jQuery.type to catch host objects
			if ( !obj || toString$1.call( obj ) !== "[object Object]" ) {
				return false;
			}

			proto = getProto( obj );

			// Objects with no prototype (e.g., `Object.create( null )`) are plain
			if ( !proto ) {
				return true;
			}

			// Objects with prototype are plain iff they were constructed by a global Object function
			Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
			return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
		},

		isEmptyObject: function( obj ) {
			var name;

			for ( name in obj ) {
				return false;
			}
			return true;
		},

		// Evaluates a script in a provided context; falls back to the global one
		// if not specified.
		globalEval: function( code, options, doc ) {
			DOMEval( code, { nonce: options && options.nonce }, doc );
		},

		each: function( obj, callback ) {
			var length, i = 0;

			if ( isArrayLike$1( obj ) ) {
				length = obj.length;
				for ( ; i < length; i++ ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			} else {
				for ( i in obj ) {
					if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
						break;
					}
				}
			}

			return obj;
		},


		// Retrieve the text value of an array of DOM nodes
		text: function( elem ) {
			var node,
				ret = "",
				i = 0,
				nodeType = elem.nodeType;

			if ( !nodeType ) {

				// If no nodeType, this is expected to be an array
				while ( ( node = elem[ i++ ] ) ) {

					// Do not traverse comment nodes
					ret += jQuery$1.text( node );
				}
			} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {

				// Use textContent for elements
				// innerText usage removed for consistency of new lines (jQuery #11153)
				if ( typeof elem.textContent === "string" ) {
					return elem.textContent;
				} else {

					// Traverse its children
					for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
						ret += jQuery$1.text( elem );
					}
				}
			} else if ( nodeType === 3 || nodeType === 4 ) {
				return elem.nodeValue;
			}

			// Do not include comment or processing instruction nodes

			return ret;
		},


		// results is for internal usage only
		makeArray: function( arr, results ) {
			var ret = results || [];

			if ( arr != null ) {
				if ( isArrayLike$1( Object( arr ) ) ) {
					jQuery$1.merge( ret,
						typeof arr === "string" ?
						[ arr ] : arr
					);
				} else {
					push.call( ret, arr );
				}
			}

			return ret;
		},

		inArray: function( elem, arr, i ) {
			return arr == null ? -1 : indexOf$1.call( arr, elem, i );
		},

		isXMLDoc: function( elem ) {
			var namespace = elem.namespaceURI,
				docElem = ( elem.ownerDocument || elem ).documentElement;

			// Assume HTML when documentElement doesn't yet exist, such as inside
			// document fragments.
			return !rhtmlSuffix.test( namespace || docElem && docElem.nodeName || "HTML" );
		},

		merge: function( first, second ) {
			var len = +second.length,
				j = 0,
				i = first.length;

			for ( ; j < len; j++ ) {
				first[ i++ ] = second[ j ];
			}

			first.length = i;

			return first;
		},

		grep: function( elems, callback, invert ) {
			var callbackInverse,
				matches = [],
				i = 0,
				length = elems.length,
				callbackExpect = !invert;

			// Go through the array, only saving the items
			// that pass the validator function
			for ( ; i < length; i++ ) {
				callbackInverse = !callback( elems[ i ], i );
				if ( callbackInverse !== callbackExpect ) {
					matches.push( elems[ i ] );
				}
			}

			return matches;
		},

		// arg is for internal usage only
		map: function( elems, callback, arg ) {
			var length, value,
				i = 0,
				ret = [];

			// Go through the array, translating each of the items to their new values
			if ( isArrayLike$1( elems ) ) {
				length = elems.length;
				for ( ; i < length; i++ ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}

			// Go through every key on the object,
			} else {
				for ( i in elems ) {
					value = callback( elems[ i ], i, arg );

					if ( value != null ) {
						ret.push( value );
					}
				}
			}

			// Flatten any nested arrays
			return flat( ret );
		},

		// A global GUID counter for objects
		guid: 1,

		// jQuery.support is not used in Core but other projects attach their
		// properties to it so it needs to exist.
		support: support
	} );

	if ( typeof Symbol === "function" ) {
		jQuery$1.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
	}

	// Populate the class2type map
	jQuery$1.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( _i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

	function isArrayLike$1( obj ) {

		var length = !!obj && obj.length,
			type = toType( obj );

		if ( typeof obj === "function" || isWindow( obj ) ) {
			return false;
		}

		return type === "array" || length === 0 ||
			typeof length === "number" && length > 0 && ( length - 1 ) in obj;
	}

	function nodeName( elem, name ) {

	  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

	}

	var documentElement = document$1.documentElement;

	var pop = arr.pop;

	// https://www.w3.org/TR/css3-selectors/#whitespace
	var whitespace = "[\\x20\\t\\r\\n\\f]";

	var isIE = document$1.documentMode;

	var rbuggyQSA = [],
		testEl = document$1.createElement( "div" ),
		input = document$1.createElement( "input" );

	// Support: IE 9 - 11+
	// IE's :disabled selector does not pick up the children of disabled fieldsets
	if ( isIE ) {
		rbuggyQSA.push( ":enabled", ":disabled" );
	}

	// Support: IE 11+, Edge 15 - 18+
	// IE 11/Edge don't find elements on a `[name='']` query in some cases.
	// Adding a temporary attribute to the document before the selection works
	// around the issue.
	// Interestingly, IE 10 & older don't seem to have the issue.
	input.setAttribute( "name", "" );
	testEl.appendChild( input );
	if ( !testEl.querySelectorAll( "[name='']" ).length ) {
		rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
			whitespace + "*(?:''|\"\")" );
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );

	var rbuggyQSA$1 = rbuggyQSA;

	// Support: IE 9 - 11+, Edge 12 - 18+
	// IE/Edge don't support the :scope pseudo-class.
	try {
		document$1.querySelectorAll( ":scope" );
		support.scope = true;
	} catch ( e ) {}

	// Note: an element does not contain itself
	jQuery$1.contains = function( a, b ) {
		var adown = a.nodeType === 9 ? a.documentElement : a,
			bup = b && b.parentNode;

		return a === bup || !!( bup && bup.nodeType === 1 && (

			// Support: IE 9 - 11+
			// IE doesn't have `contains` on SVG.
			adown.contains ?
				adown.contains( bup ) :
				a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
		) );
	};

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;

	function fcssescape( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	}

	jQuery$1.escapeSelector = function( sel ) {
		return ( sel + "" ).replace( rcssescape, fcssescape );
	};

	var sort = arr.sort;

	var hasDuplicate;

	// Document order sorting
	function sortOrder( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ) {

			// Choose the first element that is related to the document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( a == document$1 || a.ownerDocument == document$1 &&
				jQuery$1.contains( document$1, a ) ) {
				return -1;
			}

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( b == document$1 || b.ownerDocument == document$1 &&
				jQuery$1.contains( document$1, b ) ) {
				return 1;
			}

			// Maintain original order
			return 0;
		}

		return compare & 4 ? -1 : 1;
	}

	/**
	 * Document sorting and removing duplicates
	 * @param {ArrayLike} results
	 */
	jQuery$1.uniqueSort = function( results ) {
		var elem,
			duplicates = [],
			j = 0,
			i = 0;

		hasDuplicate = false;

		sort.call( results, sortOrder );

		if ( hasDuplicate ) {
			while ( ( elem = results[ i++ ] ) ) {
				if ( elem === results[ i ] ) {
					j = duplicates.push( i );
				}
			}
			while ( j-- ) {
				results.splice( duplicates[ j ], 1 );
			}
		}

		return results;
	};

	var preferredDoc = document$1,
		matches$1 = documentElement.matches || documentElement.msMatchesSelector;

	( function() {

	var i,
		Expr,
		outermostContext,

		// Local document vars
		document,
		documentElement,
		documentIsHTML,

		// Instance-specific data
		expando = jQuery$1.expando,
		dirruns = 0,
		done = 0,
		classCache = createCache(),
		tokenCache = createCache(),
		compilerCache = createCache(),
		nonnativeSelectorCache = createCache(),

		booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|" +
			"loop|multiple|open|readonly|required|scoped",

		// Regular expressions

		// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
		identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
			"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

		// Attribute selectors: https://www.w3.org/TR/selectors/#attribute-selectors
		attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

			// Operator (capture 2)
			"*([*^$|!~]?=)" + whitespace +

			// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
			"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
			whitespace + "*\\]",

		pseudos = ":(" + identifier + ")(?:\\((" +

			// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
			// 1. quoted (capture 3; capture 4 or capture 5)
			"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

			// 2. simple (capture 6)
			"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

			// 3. anything else (capture 2)
			".*" +
			")\\)|)",

		// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
		rwhitespace = new RegExp( whitespace + "+", "g" ),
		rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

		rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
		rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" +
			whitespace + "*" ),
		rdescend = new RegExp( whitespace + "|>" ),

		rpseudo = new RegExp( pseudos ),
		ridentifier = new RegExp( "^" + identifier + "$" ),

		matchExpr = {
			ID: new RegExp( "^#(" + identifier + ")" ),
			CLASS: new RegExp( "^\\.(" + identifier + ")" ),
			TAG: new RegExp( "^(" + identifier + "|[*])" ),
			ATTR: new RegExp( "^" + attributes ),
			PSEUDO: new RegExp( "^" + pseudos ),
			CHILD: new RegExp(
				"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
					whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
					whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
			bool: new RegExp( "^(?:" + booleans + ")$", "i" ),

			// For use in libraries implementing .is()
			// We use this for POS matching in `select`
			needsContext: new RegExp( "^" + whitespace +
				"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
				"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
		},

		rinputs = /^(?:input|select|textarea|button)$/i,
		rheader = /^h\d$/i,

		// Easily-parseable/retrievable ID or TAG or CLASS selectors
		rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

		rsibling = /[+~]/,

		// CSS escapes
		// https://www.w3.org/TR/CSS21/syndata.html#escaped-characters
		runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace +
			"?|\\\\([^\\r\\n\\f])", "g" ),
		funescape = function( escape, nonHex ) {
			var high = "0x" + escape.slice( 1 ) - 0x10000;

			if ( nonHex ) {

				// Strip the backslash prefix from a non-hex escape sequence
				return nonHex;
			}

			// Replace a hexadecimal escape sequence with the encoded Unicode code point
			// Support: IE <=11+
			// For values outside the Basic Multilingual Plane (BMP), manually construct a
			// surrogate pair
			return high < 0 ?
				String.fromCharCode( high + 0x10000 ) :
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
		},

		// Used for iframes; see `setDocument`.
		// Support: IE 9 - 11+, Edge 12 - 18+
		// Removing the function wrapper causes a "Permission Denied"
		// error in IE/Edge.
		unloadHandler = function() {
			setDocument();
		},

		inDisabledFieldset = addCombinator(
			function( elem ) {
				return elem.disabled === true && nodeName( elem, "fieldset" );
			},
			{ dir: "parentNode", next: "legend" }
		);

	function selectorError( msg ) {
		throw new Error( "Syntax error, unrecognized expression: " + msg );
	}

	function find( selector, context, results, seed ) {
		var m, i, elem, nid, match, groups, newSelector,
			newContext = context && context.ownerDocument,

			// nodeType defaults to 9, since context defaults to document
			nodeType = context ? context.nodeType : 9;

		results = results || [];

		// Return early from calls with invalid selector or context
		if ( typeof selector !== "string" || !selector ||
			nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

			return results;
		}

		// Try to shortcut find operations (as opposed to filters) in HTML documents
		if ( !seed ) {
			setDocument( context );
			context = context || document;

			if ( documentIsHTML ) {

				// If the selector is sufficiently simple, try using a "get*By*" DOM method
				// (excepting DocumentFragment context, where the methods don't exist)
				if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

					// ID selector
					if ( ( m = match[ 1 ] ) ) {

						// Document context
						if ( nodeType === 9 ) {
							if ( ( elem = context.getElementById( m ) ) ) {
								push.call( results, elem );
							}
							return results;

						// Element context
						} else {
							if ( newContext && ( elem = newContext.getElementById( m ) ) &&
								jQuery$1.contains( context, elem ) ) {

								push.call( results, elem );
								return results;
							}
						}

					// Type selector
					} else if ( match[ 2 ] ) {
						push.apply( results, context.getElementsByTagName( selector ) );
						return results;

					// Class selector
					} else if ( ( m = match[ 3 ] ) && context.getElementsByClassName ) {
						push.apply( results, context.getElementsByClassName( m ) );
						return results;
					}
				}

				// Take advantage of querySelectorAll
				if ( !nonnativeSelectorCache[ selector + " " ] &&
					( !rbuggyQSA$1 || !rbuggyQSA$1.test( selector ) ) ) {

					newSelector = selector;
					newContext = context;

					// qSA considers elements outside a scoping root when evaluating child or
					// descendant combinators, which is not what we want.
					// In such cases, we work around the behavior by prefixing every selector in the
					// list with an ID selector referencing the scope context.
					// The technique has to be used as well when a leading combinator is used
					// as such selectors are not recognized by querySelectorAll.
					// Thanks to Andrew Dupont for this technique.
					if ( nodeType === 1 &&
						( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {

						// Expand context for sibling selectors
						newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
							context;

						// We can use :scope instead of the ID hack if the browser
						// supports it & if we're not changing the context.
						if ( newContext !== context || !support.scope ) {

							// Capture the context ID, setting it first if necessary
							if ( ( nid = context.getAttribute( "id" ) ) ) {
								nid = jQuery$1.escapeSelector( nid );
							} else {
								context.setAttribute( "id", ( nid = expando ) );
							}
						}

						// Prefix every selector in the list
						groups = tokenize( selector );
						i = groups.length;
						while ( i-- ) {
							groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
								toSelector( groups[ i ] );
						}
						newSelector = groups.join( "," );
					}

					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
						nonnativeSelectorCache( selector, true );
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}

		// All others
		return select( selector.replace( rtrim, "$1" ), context, results, seed );
	}

	/**
	 * Create key-value caches of limited size
	 * @returns {function(string, object)} Returns the Object data after storing it on itself with
	 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
	 *	deleting the oldest entry
	 */
	function createCache() {
		var keys = [];

		function cache( key, value ) {

			// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
			if ( keys.push( key + " " ) > Expr.cacheLength ) {

				// Only keep the most recent entries
				delete cache[ keys.shift() ];
			}
			return ( cache[ key + " " ] = value );
		}
		return cache;
	}

	/**
	 * Mark a function for special use by jQuery selector module
	 * @param {Function} fn The function to mark
	 */
	function markFunction( fn ) {
		fn[ expando ] = true;
		return fn;
	}

	/**
	 * Returns a function to use in pseudos for input types
	 * @param {String} type
	 */
	function createInputPseudo( type ) {
		return function( elem ) {
			return nodeName( elem, "input" ) && elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for buttons
	 * @param {String} type
	 */
	function createButtonPseudo( type ) {
		return function( elem ) {
			return ( nodeName( elem, "input" ) || nodeName( elem, "button" ) ) &&
				elem.type === type;
		};
	}

	/**
	 * Returns a function to use in pseudos for :enabled/:disabled
	 * @param {Boolean} disabled true for :disabled; false for :enabled
	 */
	function createDisabledPseudo( disabled ) {

		// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
		return function( elem ) {

			// Only certain elements can match :enabled or :disabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
			// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
			if ( "form" in elem ) {

				// Check for inherited disabledness on relevant non-disabled elements:
				// * listed form-associated elements in a disabled fieldset
				//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
				// * option elements in a disabled optgroup
				//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
				// All such elements have a "form" property.
				if ( elem.parentNode && elem.disabled === false ) {

					// Option elements defer to a parent optgroup if present
					if ( "label" in elem ) {
						if ( "label" in elem.parentNode ) {
							return elem.parentNode.disabled === disabled;
						} else {
							return elem.disabled === disabled;
						}
					}

					// Support: IE 6 - 11+
					// Use the isDisabled shortcut property to check for disabled fieldset ancestors
					return elem.isDisabled === disabled ||

						// Where there is no isDisabled, check manually
						/* jshint -W018 */
						elem.isDisabled !== !disabled &&
							inDisabledFieldset( elem ) === disabled;
				}

				return elem.disabled === disabled;

			// Try to winnow out elements that can't be disabled before trusting the disabled property.
			// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
			// even exist on them, let alone have a boolean value.
			} else if ( "label" in elem ) {
				return elem.disabled === disabled;
			}

			// Remaining elements are neither :enabled nor :disabled
			return false;
		};
	}

	/**
	 * Returns a function to use in pseudos for positionals
	 * @param {Function} fn
	 */
	function createPositionalPseudo( fn ) {
		return markFunction( function( argument ) {
			argument = +argument;
			return markFunction( function( seed, matches ) {
				var j,
					matchIndexes = fn( [], seed.length, argument ),
					i = matchIndexes.length;

				// Match elements found at the specified indexes
				while ( i-- ) {
					if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
						seed[ j ] = !( matches[ j ] = seed[ j ] );
					}
				}
			} );
		} );
	}

	/**
	 * Checks a node for validity as a jQuery selector context
	 * @param {Element|Object=} context
	 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
	 */
	function testContext( context ) {
		return context && typeof context.getElementsByTagName !== "undefined" && context;
	}

	/**
	 * Sets document-related variables once based on the current document
	 * @param {Element|Object} [node] An element or document object to use to set the document
	 */
	function setDocument( node ) {
		var subWindow,
			doc = node ? node.ownerDocument || node : preferredDoc;

		// Return early if doc is invalid or already selected
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		if ( doc == document || doc.nodeType !== 9 ) {
			return;
		}

		// Update global variables
		document = doc;
		documentElement = document.documentElement;
		documentIsHTML = !jQuery$1.isXMLDoc( document );

		// Support: IE 9 - 11+, Edge 12 - 18+
		// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		if ( preferredDoc != document &&
			( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

			// Support: IE 9 - 11+, Edge 12 - 18+
			subWindow.addEventListener( "unload", unloadHandler );
		}
	}

	find.matches = function( expr, elements ) {
		return find( expr, null, null, elements );
	};

	find.matchesSelector = function( elem, expr ) {
		setDocument( elem );

		if ( documentIsHTML &&
			!nonnativeSelectorCache[ expr + " " ] &&
			( !rbuggyQSA$1 || !rbuggyQSA$1.test( expr ) ) ) {

			try {
				return matches$1.call( elem, expr );
			} catch ( e ) {
				nonnativeSelectorCache( expr, true );
			}
		}

		return find( expr, document, null, [ elem ] ).length > 0;
	};

	Expr = jQuery$1.expr = {

		// Can be adjusted by the user
		cacheLength: 50,

		createPseudo: markFunction,

		match: matchExpr,

		find: {
			ID: function( id, context ) {
				if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
					var elem = context.getElementById( id );
					return elem ? [ elem ] : [];
				}
			},

			TAG: function( tag, context ) {
				if ( typeof context.getElementsByTagName !== "undefined" ) {
					return context.getElementsByTagName( tag );

					// DocumentFragment nodes don't have gEBTN
				} else {
					return context.querySelectorAll( tag );
				}
			},

			CLASS: function( className, context ) {
				if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
					return context.getElementsByClassName( className );
				}
			}
		},

		relative: {
			">": { dir: "parentNode", first: true },
			" ": { dir: "parentNode" },
			"+": { dir: "previousSibling", first: true },
			"~": { dir: "previousSibling" }
		},

		preFilter: {
			ATTR: function( match ) {
				match[ 1 ] = match[ 1 ].replace( runescape, funescape );

				// Move the given value to match[3] whether quoted or unquoted
				match[ 3 ] = ( match[ 3 ] || match[ 4 ] || match[ 5 ] || "" )
					.replace( runescape, funescape );

				if ( match[ 2 ] === "~=" ) {
					match[ 3 ] = " " + match[ 3 ] + " ";
				}

				return match.slice( 0, 4 );
			},

			CHILD: function( match ) {

				/* matches from matchExpr["CHILD"]
					1 type (only|nth|...)
					2 what (child|of-type)
					3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
					4 xn-component of xn+y argument ([+-]?\d*n|)
					5 sign of xn-component
					6 x of xn-component
					7 sign of y-component
					8 y of y-component
				*/
				match[ 1 ] = match[ 1 ].toLowerCase();

				if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

					// nth-* requires argument
					if ( !match[ 3 ] ) {
						selectorError( match[ 0 ] );
					}

					// numeric x and y parameters for Expr.filter.CHILD
					// remember that false/true cast respectively to 0/1
					match[ 4 ] = +( match[ 4 ] ?
						match[ 5 ] + ( match[ 6 ] || 1 ) :
						2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" )
					);
					match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

				// other types prohibit arguments
				} else if ( match[ 3 ] ) {
					selectorError( match[ 0 ] );
				}

				return match;
			},

			PSEUDO: function( match ) {
				var excess,
					unquoted = !match[ 6 ] && match[ 2 ];

				if ( matchExpr.CHILD.test( match[ 0 ] ) ) {
					return null;
				}

				// Accept quoted arguments as-is
				if ( match[ 3 ] ) {
					match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

				// Strip excess characters from unquoted arguments
				} else if ( unquoted && rpseudo.test( unquoted ) &&

					// Get excess from tokenize (recursively)
					( excess = tokenize( unquoted, true ) ) &&

					// advance to the next closing parenthesis
					( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

					// excess is a negative index
					match[ 0 ] = match[ 0 ].slice( 0, excess );
					match[ 2 ] = unquoted.slice( 0, excess );
				}

				// Return only captures needed by the pseudo filter method (type and argument)
				return match.slice( 0, 3 );
			}
		},

		filter: {
			ID: function( id ) {
				var attrId = id.replace( runescape, funescape );
				return function( elem ) {
					return elem.getAttribute( "id" ) === attrId;
				};
			},

			TAG: function( nodeNameSelector ) {
				var expectedNodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
				return nodeNameSelector === "*" ?
					function() {
	 return true;
	} :
					function( elem ) {
						return nodeName( elem, expectedNodeName );
					};
			},

			CLASS: function( className ) {
				var pattern = classCache[ className + " " ];

				return pattern ||
					( pattern = new RegExp( "(^|" + whitespace + ")" + className +
						"(" + whitespace + "|$)" ) ) &&
					classCache( className, function( elem ) {
						return pattern.test(
							typeof elem.className === "string" && elem.className ||
								typeof elem.getAttribute !== "undefined" &&
									elem.getAttribute( "class" ) ||
								""
						);
					} );
			},

			ATTR: function( name, operator, check ) {
				return function( elem ) {
					var result = jQuery$1.attr( elem, name );

					if ( result == null ) {
						return operator === "!=";
					}
					if ( !operator ) {
						return true;
					}

					result += "";

					if ( operator === "=" ) {
						return result === check;
					}
					if ( operator === "!=" ) {
						return result !== check;
					}
					if ( operator === "^=" ) {
						return check && result.indexOf( check ) === 0;
					}
					if ( operator === "*=" ) {
						return check && result.indexOf( check ) > -1;
					}
					if ( operator === "$=" ) {
						return check && result.slice( -check.length ) === check;
					}
					if ( operator === "~=" ) {
						return ( " " + result.replace( rwhitespace, " " ) + " " )
							.indexOf( check ) > -1;
					}
					if ( operator === "|=" ) {
						return result === check || result.slice( 0, check.length + 1 ) === check + "-";
					}

					return false;
				};
			},

			CHILD: function( type, what, _argument, first, last ) {
				var simple = type.slice( 0, 3 ) !== "nth",
					forward = type.slice( -4 ) !== "last",
					ofType = what === "of-type";

				return first === 1 && last === 0 ?

					// Shortcut for :nth-*(n)
					function( elem ) {
						return !!elem.parentNode;
					} :

					function( elem, _context, xml ) {
						var cache, outerCache, node, nodeIndex, start,
							dir = simple !== forward ? "nextSibling" : "previousSibling",
							parent = elem.parentNode,
							name = ofType && elem.nodeName.toLowerCase(),
							useCache = !xml && !ofType,
							diff = false;

						if ( parent ) {

							// :(first|last|only)-(child|of-type)
							if ( simple ) {
								while ( dir ) {
									node = elem;
									while ( ( node = node[ dir ] ) ) {
										if ( ofType ?
											nodeName( node, name ) :
											node.nodeType === 1 ) {

											return false;
										}
									}

									// Reverse direction for :only-* (if we haven't yet done so)
									start = dir = type === "only" && !start && "nextSibling";
								}
								return true;
							}

							start = [ forward ? parent.firstChild : parent.lastChild ];

							// non-xml :nth-child(...) stores cache data on `parent`
							if ( forward && useCache ) {

								// Seek `elem` from a previously-cached index
								outerCache = parent[ expando ] || ( parent[ expando ] = {} );
								cache = outerCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex && cache[ 2 ];
								node = nodeIndex && parent.childNodes[ nodeIndex ];

								while ( ( node = ++nodeIndex && node && node[ dir ] ||

									// Fallback to seeking `elem` from the start
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									// When found, cache indexes on `parent` and break
									if ( node.nodeType === 1 && ++diff && node === elem ) {
										outerCache[ type ] = [ dirruns, nodeIndex, diff ];
										break;
									}
								}

							} else {

								// Use previously-cached element index if available
								if ( useCache ) {
									outerCache = elem[ expando ] || ( elem[ expando ] = {} );
									cache = outerCache[ type ] || [];
									nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
									diff = nodeIndex;
								}

								// xml :nth-child(...)
								// or :nth-last-child(...) or :nth(-last)?-of-type(...)
								if ( diff === false ) {

									// Use the same loop as above to seek `elem` from the start
									while ( ( node = ++nodeIndex && node && node[ dir ] ||
										( diff = nodeIndex = 0 ) || start.pop() ) ) {

										if ( ( ofType ?
											nodeName( node, name ) :
											node.nodeType === 1 ) &&
											++diff ) {

											// Cache the index of each encountered element
											if ( useCache ) {
												outerCache = node[ expando ] ||
													( node[ expando ] = {} );
												outerCache[ type ] = [ dirruns, diff ];
											}

											if ( node === elem ) {
												break;
											}
										}
									}
								}
							}

							// Incorporate the offset, then check against cycle size
							diff -= last;
							return diff === first || ( diff % first === 0 && diff / first >= 0 );
						}
					};
			},

			PSEUDO: function( pseudo, argument ) {

				// pseudo-class names are case-insensitive
				// https://www.w3.org/TR/selectors/#pseudo-classes
				// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
				// Remember that setFilters inherits from pseudos
				var args,
					fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
						selectorError( "unsupported pseudo: " + pseudo );

				// The user may use createPseudo to indicate that
				// arguments are needed to create the filter function
				// just as jQuery does
				if ( fn[ expando ] ) {
					return fn( argument );
				}

				// But maintain support for old signatures
				if ( fn.length > 1 ) {
					args = [ pseudo, pseudo, "", argument ];
					return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
						markFunction( function( seed, matches ) {
							var idx,
								matched = fn( seed, argument ),
								i = matched.length;
							while ( i-- ) {
								idx = indexOf$1.call( seed, matched[ i ] );
								seed[ idx ] = !( matches[ idx ] = matched[ i ] );
							}
						} ) :
						function( elem ) {
							return fn( elem, 0, args );
						};
				}

				return fn;
			}
		},

		pseudos: {

			// Potentially complex pseudos
			not: markFunction( function( selector ) {

				// Trim the selector passed to compile
				// to avoid treating leading and trailing
				// spaces as combinators
				var input = [],
					results = [],
					matcher = compile( selector.replace( rtrim, "$1" ) );

				return matcher[ expando ] ?
					markFunction( function( seed, matches, _context, xml ) {
						var elem,
							unmatched = matcher( seed, null, xml, [] ),
							i = seed.length;

						// Match elements unmatched by `matcher`
						while ( i-- ) {
							if ( ( elem = unmatched[ i ] ) ) {
								seed[ i ] = !( matches[ i ] = elem );
							}
						}
					} ) :
					function( elem, _context, xml ) {
						input[ 0 ] = elem;
						matcher( input, null, xml, results );

						// Don't keep the element (issue #299)
						input[ 0 ] = null;
						return !results.pop();
					};
			} ),

			has: markFunction( function( selector ) {
				return function( elem ) {
					return find( selector, elem ).length > 0;
				};
			} ),

			contains: markFunction( function( text ) {
				text = text.replace( runescape, funescape );
				return function( elem ) {
					return ( elem.textContent || jQuery$1.text( elem ) ).indexOf( text ) > -1;
				};
			} ),

			// "Whether an element is represented by a :lang() selector
			// is based solely on the element's language value
			// being equal to the identifier C,
			// or beginning with the identifier C immediately followed by "-".
			// The matching of C against the element's language value is performed case-insensitively.
			// The identifier C does not have to be a valid language name."
			// https://www.w3.org/TR/selectors/#lang-pseudo
			lang: markFunction( function( lang ) {

				// lang value must be a valid identifier
				if ( !ridentifier.test( lang || "" ) ) {
					selectorError( "unsupported lang: " + lang );
				}
				lang = lang.replace( runescape, funescape ).toLowerCase();
				return function( elem ) {
					var elemLang;
					do {
						if ( ( elemLang = documentIsHTML ?
							elem.lang :
							elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

							elemLang = elemLang.toLowerCase();
							return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
						}
					} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
					return false;
				};
			} ),

			// Miscellaneous
			target: function( elem ) {
				var hash = window.location && window.location.hash;
				return hash && hash.slice( 1 ) === elem.id;
			},

			root: function( elem ) {
				return elem === documentElement;
			},

			focus: function( elem ) {
				return elem === document.activeElement &&
					document.hasFocus() &&
					!!( elem.type || elem.href || ~elem.tabIndex );
			},

			// Boolean properties
			enabled: createDisabledPseudo( false ),
			disabled: createDisabledPseudo( true ),

			checked: function( elem ) {

				// In CSS3, :checked should return both checked and selected elements
				// https://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
				return ( nodeName( elem, "input" ) && !!elem.checked ) ||
					( nodeName( elem, "option" ) && !!elem.selected );
			},

			selected: function( elem ) {

				// Support: IE <=11+
				// Accessing the selectedIndex property
				// forces the browser to treat the default option as
				// selected when in an optgroup.
				if ( elem.parentNode ) {
					// eslint-disable-next-line no-unused-expressions
					elem.parentNode.selectedIndex;
				}

				return elem.selected === true;
			},

			// Contents
			empty: function( elem ) {

				// https://www.w3.org/TR/selectors/#empty-pseudo
				// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
				//   but not by others (comment: 8; processing instruction: 7; etc.)
				// nodeType < 6 works because attributes (2) do not appear as children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					if ( elem.nodeType < 6 ) {
						return false;
					}
				}
				return true;
			},

			parent: function( elem ) {
				return !Expr.pseudos.empty( elem );
			},

			// Element/input types
			header: function( elem ) {
				return rheader.test( elem.nodeName );
			},

			input: function( elem ) {
				return rinputs.test( elem.nodeName );
			},

			button: function( elem ) {
				return nodeName( elem, "input" ) && elem.type === "button" ||
					nodeName( elem, "button" );
			},

			text: function( elem ) {
				return nodeName( elem, "input" ) && elem.type === "text";
			},

			// Position-in-collection
			first: createPositionalPseudo( function() {
				return [ 0 ];
			} ),

			last: createPositionalPseudo( function( _matchIndexes, length ) {
				return [ length - 1 ];
			} ),

			eq: createPositionalPseudo( function( _matchIndexes, length, argument ) {
				return [ argument < 0 ? argument + length : argument ];
			} ),

			even: createPositionalPseudo( function( matchIndexes, length ) {
				var i = 0;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			} ),

			odd: createPositionalPseudo( function( matchIndexes, length ) {
				var i = 1;
				for ( ; i < length; i += 2 ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			} ),

			lt: createPositionalPseudo( function( matchIndexes, length, argument ) {
				var i;

				if ( argument < 0 ) {
					i = argument + length;
				} else if ( argument > length ) {
					i = length;
				} else {
					i = argument;
				}

				for ( ; --i >= 0; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			} ),

			gt: createPositionalPseudo( function( matchIndexes, length, argument ) {
				var i = argument < 0 ? argument + length : argument;
				for ( ; ++i < length; ) {
					matchIndexes.push( i );
				}
				return matchIndexes;
			} )
		}
	};

	Expr.pseudos.nth = Expr.pseudos.eq;

	// Add button/input type pseudos
	for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
		Expr.pseudos[ i ] = createInputPseudo( i );
	}
	for ( i in { submit: true, reset: true } ) {
		Expr.pseudos[ i ] = createButtonPseudo( i );
	}

	// Easy API for creating new setFilters
	function setFilters() {}
	setFilters.prototype = Expr.filters = Expr.pseudos;
	Expr.setFilters = new setFilters();

	function tokenize( selector, parseOnly ) {
		var matched, match, tokens, type,
			soFar, groups, preFilters,
			cached = tokenCache[ selector + " " ];

		if ( cached ) {
			return parseOnly ? 0 : cached.slice( 0 );
		}

		soFar = selector;
		groups = [];
		preFilters = Expr.preFilter;

		while ( soFar ) {

			// Comma and first run
			if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
				if ( match ) {

					// Don't consume trailing commas as valid
					soFar = soFar.slice( match[ 0 ].length ) || soFar;
				}
				groups.push( ( tokens = [] ) );
			}

			matched = false;

			// Combinators
			if ( ( match = rcombinators.exec( soFar ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,

					// Cast descendant combinators to space
					type: match[ 0 ].replace( rtrim, " " )
				} );
				soFar = soFar.slice( matched.length );
			}

			// Filters
			for ( type in Expr.filter ) {
				if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
					( match = preFilters[ type ]( match ) ) ) ) {
					matched = match.shift();
					tokens.push( {
						value: matched,
						type: type,
						matches: match
					} );
					soFar = soFar.slice( matched.length );
				}
			}

			if ( !matched ) {
				break;
			}
		}

		// Return the length of the invalid excess
		// if we're just parsing
		// Otherwise, throw an error or return tokens
		if ( parseOnly ) {
			return soFar.length;
		}

		return soFar ?
			selectorError( selector ) :

			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
	}

	function toSelector( tokens ) {
		var i = 0,
			len = tokens.length,
			selector = "";
		for ( ; i < len; i++ ) {
			selector += tokens[ i ].value;
		}
		return selector;
	}

	function addCombinator( matcher, combinator, base ) {
		var dir = combinator.dir,
			skip = combinator.next,
			key = skip || dir,
			checkNonElements = base && key === "parentNode",
			doneName = done++;

		return combinator.first ?

			// Check against closest ancestor/preceding element
			function( elem, context, xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						return matcher( elem, context, xml );
					}
				}
				return false;
			} :

			// Check against all ancestor/preceding elements
			function( elem, context, xml ) {
				var oldCache, outerCache,
					newCache = [ dirruns, doneName ];

				// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
				if ( xml ) {
					while ( ( elem = elem[ dir ] ) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							if ( matcher( elem, context, xml ) ) {
								return true;
							}
						}
					}
				} else {
					while ( ( elem = elem[ dir ] ) ) {
						if ( elem.nodeType === 1 || checkNonElements ) {
							outerCache = elem[ expando ] || ( elem[ expando ] = {} );

							if ( skip && nodeName( elem, skip ) ) {
								elem = elem[ dir ] || elem;
							} else if ( ( oldCache = outerCache[ key ] ) &&
								oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

								// Assign to newCache so results back-propagate to previous elements
								return ( newCache[ 2 ] = oldCache[ 2 ] );
							} else {

								// Reuse newcache so results back-propagate to previous elements
								outerCache[ key ] = newCache;

								// A match means we're done; a fail means we have to keep checking
								if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
									return true;
								}
							}
						}
					}
				}
				return false;
			};
	}

	function elementMatcher( matchers ) {
		return matchers.length > 1 ?
			function( elem, context, xml ) {
				var i = matchers.length;
				while ( i-- ) {
					if ( !matchers[ i ]( elem, context, xml ) ) {
						return false;
					}
				}
				return true;
			} :
			matchers[ 0 ];
	}

	function multipleContexts( selector, contexts, results ) {
		var i = 0,
			len = contexts.length;
		for ( ; i < len; i++ ) {
			find( selector, contexts[ i ], results );
		}
		return results;
	}

	function condense( unmatched, map, filter, context, xml ) {
		var elem,
			newUnmatched = [],
			i = 0,
			len = unmatched.length,
			mapped = map != null;

		for ( ; i < len; i++ ) {
			if ( ( elem = unmatched[ i ] ) ) {
				if ( !filter || filter( elem, context, xml ) ) {
					newUnmatched.push( elem );
					if ( mapped ) {
						map.push( i );
					}
				}
			}
		}

		return newUnmatched;
	}

	function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
		if ( postFilter && !postFilter[ expando ] ) {
			postFilter = setMatcher( postFilter );
		}
		if ( postFinder && !postFinder[ expando ] ) {
			postFinder = setMatcher( postFinder, postSelector );
		}
		return markFunction( function( seed, results, context, xml ) {
			var temp, i, elem, matcherOut,
				preMap = [],
				postMap = [],
				preexisting = results.length,

				// Get initial elements from seed or context
				elems = seed ||
					multipleContexts( selector || "*",
						context.nodeType ? [ context ] : context, [] ),

				// Prefilter to get matcher input, preserving a map for seed-results synchronization
				matcherIn = preFilter && ( seed || !selector ) ?
					condense( elems, preMap, preFilter, context, xml ) :
					elems;

			if ( matcher ) {

				// If we have a postFinder, or filtered seed, or non-seed postFilter
				// or preexisting results,
				matcherOut = postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results;

				// Find primary matches
				matcher( matcherIn, matcherOut, context, xml );
			} else {
				matcherOut = matcherIn;
			}

			// Apply postFilter
			if ( postFilter ) {
				temp = condense( matcherOut, postMap );
				postFilter( temp, [], context, xml );

				// Un-match failing elements by moving them back to matcherIn
				i = temp.length;
				while ( i-- ) {
					if ( ( elem = temp[ i ] ) ) {
						matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
					}
				}
			}

			if ( seed ) {
				if ( postFinder || preFilter ) {
					if ( postFinder ) {

						// Get the final matcherOut by condensing this intermediate into postFinder contexts
						temp = [];
						i = matcherOut.length;
						while ( i-- ) {
							if ( ( elem = matcherOut[ i ] ) ) {

								// Restore matcherIn since elem is not yet a final match
								temp.push( ( matcherIn[ i ] = elem ) );
							}
						}
						postFinder( null, ( matcherOut = [] ), temp, xml );
					}

					// Move matched elements from seed to results to keep them synchronized
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) &&
							( temp = postFinder ? indexOf$1.call( seed, elem ) : preMap[ i ] ) > -1 ) {

							seed[ temp ] = !( results[ temp ] = elem );
						}
					}
				}

			// Add elements to results, through postFinder if defined
			} else {
				matcherOut = condense(
					matcherOut === results ?
						matcherOut.splice( preexisting, matcherOut.length ) :
						matcherOut
				);
				if ( postFinder ) {
					postFinder( null, results, matcherOut, xml );
				} else {
					push.apply( results, matcherOut );
				}
			}
		} );
	}

	function matcherFromTokens( tokens ) {
		var checkContext, matcher, j,
			len = tokens.length,
			leadingRelative = Expr.relative[ tokens[ 0 ].type ],
			implicitRelative = leadingRelative || Expr.relative[ " " ],
			i = leadingRelative ? 1 : 0,

			// The foundational matcher ensures that elements are reachable from top-level context(s)
			matchContext = addCombinator( function( elem ) {
				return elem === checkContext;
			}, implicitRelative, true ),
			matchAnyContext = addCombinator( function( elem ) {
				return indexOf$1.call( checkContext, elem ) > -1;
			}, implicitRelative, true ),
			matchers = [ function( elem, context, xml ) {
				var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
					( checkContext = context ).nodeType ?
						matchContext( elem, context, xml ) :
						matchAnyContext( elem, context, xml ) );

				// Avoid hanging onto element (issue #299)
				checkContext = null;
				return ret;
			} ];

		for ( ; i < len; i++ ) {
			if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
				matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
			} else {
				matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

				// Return special upon seeing a positional matcher
				if ( matcher[ expando ] ) {

					// Find the next relative operator (if any) for proper handling
					j = ++i;
					for ( ; j < len; j++ ) {
						if ( Expr.relative[ tokens[ j ].type ] ) {
							break;
						}
					}
					return setMatcher(
						i > 1 && elementMatcher( matchers ),
						i > 1 && toSelector(

							// If the preceding token was a descendant combinator, insert an implicit any-element `*`
							tokens.slice( 0, i - 1 )
								.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
						).replace( rtrim, "$1" ),
						matcher,
						i < j && matcherFromTokens( tokens.slice( i, j ) ),
						j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
						j < len && toSelector( tokens )
					);
				}
				matchers.push( matcher );
			}
		}

		return elementMatcher( matchers );
	}

	function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
		var bySet = setMatchers.length > 0,
			byElement = elementMatchers.length > 0,
			superMatcher = function( seed, context, xml, results, outermost ) {
				var elem, j, matcher,
					matchedCount = 0,
					i = "0",
					unmatched = seed && [],
					setMatched = [],
					contextBackup = outermostContext,

					// We must always have either seed elements or outermost context
					elems = seed || byElement && Expr.find.TAG( "*", outermost ),

					// Use integer dirruns iff this is the outermost matcher
					dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 );

				if ( outermost ) {

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					outermostContext = context == document || context || outermost;
				}

				// Add elements passing elementMatchers directly to results
				for ( ; ( elem = elems[ i ] ) != null; i++ ) {
					if ( byElement && elem ) {
						j = 0;

						// Support: IE 11+, Edge 17 - 18+
						// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
						// two documents; shallow comparisons work.
						// eslint-disable-next-line eqeqeq
						if ( !context && elem.ownerDocument != document ) {
							setDocument( elem );
							xml = !documentIsHTML;
						}
						while ( ( matcher = elementMatchers[ j++ ] ) ) {
							if ( matcher( elem, context || document, xml ) ) {
								push.call( results, elem );
								break;
							}
						}
						if ( outermost ) {
							dirruns = dirrunsUnique;
						}
					}

					// Track unmatched elements for set filters
					if ( bySet ) {

						// They will have gone through all possible matchers
						if ( ( elem = !matcher && elem ) ) {
							matchedCount--;
						}

						// Lengthen the array for every element, matched or not
						if ( seed ) {
							unmatched.push( elem );
						}
					}
				}

				// `i` is now the count of elements visited above, and adding it to `matchedCount`
				// makes the latter nonnegative.
				matchedCount += i;

				// Apply set filters to unmatched elements
				// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
				// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
				// no element matchers and no seed.
				// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
				// case, which will result in a "00" `matchedCount` that differs from `i` but is also
				// numerically zero.
				if ( bySet && i !== matchedCount ) {
					j = 0;
					while ( ( matcher = setMatchers[ j++ ] ) ) {
						matcher( unmatched, setMatched, context, xml );
					}

					if ( seed ) {

						// Reintegrate element matches to eliminate the need for sorting
						if ( matchedCount > 0 ) {
							while ( i-- ) {
								if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
									setMatched[ i ] = pop.call( results );
								}
							}
						}

						// Discard index placeholder values to get only actual matches
						setMatched = condense( setMatched );
					}

					// Add matches to results
					push.apply( results, setMatched );

					// Seedless set matches succeeding multiple successful matchers stipulate sorting
					if ( outermost && !seed && setMatched.length > 0 &&
						( matchedCount + setMatchers.length ) > 1 ) {

						jQuery$1.uniqueSort( results );
					}
				}

				// Override manipulation of globals by nested matchers
				if ( outermost ) {
					dirruns = dirrunsUnique;
					outermostContext = contextBackup;
				}

				return unmatched;
			};

		return bySet ?
			markFunction( superMatcher ) :
			superMatcher;
	}

	function compile( selector, match /* Internal Use Only */ ) {
		var i,
			setMatchers = [],
			elementMatchers = [],
			cached = compilerCache[ selector + " " ];

		if ( !cached ) {

			// Generate a function of recursive functions that can be used to check each element
			if ( !match ) {
				match = tokenize( selector );
			}
			i = match.length;
			while ( i-- ) {
				cached = matcherFromTokens( match[ i ] );
				if ( cached[ expando ] ) {
					setMatchers.push( cached );
				} else {
					elementMatchers.push( cached );
				}
			}

			// Cache the compiled function
			cached = compilerCache( selector,
				matcherFromGroupMatchers( elementMatchers, setMatchers ) );

			// Save selector and tokenization
			cached.selector = selector;
		}
		return cached;
	}

	/**
	 * A low-level selection function that works with jQuery's compiled
	 *  selector functions
	 * @param {String|Function} selector A selector or a pre-compiled
	 *  selector function built with jQuery selector compile
	 * @param {Element} context
	 * @param {Array} [results]
	 * @param {Array} [seed] A set of elements to match against
	 */
	function select( selector, context, results, seed ) {
		var i, tokens, token, type, find,
			compiled = typeof selector === "function" && selector,
			match = !seed && tokenize( ( selector = compiled.selector || selector ) );

		results = results || [];

		// Try to minimize operations if there is only one selector in the list and no seed
		// (the latter of which guarantees us context)
		if ( match.length === 1 ) {

			// Reduce context if the leading compound selector is an ID
			tokens = match[ 0 ] = match[ 0 ].slice( 0 );
			if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
					context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

				context = ( Expr.find.ID(
					token.matches[ 0 ].replace( runescape, funescape ),
					context
				) || [] )[ 0 ];
				if ( !context ) {
					return results;

				// Precompiled matchers will still verify ancestry, so step up a level
				} else if ( compiled ) {
					context = context.parentNode;
				}

				selector = selector.slice( tokens.shift().value.length );
			}

			// Fetch a seed set for right-to-left matching
			i = matchExpr.needsContext.test( selector ) ? 0 : tokens.length;
			while ( i-- ) {
				token = tokens[ i ];

				// Abort if we hit a combinator
				if ( Expr.relative[ ( type = token.type ) ] ) {
					break;
				}
				if ( ( find = Expr.find[ type ] ) ) {

					// Search, expanding context for leading sibling combinators
					if ( ( seed = find(
						token.matches[ 0 ].replace( runescape, funescape ),
						rsibling.test( tokens[ 0 ].type ) &&
							testContext( context.parentNode ) || context
					) ) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && toSelector( tokens );
						if ( !selector ) {
							push.apply( results, seed );
							return results;
						}

						break;
					}
				}
			}
		}

		// Compile and execute a filtering function if one is not provided
		// Provide `match` to avoid retokenization if we modified the selector above
		( compiled || compile( selector, match ) )(
			seed,
			context,
			!documentIsHTML,
			results,
			!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
		);
		return results;
	}

	// Initialize against the default document
	setDocument();

	jQuery$1.find = find;

	} )();

	function dir( elem, dir, until ) {
		var matched = [],
			truncate = until !== undefined;

		while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
			if ( elem.nodeType === 1 ) {
				if ( truncate && jQuery$1( elem ).is( until ) ) {
					break;
				}
				matched.push( elem );
			}
		}
		return matched;
	}

	function siblings( n, elem ) {
		var matched = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				matched.push( n );
			}
		}

		return matched;
	}

	var rneedsContext = jQuery$1.expr.match.needsContext;

	// rsingleTag matches a string consisting of a single HTML element with no attributes
	// and captures the element's name
	var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );

	// Implement the identical functionality for filter and not
	function winnow( elements, qualifier, not ) {
		if ( typeof qualifier === "function" ) {
			return jQuery$1.grep( elements, function( elem, i ) {
				return !!qualifier.call( elem, i, elem ) !== not;
			} );
		}

		// Single element
		if ( qualifier.nodeType ) {
			return jQuery$1.grep( elements, function( elem ) {
				return ( elem === qualifier ) !== not;
			} );
		}

		// Arraylike of elements (jQuery, arguments, Array)
		if ( typeof qualifier !== "string" ) {
			return jQuery$1.grep( elements, function( elem ) {
				return ( indexOf$1.call( qualifier, elem ) > -1 ) !== not;
			} );
		}

		// Filtered directly for both simple and complex selectors
		return jQuery$1.filter( qualifier, elements, not );
	}

	jQuery$1.filter = function( expr, elems, not ) {
		var elem = elems[ 0 ];

		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		if ( elems.length === 1 && elem.nodeType === 1 ) {
			return jQuery$1.find.matchesSelector( elem, expr ) ? [ elem ] : [];
		}

		return jQuery$1.find.matches( expr, jQuery$1.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		} ) );
	};

	jQuery$1.fn.extend( {
		find: function( selector ) {
			var i, ret,
				len = this.length,
				self = this;

			if ( typeof selector !== "string" ) {
				return this.pushStack( jQuery$1( selector ).filter( function() {
					for ( i = 0; i < len; i++ ) {
						if ( jQuery$1.contains( self[ i ], this ) ) {
							return true;
						}
					}
				} ) );
			}

			ret = this.pushStack( [] );

			for ( i = 0; i < len; i++ ) {
				jQuery$1.find( selector, self[ i ], ret );
			}

			return len > 1 ? jQuery$1.uniqueSort( ret ) : ret;
		},
		filter: function( selector ) {
			return this.pushStack( winnow( this, selector || [], false ) );
		},
		not: function( selector ) {
			return this.pushStack( winnow( this, selector || [], true ) );
		},
		is: function( selector ) {
			return !!winnow(
				this,

				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				typeof selector === "string" && rneedsContext.test( selector ) ?
					jQuery$1( selector ) :
					selector || [],
				false
			).length;
		}
	} );

	// Initialize a jQuery object

	// A central reference to the root jQuery(document)
	var rootjQuery,

		// A simple way to check for HTML strings
		// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
		// Strict HTML recognition (#11290: must start with <)
		// Shortcut simple #id case for speed
		rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

		init = jQuery$1.fn.init = function( selector, context, root ) {
			var match, elem;

			// HANDLE: $(""), $(null), $(undefined), $(false)
			if ( !selector ) {
				return this;
			}

			// Method init() accepts an alternate rootjQuery
			// so migrate can support jQuery.sub (gh-2101)
			root = root || rootjQuery;

			// Handle HTML strings
			if ( typeof selector === "string" ) {
				if ( selector[ 0 ] === "<" &&
					selector[ selector.length - 1 ] === ">" &&
					selector.length >= 3 ) {

					// Assume that strings that start and end with <> are HTML and skip the regex check
					match = [ null, selector, null ];

				} else {
					match = rquickExpr.exec( selector );
				}

				// Match html or make sure no context is specified for #id
				if ( match && ( match[ 1 ] || !context ) ) {

					// HANDLE: $(html) -> $(array)
					if ( match[ 1 ] ) {
						context = context instanceof jQuery$1 ? context[ 0 ] : context;

						// Option to run scripts is true for back-compat
						// Intentionally let the error be thrown if parseHTML is not present
						jQuery$1.merge( this, jQuery$1.parseHTML(
							match[ 1 ],
							context && context.nodeType ? context.ownerDocument || context : document$1,
							true
						) );

						// HANDLE: $(html, props)
						if ( rsingleTag.test( match[ 1 ] ) && jQuery$1.isPlainObject( context ) ) {
							for ( match in context ) {

								// Properties of context are called as methods if possible
								if ( typeof this[ match ] === "function" ) {
									this[ match ]( context[ match ] );

								// ...and otherwise set as attributes
								} else {
									this.attr( match, context[ match ] );
								}
							}
						}

						return this;

					// HANDLE: $(#id)
					} else {
						elem = document$1.getElementById( match[ 2 ] );

						if ( elem ) {

							// Inject the element directly into the jQuery object
							this[ 0 ] = elem;
							this.length = 1;
						}
						return this;
					}

				// HANDLE: $(expr, $(...))
				} else if ( !context || context.jquery ) {
					return ( context || root ).find( selector );

				// HANDLE: $(expr, context)
				// (which is just equivalent to: $(context).find(expr)
				} else {
					return this.constructor( context ).find( selector );
				}

			// HANDLE: $(DOMElement)
			} else if ( selector.nodeType ) {
				this[ 0 ] = selector;
				this.length = 1;
				return this;

			// HANDLE: $(function)
			// Shortcut for document ready
			} else if ( typeof selector === "function" ) {
				return root.ready !== undefined ?
					root.ready( selector ) :

					// Execute immediately if ready is not present
					selector( jQuery$1 );
			}

			return jQuery$1.makeArray( selector, this );
		};

	// Give the init function the jQuery prototype for later instantiation
	init.prototype = jQuery$1.fn;

	// Initialize central reference
	rootjQuery = jQuery$1( document$1 );

	var rparentsprev = /^(?:parents|prev(?:Until|All))/,

		// Methods guaranteed to produce a unique set when starting from a unique set
		guaranteedUnique = {
			children: true,
			contents: true,
			next: true,
			prev: true
		};

	jQuery$1.fn.extend( {
		has: function( target ) {
			var targets = jQuery$1( target, this ),
				l = targets.length;

			return this.filter( function() {
				var i = 0;
				for ( ; i < l; i++ ) {
					if ( jQuery$1.contains( this, targets[ i ] ) ) {
						return true;
					}
				}
			} );
		},

		closest: function( selectors, context ) {
			var cur,
				i = 0,
				l = this.length,
				matched = [],
				targets = typeof selectors !== "string" && jQuery$1( selectors );

			// Positional selectors never match, since there's no _selection_ context
			if ( !rneedsContext.test( selectors ) ) {
				for ( ; i < l; i++ ) {
					for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

						// Always skip document fragments
						if ( cur.nodeType < 11 && ( targets ?
							targets.index( cur ) > -1 :

							// Don't pass non-elements to jQuery#find
							cur.nodeType === 1 &&
								jQuery$1.find.matchesSelector( cur, selectors ) ) ) {

							matched.push( cur );
							break;
						}
					}
				}
			}

			return this.pushStack( matched.length > 1 ? jQuery$1.uniqueSort( matched ) : matched );
		},

		// Determine the position of an element within the set
		index: function( elem ) {

			// No argument, return index in parent
			if ( !elem ) {
				return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
			}

			// Index in selector
			if ( typeof elem === "string" ) {
				return indexOf$1.call( jQuery$1( elem ), this[ 0 ] );
			}

			// Locate the position of the desired element
			return indexOf$1.call( this,

				// If it receives a jQuery object, the first element is used
				elem.jquery ? elem[ 0 ] : elem
			);
		},

		add: function( selector, context ) {
			return this.pushStack(
				jQuery$1.uniqueSort(
					jQuery$1.merge( this.get(), jQuery$1( selector, context ) )
				)
			);
		},

		addBack: function( selector ) {
			return this.add( selector == null ?
				this.prevObject : this.prevObject.filter( selector )
			);
		}
	} );

	function sibling( cur, dir ) {
		while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
		return cur;
	}

	jQuery$1.each( {
		parent: function( elem ) {
			var parent = elem.parentNode;
			return parent && parent.nodeType !== 11 ? parent : null;
		},
		parents: function( elem ) {
			return dir( elem, "parentNode" );
		},
		parentsUntil: function( elem, _i, until ) {
			return dir( elem, "parentNode", until );
		},
		next: function( elem ) {
			return sibling( elem, "nextSibling" );
		},
		prev: function( elem ) {
			return sibling( elem, "previousSibling" );
		},
		nextAll: function( elem ) {
			return dir( elem, "nextSibling" );
		},
		prevAll: function( elem ) {
			return dir( elem, "previousSibling" );
		},
		nextUntil: function( elem, _i, until ) {
			return dir( elem, "nextSibling", until );
		},
		prevUntil: function( elem, _i, until ) {
			return dir( elem, "previousSibling", until );
		},
		siblings: function( elem ) {
			return siblings( ( elem.parentNode || {} ).firstChild, elem );
		},
		children: function( elem ) {
			return siblings( elem.firstChild );
		},
		contents: function( elem ) {
			if ( elem.contentDocument != null &&

				// Support: IE 11+
				// <object> elements with no `data` attribute has an object
				// `contentDocument` with a `null` prototype.
				getProto( elem.contentDocument ) ) {

				return elem.contentDocument;
			}

			// Support: IE 9 - 11+
			// Treat the template element as a regular one in browsers that
			// don't support it.
			if ( nodeName( elem, "template" ) ) {
				elem = elem.content || elem;
			}

			return jQuery$1.merge( [], elem.childNodes );
		}
	}, function( name, fn ) {
		jQuery$1.fn[ name ] = function( until, selector ) {
			var matched = jQuery$1.map( this, fn, until );

			if ( name.slice( -5 ) !== "Until" ) {
				selector = until;
			}

			if ( selector && typeof selector === "string" ) {
				matched = jQuery$1.filter( selector, matched );
			}

			if ( this.length > 1 ) {

				// Remove duplicates
				if ( !guaranteedUnique[ name ] ) {
					jQuery$1.uniqueSort( matched );
				}

				// Reverse order for parents* and prev-derivatives
				if ( rparentsprev.test( name ) ) {
					matched.reverse();
				}
			}

			return this.pushStack( matched );
		};
	} );

	// Only count HTML whitespace
	// Other whitespace should count in values
	// https://infra.spec.whatwg.org/#ascii-whitespace
	var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );

	// Convert String-formatted options into Object-formatted ones
	function createOptions( options ) {
		var object = {};
		jQuery$1.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
			object[ flag ] = true;
		} );
		return object;
	}

	/*
	 * Create a callback list using the following parameters:
	 *
	 *	options: an optional list of space-separated options that will change how
	 *			the callback list behaves or a more traditional option object
	 *
	 * By default a callback list will act like an event callback list and can be
	 * "fired" multiple times.
	 *
	 * Possible options:
	 *
	 *	once:			will ensure the callback list can only be fired once (like a Deferred)
	 *
	 *	memory:			will keep track of previous values and will call any callback added
	 *					after the list has been fired right away with the latest "memorized"
	 *					values (like a Deferred)
	 *
	 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
	 *
	 *	stopOnFalse:	interrupt callings when a callback returns false
	 *
	 */
	jQuery$1.Callbacks = function( options ) {

		// Convert options from String-formatted to Object-formatted if needed
		// (we check in cache first)
		options = typeof options === "string" ?
			createOptions( options ) :
			jQuery$1.extend( {}, options );

		var // Flag to know if list is currently firing
			firing,

			// Last fire value for non-forgettable lists
			memory,

			// Flag to know if list was already fired
			fired,

			// Flag to prevent firing
			locked,

			// Actual callback list
			list = [],

			// Queue of execution data for repeatable lists
			queue = [],

			// Index of currently firing callback (modified by add/remove as needed)
			firingIndex = -1,

			// Fire callbacks
			fire = function() {

				// Enforce single-firing
				locked = locked || options.once;

				// Execute callbacks for all pending executions,
				// respecting firingIndex overrides and runtime changes
				fired = firing = true;
				for ( ; queue.length; firingIndex = -1 ) {
					memory = queue.shift();
					while ( ++firingIndex < list.length ) {

						// Run callback and check for early termination
						if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
							options.stopOnFalse ) {

							// Jump to end and forget the data so .add doesn't re-fire
							firingIndex = list.length;
							memory = false;
						}
					}
				}

				// Forget the data if we're done with it
				if ( !options.memory ) {
					memory = false;
				}

				firing = false;

				// Clean up if we're done firing for good
				if ( locked ) {

					// Keep an empty list if we have data for future add calls
					if ( memory ) {
						list = [];

					// Otherwise, this object is spent
					} else {
						list = "";
					}
				}
			},

			// Actual Callbacks object
			self = {

				// Add a callback or a collection of callbacks to the list
				add: function() {
					if ( list ) {

						// If we have memory from a past run, we should fire after adding
						if ( memory && !firing ) {
							firingIndex = list.length - 1;
							queue.push( memory );
						}

						( function add( args ) {
							jQuery$1.each( args, function( _, arg ) {
								if ( typeof arg === "function" ) {
									if ( !options.unique || !self.has( arg ) ) {
										list.push( arg );
									}
								} else if ( arg && arg.length && toType( arg ) !== "string" ) {

									// Inspect recursively
									add( arg );
								}
							} );
						} )( arguments );

						if ( memory && !firing ) {
							fire();
						}
					}
					return this;
				},

				// Remove a callback from the list
				remove: function() {
					jQuery$1.each( arguments, function( _, arg ) {
						var index;
						while ( ( index = jQuery$1.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );

							// Handle firing indexes
							if ( index <= firingIndex ) {
								firingIndex--;
							}
						}
					} );
					return this;
				},

				// Check if a given callback is in the list.
				// If no argument is given, return whether or not list has callbacks attached.
				has: function( fn ) {
					return fn ?
						jQuery$1.inArray( fn, list ) > -1 :
						list.length > 0;
				},

				// Remove all callbacks from the list
				empty: function() {
					if ( list ) {
						list = [];
					}
					return this;
				},

				// Disable .fire and .add
				// Abort any current/pending executions
				// Clear all callbacks and values
				disable: function() {
					locked = queue = [];
					list = memory = "";
					return this;
				},
				disabled: function() {
					return !list;
				},

				// Disable .fire
				// Also disable .add unless we have memory (since it would have no effect)
				// Abort any pending executions
				lock: function() {
					locked = queue = [];
					if ( !memory && !firing ) {
						list = memory = "";
					}
					return this;
				},
				locked: function() {
					return !!locked;
				},

				// Call all callbacks with the given context and arguments
				fireWith: function( context, args ) {
					if ( !locked ) {
						args = args || [];
						args = [ context, args.slice ? args.slice() : args ];
						queue.push( args );
						if ( !firing ) {
							fire();
						}
					}
					return this;
				},

				// Call all the callbacks with the given arguments
				fire: function() {
					self.fireWith( this, arguments );
					return this;
				},

				// To know if the callbacks have already been called at least once
				fired: function() {
					return !!fired;
				}
			};

		return self;
	};

	function Identity( v ) {
		return v;
	}
	function Thrower( ex ) {
		throw ex;
	}

	function adoptValue( value, resolve, reject, noValue ) {
		var method;

		try {

			// Check for promise aspect first to privilege synchronous behavior
			if ( value && typeof( method = value.promise ) === "function" ) {
				method.call( value ).done( resolve ).fail( reject );

			// Other thenables
			} else if ( value && typeof( method = value.then ) === "function" ) {
				method.call( value, resolve, reject );

			// Other non-thenables
			} else {

				// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
				// * false: [ value ].slice( 0 ) => resolve( value )
				// * true: [ value ].slice( 1 ) => resolve()
				resolve.apply( undefined, [ value ].slice( noValue ) );
			}

		// For Promises/A+, convert exceptions into rejections
		// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
		// Deferred#then to conditionally suppress rejection.
		} catch ( value ) {
			reject( value );
		}
	}

	jQuery$1.extend( {

		Deferred: function( func ) {
			var tuples = [

					// action, add listener, callbacks,
					// ... .then handlers, argument index, [final state]
					[ "notify", "progress", jQuery$1.Callbacks( "memory" ),
						jQuery$1.Callbacks( "memory" ), 2 ],
					[ "resolve", "done", jQuery$1.Callbacks( "once memory" ),
						jQuery$1.Callbacks( "once memory" ), 0, "resolved" ],
					[ "reject", "fail", jQuery$1.Callbacks( "once memory" ),
						jQuery$1.Callbacks( "once memory" ), 1, "rejected" ]
				],
				state = "pending",
				promise = {
					state: function() {
						return state;
					},
					always: function() {
						deferred.done( arguments ).fail( arguments );
						return this;
					},
					catch: function( fn ) {
						return promise.then( null, fn );
					},

					// Keep pipe for back-compat
					pipe: function( /* fnDone, fnFail, fnProgress */ ) {
						var fns = arguments;

						return jQuery$1.Deferred( function( newDefer ) {
							jQuery$1.each( tuples, function( _i, tuple ) {

								// Map tuples (progress, done, fail) to arguments (done, fail, progress)
								var fn = typeof fns[ tuple[ 4 ] ] === "function" &&
									fns[ tuple[ 4 ] ];

								// deferred.progress(function() { bind to newDefer or newDefer.notify })
								// deferred.done(function() { bind to newDefer or newDefer.resolve })
								// deferred.fail(function() { bind to newDefer or newDefer.reject })
								deferred[ tuple[ 1 ] ]( function() {
									var returned = fn && fn.apply( this, arguments );
									if ( returned && typeof returned.promise === "function" ) {
										returned.promise()
											.progress( newDefer.notify )
											.done( newDefer.resolve )
											.fail( newDefer.reject );
									} else {
										newDefer[ tuple[ 0 ] + "With" ](
											this,
											fn ? [ returned ] : arguments
										);
									}
								} );
							} );
							fns = null;
						} ).promise();
					},
					then: function( onFulfilled, onRejected, onProgress ) {
						var maxDepth = 0;
						function resolve( depth, deferred, handler, special ) {
							return function() {
								var that = this,
									args = arguments,
									mightThrow = function() {
										var returned, then;

										// Support: Promises/A+ section 2.3.3.3.3
										// https://promisesaplus.com/#point-59
										// Ignore double-resolution attempts
										if ( depth < maxDepth ) {
											return;
										}

										returned = handler.apply( that, args );

										// Support: Promises/A+ section 2.3.1
										// https://promisesaplus.com/#point-48
										if ( returned === deferred.promise() ) {
											throw new TypeError( "Thenable self-resolution" );
										}

										// Support: Promises/A+ sections 2.3.3.1, 3.5
										// https://promisesaplus.com/#point-54
										// https://promisesaplus.com/#point-75
										// Retrieve `then` only once
										then = returned &&

											// Support: Promises/A+ section 2.3.4
											// https://promisesaplus.com/#point-64
											// Only check objects and functions for thenability
											( typeof returned === "object" ||
												typeof returned === "function" ) &&
											returned.then;

										// Handle a returned thenable
										if ( typeof then === "function" ) {

											// Special processors (notify) just wait for resolution
											if ( special ) {
												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special )
												);

											// Normal processors (resolve) also hook into progress
											} else {

												// ...and disregard older resolution values
												maxDepth++;

												then.call(
													returned,
													resolve( maxDepth, deferred, Identity, special ),
													resolve( maxDepth, deferred, Thrower, special ),
													resolve( maxDepth, deferred, Identity,
														deferred.notifyWith )
												);
											}

										// Handle all other returned values
										} else {

											// Only substitute handlers pass on context
											// and multiple values (non-spec behavior)
											if ( handler !== Identity ) {
												that = undefined;
												args = [ returned ];
											}

											// Process the value(s)
											// Default process is resolve
											( special || deferred.resolveWith )( that, args );
										}
									},

									// Only normal processors (resolve) catch and reject exceptions
									process = special ?
										mightThrow :
										function() {
											try {
												mightThrow();
											} catch ( e ) {

												if ( jQuery$1.Deferred.exceptionHook ) {
													jQuery$1.Deferred.exceptionHook( e,
														process.stackTrace );
												}

												// Support: Promises/A+ section 2.3.3.3.4.1
												// https://promisesaplus.com/#point-61
												// Ignore post-resolution exceptions
												if ( depth + 1 >= maxDepth ) {

													// Only substitute handlers pass on context
													// and multiple values (non-spec behavior)
													if ( handler !== Thrower ) {
														that = undefined;
														args = [ e ];
													}

													deferred.rejectWith( that, args );
												}
											}
										};

								// Support: Promises/A+ section 2.3.3.3.1
								// https://promisesaplus.com/#point-57
								// Re-resolve promises immediately to dodge false rejection from
								// subsequent errors
								if ( depth ) {
									process();
								} else {

									// Call an optional hook to record the stack, in case of exception
									// since it's otherwise lost when execution goes async
									if ( jQuery$1.Deferred.getStackHook ) {
										process.stackTrace = jQuery$1.Deferred.getStackHook();
									}
									window.setTimeout( process );
								}
							};
						}

						return jQuery$1.Deferred( function( newDefer ) {

							// progress_handlers.add( ... )
							tuples[ 0 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									typeof onProgress === "function" ?
										onProgress :
										Identity,
									newDefer.notifyWith
								)
							);

							// fulfilled_handlers.add( ... )
							tuples[ 1 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									typeof onFulfilled === "function" ?
										onFulfilled :
										Identity
								)
							);

							// rejected_handlers.add( ... )
							tuples[ 2 ][ 3 ].add(
								resolve(
									0,
									newDefer,
									typeof onRejected === "function" ?
										onRejected :
										Thrower
								)
							);
						} ).promise();
					},

					// Get a promise for this deferred
					// If obj is provided, the promise aspect is added to the object
					promise: function( obj ) {
						return obj != null ? jQuery$1.extend( obj, promise ) : promise;
					}
				},
				deferred = {};

			// Add list-specific methods
			jQuery$1.each( tuples, function( i, tuple ) {
				var list = tuple[ 2 ],
					stateString = tuple[ 5 ];

				// promise.progress = list.add
				// promise.done = list.add
				// promise.fail = list.add
				promise[ tuple[ 1 ] ] = list.add;

				// Handle state
				if ( stateString ) {
					list.add(
						function() {

							// state = "resolved" (i.e., fulfilled)
							// state = "rejected"
							state = stateString;
						},

						// rejected_callbacks.disable
						// fulfilled_callbacks.disable
						tuples[ 3 - i ][ 2 ].disable,

						// rejected_handlers.disable
						// fulfilled_handlers.disable
						tuples[ 3 - i ][ 3 ].disable,

						// progress_callbacks.lock
						tuples[ 0 ][ 2 ].lock,

						// progress_handlers.lock
						tuples[ 0 ][ 3 ].lock
					);
				}

				// progress_handlers.fire
				// fulfilled_handlers.fire
				// rejected_handlers.fire
				list.add( tuple[ 3 ].fire );

				// deferred.notify = function() { deferred.notifyWith(...) }
				// deferred.resolve = function() { deferred.resolveWith(...) }
				// deferred.reject = function() { deferred.rejectWith(...) }
				deferred[ tuple[ 0 ] ] = function() {
					deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
					return this;
				};

				// deferred.notifyWith = list.fireWith
				// deferred.resolveWith = list.fireWith
				// deferred.rejectWith = list.fireWith
				deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
			} );

			// Make the deferred a promise
			promise.promise( deferred );

			// Call given func if any
			if ( func ) {
				func.call( deferred, deferred );
			}

			// All done!
			return deferred;
		},

		// Deferred helper
		when: function( singleValue ) {
			var

				// count of uncompleted subordinates
				remaining = arguments.length,

				// count of unprocessed arguments
				i = remaining,

				// subordinate fulfillment data
				resolveContexts = Array( i ),
				resolveValues = slice$1.call( arguments ),

				// the master Deferred
				master = jQuery$1.Deferred(),

				// subordinate callback factory
				updateFunc = function( i ) {
					return function( value ) {
						resolveContexts[ i ] = this;
						resolveValues[ i ] = arguments.length > 1 ? slice$1.call( arguments ) : value;
						if ( !( --remaining ) ) {
							master.resolveWith( resolveContexts, resolveValues );
						}
					};
				};

			// Single- and empty arguments are adopted like Promise.resolve
			if ( remaining <= 1 ) {
				adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
					!remaining );

				// Use .then() to unwrap secondary thenables (cf. gh-3000)
				if ( master.state() === "pending" ||
					typeof( resolveValues[ i ] && resolveValues[ i ].then ) === "function" ) {

					return master.then();
				}
			}

			// Multiple arguments are aggregated like Promise.all array elements
			while ( i-- ) {
				adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
			}

			return master.promise();
		}
	} );

	// These usually indicate a programmer mistake during development,
	// warn about them ASAP rather than swallowing them by default.
	var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

	jQuery$1.Deferred.exceptionHook = function( error, stack ) {

		if ( error && rerrorNames.test( error.name ) ) {
			window.console.warn(
				"jQuery.Deferred exception: " + error.message,
				error.stack,
				stack
			);
		}
	};

	jQuery$1.readyException = function( error ) {
		window.setTimeout( function() {
			throw error;
		} );
	};

	// The deferred used on DOM ready
	var readyList = jQuery$1.Deferred();

	jQuery$1.fn.ready = function( fn ) {

		readyList
			.then( fn )

			// Wrap jQuery.readyException in a function so that the lookup
			// happens at the time of error handling instead of callback
			// registration.
			.catch( function( error ) {
				jQuery$1.readyException( error );
			} );

		return this;
	};

	jQuery$1.extend( {

		// Is the DOM ready to be used? Set to true once it occurs.
		isReady: false,

		// A counter to track how many items to wait for before
		// the ready event fires. See #6781
		readyWait: 1,

		// Handle when the DOM is ready
		ready: function( wait ) {

			// Abort if there are pending holds or we're already ready
			if ( wait === true ? --jQuery$1.readyWait : jQuery$1.isReady ) {
				return;
			}

			// Remember that the DOM is ready
			jQuery$1.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery$1.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.resolveWith( document$1, [ jQuery$1 ] );
		}
	} );

	jQuery$1.ready.then = readyList.then;

	// The ready event handler and self cleanup method
	function completed() {
		document$1.removeEventListener( "DOMContentLoaded", completed );
		window.removeEventListener( "load", completed );
		jQuery$1.ready();
	}

	// Catch cases where $(document).ready() is called
	// after the browser event has already occurred.
	if ( document$1.readyState !== "loading" ) {

		// Handle it asynchronously to allow scripts the opportunity to delay ready
		window.setTimeout( jQuery$1.ready );

	} else {

		// Use the handy event callback
		document$1.addEventListener( "DOMContentLoaded", completed );

		// A fallback to window.onload, that will always work
		window.addEventListener( "load", completed );
	}

	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
		var i = 0,
			len = elems.length,
			bulk = key == null;

		// Sets many values
		if ( toType( key ) === "object" ) {
			chainable = true;
			for ( i in key ) {
				access( elems, fn, i, key[ i ], true, emptyGet, raw );
			}

		// Sets one value
		} else if ( value !== undefined ) {
			chainable = true;

			if ( typeof value !== "function" ) {
				raw = true;
			}

			if ( bulk ) {

				// Bulk operations run against the entire set
				if ( raw ) {
					fn.call( elems, value );
					fn = null;

				// ...except when executing function values
				} else {
					bulk = fn;
					fn = function( elem, _key, value ) {
						return bulk.call( jQuery$1( elem ), value );
					};
				}
			}

			if ( fn ) {
				for ( ; i < len; i++ ) {
					fn(
						elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
					);
				}
			}
		}

		if ( chainable ) {
			return elems;
		}

		// Gets
		if ( bulk ) {
			return fn.call( elems );
		}

		return len ? fn( elems[ 0 ], key ) : emptyGet;
	};

	// Matches dashed string for camelizing
	var rdashAlpha = /-([a-z])/g;

	// Used by camelCase as callback to replace()
	function fcamelCase( _all, letter ) {
		return letter.toUpperCase();
	}

	// Convert dashed to camelCase
	function camelCase$1( string ) {
		return string.replace( rdashAlpha, fcamelCase );
	}

	/**
	 * Determines whether an object can have data
	 */
	function acceptData( owner ) {

		// Accepts only:
		//  - Node
		//    - Node.ELEMENT_NODE
		//    - Node.DOCUMENT_NODE
		//  - Object
		//    - Any
		return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
	}

	function Data() {
		this.expando = jQuery$1.expando + Data.uid++;
	}

	Data.uid = 1;

	Data.prototype = {

		cache: function( owner ) {

			// Check if the owner object already has a cache
			var value = owner[ this.expando ];

			// If not, create one
			if ( !value ) {
				value = Object.create( null );

				// We can accept data for non-element nodes in modern browsers,
				// but we should not, see #8335.
				// Always return an empty object.
				if ( acceptData( owner ) ) {

					// If it is a node unlikely to be stringify-ed or looped over
					// use plain assignment
					if ( owner.nodeType ) {
						owner[ this.expando ] = value;

					// Otherwise secure it in a non-enumerable property
					// configurable must be true to allow the property to be
					// deleted when data is removed
					} else {
						Object.defineProperty( owner, this.expando, {
							value: value,
							configurable: true
						} );
					}
				}
			}

			return value;
		},
		set: function( owner, data, value ) {
			var prop,
				cache = this.cache( owner );

			// Handle: [ owner, key, value ] args
			// Always use camelCase key (gh-2257)
			if ( typeof data === "string" ) {
				cache[ camelCase$1( data ) ] = value;

			// Handle: [ owner, { properties } ] args
			} else {

				// Copy the properties one-by-one to the cache object
				for ( prop in data ) {
					cache[ camelCase$1( prop ) ] = data[ prop ];
				}
			}
			return cache;
		},
		get: function( owner, key ) {
			return key === undefined ?
				this.cache( owner ) :

				// Always use camelCase key (gh-2257)
				owner[ this.expando ] && owner[ this.expando ][ camelCase$1( key ) ];
		},
		access: function( owner, key, value ) {

			// In cases where either:
			//
			//   1. No key was specified
			//   2. A string key was specified, but no value provided
			//
			// Take the "read" path and allow the get method to determine
			// which value to return, respectively either:
			//
			//   1. The entire cache object
			//   2. The data stored at the key
			//
			if ( key === undefined ||
					( ( key && typeof key === "string" ) && value === undefined ) ) {

				return this.get( owner, key );
			}

			// When the key is not a string, or both a key and value
			// are specified, set or extend (existing objects) with either:
			//
			//   1. An object of properties
			//   2. A key and value
			//
			this.set( owner, key, value );

			// Since the "set" path can have two possible entry points
			// return the expected data based on which path was taken[*]
			return value !== undefined ? value : key;
		},
		remove: function( owner, key ) {
			var i,
				cache = owner[ this.expando ];

			if ( cache === undefined ) {
				return;
			}

			if ( key !== undefined ) {

				// Support array or space separated string of keys
				if ( Array.isArray( key ) ) {

					// If key is an array of keys...
					// We always set camelCase keys, so remove that.
					key = key.map( camelCase$1 );
				} else {
					key = camelCase$1( key );

					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					key = key in cache ?
						[ key ] :
						( key.match( rnothtmlwhite ) || [] );
				}

				i = key.length;

				while ( i-- ) {
					delete cache[ key[ i ] ];
				}
			}

			// Remove the expando if there's no more data
			if ( key === undefined || jQuery$1.isEmptyObject( cache ) ) {

				// Support: Chrome <=35 - 45+
				// Webkit & Blink performance suffers when deleting properties
				// from DOM nodes, so set to undefined instead
				// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
				if ( owner.nodeType ) {
					owner[ this.expando ] = undefined;
				} else {
					delete owner[ this.expando ];
				}
			}
		},
		hasData: function( owner ) {
			var cache = owner[ this.expando ];
			return cache !== undefined && !jQuery$1.isEmptyObject( cache );
		}
	};

	var dataPriv = new Data();

	var dataUser = new Data();

	//	Implementation Summary
	//
	//	1. Enforce API surface and semantic compatibility with 1.9.x branch
	//	2. Improve the module's maintainability by reducing the storage
	//		paths to a single mechanism.
	//	3. Use the same single mechanism to support "private" and "user" data.
	//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
	//	5. Avoid exposing implementation details on user objects (eg. expando properties)
	//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

	var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
		rmultiDash = /[A-Z]/g;

	function getData$1( data ) {
		if ( data === "true" ) {
			return true;
		}

		if ( data === "false" ) {
			return false;
		}

		if ( data === "null" ) {
			return null;
		}

		// Only convert to a number if it doesn't change the string
		if ( data === +data + "" ) {
			return +data;
		}

		if ( rbrace.test( data ) ) {
			return JSON.parse( data );
		}

		return data;
	}

	function dataAttr( elem, key, data ) {
		var name;

		// If nothing was found internally, try to fetch any
		// data from the HTML5 data-* attribute
		if ( data === undefined && elem.nodeType === 1 ) {
			name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
			data = elem.getAttribute( name );

			if ( typeof data === "string" ) {
				try {
					data = getData$1( data );
				} catch ( e ) {}

				// Make sure we set the data so it isn't changed later
				dataUser.set( elem, key, data );
			} else {
				data = undefined;
			}
		}
		return data;
	}

	jQuery$1.extend( {
		hasData: function( elem ) {
			return dataUser.hasData( elem ) || dataPriv.hasData( elem );
		},

		data: function( elem, name, data ) {
			return dataUser.access( elem, name, data );
		},

		removeData: function( elem, name ) {
			dataUser.remove( elem, name );
		},

		// TODO: Now that all calls to _data and _removeData have been replaced
		// with direct calls to dataPriv methods, these can be deprecated.
		_data: function( elem, name, data ) {
			return dataPriv.access( elem, name, data );
		},

		_removeData: function( elem, name ) {
			dataPriv.remove( elem, name );
		}
	} );

	jQuery$1.fn.extend( {
		data: function( key, value ) {
			var i, name, data,
				elem = this[ 0 ],
				attrs = elem && elem.attributes;

			// Gets all values
			if ( key === undefined ) {
				if ( this.length ) {
					data = dataUser.get( elem );

					if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
						i = attrs.length;
						while ( i-- ) {

							// Support: IE 11+
							// The attrs elements can be null (#14894)
							if ( attrs[ i ] ) {
								name = attrs[ i ].name;
								if ( name.indexOf( "data-" ) === 0 ) {
									name = camelCase$1( name.slice( 5 ) );
									dataAttr( elem, name, data[ name ] );
								}
							}
						}
						dataPriv.set( elem, "hasDataAttrs", true );
					}
				}

				return data;
			}

			// Sets multiple values
			if ( typeof key === "object" ) {
				return this.each( function() {
					dataUser.set( this, key );
				} );
			}

			return access( this, function( value ) {
				var data;

				// The calling jQuery object (element matches) is not empty
				// (and therefore has an element appears at this[ 0 ]) and the
				// `value` parameter was not undefined. An empty jQuery object
				// will result in `undefined` for elem = this[ 0 ] which will
				// throw an exception if an attempt to read a data cache is made.
				if ( elem && value === undefined ) {

					// Attempt to get data from the cache
					// The key will always be camelCased in Data
					data = dataUser.get( elem, key );
					if ( data !== undefined ) {
						return data;
					}

					// Attempt to "discover" the data in
					// HTML5 custom data-* attrs
					data = dataAttr( elem, key );
					if ( data !== undefined ) {
						return data;
					}

					// We tried really hard, but the data doesn't exist.
					return;
				}

				// Set the data...
				this.each( function() {

					// We always store the camelCased key
					dataUser.set( this, key, value );
				} );
			}, null, value, arguments.length > 1, null, true );
		},

		removeData: function( key ) {
			return this.each( function() {
				dataUser.remove( this, key );
			} );
		}
	} );

	jQuery$1.extend( {
		queue: function( elem, type, data ) {
			var queue;

			if ( elem ) {
				type = ( type || "fx" ) + "queue";
				queue = dataPriv.get( elem, type );

				// Speed up dequeue by getting out quickly if this is just a lookup
				if ( data ) {
					if ( !queue || Array.isArray( data ) ) {
						queue = dataPriv.access( elem, type, jQuery$1.makeArray( data ) );
					} else {
						queue.push( data );
					}
				}
				return queue || [];
			}
		},

		dequeue: function( elem, type ) {
			type = type || "fx";

			var queue = jQuery$1.queue( elem, type ),
				startLength = queue.length,
				fn = queue.shift(),
				hooks = jQuery$1._queueHooks( elem, type ),
				next = function() {
					jQuery$1.dequeue( elem, type );
				};

			// If the fx queue is dequeued, always remove the progress sentinel
			if ( fn === "inprogress" ) {
				fn = queue.shift();
				startLength--;
			}

			if ( fn ) {

				// Add a progress sentinel to prevent the fx queue from being
				// automatically dequeued
				if ( type === "fx" ) {
					queue.unshift( "inprogress" );
				}

				// Clear up the last queue stop function
				delete hooks.stop;
				fn.call( elem, next, hooks );
			}

			if ( !startLength && hooks ) {
				hooks.empty.fire();
			}
		},

		// Not public - generate a queueHooks object, or return the current one
		_queueHooks: function( elem, type ) {
			var key = type + "queueHooks";
			return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
				empty: jQuery$1.Callbacks( "once memory" ).add( function() {
					dataPriv.remove( elem, [ type + "queue", key ] );
				} )
			} );
		}
	} );

	jQuery$1.fn.extend( {
		queue: function( type, data ) {
			var setter = 2;

			if ( typeof type !== "string" ) {
				data = type;
				type = "fx";
				setter--;
			}

			if ( arguments.length < setter ) {
				return jQuery$1.queue( this[ 0 ], type );
			}

			return data === undefined ?
				this :
				this.each( function() {
					var queue = jQuery$1.queue( this, type, data );

					// Ensure a hooks for this queue
					jQuery$1._queueHooks( this, type );

					if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
						jQuery$1.dequeue( this, type );
					}
				} );
		},
		dequeue: function( type ) {
			return this.each( function() {
				jQuery$1.dequeue( this, type );
			} );
		},
		clearQueue: function( type ) {
			return this.queue( type || "fx", [] );
		},

		// Get a promise resolved when queues of a certain type
		// are emptied (fx is the type by default)
		promise: function( type, obj ) {
			var tmp,
				count = 1,
				defer = jQuery$1.Deferred(),
				elements = this,
				i = this.length,
				resolve = function() {
					if ( !( --count ) ) {
						defer.resolveWith( elements, [ elements ] );
					}
				};

			if ( typeof type !== "string" ) {
				obj = type;
				type = undefined;
			}
			type = type || "fx";

			while ( i-- ) {
				tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
				if ( tmp && tmp.empty ) {
					count++;
					tmp.empty.add( resolve );
				}
			}
			resolve();
			return defer.promise( obj );
		}
	} );

	var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

	var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );

	var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

	// isHiddenWithinTree reports if an element has a non-"none" display style (inline and/or
	// through the CSS cascade), which is useful in deciding whether or not to make it visible.
	// It differs from the :hidden selector (jQuery.expr.pseudos.hidden) in two important ways:
	// * A hidden ancestor does not force an element to be classified as hidden.
	// * Being disconnected from the document does not force an element to be classified as hidden.
	// These differences improve the behavior of .toggle() et al. when applied to elements that are
	// detached or contained within hidden ancestors (gh-2404, gh-2863).
	function isHiddenWithinTree( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&
			jQuery$1.css( elem, "display" ) === "none";
	}

	var ralphaStart = /^[a-z]/,

		// The regex visualized:
		//
		//                         /----------\
		//                        |            |    /-------\
		//                        |  / Top  \  |   |         |
		//         /--- Border ---+-| Right  |-+---+- Width -+---\
		//        |                 | Bottom |                    |
		//        |                  \ Left /                     |
		//        |                                               |
		//        |                              /----------\     |
		//        |          /-------------\    |            |    |- END
		//        |         |               |   |  / Top  \  |    |
		//        |         |  / Margin  \  |   | | Right  | |    |
		//        |---------+-|           |-+---+-| Bottom |-+----|
		//        |            \ Padding /         \ Left /       |
		// BEGIN -|                                               |
		//        |                /---------\                    |
		//        |               |           |                   |
		//        |               |  / Min \  |    / Width  \     |
		//         \--------------+-|       |-+---|          |---/
		//                           \ Max /       \ Height /
		rautoPx = /^(?:Border(?:Top|Right|Bottom|Left)?(?:Width|)|(?:Margin|Padding)?(?:Top|Right|Bottom|Left)?|(?:Min|Max)?(?:Width|Height))$/;

	function isAutoPx( prop ) {

		// The first test is used to ensure that:
		// 1. The prop starts with a lowercase letter (as we uppercase it for the second regex).
		// 2. The prop is not empty.
		return ralphaStart.test( prop ) &&
			rautoPx.test( prop[ 0 ].toUpperCase() + prop.slice( 1 ) );
	}

	function adjustCSS( elem, prop, valueParts, tween ) {
		var adjusted, scale,
			maxIterations = 20,
			currentValue = tween ?
				function() {
					return tween.cur();
				} :
				function() {
					return jQuery$1.css( elem, prop, "" );
				},
			initial = currentValue(),
			unit = valueParts && valueParts[ 3 ] || ( isAutoPx( prop ) ? "px" : "" ),

			// Starting value computation is required for potential unit mismatches
			initialInUnit = elem.nodeType &&
				( !isAutoPx( prop ) || unit !== "px" && +initial ) &&
				rcssNum.exec( jQuery$1.css( elem, prop ) );

		if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

			// Support: Firefox <=54 - 66+
			// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
			initial = initial / 2;

			// Trust units reported by jQuery.css
			unit = unit || initialInUnit[ 3 ];

			// Iteratively approximate from a nonzero starting point
			initialInUnit = +initial || 1;

			while ( maxIterations-- ) {

				// Evaluate and update our best guess (doubling guesses that zero out).
				// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
				jQuery$1.style( elem, prop, initialInUnit + unit );
				if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
					maxIterations = 0;
				}
				initialInUnit = initialInUnit / scale;

			}

			initialInUnit = initialInUnit * 2;
			jQuery$1.style( elem, prop, initialInUnit + unit );

			// Make sure we update the tween properties later on
			valueParts = valueParts || [];
		}

		if ( valueParts ) {
			initialInUnit = +initialInUnit || +initial || 0;

			// Apply relative offset (+=/-=) if specified
			adjusted = valueParts[ 1 ] ?
				initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
				+valueParts[ 2 ];
			if ( tween ) {
				tween.unit = unit;
				tween.start = initialInUnit;
				tween.end = adjusted;
			}
		}
		return adjusted;
	}

	// Matches dashed string for camelizing
	var rmsPrefix = /^-ms-/;

	// Convert dashed to camelCase, handle vendor prefixes.
	// Used by the css & effects modules.
	// Support: IE <=9 - 11+, Edge 12 - 18+
	// Microsoft forgot to hump their vendor prefix (#9572)
	function cssCamelCase( string ) {
		return camelCase$1( string.replace( rmsPrefix, "ms-" ) );
	}

	var defaultDisplayMap = {};

	function getDefaultDisplay( elem ) {
		var temp,
			doc = elem.ownerDocument,
			nodeName = elem.nodeName,
			display = defaultDisplayMap[ nodeName ];

		if ( display ) {
			return display;
		}

		temp = doc.body.appendChild( doc.createElement( nodeName ) );
		display = jQuery$1.css( temp, "display" );

		temp.parentNode.removeChild( temp );

		if ( display === "none" ) {
			display = "block";
		}
		defaultDisplayMap[ nodeName ] = display;

		return display;
	}

	function showHide( elements, show ) {
		var display, elem,
			values = [],
			index = 0,
			length = elements.length;

		// Determine new display value for elements that need to change
		for ( ; index < length; index++ ) {
			elem = elements[ index ];
			if ( !elem.style ) {
				continue;
			}

			display = elem.style.display;
			if ( show ) {

				// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
				// check is required in this first loop unless we have a nonempty display value (either
				// inline or about-to-be-restored)
				if ( display === "none" ) {
					values[ index ] = dataPriv.get( elem, "display" ) || null;
					if ( !values[ index ] ) {
						elem.style.display = "";
					}
				}
				if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
					values[ index ] = getDefaultDisplay( elem );
				}
			} else {
				if ( display !== "none" ) {
					values[ index ] = "none";

					// Remember what we're overwriting
					dataPriv.set( elem, "display", display );
				}
			}
		}

		// Set the display of the elements in a second loop to avoid constant reflow
		for ( index = 0; index < length; index++ ) {
			if ( values[ index ] != null ) {
				elements[ index ].style.display = values[ index ];
			}
		}

		return elements;
	}

	jQuery$1.fn.extend( {
		show: function() {
			return showHide( this, true );
		},
		hide: function() {
			return showHide( this );
		},
		toggle: function( state ) {
			if ( typeof state === "boolean" ) {
				return state ? this.show() : this.hide();
			}

			return this.each( function() {
				if ( isHiddenWithinTree( this ) ) {
					jQuery$1( this ).show();
				} else {
					jQuery$1( this ).hide();
				}
			} );
		}
	} );

	var isAttached = function( elem ) {
			return jQuery$1.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery$1.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}

	var isAttached$1 = isAttached;

	// rtagName captures the name from the first start tag in a string of HTML
	// https://html.spec.whatwg.org/multipage/syntax.html#tag-open-state
	// https://html.spec.whatwg.org/multipage/syntax.html#tag-name-state
	var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

	var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );

	// We have to close these tags to support XHTML (#13200)
	var wrapMap = {

		// Table parts need to be wrapped with `<table>` or they're
		// stripped to their contents when put in a div.
		// XHTML parsers do not magically insert elements in the
		// same way that tag soup parsers do, so we cannot shorten
		// this by omitting <tbody> or other required elements.
		thead: [ 1, "<table>", "</table>" ],
		col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

		_default: [ 0, "", "" ]
	};

	wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
	wrapMap.th = wrapMap.td;

	function getAll( context, tag ) {

		// Support: IE <=9 - 11+
		// Use typeof to avoid zero-argument method invocation on host objects (#15151)
		var ret;

		if ( typeof context.getElementsByTagName !== "undefined" ) {
			ret = context.getElementsByTagName( tag || "*" );

		} else if ( typeof context.querySelectorAll !== "undefined" ) {
			ret = context.querySelectorAll( tag || "*" );

		} else {
			ret = [];
		}

		if ( tag === undefined || tag && nodeName( context, tag ) ) {
			return jQuery$1.merge( [ context ], ret );
		}

		return ret;
	}

	// Mark scripts as having already been evaluated
	function setGlobalEval( elems, refElements ) {
		var i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			dataPriv.set(
				elems[ i ],
				"globalEval",
				!refElements || dataPriv.get( refElements[ i ], "globalEval" )
			);
		}
	}

	var rhtml = /<|&#?\w+;/;

	function buildFragment( elems, context, scripts, selection, ignored ) {
		var elem, tmp, tag, wrap, attached, j,
			fragment = context.createDocumentFragment(),
			nodes = [],
			i = 0,
			l = elems.length;

		for ( ; i < l; i++ ) {
			elem = elems[ i ];

			if ( elem || elem === 0 ) {

				// Add nodes directly
				if ( toType( elem ) === "object" ) {
					jQuery$1.merge( nodes, elem.nodeType ? [ elem ] : elem );

				// Convert non-html into a text node
				} else if ( !rhtml.test( elem ) ) {
					nodes.push( context.createTextNode( elem ) );

				// Convert html into DOM nodes
				} else {
					tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

					// Deserialize a standard representation
					tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					tmp.innerHTML = wrap[ 1 ] + jQuery$1.htmlPrefilter( elem ) + wrap[ 2 ];

					// Descend through wrappers to the right content
					j = wrap[ 0 ];
					while ( j-- ) {
						tmp = tmp.lastChild;
					}

					jQuery$1.merge( nodes, tmp.childNodes );

					// Remember the top-level container
					tmp = fragment.firstChild;

					// Ensure the created nodes are orphaned (#12392)
					tmp.textContent = "";
				}
			}
		}

		// Remove wrapper from fragment
		fragment.textContent = "";

		i = 0;
		while ( ( elem = nodes[ i++ ] ) ) {

			// Skip elements already in the context collection (trac-4087)
			if ( selection && jQuery$1.inArray( elem, selection ) > -1 ) {
				if ( ignored ) {
					ignored.push( elem );
				}
				continue;
			}

			attached = isAttached$1( elem );

			// Append to fragment
			tmp = getAll( fragment.appendChild( elem ), "script" );

			// Preserve script evaluation history
			if ( attached ) {
				setGlobalEval( tmp );
			}

			// Capture executables
			if ( scripts ) {
				j = 0;
				while ( ( elem = tmp[ j++ ] ) ) {
					if ( rscriptType.test( elem.type || "" ) ) {
						scripts.push( elem );
					}
				}
			}
		}

		return fragment;
	}

	var rcheckableType = ( /^(?:checkbox|radio)$/i );

	var
		rkeyEvent = /^key/,
		rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
		rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

	function returnTrue() {
		return true;
	}

	function returnFalse() {
		return false;
	}

	// Support: IE <=9 - 11+
	// focus() and blur() are asynchronous, except when they are no-op.
	// So expect focus to be synchronous when the element is already active,
	// and blur to be synchronous when the element is not already active.
	// (focus and blur are always synchronous in other supported browsers,
	// this just defines when we can count on it).
	function expectSync( elem, type ) {
		return ( elem === document$1.activeElement ) === ( type === "focus" );
	}

	function on( elem, types, selector, data, fn, one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {

			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {

				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				on( elem, type, selector, data, types[ type ], one );
			}
			return elem;
		}

		if ( data == null && fn == null ) {

			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {

				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {

				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return elem;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {

				// Can use an empty set, since event contains the info
				jQuery$1().off( event );
				return origFn.apply( this, arguments );
			};

			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery$1.guid++ );
		}
		return elem.each( function() {
			jQuery$1.event.add( this, types, fn, data, selector );
		} );
	}

	/*
	 * Helper functions for managing events -- not part of the public interface.
	 * Props to Dean Edwards' addEvent library for many of the ideas.
	 */
	jQuery$1.event = {

		add: function( elem, types, handler, data, selector ) {

			var handleObjIn, eventHandle, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.get( elem );

			// Only attach events to objects that accept data
			if ( !acceptData( elem ) ) {
				return;
			}

			// Caller can pass in an object of custom data in lieu of the handler
			if ( handler.handler ) {
				handleObjIn = handler;
				handler = handleObjIn.handler;
				selector = handleObjIn.selector;
			}

			// Ensure that invalid selectors throw exceptions at attach time
			// Evaluate against documentElement in case elem is a non-element node (e.g., document)
			if ( selector ) {
				jQuery$1.find.matchesSelector( documentElement, selector );
			}

			// Make sure that the handler has a unique ID, used to find/remove it later
			if ( !handler.guid ) {
				handler.guid = jQuery$1.guid++;
			}

			// Init the element's event structure and main handler, if this is the first
			if ( !( events = elemData.events ) ) {
				events = elemData.events = Object.create( null );
			}
			if ( !( eventHandle = elemData.handle ) ) {
				eventHandle = elemData.handle = function( e ) {

					// Discard the second event of a jQuery.event.trigger() and
					// when an event is called after a page has unloaded
					return typeof jQuery$1 !== "undefined" && jQuery$1.event.triggered !== e.type ?
						jQuery$1.event.dispatch.apply( elem, arguments ) : undefined;
				};
			}

			// Handle multiple events separated by a space
			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// There *must* be a type, no attaching namespace-only handlers
				if ( !type ) {
					continue;
				}

				// If event changes its type, use the special event handlers for the changed type
				special = jQuery$1.event.special[ type ] || {};

				// If selector defined, determine special event api type, otherwise given type
				type = ( selector ? special.delegateType : special.bindType ) || type;

				// Update special based on newly reset type
				special = jQuery$1.event.special[ type ] || {};

				// handleObj is passed to all event handlers
				handleObj = jQuery$1.extend( {
					type: type,
					origType: origType,
					data: data,
					handler: handler,
					guid: handler.guid,
					selector: selector,
					needsContext: selector && jQuery$1.expr.match.needsContext.test( selector ),
					namespace: namespaces.join( "." )
				}, handleObjIn );

				// Init the event handler queue if we're the first
				if ( !( handlers = events[ type ] ) ) {
					handlers = events[ type ] = [];
					handlers.delegateCount = 0;

					// Only use addEventListener if the special events handler returns false
					if ( !special.setup ||
						special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

						if ( elem.addEventListener ) {
							elem.addEventListener( type, eventHandle );
						}
					}
				}

				if ( special.add ) {
					special.add.call( elem, handleObj );

					if ( !handleObj.handler.guid ) {
						handleObj.handler.guid = handler.guid;
					}
				}

				// Add to the element's handler list, delegates in front
				if ( selector ) {
					handlers.splice( handlers.delegateCount++, 0, handleObj );
				} else {
					handlers.push( handleObj );
				}
			}

		},

		// Detach an event or set of events from an element
		remove: function( elem, types, handler, selector, mappedTypes ) {

			var j, origCount, tmp,
				events, t, handleObj,
				special, handlers, type, namespaces, origType,
				elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

			if ( !elemData || !( events = elemData.events ) ) {
				return;
			}

			// Once for each type.namespace in types; type may be omitted
			types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
			t = types.length;
			while ( t-- ) {
				tmp = rtypenamespace.exec( types[ t ] ) || [];
				type = origType = tmp[ 1 ];
				namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

				// Unbind all events (on this namespace, if provided) for the element
				if ( !type ) {
					for ( type in events ) {
						jQuery$1.event.remove( elem, type + types[ t ], handler, selector, true );
					}
					continue;
				}

				special = jQuery$1.event.special[ type ] || {};
				type = ( selector ? special.delegateType : special.bindType ) || type;
				handlers = events[ type ] || [];
				tmp = tmp[ 2 ] &&
					new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

				// Remove matching events
				origCount = j = handlers.length;
				while ( j-- ) {
					handleObj = handlers[ j ];

					if ( ( mappedTypes || origType === handleObj.origType ) &&
						( !handler || handler.guid === handleObj.guid ) &&
						( !tmp || tmp.test( handleObj.namespace ) ) &&
						( !selector || selector === handleObj.selector ||
							selector === "**" && handleObj.selector ) ) {
						handlers.splice( j, 1 );

						if ( handleObj.selector ) {
							handlers.delegateCount--;
						}
						if ( special.remove ) {
							special.remove.call( elem, handleObj );
						}
					}
				}

				// Remove generic event handler if we removed something and no more handlers exist
				// (avoids potential for endless recursion during removal of special event handlers)
				if ( origCount && !handlers.length ) {
					if ( !special.teardown ||
						special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

						jQuery$1.removeEvent( elem, type, elemData.handle );
					}

					delete events[ type ];
				}
			}

			// Remove data and the expando if it's no longer used
			if ( jQuery$1.isEmptyObject( events ) ) {
				dataPriv.remove( elem, "handle events" );
			}
		},

		dispatch: function( nativeEvent ) {

			var i, j, ret, matched, handleObj, handlerQueue,
				args = new Array( arguments.length ),

				// Make a writable jQuery.Event from the native event object
				event = jQuery$1.event.fix( nativeEvent ),

				handlers = (
						dataPriv.get( this, "events" ) || Object.create( null )
					)[ event.type ] || [],
				special = jQuery$1.event.special[ event.type ] || {};

			// Use the fix-ed jQuery.Event rather than the (read-only) native event
			args[ 0 ] = event;

			for ( i = 1; i < arguments.length; i++ ) {
				args[ i ] = arguments[ i ];
			}

			event.delegateTarget = this;

			// Call the preDispatch hook for the mapped type, and let it bail if desired
			if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
				return;
			}

			// Determine handlers
			handlerQueue = jQuery$1.event.handlers.call( this, event, handlers );

			// Run delegates first; they may want to stop propagation beneath us
			i = 0;
			while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
				event.currentTarget = matched.elem;

				j = 0;
				while ( ( handleObj = matched.handlers[ j++ ] ) &&
					!event.isImmediatePropagationStopped() ) {

					// If the event is namespaced, then each handler is only invoked if it is
					// specially universal or its namespaces are a superset of the event's.
					if ( !event.rnamespace || handleObj.namespace === false ||
						event.rnamespace.test( handleObj.namespace ) ) {

						event.handleObj = handleObj;
						event.data = handleObj.data;

						ret = ( ( jQuery$1.event.special[ handleObj.origType ] || {} ).handle ||
							handleObj.handler ).apply( matched.elem, args );

						if ( ret !== undefined ) {
							if ( ( event.result = ret ) === false ) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					}
				}
			}

			// Call the postDispatch hook for the mapped type
			if ( special.postDispatch ) {
				special.postDispatch.call( this, event );
			}

			return event.result;
		},

		handlers: function( event, handlers ) {
			var i, handleObj, sel, matchedHandlers, matchedSelectors,
				handlerQueue = [],
				delegateCount = handlers.delegateCount,
				cur = event.target;

			// Find delegate handlers
			if ( delegateCount &&

				// Support: Firefox <=42 - 66+
				// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
				// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
				// Support: IE 11+
				// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
				!( event.type === "click" && event.button >= 1 ) ) {

				for ( ; cur !== this; cur = cur.parentNode || this ) {

					// Don't check non-elements (#13208)
					// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
					if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
						matchedHandlers = [];
						matchedSelectors = {};
						for ( i = 0; i < delegateCount; i++ ) {
							handleObj = handlers[ i ];

							// Don't conflict with Object.prototype properties (#13203)
							sel = handleObj.selector + " ";

							if ( matchedSelectors[ sel ] === undefined ) {
								matchedSelectors[ sel ] = handleObj.needsContext ?
									jQuery$1( sel, this ).index( cur ) > -1 :
									jQuery$1.find( sel, this, null, [ cur ] ).length;
							}
							if ( matchedSelectors[ sel ] ) {
								matchedHandlers.push( handleObj );
							}
						}
						if ( matchedHandlers.length ) {
							handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
						}
					}
				}
			}

			// Add the remaining (directly-bound) handlers
			cur = this;
			if ( delegateCount < handlers.length ) {
				handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
			}

			return handlerQueue;
		},

		addProp: function( name, hook ) {
			Object.defineProperty( jQuery$1.Event.prototype, name, {
				enumerable: true,
				configurable: true,

				get: typeof hook === "function" ?
					function() {
						if ( this.originalEvent ) {
								return hook( this.originalEvent );
						}
					} :
					function() {
						if ( this.originalEvent ) {
								return this.originalEvent[ name ];
						}
					},

				set: function( value ) {
					Object.defineProperty( this, name, {
						enumerable: true,
						configurable: true,
						writable: true,
						value: value
					} );
				}
			} );
		},

		fix: function( originalEvent ) {
			return originalEvent[ jQuery$1.expando ] ?
				originalEvent :
				new jQuery$1.Event( originalEvent );
		},

		special: {
			load: {

				// Prevent triggered image.load events from bubbling to window.load
				noBubble: true
			},
			click: {

				// Utilize native event to ensure correct state for checkable inputs
				setup: function( data ) {

					// For mutual compressibility with _default, replace `this` access with a local var.
					// `|| data` is dead code meant only to preserve the variable through minification.
					var el = this || data;

					// Claim the first handler
					if ( rcheckableType.test( el.type ) &&
						el.click && nodeName( el, "input" ) ) {

						// dataPriv.set( el, "click", ... )
						leverageNative( el, "click", returnTrue );
					}

					// Return false to allow normal processing in the caller
					return false;
				},
				trigger: function( data ) {

					// For mutual compressibility with _default, replace `this` access with a local var.
					// `|| data` is dead code meant only to preserve the variable through minification.
					var el = this || data;

					// Force setup before triggering a click
					if ( rcheckableType.test( el.type ) &&
						el.click && nodeName( el, "input" ) ) {

						leverageNative( el, "click" );
					}

					// Return non-false to allow normal event-path propagation
					return true;
				},

				// For cross-browser consistency, suppress native .click() on links
				// Also prevent it if we're currently inside a leveraged native-event stack
				_default: function( event ) {
					var target = event.target;
					return rcheckableType.test( target.type ) &&
						target.click && nodeName( target, "input" ) &&
						dataPriv.get( target, "click" ) ||
						nodeName( target, "a" );
				}
			},

			beforeunload: {
				postDispatch: function( event ) {

					// Support: Chrome <=73+
					// Chrome doesn't alert on `event.preventDefault()`
					// as the standard mandates.
					if ( event.result !== undefined && event.originalEvent ) {
						event.originalEvent.returnValue = event.result;
					}
				}
			}
		}
	};

	// Ensure the presence of an event listener that handles manually-triggered
	// synthetic events by interrupting progress until reinvoked in response to
	// *native* events that it fires directly, ensuring that state changes have
	// already occurred before other listeners are invoked.
	function leverageNative( el, type, expectSync ) {

		// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
		if ( !expectSync ) {
			if ( dataPriv.get( el, type ) === undefined ) {
				jQuery$1.event.add( el, type, returnTrue );
			}
			return;
		}

		// Register the controller as a special universal handler for all event namespaces
		dataPriv.set( el, type, false );
		jQuery$1.event.add( el, type, {
			namespace: false,
			handler: function( event ) {
				var notAsync, result,
					saved = dataPriv.get( this, type );

				if ( ( event.isTrigger & 1 ) && this[ type ] ) {

					// Interrupt processing of the outer synthetic .trigger()ed event
					// Saved data should be false in such cases, but might be a leftover capture object
					// from an async native handler (gh-4350)
					if ( !saved.length ) {

						// Store arguments for use when handling the inner native event
						// There will always be at least one argument (an event object), so this array
						// will not be confused with a leftover capture object.
						saved = slice$1.call( arguments );
						dataPriv.set( this, type, saved );

						// Trigger the native event and capture its result
						// Support: IE <=9 - 11+
						// focus() and blur() are asynchronous
						notAsync = expectSync( this, type );
						this[ type ]();
						result = dataPriv.get( this, type );
						if ( saved !== result || notAsync ) {
							dataPriv.set( this, type, false );
						} else {
							result = {};
						}
						if ( saved !== result ) {

							// Cancel the outer synthetic event
							event.stopImmediatePropagation();
							event.preventDefault();
							return result.value;
						}

					// If this is an inner synthetic event for an event with a bubbling surrogate
					// (focus or blur), assume that the surrogate already propagated from triggering the
					// native event and prevent that from happening again here.
					// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
					// bubbling surrogate propagates *after* the non-bubbling base), but that seems
					// less bad than duplication.
					} else if ( ( jQuery$1.event.special[ type ] || {} ).delegateType ) {
						event.stopPropagation();
					}

				// If this is a native event triggered above, everything is now in order
				// Fire an inner synthetic event with the original arguments
				} else if ( saved.length ) {

					// ...and capture the result
					dataPriv.set( this, type, {
						value: jQuery$1.event.trigger(

							// Support: IE <=9 - 11+
							// Extend with the prototype to reset the above stopImmediatePropagation()
							jQuery$1.extend( saved[ 0 ], jQuery$1.Event.prototype ),
							saved.slice( 1 ),
							this
						)
					} );

					// Abort handling of the native event
					event.stopImmediatePropagation();
				}
			}
		} );
	}

	jQuery$1.removeEvent = function( elem, type, handle ) {

		// This "if" is needed for plain objects
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle );
		}
	};

	jQuery$1.Event = function( src, props ) {

		// Allow instantiation without the 'new' keyword
		if ( !( this instanceof jQuery$1.Event ) ) {
			return new jQuery$1.Event( src, props );
		}

		// Event object
		if ( src && src.type ) {
			this.originalEvent = src;
			this.type = src.type;

			// Events bubbling up the document may have been marked as prevented
			// by a handler lower down the tree; reflect the correct value.
			this.isDefaultPrevented = src.defaultPrevented ?
				returnTrue :
				returnFalse;

			// Create target properties
			this.target = src.target;
			this.currentTarget = src.currentTarget;
			this.relatedTarget = src.relatedTarget;

		// Event type
		} else {
			this.type = src;
		}

		// Put explicitly provided properties onto the event object
		if ( props ) {
			jQuery$1.extend( this, props );
		}

		// Create a timestamp if incoming event doesn't have one
		this.timeStamp = src && src.timeStamp || Date.now();

		// Mark it as fixed
		this[ jQuery$1.expando ] = true;
	};

	// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
	// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
	jQuery$1.Event.prototype = {
		constructor: jQuery$1.Event,
		isDefaultPrevented: returnFalse,
		isPropagationStopped: returnFalse,
		isImmediatePropagationStopped: returnFalse,
		isSimulated: false,

		preventDefault: function() {
			var e = this.originalEvent;

			this.isDefaultPrevented = returnTrue;

			if ( e && !this.isSimulated ) {
				e.preventDefault();
			}
		},
		stopPropagation: function() {
			var e = this.originalEvent;

			this.isPropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopPropagation();
			}
		},
		stopImmediatePropagation: function() {
			var e = this.originalEvent;

			this.isImmediatePropagationStopped = returnTrue;

			if ( e && !this.isSimulated ) {
				e.stopImmediatePropagation();
			}

			this.stopPropagation();
		}
	};

	// Includes all common event props including KeyEvent and MouseEvent specific props
	jQuery$1.each( {
		altKey: true,
		bubbles: true,
		cancelable: true,
		changedTouches: true,
		ctrlKey: true,
		detail: true,
		eventPhase: true,
		metaKey: true,
		pageX: true,
		pageY: true,
		shiftKey: true,
		view: true,
		"char": true,
		code: true,
		charCode: true,
		key: true,
		keyCode: true,
		button: true,
		buttons: true,
		clientX: true,
		clientY: true,
		offsetX: true,
		offsetY: true,
		pointerId: true,
		pointerType: true,
		screenX: true,
		screenY: true,
		targetTouches: true,
		toElement: true,
		touches: true,

		which: function( event ) {
			var button = event.button;

			// Add which for key events
			if ( event.which == null && rkeyEvent.test( event.type ) ) {
				return event.charCode != null ? event.charCode : event.keyCode;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
				if ( button & 1 ) {
					return 1;
				}

				if ( button & 2 ) {
					return 3;
				}

				if ( button & 4 ) {
					return 2;
				}

				return 0;
			}

			return event.which;
		}
	}, jQuery$1.event.addProp );

	jQuery$1.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
		jQuery$1.event.special[ type ] = {

			// Utilize native event if possible so blur/focus sequence is correct
			setup: function() {

				// Claim the first handler
				// dataPriv.set( this, "focus", ... )
				// dataPriv.set( this, "blur", ... )
				leverageNative( this, type, expectSync );

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function() {

				// Force setup before trigger
				leverageNative( this, type );

				// Return non-false to allow normal event-path propagation
				return true;
			},

			delegateType: delegateType
		};
	} );

	// Create mouseenter/leave events using mouseover/out and event-time checks
	// so that event delegation works in jQuery.
	// Do the same for pointerenter/pointerleave and pointerover/pointerout
	jQuery$1.each( {
		mouseenter: "mouseover",
		mouseleave: "mouseout",
		pointerenter: "pointerover",
		pointerleave: "pointerout"
	}, function( orig, fix ) {
		jQuery$1.event.special[ orig ] = {
			delegateType: fix,
			bindType: fix,

			handle: function( event ) {
				var ret,
					target = this,
					related = event.relatedTarget,
					handleObj = event.handleObj;

				// For mouseenter/leave call the handler if related is outside the target.
				// NB: No relatedTarget if the mouse left/entered the browser window
				if ( !related || ( related !== target && !jQuery$1.contains( target, related ) ) ) {
					event.type = handleObj.origType;
					ret = handleObj.handler.apply( this, arguments );
					event.type = fix;
				}
				return ret;
			}
		};
	} );

	jQuery$1.fn.extend( {

		on: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn );
		},
		one: function( types, selector, data, fn ) {
			return on( this, types, selector, data, fn, 1 );
		},
		off: function( types, selector, fn ) {
			var handleObj, type;
			if ( types && types.preventDefault && types.handleObj ) {

				// ( event )  dispatched jQuery.Event
				handleObj = types.handleObj;
				jQuery$1( types.delegateTarget ).off(
					handleObj.namespace ?
						handleObj.origType + "." + handleObj.namespace :
						handleObj.origType,
					handleObj.selector,
					handleObj.handler
				);
				return this;
			}
			if ( typeof types === "object" ) {

				// ( types-object [, selector] )
				for ( type in types ) {
					this.off( type, selector, types[ type ] );
				}
				return this;
			}
			if ( selector === false || typeof selector === "function" ) {

				// ( types [, fn] )
				fn = selector;
				selector = undefined;
			}
			if ( fn === false ) {
				fn = returnFalse;
			}
			return this.each( function() {
				jQuery$1.event.remove( this, types, fn, selector );
			} );
		}
	} );

	var

		// See https://github.com/eslint/eslint/issues/3229
		rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

		// Support: IE <=10 - 11+, Edge 12 - 13 only
		// In IE/Edge using regex groups here causes severe slowdowns.
		// See https://connect.microsoft.com/IE/feedback/details/1736512/
		rnoInnerhtml = /<script|<style|<link/i,

		rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

	// Prefer a tbody over its parent table for containing new rows
	function manipulationTarget( elem, content ) {
		if ( nodeName( elem, "table" ) &&
			nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

			return jQuery$1( elem ).children( "tbody" )[ 0 ] || elem;
		}

		return elem;
	}

	// Replace/restore the type attribute of script elements for safe DOM manipulation
	function disableScript( elem ) {
		elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
		return elem;
	}
	function restoreScript( elem ) {
		if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
			elem.type = elem.type.slice( 5 );
		} else {
			elem.removeAttribute( "type" );
		}

		return elem;
	}

	function cloneCopyEvent( src, dest ) {
		var i, l, type, pdataOld, udataOld, udataCur, events;

		if ( dest.nodeType !== 1 ) {
			return;
		}

		// 1. Copy private data: events, handlers, etc.
		if ( dataPriv.hasData( src ) ) {
			pdataOld = dataPriv.get( src );
			events = pdataOld.events;

			if ( events ) {
				dataPriv.remove( dest, "handle events" );

				for ( type in events ) {
					for ( i = 0, l = events[ type ].length; i < l; i++ ) {
						jQuery$1.event.add( dest, type, events[ type ][ i ] );
					}
				}
			}
		}

		// 2. Copy user data
		if ( dataUser.hasData( src ) ) {
			udataOld = dataUser.access( src );
			udataCur = jQuery$1.extend( {}, udataOld );

			dataUser.set( dest, udataCur );
		}
	}

	function domManip( collection, args, callback, ignored ) {

		// Flatten any nested arrays
		args = flat( args );

		var fragment, first, scripts, hasScripts, node, doc,
			i = 0,
			l = collection.length,
			iNoClone = l - 1,
			value = args[ 0 ],
			valueIsFunction = typeof value === "function";

		if ( valueIsFunction ) {
			return collection.each( function( index ) {
				var self = collection.eq( index );
				args[ 0 ] = value.call( this, index, self.html() );
				domManip( self, args, callback, ignored );
			} );
		}

		if ( l ) {
			fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			// Require either new content or an interest in ignored elements to invoke the callback
			if ( first || ignored ) {
				scripts = jQuery$1.map( getAll( fragment, "script" ), disableScript );
				hasScripts = scripts.length;

				// Use the original fragment for the last item
				// instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				for ( ; i < l; i++ ) {
					node = fragment;

					if ( i !== iNoClone ) {
						node = jQuery$1.clone( node, true, true );

						// Keep references to cloned scripts for later restoration
						if ( hasScripts ) {
							jQuery$1.merge( scripts, getAll( node, "script" ) );
						}
					}

					callback.call( collection[ i ], node, i );
				}

				if ( hasScripts ) {
					doc = scripts[ scripts.length - 1 ].ownerDocument;

					// Reenable scripts
					jQuery$1.map( scripts, restoreScript );

					// Evaluate executable scripts on first document insertion
					for ( i = 0; i < hasScripts; i++ ) {
						node = scripts[ i ];
						if ( rscriptType.test( node.type || "" ) &&
							!dataPriv.access( node, "globalEval" ) &&
							jQuery$1.contains( doc, node ) ) {

							if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

								// Optional AJAX dependency, but won't run scripts if not present
								if ( jQuery$1._evalUrl && !node.noModule ) {
									jQuery$1._evalUrl( node.src, {
										nonce: node.nonce || node.getAttribute( "nonce" )
									}, doc );
								}
							} else {
								DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
							}
						}
					}
				}
			}
		}

		return collection;
	}

	function remove$1( elem, selector, keepData ) {
		var node,
			nodes = selector ? jQuery$1.filter( selector, elem ) : elem,
			i = 0;

		for ( ; ( node = nodes[ i ] ) != null; i++ ) {
			if ( !keepData && node.nodeType === 1 ) {
				jQuery$1.cleanData( getAll( node ) );
			}

			if ( node.parentNode ) {
				if ( keepData && isAttached$1( node ) ) {
					setGlobalEval( getAll( node, "script" ) );
				}
				node.parentNode.removeChild( node );
			}
		}

		return elem;
	}

	jQuery$1.extend( {
		htmlPrefilter: function( html ) {
			return html.replace( rxhtmlTag, "<$1></$2>" );
		},

		clone: function( elem, dataAndEvents, deepDataAndEvents ) {
			var i, l, srcElements, destElements,
				clone = elem.cloneNode( true ),
				inPage = isAttached$1( elem );

			// Fix IE cloning issues
			if ( isIE && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
					!jQuery$1.isXMLDoc( elem ) ) {

				// We eschew jQuery#find here for performance reasons:
				// https://jsperf.com/getall-vs-sizzle/2
				destElements = getAll( clone );
				srcElements = getAll( elem );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {

					// Support: IE <=11+
					// IE fails to set the defaultValue to the correct value when
					// cloning textareas.
					if ( nodeName( destElements[ i ], "textarea" ) ) {
						destElements[ i ].defaultValue = srcElements[ i ].defaultValue;
					}
				}
			}

			// Copy the events from the original to the clone
			if ( dataAndEvents ) {
				if ( deepDataAndEvents ) {
					srcElements = srcElements || getAll( elem );
					destElements = destElements || getAll( clone );

					for ( i = 0, l = srcElements.length; i < l; i++ ) {
						cloneCopyEvent( srcElements[ i ], destElements[ i ] );
					}
				} else {
					cloneCopyEvent( elem, clone );
				}
			}

			// Preserve script evaluation history
			destElements = getAll( clone, "script" );
			if ( destElements.length > 0 ) {
				setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
			}

			// Return the cloned set
			return clone;
		},

		cleanData: function( elems ) {
			var data, elem, type,
				special = jQuery$1.event.special,
				i = 0;

			for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
				if ( acceptData( elem ) ) {
					if ( ( data = elem[ dataPriv.expando ] ) ) {
						if ( data.events ) {
							for ( type in data.events ) {
								if ( special[ type ] ) {
									jQuery$1.event.remove( elem, type );

								// This is a shortcut to avoid jQuery.event.remove's overhead
								} else {
									jQuery$1.removeEvent( elem, type, data.handle );
								}
							}
						}

						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataPriv.expando ] = undefined;
					}
					if ( elem[ dataUser.expando ] ) {

						// Support: Chrome <=35 - 45+
						// Assign undefined instead of using delete, see Data#remove
						elem[ dataUser.expando ] = undefined;
					}
				}
			}
		}
	} );

	jQuery$1.fn.extend( {
		detach: function( selector ) {
			return remove$1( this, selector, true );
		},

		remove: function( selector ) {
			return remove$1( this, selector );
		},

		text: function( value ) {
			return access( this, function( value ) {
				return value === undefined ?
					jQuery$1.text( this ) :
					this.empty().each( function() {
						if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
							this.textContent = value;
						}
					} );
			}, null, value, arguments.length );
		},

		append: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.appendChild( elem );
				}
			} );
		},

		prepend: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
					var target = manipulationTarget( this, elem );
					target.insertBefore( elem, target.firstChild );
				}
			} );
		},

		before: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this );
				}
			} );
		},

		after: function() {
			return domManip( this, arguments, function( elem ) {
				if ( this.parentNode ) {
					this.parentNode.insertBefore( elem, this.nextSibling );
				}
			} );
		},

		empty: function() {
			var elem,
				i = 0;

			for ( ; ( elem = this[ i ] ) != null; i++ ) {
				if ( elem.nodeType === 1 ) {

					// Prevent memory leaks
					jQuery$1.cleanData( getAll( elem, false ) );

					// Remove any remaining nodes
					elem.textContent = "";
				}
			}

			return this;
		},

		clone: function( dataAndEvents, deepDataAndEvents ) {
			dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
			deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

			return this.map( function() {
				return jQuery$1.clone( this, dataAndEvents, deepDataAndEvents );
			} );
		},

		html: function( value ) {
			return access( this, function( value ) {
				var elem = this[ 0 ] || {},
					i = 0,
					l = this.length;

				if ( value === undefined && elem.nodeType === 1 ) {
					return elem.innerHTML;
				}

				// See if we can take a shortcut and just use innerHTML
				if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
					!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

					value = jQuery$1.htmlPrefilter( value );

					try {
						for ( ; i < l; i++ ) {
							elem = this[ i ] || {};

							// Remove element nodes and prevent memory leaks
							if ( elem.nodeType === 1 ) {
								jQuery$1.cleanData( getAll( elem, false ) );
								elem.innerHTML = value;
							}
						}

						elem = 0;

					// If using innerHTML throws an exception, use the fallback method
					} catch ( e ) {}
				}

				if ( elem ) {
					this.empty().append( value );
				}
			}, null, value, arguments.length );
		},

		replaceWith: function() {
			var ignored = [];

			// Make the changes, replacing each non-ignored context element with the new content
			return domManip( this, arguments, function( elem ) {
				var parent = this.parentNode;

				if ( jQuery$1.inArray( this, ignored ) < 0 ) {
					jQuery$1.cleanData( getAll( this ) );
					if ( parent ) {
						parent.replaceChild( elem, this );
					}
				}

			// Force callback invocation
			}, ignored );
		}
	} );

	jQuery$1.each( {
		appendTo: "append",
		prependTo: "prepend",
		insertBefore: "before",
		insertAfter: "after",
		replaceAll: "replaceWith"
	}, function( name, original ) {
		jQuery$1.fn[ name ] = function( selector ) {
			var elems,
				ret = [],
				insert = jQuery$1( selector ),
				last = insert.length - 1,
				i = 0;

			for ( ; i <= last; i++ ) {
				elems = i === last ? this : this.clone( true );
				jQuery$1( insert[ i ] )[ original ]( elems );
				push.apply( ret, elems.get() );
			}

			return this.pushStack( ret );
		};
	} );

	var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

	function getStyles( elem ) {

		// Support: IE <=11+ (trac-14150)
		// In IE popup's `window` is the opener window which makes `window.getComputedStyle( elem )`
		// break. Using `elem.ownerDocument.defaultView` avoids the issue.
		var view = elem.ownerDocument.defaultView;

		// `document.implementation.createHTMLDocument( "" )` has a `null` `defaultView`
		// property; check `defaultView` truthiness to fallback to window in such a case.
		if ( !view ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	}

	// A method for quickly swapping in/out CSS properties to get correct calculations.
	function swap( elem, options, callback ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.call( elem );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	}

	function curCSS( elem, name, computed ) {
		var ret;

		computed = computed || getStyles( elem );

		// getPropertyValue is needed for `.css('--customProperty')` (gh-3144)
		if ( computed ) {
			ret = computed.getPropertyValue( name ) || computed[ name ];

			if ( ret === "" && !isAttached$1( elem ) ) {
				ret = jQuery$1.style( elem, name );
			}
		}

		return ret !== undefined ?

			// Support: IE <=9 - 11+
			// IE returns zIndex value as an integer.
			ret + "" :
			ret;
	}

	var reliableTrDimensionsVal;

	// Support: IE 11+, Edge 15 - 18+
	// IE/Edge misreport `getComputedStyle` of table rows with width/height
	// set in CSS while `offset*` properties report correct values.
	support.reliableTrDimensions = function() {
		var table, tr, trChild, trStyle;
		if ( reliableTrDimensionsVal == null ) {
			table = document$1.createElement( "table" );
			tr = document$1.createElement( "tr" );
			trChild = document$1.createElement( "div" );

			table.style.cssText = "position:absolute;left:-11111px";
			tr.style.height = "1px";
			trChild.style.height = "9px";

			documentElement
				.appendChild( table )
				.appendChild( tr )
				.appendChild( trChild );

			trStyle = window.getComputedStyle( tr );
			reliableTrDimensionsVal = parseInt( trStyle.height ) > 3;

			documentElement.removeChild( table );
		}
		return reliableTrDimensionsVal;
	};

	var cssPrefixes = [ "Webkit", "Moz", "ms" ],
		emptyStyle = document$1.createElement( "div" ).style,
		vendorProps = {};

	// Return a vendor-prefixed property or undefined
	function vendorPropName( name ) {

		// Check for vendor prefixed names
		var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
			i = cssPrefixes.length;

		while ( i-- ) {
			name = cssPrefixes[ i ] + capName;
			if ( name in emptyStyle ) {
				return name;
			}
		}
	}

	// Return a potentially-mapped vendor prefixed property
	function finalPropName( name ) {
		var final = vendorProps[ name ];

		if ( final ) {
			return final;
		}
		if ( name in emptyStyle ) {
			return name;
		}
		return vendorProps[ name ] = vendorPropName( name ) || name;
	}

	var

		// Swappable if display is none or starts with table
		// except "table", "table-cell", or "table-caption"
		// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
		rdisplayswap = /^(none|table(?!-c[ea]).+)/,
		rcustomProp = /^--/,
		cssShow = { position: "absolute", visibility: "hidden", display: "block" },
		cssNormalTransform = {
			letterSpacing: "0",
			fontWeight: "400"
		};

	function setPositiveNumber( _elem, value, subtract ) {

		// Any relative (+/-) values have already been
		// normalized at this point
		var matches = rcssNum.exec( value );
		return matches ?

			// Guard against undefined "subtract", e.g., when used as in cssHooks
			Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
			value;
	}

	function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
		var i = dimension === "width" ? 1 : 0,
			extra = 0,
			delta = 0;

		// Adjustment may not be necessary
		if ( box === ( isBorderBox ? "border" : "content" ) ) {
			return 0;
		}

		for ( ; i < 4; i += 2 ) {

			// Both box models exclude margin
			if ( box === "margin" ) {
				delta += jQuery$1.css( elem, box + cssExpand[ i ], true, styles );
			}

			// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
			if ( !isBorderBox ) {

				// Add padding
				delta += jQuery$1.css( elem, "padding" + cssExpand[ i ], true, styles );

				// For "border" or "margin", add border
				if ( box !== "padding" ) {
					delta += jQuery$1.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

				// But still keep track of it otherwise
				} else {
					extra += jQuery$1.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}

			// If we get here with a border-box (content + padding + border), we're seeking "content" or
			// "padding" or "margin"
			} else {

				// For "content", subtract padding
				if ( box === "content" ) {
					delta -= jQuery$1.css( elem, "padding" + cssExpand[ i ], true, styles );
				}

				// For "content" or "padding", subtract border
				if ( box !== "margin" ) {
					delta -= jQuery$1.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
				}
			}
		}

		// Account for positive content-box scroll gutter when requested by providing computedVal
		if ( !isBorderBox && computedVal >= 0 ) {

			// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
			// Assuming integer scroll gutter, subtract the rest and round down
			delta += Math.max( 0, Math.ceil(
				elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
				computedVal -
				delta -
				extra -
				0.5

			// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
			// Use an explicit zero to avoid NaN (gh-3964)
			) ) || 0;
		}

		return delta;
	}

	function getWidthOrHeight( elem, dimension, extra ) {

		// Start with computed style
		var styles = getStyles( elem ),

			// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
			// Fake content-box until we know it's needed to know the true value.
			boxSizingNeeded = isIE || extra,
			isBorderBox = boxSizingNeeded &&
				jQuery$1.css( elem, "boxSizing", false, styles ) === "border-box",
			valueIsBorderBox = isBorderBox,

			val = curCSS( elem, dimension, styles ),
			offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

		// Return a confounding non-pixel value or feign ignorance, as appropriate.
		if ( rnumnonpx.test( val ) ) {
			if ( !extra ) {
				return val;
			}
			val = "auto";
		}


		// Support: IE 9 - 11+
		// Use offsetWidth/offsetHeight for when box sizing is unreliable.
		// In those cases, the computed value can be trusted to be border-box.
		if ( ( isIE && isBorderBox ||

			// Support: IE 10 - 11+, Edge 15 - 18+
			// IE/Edge misreport `getComputedStyle` of table rows with width/height
			// set in CSS while `offset*` properties report correct values.
			!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

			// Fall back to offsetWidth/offsetHeight when value is "auto"
			// This happens for inline elements with no explicit setting (gh-3571)
			val === "auto" ) &&

			// Make sure the element is visible & connected
			elem.getClientRects().length ) {

			isBorderBox = jQuery$1.css( elem, "boxSizing", false, styles ) === "border-box";

			// Where available, offsetWidth/offsetHeight approximate border box dimensions.
			// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
			// retrieved value as a content box dimension.
			valueIsBorderBox = offsetProp in elem;
			if ( valueIsBorderBox ) {
				val = elem[ offsetProp ];
			}
		}

		// Normalize "" and auto
		val = parseFloat( val ) || 0;

		// Adjust for the element's box model
		return ( val +
			boxModelAdjustment(
				elem,
				dimension,
				extra || ( isBorderBox ? "border" : "content" ),
				valueIsBorderBox,
				styles,

				// Provide the current computed size to request scroll gutter calculation (gh-3589)
				val
			)
		) + "px";
	}

	jQuery$1.extend( {

		// Add in style property hooks for overriding the default
		// behavior of getting and setting a style property
		cssHooks: {},

		// Get and set the style property on a DOM Node
		style: function( elem, name, value, extra ) {

			// Don't set styles on text and comment nodes
			if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
				return;
			}

			// Make sure that we're working with the right name
			var ret, type, hooks,
				origName = cssCamelCase( name ),
				isCustomProp = rcustomProp.test( name ),
				style = elem.style;

			// Make sure that we're working with the right name. We don't
			// want to query the value if it is a CSS custom property
			// since they are user-defined.
			if ( !isCustomProp ) {
				name = finalPropName( origName );
			}

			// Gets hook for the prefixed version, then unprefixed version
			hooks = jQuery$1.cssHooks[ name ] || jQuery$1.cssHooks[ origName ];

			// Check if we're setting a value
			if ( value !== undefined ) {
				type = typeof value;

				// Convert "+=" or "-=" to relative numbers (#7345)
				if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
					value = adjustCSS( elem, name, ret );

					// Fixes bug #9237
					type = "number";
				}

				// Make sure that null and NaN values aren't set (#7116)
				if ( value == null || value !== value ) {
					return;
				}

				// If the value is a number, add `px` for certain CSS properties
				if ( type === "number" ) {
					value += ret && ret[ 3 ] || ( isAutoPx( origName ) ? "px" : "" );
				}

				// Support: IE <=9 - 11+
				// background-* props of a cloned element affect the source element (#8908)
				if ( isIE && value === "" && name.indexOf( "background" ) === 0 ) {
					style[ name ] = "inherit";
				}

				// If a hook was provided, use that value, otherwise just set the specified value
				if ( !hooks || !( "set" in hooks ) ||
					( value = hooks.set( elem, value, extra ) ) !== undefined ) {

					if ( isCustomProp ) {
						style.setProperty( name, value );
					} else {
						style[ name ] = value;
					}
				}

			} else {

				// If a hook was provided get the non-computed value from there
				if ( hooks && "get" in hooks &&
					( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

					return ret;
				}

				// Otherwise just get the value from the style object
				return style[ name ];
			}
		},

		css: function( elem, name, extra, styles ) {
			var val, num, hooks,
				origName = cssCamelCase( name ),
				isCustomProp = rcustomProp.test( name );

			// Make sure that we're working with the right name. We don't
			// want to modify the value if it is a CSS custom property
			// since they are user-defined.
			if ( !isCustomProp ) {
				name = finalPropName( origName );
			}

			// Try prefixed name followed by the unprefixed name
			hooks = jQuery$1.cssHooks[ name ] || jQuery$1.cssHooks[ origName ];

			// If a hook was provided get the computed value from there
			if ( hooks && "get" in hooks ) {
				val = hooks.get( elem, true, extra );
			}

			// Otherwise, if a way to get the computed value exists, use that
			if ( val === undefined ) {
				val = curCSS( elem, name, styles );
			}

			// Convert "normal" to computed value
			if ( val === "normal" && name in cssNormalTransform ) {
				val = cssNormalTransform[ name ];
			}

			// Make numeric if forced or a qualifier was provided and val looks numeric
			if ( extra === "" || extra ) {
				num = parseFloat( val );
				return extra === true || isFinite( num ) ? num || 0 : val;
			}

			return val;
		}
	} );

	jQuery$1.each( [ "height", "width" ], function( _i, dimension ) {
		jQuery$1.cssHooks[ dimension ] = {
			get: function( elem, computed, extra ) {
				if ( computed ) {

					// Certain elements can have dimension info if we invisibly show them
					// but it must have a current display style that would benefit
					return rdisplayswap.test( jQuery$1.css( elem, "display" ) ) &&

						// Support: Safari <=8 - 12+, Chrome <=73+
						// Table columns in WebKit/Blink have non-zero offsetWidth & zero
						// getBoundingClientRect().width unless display is changed.
						// Support: IE <=11+
						// Running getBoundingClientRect on a disconnected node
						// in IE throws an error.
						( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
							swap( elem, cssShow, function() {
								return getWidthOrHeight( elem, dimension, extra );
							} ) :
							getWidthOrHeight( elem, dimension, extra );
				}
			},

			set: function( elem, value, extra ) {
				var matches,
					styles = getStyles( elem ),

					// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
					isBorderBox = extra &&
						jQuery$1.css( elem, "boxSizing", false, styles ) === "border-box",
					subtract = extra ?
						boxModelAdjustment(
							elem,
							dimension,
							extra,
							isBorderBox,
							styles
						) :
						0;

				// Convert to pixels if value adjustment is needed
				if ( subtract && ( matches = rcssNum.exec( value ) ) &&
					( matches[ 3 ] || "px" ) !== "px" ) {

					elem.style[ dimension ] = value;
					value = jQuery$1.css( elem, dimension );
				}

				return setPositiveNumber( elem, value, subtract );
			}
		};
	} );

	// These hooks are used by animate to expand properties
	jQuery$1.each( {
		margin: "",
		padding: "",
		border: "Width"
	}, function( prefix, suffix ) {
		jQuery$1.cssHooks[ prefix + suffix ] = {
			expand: function( value ) {
				var i = 0,
					expanded = {},

					// Assumes a single number if not a string
					parts = typeof value === "string" ? value.split( " " ) : [ value ];

				for ( ; i < 4; i++ ) {
					expanded[ prefix + cssExpand[ i ] + suffix ] =
						parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
				}

				return expanded;
			}
		};

		if ( prefix !== "margin" ) {
			jQuery$1.cssHooks[ prefix + suffix ].set = setPositiveNumber;
		}
	} );

	jQuery$1.fn.extend( {
		css: function( name, value ) {
			return access( this, function( elem, name, value ) {
				var styles, len,
					map = {},
					i = 0;

				if ( Array.isArray( name ) ) {
					styles = getStyles( elem );
					len = name.length;

					for ( ; i < len; i++ ) {
						map[ name[ i ] ] = jQuery$1.css( elem, name[ i ], false, styles );
					}

					return map;
				}

				return value !== undefined ?
					jQuery$1.style( elem, name, value ) :
					jQuery$1.css( elem, name );
			}, name, value, arguments.length > 1 );
		}
	} );

	function Tween( elem, options, prop, end, easing ) {
		return new Tween.prototype.init( elem, options, prop, end, easing );
	}
	jQuery$1.Tween = Tween;

	Tween.prototype = {
		constructor: Tween,
		init: function( elem, options, prop, end, easing, unit ) {
			this.elem = elem;
			this.prop = prop;
			this.easing = easing || jQuery$1.easing._default;
			this.options = options;
			this.start = this.now = this.cur();
			this.end = end;
			this.unit = unit || ( isAutoPx( prop ) ? "px" : "" );
		},
		cur: function() {
			var hooks = Tween.propHooks[ this.prop ];

			return hooks && hooks.get ?
				hooks.get( this ) :
				Tween.propHooks._default.get( this );
		},
		run: function( percent ) {
			var eased,
				hooks = Tween.propHooks[ this.prop ];

			if ( this.options.duration ) {
				this.pos = eased = jQuery$1.easing[ this.easing ](
					percent, this.options.duration * percent, 0, 1, this.options.duration
				);
			} else {
				this.pos = eased = percent;
			}
			this.now = ( this.end - this.start ) * eased + this.start;

			if ( this.options.step ) {
				this.options.step.call( this.elem, this.now, this );
			}

			if ( hooks && hooks.set ) {
				hooks.set( this );
			} else {
				Tween.propHooks._default.set( this );
			}
			return this;
		}
	};

	Tween.prototype.init.prototype = Tween.prototype;

	Tween.propHooks = {
		_default: {
			get: function( tween ) {
				var result;

				// Use a property on the element directly when it is not a DOM element,
				// or when there is no matching style property that exists.
				if ( tween.elem.nodeType !== 1 ||
					tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
					return tween.elem[ tween.prop ];
				}

				// Passing an empty string as a 3rd parameter to .css will automatically
				// attempt a parseFloat and fallback to a string if the parse fails.
				// Simple values such as "10px" are parsed to Float;
				// complex values such as "rotate(1rad)" are returned as-is.
				result = jQuery$1.css( tween.elem, tween.prop, "" );

				// Empty strings, null, undefined and "auto" are converted to 0.
				return !result || result === "auto" ? 0 : result;
			},
			set: function( tween ) {

				// Use step hook for back compat.
				// Use cssHook if its there.
				// Use .style if available and use plain properties where available.
				if ( jQuery$1.fx.step[ tween.prop ] ) {
					jQuery$1.fx.step[ tween.prop ]( tween );
				} else if ( tween.elem.nodeType === 1 && (
						jQuery$1.cssHooks[ tween.prop ] ||
						tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
					jQuery$1.style( tween.elem, tween.prop, tween.now + tween.unit );
				} else {
					tween.elem[ tween.prop ] = tween.now;
				}
			}
		}
	};

	jQuery$1.easing = {
		linear: function( p ) {
			return p;
		},
		swing: function( p ) {
			return 0.5 - Math.cos( p * Math.PI ) / 2;
		},
		_default: "swing"
	};

	jQuery$1.fx = Tween.prototype.init;

	// Back compat <1.8 extension point
	jQuery$1.fx.step = {};

	var
		fxNow, inProgress,
		rfxtypes = /^(?:toggle|show|hide)$/,
		rrun = /queueHooks$/;

	function schedule() {
		if ( inProgress ) {
			if ( document$1.hidden === false && window.requestAnimationFrame ) {
				window.requestAnimationFrame( schedule );
			} else {
				window.setTimeout( schedule, jQuery$1.fx.interval );
			}

			jQuery$1.fx.tick();
		}
	}

	// Animations created synchronously will run synchronously
	function createFxNow() {
		window.setTimeout( function() {
			fxNow = undefined;
		} );
		return ( fxNow = Date.now() );
	}

	// Generate parameters to create a standard animation
	function genFx( type, includeWidth ) {
		var which,
			i = 0,
			attrs = { height: type };

		// If we include width, step value is 1 to do all cssExpand values,
		// otherwise step value is 2 to skip over Left and Right
		includeWidth = includeWidth ? 1 : 0;
		for ( ; i < 4; i += 2 - includeWidth ) {
			which = cssExpand[ i ];
			attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
		}

		if ( includeWidth ) {
			attrs.opacity = attrs.width = type;
		}

		return attrs;
	}

	function createTween( value, prop, animation ) {
		var tween,
			collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

				// We're done with this property
				return tween;
			}
		}
	}

	function defaultPrefilter( elem, props, opts ) {
		var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
			isBox = "width" in props || "height" in props,
			anim = this,
			orig = {},
			style = elem.style,
			hidden = elem.nodeType && isHiddenWithinTree( elem ),
			dataShow = dataPriv.get( elem, "fxshow" );

		// Queue-skipping animations hijack the fx hooks
		if ( !opts.queue ) {
			hooks = jQuery$1._queueHooks( elem, "fx" );
			if ( hooks.unqueued == null ) {
				hooks.unqueued = 0;
				oldfire = hooks.empty.fire;
				hooks.empty.fire = function() {
					if ( !hooks.unqueued ) {
						oldfire();
					}
				};
			}
			hooks.unqueued++;

			anim.always( function() {

				// Ensure the complete handler is called before this completes
				anim.always( function() {
					hooks.unqueued--;
					if ( !jQuery$1.queue( elem, "fx" ).length ) {
						hooks.empty.fire();
					}
				} );
			} );
		}

		// Detect show/hide animations
		for ( prop in props ) {
			value = props[ prop ];
			if ( rfxtypes.test( value ) ) {
				delete props[ prop ];
				toggle = toggle || value === "toggle";
				if ( value === ( hidden ? "hide" : "show" ) ) {

					// Pretend to be hidden if this is a "show" and
					// there is still data from a stopped show/hide
					if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
						hidden = true;

					// Ignore all other no-op show/hide data
					} else {
						continue;
					}
				}
				orig[ prop ] = dataShow && dataShow[ prop ] || jQuery$1.style( elem, prop );
			}
		}

		// Bail out if this is a no-op like .hide().hide()
		propTween = !jQuery$1.isEmptyObject( props );
		if ( !propTween && jQuery$1.isEmptyObject( orig ) ) {
			return;
		}

		// Restrict "overflow" and "display" styles during box animations
		if ( isBox && elem.nodeType === 1 ) {

			// Support: IE <=9 - 11+, Edge 12 - 18+
			// Record all 3 overflow attributes because IE does not infer the shorthand
			// from identically-valued overflowX and overflowY and Edge just mirrors
			// the overflowX value there.
			opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

			// Identify a display type, preferring old show/hide data over the CSS cascade
			restoreDisplay = dataShow && dataShow.display;
			if ( restoreDisplay == null ) {
				restoreDisplay = dataPriv.get( elem, "display" );
			}
			display = jQuery$1.css( elem, "display" );
			if ( display === "none" ) {
				if ( restoreDisplay ) {
					display = restoreDisplay;
				} else {

					// Get nonempty value(s) by temporarily forcing visibility
					showHide( [ elem ], true );
					restoreDisplay = elem.style.display || restoreDisplay;
					display = jQuery$1.css( elem, "display" );
					showHide( [ elem ] );
				}
			}

			// Animate inline elements as inline-block
			if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
				if ( jQuery$1.css( elem, "float" ) === "none" ) {

					// Restore the original display value at the end of pure show/hide animations
					if ( !propTween ) {
						anim.done( function() {
							style.display = restoreDisplay;
						} );
						if ( restoreDisplay == null ) {
							display = style.display;
							restoreDisplay = display === "none" ? "" : display;
						}
					}
					style.display = "inline-block";
				}
			}
		}

		if ( opts.overflow ) {
			style.overflow = "hidden";
			anim.always( function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			} );
		}

		// Implement show/hide animations
		propTween = false;
		for ( prop in orig ) {

			// General show/hide setup for this element animation
			if ( !propTween ) {
				if ( dataShow ) {
					if ( "hidden" in dataShow ) {
						hidden = dataShow.hidden;
					}
				} else {
					dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
				}

				// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
				if ( toggle ) {
					dataShow.hidden = !hidden;
				}

				// Show elements before animating them
				if ( hidden ) {
					showHide( [ elem ], true );
				}

				// eslint-disable-next-line no-loop-func
				anim.done( function() {

					// The final step of a "hide" animation is actually hiding the element
					if ( !hidden ) {
						showHide( [ elem ] );
					}
					dataPriv.remove( elem, "fxshow" );
					for ( prop in orig ) {
						jQuery$1.style( elem, prop, orig[ prop ] );
					}
				} );
			}

			// Per-property setup
			propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = propTween.start;
				if ( hidden ) {
					propTween.end = propTween.start;
					propTween.start = 0;
				}
			}
		}
	}

	function propFilter( props, specialEasing ) {
		var index, name, easing, value, hooks;

		// camelCase, specialEasing and expand cssHook pass
		for ( index in props ) {
			name = cssCamelCase( index );
			easing = specialEasing[ name ];
			value = props[ index ];
			if ( Array.isArray( value ) ) {
				easing = value[ 1 ];
				value = props[ index ] = value[ 0 ];
			}

			if ( index !== name ) {
				props[ name ] = value;
				delete props[ index ];
			}

			hooks = jQuery$1.cssHooks[ name ];
			if ( hooks && "expand" in hooks ) {
				value = hooks.expand( value );
				delete props[ name ];

				// Not quite $.extend, this won't overwrite existing keys.
				// Reusing 'index' because we have the correct "name"
				for ( index in value ) {
					if ( !( index in props ) ) {
						props[ index ] = value[ index ];
						specialEasing[ index ] = easing;
					}
				}
			} else {
				specialEasing[ name ] = easing;
			}
		}
	}

	function Animation( elem, properties, options ) {
		var result,
			stopped,
			index = 0,
			length = Animation.prefilters.length,
			deferred = jQuery$1.Deferred().always( function() {

				// Don't match elem in the :animated selector
				delete tick.elem;
			} ),
			tick = function() {
				if ( stopped ) {
					return false;
				}
				var currentTime = fxNow || createFxNow(),
					remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

					percent = 1 - ( remaining / animation.duration || 0 ),
					index = 0,
					length = animation.tweens.length;

				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( percent );
				}

				deferred.notifyWith( elem, [ animation, percent, remaining ] );

				// If there's more to do, yield
				if ( percent < 1 && length ) {
					return remaining;
				}

				// If this was an empty animation, synthesize a final progress notification
				if ( !length ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
				}

				// Resolve the animation and report its conclusion
				deferred.resolveWith( elem, [ animation ] );
				return false;
			},
			animation = deferred.promise( {
				elem: elem,
				props: jQuery$1.extend( {}, properties ),
				opts: jQuery$1.extend( true, {
					specialEasing: {},
					easing: jQuery$1.easing._default
				}, options ),
				originalProperties: properties,
				originalOptions: options,
				startTime: fxNow || createFxNow(),
				duration: options.duration,
				tweens: [],
				createTween: function( prop, end ) {
					var tween = jQuery$1.Tween( elem, animation.opts, prop, end,
							animation.opts.specialEasing[ prop ] || animation.opts.easing );
					animation.tweens.push( tween );
					return tween;
				},
				stop: function( gotoEnd ) {
					var index = 0,

						// If we are going to the end, we want to run all the tweens
						// otherwise we skip this part
						length = gotoEnd ? animation.tweens.length : 0;
					if ( stopped ) {
						return this;
					}
					stopped = true;
					for ( ; index < length; index++ ) {
						animation.tweens[ index ].run( 1 );
					}

					// Resolve when we played the last frame; otherwise, reject
					if ( gotoEnd ) {
						deferred.notifyWith( elem, [ animation, 1, 0 ] );
						deferred.resolveWith( elem, [ animation, gotoEnd ] );
					} else {
						deferred.rejectWith( elem, [ animation, gotoEnd ] );
					}
					return this;
				}
			} ),
			props = animation.props;

		propFilter( props, animation.opts.specialEasing );

		for ( ; index < length; index++ ) {
			result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
			if ( result ) {
				if ( typeof result.stop === "function" ) {
					jQuery$1._queueHooks( animation.elem, animation.opts.queue ).stop =
						result.stop.bind( result );
				}
				return result;
			}
		}

		jQuery$1.map( props, createTween, animation );

		if ( typeof animation.opts.start === "function" ) {
			animation.opts.start.call( elem, animation );
		}

		// Attach callbacks from options
		animation
			.progress( animation.opts.progress )
			.done( animation.opts.done, animation.opts.complete )
			.fail( animation.opts.fail )
			.always( animation.opts.always );

		jQuery$1.fx.timer(
			jQuery$1.extend( tick, {
				elem: elem,
				anim: animation,
				queue: animation.opts.queue
			} )
		);

		return animation;
	}

	jQuery$1.Animation = jQuery$1.extend( Animation, {

		tweeners: {
			"*": [ function( prop, value ) {
				var tween = this.createTween( prop, value );
				adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
				return tween;
			} ]
		},

		tweener: function( props, callback ) {
			if ( typeof props === "function" ) {
				callback = props;
				props = [ "*" ];
			} else {
				props = props.match( rnothtmlwhite );
			}

			var prop,
				index = 0,
				length = props.length;

			for ( ; index < length; index++ ) {
				prop = props[ index ];
				Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
				Animation.tweeners[ prop ].unshift( callback );
			}
		},

		prefilters: [ defaultPrefilter ],

		prefilter: function( callback, prepend ) {
			if ( prepend ) {
				Animation.prefilters.unshift( callback );
			} else {
				Animation.prefilters.push( callback );
			}
		}
	} );

	jQuery$1.speed = function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery$1.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				typeof speed === "function" && speed,
			duration: speed,
			easing: fn && easing || easing && typeof easing !== "function" && easing
		};

		// Go to the end state if fx are off
		if ( jQuery$1.fx.off ) {
			opt.duration = 0;

		} else {
			if ( typeof opt.duration !== "number" ) {
				if ( opt.duration in jQuery$1.fx.speeds ) {
					opt.duration = jQuery$1.fx.speeds[ opt.duration ];

				} else {
					opt.duration = jQuery$1.fx.speeds._default;
				}
			}
		}

		// Normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function() {
			if ( typeof opt.old === "function" ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery$1.dequeue( this, opt.queue );
			}
		};

		return opt;
	};

	jQuery$1.fn.extend( {
		fadeTo: function( speed, to, easing, callback ) {

			// Show any hidden elements after setting opacity to 0
			return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

				// Animate to the value specified
				.end().animate( { opacity: to }, speed, easing, callback );
		},
		animate: function( prop, speed, easing, callback ) {
			var empty = jQuery$1.isEmptyObject( prop ),
				optall = jQuery$1.speed( speed, easing, callback ),
				doAnimation = function() {

					// Operate on a copy of prop so per-property easing won't be lost
					var anim = Animation( this, jQuery$1.extend( {}, prop ), optall );

					// Empty animations, or finishing resolves immediately
					if ( empty || dataPriv.get( this, "finish" ) ) {
						anim.stop( true );
					}
				};
				doAnimation.finish = doAnimation;

			return empty || optall.queue === false ?
				this.each( doAnimation ) :
				this.queue( optall.queue, doAnimation );
		},
		stop: function( type, clearQueue, gotoEnd ) {
			var stopQueue = function( hooks ) {
				var stop = hooks.stop;
				delete hooks.stop;
				stop( gotoEnd );
			};

			if ( typeof type !== "string" ) {
				gotoEnd = clearQueue;
				clearQueue = type;
				type = undefined;
			}
			if ( clearQueue ) {
				this.queue( type || "fx", [] );
			}

			return this.each( function() {
				var dequeue = true,
					index = type != null && type + "queueHooks",
					timers = jQuery$1.timers,
					data = dataPriv.get( this );

				if ( index ) {
					if ( data[ index ] && data[ index ].stop ) {
						stopQueue( data[ index ] );
					}
				} else {
					for ( index in data ) {
						if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
							stopQueue( data[ index ] );
						}
					}
				}

				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this &&
						( type == null || timers[ index ].queue === type ) ) {

						timers[ index ].anim.stop( gotoEnd );
						dequeue = false;
						timers.splice( index, 1 );
					}
				}

				// Start the next in the queue if the last step wasn't forced.
				// Timers currently will call their complete callbacks, which
				// will dequeue but only if they were gotoEnd.
				if ( dequeue || !gotoEnd ) {
					jQuery$1.dequeue( this, type );
				}
			} );
		},
		finish: function( type ) {
			if ( type !== false ) {
				type = type || "fx";
			}
			return this.each( function() {
				var index,
					data = dataPriv.get( this ),
					queue = data[ type + "queue" ],
					hooks = data[ type + "queueHooks" ],
					timers = jQuery$1.timers,
					length = queue ? queue.length : 0;

				// Enable finishing flag on private data
				data.finish = true;

				// Empty the queue first
				jQuery$1.queue( this, type, [] );

				if ( hooks && hooks.stop ) {
					hooks.stop.call( this, true );
				}

				// Look for any active animations, and finish them
				for ( index = timers.length; index--; ) {
					if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
						timers[ index ].anim.stop( true );
						timers.splice( index, 1 );
					}
				}

				// Look for any animations in the old queue and finish them
				for ( index = 0; index < length; index++ ) {
					if ( queue[ index ] && queue[ index ].finish ) {
						queue[ index ].finish.call( this );
					}
				}

				// Turn off finishing flag
				delete data.finish;
			} );
		}
	} );

	jQuery$1.each( [ "toggle", "show", "hide" ], function( _i, name ) {
		var cssFn = jQuery$1.fn[ name ];
		jQuery$1.fn[ name ] = function( speed, easing, callback ) {
			return speed == null || typeof speed === "boolean" ?
				cssFn.apply( this, arguments ) :
				this.animate( genFx( name, true ), speed, easing, callback );
		};
	} );

	// Generate shortcuts for custom animations
	jQuery$1.each( {
		slideDown: genFx( "show" ),
		slideUp: genFx( "hide" ),
		slideToggle: genFx( "toggle" ),
		fadeIn: { opacity: "show" },
		fadeOut: { opacity: "hide" },
		fadeToggle: { opacity: "toggle" }
	}, function( name, props ) {
		jQuery$1.fn[ name ] = function( speed, easing, callback ) {
			return this.animate( props, speed, easing, callback );
		};
	} );

	jQuery$1.timers = [];
	jQuery$1.fx.tick = function() {
		var timer,
			i = 0,
			timers = jQuery$1.timers;

		fxNow = Date.now();

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];

			// Run the timer and safely remove it when done (allowing for external removal)
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery$1.fx.stop();
		}
		fxNow = undefined;
	};

	jQuery$1.fx.timer = function( timer ) {
		jQuery$1.timers.push( timer );
		jQuery$1.fx.start();
	};

	jQuery$1.fx.interval = 13;
	jQuery$1.fx.start = function() {
		if ( inProgress ) {
			return;
		}

		inProgress = true;
		schedule();
	};

	jQuery$1.fx.stop = function() {
		inProgress = null;
	};

	jQuery$1.fx.speeds = {
		slow: 600,
		fast: 200,

		// Default speed
		_default: 400
	};

	// Based off of the plugin by Clint Helfers, with permission.
	// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
	jQuery$1.fn.delay = function( time, type ) {
		time = jQuery$1.fx ? jQuery$1.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = window.setTimeout( next, time );
			hooks.stop = function() {
				window.clearTimeout( timeout );
			};
		} );
	};

	jQuery$1.fn.extend( {
		attr: function( name, value ) {
			return access( this, jQuery$1.attr, name, value, arguments.length > 1 );
		},

		removeAttr: function( name ) {
			return this.each( function() {
				jQuery$1.removeAttr( this, name );
			} );
		}
	} );

	jQuery$1.extend( {
		attr: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set attributes on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			// Fallback to prop when attributes are not supported
			if ( typeof elem.getAttribute === "undefined" ) {
				return jQuery$1.prop( elem, name, value );
			}

			// Attribute hooks are determined by the lowercase version
			// Grab necessary hook if one is defined
			if ( nType !== 1 || !jQuery$1.isXMLDoc( elem ) ) {
				hooks = jQuery$1.attrHooks[ name.toLowerCase() ];
			}

			if ( value !== undefined ) {
				if ( value === null ) {
					jQuery$1.removeAttr( elem, name );
					return;
				}

				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				elem.setAttribute( name, value + "" );
				return value;
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			ret = elem.getAttribute( name );

			// Non-existent attributes return null, we normalize to undefined
			return ret == null ? undefined : ret;
		},

		attrHooks: {},

		removeAttr: function( elem, value ) {
			var name,
				i = 0,

				// Attribute names can contain non-HTML whitespace characters
				// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
				attrNames = value && value.match( rnothtmlwhite );

			if ( attrNames && elem.nodeType === 1 ) {
				while ( ( name = attrNames[ i++ ] ) ) {
					elem.removeAttribute( name );
				}
			}
		}
	} );

	// Support: IE <=11+
	// An input loses its value after becoming a radio
	if ( isIE ) {
		jQuery$1.attrHooks.type = {
			set: function( elem, value ) {
				if ( value === "radio" && nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		};
	}

	jQuery$1.each( jQuery$1.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
		jQuery$1.attrHooks[ name ] = {
			get: function( elem ) {
				var ret,
					isXML = jQuery$1.isXMLDoc( elem ),
					lowercaseName = name.toLowerCase();

				if ( !isXML ) {
					ret = elem.getAttribute( name ) != null ?
						lowercaseName :
						null;
				}
				return ret;
			},

			set: function( elem, value, name ) {
				if ( value === false ) {

					// Remove boolean attributes when set to false
					jQuery$1.removeAttr( elem, name );
				} else {
					elem.setAttribute( name, name );
				}
				return name;
			}
		};
	} );

	var rfocusable = /^(?:input|select|textarea|button)$/i,
		rclickable = /^(?:a|area)$/i;

	jQuery$1.fn.extend( {
		prop: function( name, value ) {
			return access( this, jQuery$1.prop, name, value, arguments.length > 1 );
		},

		removeProp: function( name ) {
			return this.each( function() {
				delete this[ jQuery$1.propFix[ name ] || name ];
			} );
		}
	} );

	jQuery$1.extend( {
		prop: function( elem, name, value ) {
			var ret, hooks,
				nType = elem.nodeType;

			// Don't get/set properties on text, comment and attribute nodes
			if ( nType === 3 || nType === 8 || nType === 2 ) {
				return;
			}

			if ( nType !== 1 || !jQuery$1.isXMLDoc( elem ) ) {

				// Fix name and attach hooks
				name = jQuery$1.propFix[ name ] || name;
				hooks = jQuery$1.propHooks[ name ];
			}

			if ( value !== undefined ) {
				if ( hooks && "set" in hooks &&
					( ret = hooks.set( elem, value, name ) ) !== undefined ) {
					return ret;
				}

				return ( elem[ name ] = value );
			}

			if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
				return ret;
			}

			return elem[ name ];
		},

		propHooks: {
			tabIndex: {
				get: function( elem ) {

					// Support: IE <=9 - 11+
					// elem.tabIndex doesn't always return the
					// correct value when it hasn't been explicitly set
					// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
					// Use proper attribute retrieval(#12072)
					var tabindex = elem.getAttribute( "tabindex" );

					if ( tabindex ) {
						return parseInt( tabindex, 10 );
					}

					if (
						rfocusable.test( elem.nodeName ) ||
						rclickable.test( elem.nodeName ) &&
						elem.href
					) {
						return 0;
					}

					return -1;
				}
			}
		},

		propFix: {
			"for": "htmlFor",
			"class": "className"
		}
	} );

	// Support: IE <=11+
	// Accessing the selectedIndex property forces the browser to respect
	// setting selected on the option. The getter ensures a default option
	// is selected when in an optgroup. ESLint rule "no-unused-expressions"
	// is disabled for this code since it considers such accessions noop.
	if ( isIE ) {
		jQuery$1.propHooks.selected = {
			get: function( elem ) {

				var parent = elem.parentNode;
				if ( parent && parent.parentNode ) {
					// eslint-disable-next-line no-unused-expressions
					parent.parentNode.selectedIndex;
				}
				return null;
			},
			set: function( elem ) {


				var parent = elem.parentNode;
				if ( parent ) {
					// eslint-disable-next-line no-unused-expressions
					parent.selectedIndex;

					if ( parent.parentNode ) {
						// eslint-disable-next-line no-unused-expressions
						parent.parentNode.selectedIndex;
					}
				}
			}
		};
	}

	jQuery$1.each( [
		"tabIndex",
		"readOnly",
		"maxLength",
		"cellSpacing",
		"cellPadding",
		"rowSpan",
		"colSpan",
		"useMap",
		"frameBorder",
		"contentEditable"
	], function() {
		jQuery$1.propFix[ this.toLowerCase() ] = this;
	} );

	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}

	function getClass( elem ) {
		return elem.getAttribute && elem.getAttribute( "class" ) || "";
	}

	function classesToArray( value ) {
		if ( Array.isArray( value ) ) {
			return value;
		}
		if ( typeof value === "string" ) {
			return value.match( rnothtmlwhite ) || [];
		}
		return [];
	}

	jQuery$1.fn.extend( {
		addClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( typeof value === "function" ) {
				return this.each( function( j ) {
					jQuery$1( this ).addClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			classes = classesToArray( value );

			if ( classes.length ) {
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );
					cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {
							if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
								cur += clazz + " ";
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		removeClass: function( value ) {
			var classes, elem, cur, curValue, clazz, j, finalValue,
				i = 0;

			if ( typeof value === "function" ) {
				return this.each( function( j ) {
					jQuery$1( this ).removeClass( value.call( this, j, getClass( this ) ) );
				} );
			}

			if ( !arguments.length ) {
				return this.attr( "class", "" );
			}

			classes = classesToArray( value );

			if ( classes.length ) {
				while ( ( elem = this[ i++ ] ) ) {
					curValue = getClass( elem );

					// This expression is here for better compressibility (see addClass)
					cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

					if ( cur ) {
						j = 0;
						while ( ( clazz = classes[ j++ ] ) ) {

							// Remove *all* instances
							while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
								cur = cur.replace( " " + clazz + " ", " " );
							}
						}

						// Only assign if different to avoid unneeded rendering.
						finalValue = stripAndCollapse( cur );
						if ( curValue !== finalValue ) {
							elem.setAttribute( "class", finalValue );
						}
					}
				}
			}

			return this;
		},

		toggleClass: function( value, stateVal ) {
			var type = typeof value,
				isValidValue = type === "string" || Array.isArray( value );

			if ( typeof stateVal === "boolean" && isValidValue ) {
				return stateVal ? this.addClass( value ) : this.removeClass( value );
			}

			if ( typeof value === "function" ) {
				return this.each( function( i ) {
					jQuery$1( this ).toggleClass(
						value.call( this, i, getClass( this ), stateVal ),
						stateVal
					);
				} );
			}

			return this.each( function() {
				var className, i, self, classNames;

				if ( isValidValue ) {

					// Toggle individual class names
					i = 0;
					self = jQuery$1( this );
					classNames = classesToArray( value );

					while ( ( className = classNames[ i++ ] ) ) {

						// Check each className given, space separated list
						if ( self.hasClass( className ) ) {
							self.removeClass( className );
						} else {
							self.addClass( className );
						}
					}

				// Toggle whole class name
				} else if ( value === undefined || type === "boolean" ) {
					className = getClass( this );
					if ( className ) {

						// Store className if set
						dataPriv.set( this, "__className__", className );
					}

					// If the element has a class name or if we're passed `false`,
					// then remove the whole classname (if there was one, the above saved it).
					// Otherwise bring back whatever was previously saved (if anything),
					// falling back to the empty string if nothing was stored.
					if ( this.setAttribute ) {
						this.setAttribute( "class",
							className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
						);
					}
				}
			} );
		},

		hasClass: function( selector ) {
			var className, elem,
				i = 0;

			className = " " + selector + " ";
			while ( ( elem = this[ i++ ] ) ) {
				if ( elem.nodeType === 1 &&
					( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
						return true;
				}
			}

			return false;
		}
	} );

	jQuery$1.fn.extend( {
		val: function( value ) {
			var hooks, ret, valueIsFunction,
				elem = this[ 0 ];

			if ( !arguments.length ) {
				if ( elem ) {
					hooks = jQuery$1.valHooks[ elem.type ] ||
						jQuery$1.valHooks[ elem.nodeName.toLowerCase() ];

					if ( hooks &&
						"get" in hooks &&
						( ret = hooks.get( elem, "value" ) ) !== undefined
					) {
						return ret;
					}

					ret = elem.value;

					// Handle cases where value is null/undef or number
					return ret == null ? "" : ret;
				}

				return;
			}

			valueIsFunction = typeof value === "function";

			return this.each( function( i ) {
				var val;

				if ( this.nodeType !== 1 ) {
					return;
				}

				if ( valueIsFunction ) {
					val = value.call( this, i, jQuery$1( this ).val() );
				} else {
					val = value;
				}

				// Treat null/undefined as ""; convert numbers to string
				if ( val == null ) {
					val = "";

				} else if ( typeof val === "number" ) {
					val += "";

				} else if ( Array.isArray( val ) ) {
					val = jQuery$1.map( val, function( value ) {
						return value == null ? "" : value + "";
					} );
				}

				hooks = jQuery$1.valHooks[ this.type ] || jQuery$1.valHooks[ this.nodeName.toLowerCase() ];

				// If set returns undefined, fall back to normal setting
				if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
					this.value = val;
				}
			} );
		}
	} );

	jQuery$1.extend( {
		valHooks: {
			select: {
				get: function( elem ) {
					var value, option, i,
						options = elem.options,
						index = elem.selectedIndex,
						one = elem.type === "select-one",
						values = one ? null : [],
						max = one ? index + 1 : options.length;

					if ( index < 0 ) {
						i = max;

					} else {
						i = one ? index : 0;
					}

					// Loop through all the selected options
					for ( ; i < max; i++ ) {
						option = options[ i ];

						if ( option.selected &&

								// Don't return options that are disabled or in a disabled optgroup
								!option.disabled &&
								( !option.parentNode.disabled ||
									!nodeName( option.parentNode, "optgroup" ) ) ) {

							// Get the specific value for the option
							value = jQuery$1( option ).val();

							// We don't need an array for one selects
							if ( one ) {
								return value;
							}

							// Multi-Selects return an array
							values.push( value );
						}
					}

					return values;
				},

				set: function( elem, value ) {
					var optionSet, option,
						options = elem.options,
						values = jQuery$1.makeArray( value ),
						i = options.length;

					while ( i-- ) {
						option = options[ i ];

						if ( ( option.selected =
							jQuery$1.inArray( jQuery$1( option ).val(), values ) > -1
						) ) {
							optionSet = true;
						}
					}

					// Force browsers to behave consistently when non-matching value is set
					if ( !optionSet ) {
						elem.selectedIndex = -1;
					}
					return values;
				}
			}
		}
	} );

	if ( isIE ) {
		jQuery$1.valHooks.option = {
			get: function( elem ) {

				var val = elem.getAttribute( "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11+
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery$1.text( elem ) );
			}
		};
	}

	// Radios and checkboxes getter/setter
	jQuery$1.each( [ "radio", "checkbox" ], function() {
		jQuery$1.valHooks[ this ] = {
			set: function( elem, value ) {
				if ( Array.isArray( value ) ) {
					return ( elem.checked = jQuery$1.inArray( jQuery$1( elem ).val(), value ) > -1 );
				}
			}
		};
	} );

	var location = window.location;

	var nonce = { guid: Date.now() };

	var rquery = ( /\?/ );

	// Cross-browser xml parsing
	jQuery$1.parseXML = function( data ) {
		var xml;
		if ( !data || typeof data !== "string" ) {
			return null;
		}

		// Support: IE 9 - 11+
		// IE throws on parseFromString with invalid input.
		try {
			xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
		} catch ( e ) {
			xml = undefined;
		}

		if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery$1.error( "Invalid XML: " + data );
		}
		return xml;
	};

	var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
		stopPropagationCallback = function( e ) {
			e.stopPropagation();
		};

	jQuery$1.extend( jQuery$1.event, {

		trigger: function( event, data, elem, onlyHandlers ) {

			var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
				eventPath = [ elem || document$1 ],
				type = hasOwn.call( event, "type" ) ? event.type : event,
				namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

			cur = lastElement = tmp = elem = elem || document$1;

			// Don't do events on text and comment nodes
			if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
				return;
			}

			// focus/blur morphs to focusin/out; ensure we're not firing them right now
			if ( rfocusMorph.test( type + jQuery$1.event.triggered ) ) {
				return;
			}

			if ( type.indexOf( "." ) > -1 ) {

				// Namespaced trigger; create a regexp to match event type in handle()
				namespaces = type.split( "." );
				type = namespaces.shift();
				namespaces.sort();
			}
			ontype = type.indexOf( ":" ) < 0 && "on" + type;

			// Caller can pass in a jQuery.Event object, Object, or just an event type string
			event = event[ jQuery$1.expando ] ?
				event :
				new jQuery$1.Event( type, typeof event === "object" && event );

			// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
			event.isTrigger = onlyHandlers ? 2 : 3;
			event.namespace = namespaces.join( "." );
			event.rnamespace = event.namespace ?
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
				null;

			// Clean up the event in case it is being reused
			event.result = undefined;
			if ( !event.target ) {
				event.target = elem;
			}

			// Clone any incoming data and prepend the event, creating the handler arg list
			data = data == null ?
				[ event ] :
				jQuery$1.makeArray( data, [ event ] );

			// Allow special events to draw outside the lines
			special = jQuery$1.event.special[ type ] || {};
			if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
				return;
			}

			// Determine event propagation path in advance, per W3C events spec (#9951)
			// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
			if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

				bubbleType = special.delegateType || type;
				if ( !rfocusMorph.test( bubbleType + type ) ) {
					cur = cur.parentNode;
				}
				for ( ; cur; cur = cur.parentNode ) {
					eventPath.push( cur );
					tmp = cur;
				}

				// Only add window if we got to document (e.g., not plain obj or detached DOM)
				if ( tmp === ( elem.ownerDocument || document$1 ) ) {
					eventPath.push( tmp.defaultView || tmp.parentWindow || window );
				}
			}

			// Fire handlers on the event path
			i = 0;
			while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
				lastElement = cur;
				event.type = i > 1 ?
					bubbleType :
					special.bindType || type;

				// jQuery handler
				handle = (
						dataPriv.get( cur, "events" ) || Object.create( null )
					)[ event.type ] &&
					dataPriv.get( cur, "handle" );
				if ( handle ) {
					handle.apply( cur, data );
				}

				// Native handler
				handle = ontype && cur[ ontype ];
				if ( handle && handle.apply && acceptData( cur ) ) {
					event.result = handle.apply( cur, data );
					if ( event.result === false ) {
						event.preventDefault();
					}
				}
			}
			event.type = type;

			// If nobody prevented the default action, do it now
			if ( !onlyHandlers && !event.isDefaultPrevented() ) {

				if ( ( !special._default ||
					special._default.apply( eventPath.pop(), data ) === false ) &&
					acceptData( elem ) ) {

					// Call a native DOM method on the target with the same name as the event.
					// Don't do default actions on window, that's where global variables be (#6170)
					if ( ontype && typeof elem[ type ] === "function" && !isWindow( elem ) ) {

						// Don't re-trigger an onFOO event when we call its FOO() method
						tmp = elem[ ontype ];

						if ( tmp ) {
							elem[ ontype ] = null;
						}

						// Prevent re-triggering of the same event, since we already bubbled it above
						jQuery$1.event.triggered = type;

						if ( event.isPropagationStopped() ) {
							lastElement.addEventListener( type, stopPropagationCallback );
						}

						elem[ type ]();

						if ( event.isPropagationStopped() ) {
							lastElement.removeEventListener( type, stopPropagationCallback );
						}

						jQuery$1.event.triggered = undefined;

						if ( tmp ) {
							elem[ ontype ] = tmp;
						}
					}
				}
			}

			return event.result;
		},

		// Piggyback on a donor event to simulate a different one
		// Used only for `focus(in | out)` events
		simulate: function( type, elem, event ) {
			var e = jQuery$1.extend(
				new jQuery$1.Event(),
				event,
				{
					type: type,
					isSimulated: true
				}
			);

			jQuery$1.event.trigger( e, null, elem );
		}

	} );

	jQuery$1.fn.extend( {

		trigger: function( type, data ) {
			return this.each( function() {
				jQuery$1.event.trigger( type, data, this );
			} );
		},
		triggerHandler: function( type, data ) {
			var elem = this[ 0 ];
			if ( elem ) {
				return jQuery$1.event.trigger( type, data, elem, true );
			}
		}
	} );

	var
		rbracket = /\[\]$/,
		rCRLF = /\r?\n/g,
		rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
		rsubmittable = /^(?:input|select|textarea|keygen)/i;

	function buildParams( prefix, obj, traditional, add ) {
		var name;

		if ( Array.isArray( obj ) ) {

			// Serialize array item.
			jQuery$1.each( obj, function( i, v ) {
				if ( traditional || rbracket.test( prefix ) ) {

					// Treat each array item as a scalar.
					add( prefix, v );

				} else {

					// Item is non-scalar (array or object), encode its numeric index.
					buildParams(
						prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
						v,
						traditional,
						add
					);
				}
			} );

		} else if ( !traditional && toType( obj ) === "object" ) {

			// Serialize object item.
			for ( name in obj ) {
				buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
			}

		} else {

			// Serialize scalar item.
			add( prefix, obj );
		}
	}

	// Serialize an array of form elements or a set of
	// key/values into a query string
	jQuery$1.param = function( a, traditional ) {
		var prefix,
			s = [],
			add = function( key, valueOrFunction ) {

				// If value is a function, invoke it and use its return value
				var value = typeof valueOrFunction === "function" ?
					valueOrFunction() :
					valueOrFunction;

				s[ s.length ] = encodeURIComponent( key ) + "=" +
					encodeURIComponent( value == null ? "" : value );
			};

		if ( a == null ) {
			return "";
		}

		// If an array was passed in, assume that it is an array of form elements.
		if ( Array.isArray( a ) || ( a.jquery && !jQuery$1.isPlainObject( a ) ) ) {

			// Serialize the form elements
			jQuery$1.each( a, function() {
				add( this.name, this.value );
			} );

		} else {

			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" );
	};

	jQuery$1.fn.extend( {
		serialize: function() {
			return jQuery$1.param( this.serializeArray() );
		},
		serializeArray: function() {
			return this.map( function() {

				// Can add propHook for "elements" to filter or add form elements
				var elements = jQuery$1.prop( this, "elements" );
				return elements ? jQuery$1.makeArray( elements ) : this;
			} )
			.filter( function() {
				var type = this.type;

				// Use .is( ":disabled" ) so that fieldset[disabled] works
				return this.name && !jQuery$1( this ).is( ":disabled" ) &&
					rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
					( this.checked || !rcheckableType.test( type ) );
			} )
			.map( function( _i, elem ) {
				var val = jQuery$1( this ).val();

				if ( val == null ) {
					return null;
				}

				if ( Array.isArray( val ) ) {
					return jQuery$1.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					} );
				}

				return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
			} ).get();
		}
	} );

	var
		r20 = /%20/g,
		rhash = /#.*$/,
		rantiCache = /([?&])_=[^&]*/,
		rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

		// #7653, #8125, #8152: local protocol detection
		rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
		rnoContent = /^(?:GET|HEAD)$/,
		rprotocol = /^\/\//,

		/* Prefilters
		 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
		 * 2) These are called:
		 *    - BEFORE asking for a transport
		 *    - AFTER param serialization (s.data is a string if s.processData is true)
		 * 3) key is the dataType
		 * 4) the catchall symbol "*" can be used
		 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
		 */
		prefilters = {},

		/* Transports bindings
		 * 1) key is the dataType
		 * 2) the catchall symbol "*" can be used
		 * 3) selection will start with transport dataType and THEN go to "*" if needed
		 */
		transports = {},

		// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
		allTypes = "*/".concat( "*" ),

		// Anchor tag for parsing the document origin
		originAnchor = document$1.createElement( "a" );
		originAnchor.href = location.href;

	// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
	function addToPrefiltersOrTransports( structure ) {

		// dataTypeExpression is optional and defaults to "*"
		return function( dataTypeExpression, func ) {

			if ( typeof dataTypeExpression !== "string" ) {
				func = dataTypeExpression;
				dataTypeExpression = "*";
			}

			var dataType,
				i = 0,
				dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

			if ( typeof func === "function" ) {

				// For each dataType in the dataTypeExpression
				while ( ( dataType = dataTypes[ i++ ] ) ) {

					// Prepend if requested
					if ( dataType[ 0 ] === "+" ) {
						dataType = dataType.slice( 1 ) || "*";
						( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

					// Otherwise append
					} else {
						( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
					}
				}
			}
		};
	}

	// Base inspection function for prefilters and transports
	function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

		var inspected = {},
			seekingTransport = ( structure === transports );

		function inspect( dataType ) {
			var selected;
			inspected[ dataType ] = true;
			jQuery$1.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
				var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
				if ( typeof dataTypeOrTransport === "string" &&
					!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

					options.dataTypes.unshift( dataTypeOrTransport );
					inspect( dataTypeOrTransport );
					return false;
				} else if ( seekingTransport ) {
					return !( selected = dataTypeOrTransport );
				}
			} );
			return selected;
		}

		return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
	}

	// A special extend for ajax options
	// that takes "flat" options (not to be deep extended)
	// Fixes #9887
	function ajaxExtend( target, src ) {
		var key, deep,
			flatOptions = jQuery$1.ajaxSettings.flatOptions || {};

		for ( key in src ) {
			if ( src[ key ] !== undefined ) {
				( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
			}
		}
		if ( deep ) {
			jQuery$1.extend( true, target, deep );
		}

		return target;
	}

	/* Handles responses to an ajax request:
	 * - finds the right dataType (mediates between content-type and expected dataType)
	 * - returns the corresponding response
	 */
	function ajaxHandleResponses( s, jqXHR, responses ) {

		var ct, type, finalDataType, firstDataType,
			contents = s.contents,
			dataTypes = s.dataTypes;

		// Remove auto dataType and get content-type in the process
		while ( dataTypes[ 0 ] === "*" ) {
			dataTypes.shift();
			if ( ct === undefined ) {
				ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
			}
		}

		// Check if we're dealing with a known content-type
		if ( ct ) {
			for ( type in contents ) {
				if ( contents[ type ] && contents[ type ].test( ct ) ) {
					dataTypes.unshift( type );
					break;
				}
			}
		}

		// Check to see if we have a response for the expected dataType
		if ( dataTypes[ 0 ] in responses ) {
			finalDataType = dataTypes[ 0 ];
		} else {

			// Try convertible dataTypes
			for ( type in responses ) {
				if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
					finalDataType = type;
					break;
				}
				if ( !firstDataType ) {
					firstDataType = type;
				}
			}

			// Or just use first one
			finalDataType = finalDataType || firstDataType;
		}

		// If we found a dataType
		// We add the dataType to the list if needed
		// and return the corresponding response
		if ( finalDataType ) {
			if ( finalDataType !== dataTypes[ 0 ] ) {
				dataTypes.unshift( finalDataType );
			}
			return responses[ finalDataType ];
		}
	}

	/* Chain conversions given the request and the original response
	 * Also sets the responseXXX fields on the jqXHR instance
	 */
	function ajaxConvert( s, response, jqXHR, isSuccess ) {
		var conv2, current, conv, tmp, prev,
			converters = {},

			// Work with a copy of dataTypes in case we need to modify it for conversion
			dataTypes = s.dataTypes.slice();

		// Create converters map with lowercased keys
		if ( dataTypes[ 1 ] ) {
			for ( conv in s.converters ) {
				converters[ conv.toLowerCase() ] = s.converters[ conv ];
			}
		}

		current = dataTypes.shift();

		// Convert to each sequential dataType
		while ( current ) {

			if ( s.responseFields[ current ] ) {
				jqXHR[ s.responseFields[ current ] ] = response;
			}

			// Apply the dataFilter if provided
			if ( !prev && isSuccess && s.dataFilter ) {
				response = s.dataFilter( response, s.dataType );
			}

			prev = current;
			current = dataTypes.shift();

			if ( current ) {

				// There's only work to do if current dataType is non-auto
				if ( current === "*" ) {

					current = prev;

				// Convert response if prev dataType is non-auto and differs from current
				} else if ( prev !== "*" && prev !== current ) {

					// Seek a direct converter
					conv = converters[ prev + " " + current ] || converters[ "* " + current ];

					// If none found, seek a pair
					if ( !conv ) {
						for ( conv2 in converters ) {

							// If conv2 outputs current
							tmp = conv2.split( " " );
							if ( tmp[ 1 ] === current ) {

								// If prev can be converted to accepted input
								conv = converters[ prev + " " + tmp[ 0 ] ] ||
									converters[ "* " + tmp[ 0 ] ];
								if ( conv ) {

									// Condense equivalence converters
									if ( conv === true ) {
										conv = converters[ conv2 ];

									// Otherwise, insert the intermediate dataType
									} else if ( converters[ conv2 ] !== true ) {
										current = tmp[ 0 ];
										dataTypes.unshift( tmp[ 1 ] );
									}
									break;
								}
							}
						}
					}

					// Apply converter (if not an equivalence)
					if ( conv !== true ) {

						// Unless errors are allowed to bubble, catch and return them
						if ( conv && s.throws ) {
							response = conv( response );
						} else {
							try {
								response = conv( response );
							} catch ( e ) {
								return {
									state: "parsererror",
									error: conv ? e : "No conversion from " + prev + " to " + current
								};
							}
						}
					}
				}
			}
		}

		return { state: "success", data: response };
	}

	jQuery$1.extend( {

		// Counter for holding the number of active queries
		active: 0,

		// Last-Modified header cache for next request
		lastModified: {},
		etag: {},

		ajaxSettings: {
			url: location.href,
			type: "GET",
			isLocal: rlocalProtocol.test( location.protocol ),
			global: true,
			processData: true,
			async: true,
			contentType: "application/x-www-form-urlencoded; charset=UTF-8",

			/*
			timeout: 0,
			data: null,
			dataType: null,
			username: null,
			password: null,
			cache: null,
			throws: false,
			traditional: false,
			headers: {},
			*/

			accepts: {
				"*": allTypes,
				text: "text/plain",
				html: "text/html",
				xml: "application/xml, text/xml",
				json: "application/json, text/javascript"
			},

			contents: {
				xml: /\bxml\b/,
				html: /\bhtml/,
				json: /\bjson\b/
			},

			responseFields: {
				xml: "responseXML",
				text: "responseText",
				json: "responseJSON"
			},

			// Data converters
			// Keys separate source (or catchall "*") and destination types with a single space
			converters: {

				// Convert anything to text
				"* text": String,

				// Text to html (true = no transformation)
				"text html": true,

				// Evaluate text as a json expression
				"text json": JSON.parse,

				// Parse text as xml
				"text xml": jQuery$1.parseXML
			},

			// For options that shouldn't be deep extended:
			// you can add your own custom options here if
			// and when you create one that shouldn't be
			// deep extended (see ajaxExtend)
			flatOptions: {
				url: true,
				context: true
			}
		},

		// Creates a full fledged settings object into target
		// with both ajaxSettings and settings fields.
		// If target is omitted, writes into ajaxSettings.
		ajaxSetup: function( target, settings ) {
			return settings ?

				// Building a settings object
				ajaxExtend( ajaxExtend( target, jQuery$1.ajaxSettings ), settings ) :

				// Extending ajaxSettings
				ajaxExtend( jQuery$1.ajaxSettings, target );
		},

		ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
		ajaxTransport: addToPrefiltersOrTransports( transports ),

		// Main method
		ajax: function( url, options ) {

			// If url is an object, simulate pre-1.5 signature
			if ( typeof url === "object" ) {
				options = url;
				url = undefined;
			}

			// Force options to be an object
			options = options || {};

			var transport,

				// URL without anti-cache param
				cacheURL,

				// Response headers
				responseHeadersString,
				responseHeaders,

				// timeout handle
				timeoutTimer,

				// Url cleanup var
				urlAnchor,

				// Request state (becomes false upon send and true upon completion)
				completed,

				// To know if global events are to be dispatched
				fireGlobals,

				// Loop variable
				i,

				// uncached part of the url
				uncached,

				// Create the final options object
				s = jQuery$1.ajaxSetup( {}, options ),

				// Callbacks context
				callbackContext = s.context || s,

				// Context for global events is callbackContext if it is a DOM node or jQuery collection
				globalEventContext = s.context &&
					( callbackContext.nodeType || callbackContext.jquery ) ?
						jQuery$1( callbackContext ) :
						jQuery$1.event,

				// Deferreds
				deferred = jQuery$1.Deferred(),
				completeDeferred = jQuery$1.Callbacks( "once memory" ),

				// Status-dependent callbacks
				statusCode = s.statusCode || {},

				// Headers (they are sent all at once)
				requestHeaders = {},
				requestHeadersNames = {},

				// Default abort message
				strAbort = "canceled",

				// Fake xhr
				jqXHR = {
					readyState: 0,

					// Builds headers hashtable if needed
					getResponseHeader: function( key ) {
						var match;
						if ( completed ) {
							if ( !responseHeaders ) {
								responseHeaders = {};
								while ( ( match = rheaders.exec( responseHeadersString ) ) ) {

									// Support: IE 11+
									// `getResponseHeader( key )` in IE doesn't combine all header
									// values for the provided key into a single result with values
									// joined by commas as other browsers do. Instead, it returns
									// them on separate lines.
									responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
										( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
											.concat( match[ 2 ] );
								}
							}
							match = responseHeaders[ key.toLowerCase() + " " ];
						}
						return match == null ? null : match.join( ", " );
					},

					// Raw string
					getAllResponseHeaders: function() {
						return completed ? responseHeadersString : null;
					},

					// Caches the header
					setRequestHeader: function( name, value ) {
						if ( completed == null ) {
							name = requestHeadersNames[ name.toLowerCase() ] =
								requestHeadersNames[ name.toLowerCase() ] || name;
							requestHeaders[ name ] = value;
						}
						return this;
					},

					// Overrides response content-type header
					overrideMimeType: function( type ) {
						if ( completed == null ) {
							s.mimeType = type;
						}
						return this;
					},

					// Status-dependent callbacks
					statusCode: function( map ) {
						var code;
						if ( map ) {
							if ( completed ) {

								// Execute the appropriate callbacks
								jqXHR.always( map[ jqXHR.status ] );
							} else {

								// Lazy-add the new callbacks in a way that preserves old ones
								for ( code in map ) {
									statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
								}
							}
						}
						return this;
					},

					// Cancel the request
					abort: function( statusText ) {
						var finalText = statusText || strAbort;
						if ( transport ) {
							transport.abort( finalText );
						}
						done( 0, finalText );
						return this;
					}
				};

			// Attach deferreds
			deferred.promise( jqXHR );

			// Add protocol if not provided (prefilters might expect it)
			// Handle falsy url in the settings object (#10093: consistency with old signature)
			// We also use the url parameter if available
			s.url = ( ( url || s.url || location.href ) + "" )
				.replace( rprotocol, location.protocol + "//" );

			// Alias method option to type as per ticket #12004
			s.type = options.method || options.type || s.method || s.type;

			// Extract dataTypes list
			s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

			// A cross-domain request is in order when the origin doesn't match the current origin.
			if ( s.crossDomain == null ) {
				urlAnchor = document$1.createElement( "a" );

				// Support: IE <=8 - 11+, Edge 12 - 17 only
				// IE throws exception on accessing the href property if url is malformed,
				// e.g. http://example.com:80x/
				try {
					urlAnchor.href = s.url;

					// Support: IE <=8 - 11+
					// Anchor's host property isn't correctly set when s.url is relative
					urlAnchor.href = urlAnchor.href;
					s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
						urlAnchor.protocol + "//" + urlAnchor.host;
				} catch ( e ) {

					// If there is an error parsing the URL, assume it is crossDomain,
					// it can be rejected by the transport if it is invalid
					s.crossDomain = true;
				}
			}

			// Convert data if not already a string
			if ( s.data && s.processData && typeof s.data !== "string" ) {
				s.data = jQuery$1.param( s.data, s.traditional );
			}

			// Apply prefilters
			inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

			// If request was aborted inside a prefilter, stop there
			if ( completed ) {
				return jqXHR;
			}

			// We can fire global events as of now if asked to
			// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
			fireGlobals = jQuery$1.event && s.global;

			// Watch for a new set of requests
			if ( fireGlobals && jQuery$1.active++ === 0 ) {
				jQuery$1.event.trigger( "ajaxStart" );
			}

			// Uppercase the type
			s.type = s.type.toUpperCase();

			// Determine if request has content
			s.hasContent = !rnoContent.test( s.type );

			// Save the URL in case we're toying with the If-Modified-Since
			// and/or If-None-Match header later on
			// Remove hash to simplify url manipulation
			cacheURL = s.url.replace( rhash, "" );

			// More options handling for requests with no content
			if ( !s.hasContent ) {

				// Remember the hash so we can put it back
				uncached = s.url.slice( cacheURL.length );

				// If data is available and should be processed, append data to url
				if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
					cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

					// #9682: remove data so that it's not used in an eventual retry
					delete s.data;
				}

				// Add or update anti-cache param if needed
				if ( s.cache === false ) {
					cacheURL = cacheURL.replace( rantiCache, "$1" );
					uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" +
						( nonce.guid++ ) + uncached;
				}

				// Put hash and anti-cache on the URL that will be requested (gh-1732)
				s.url = cacheURL + uncached;

			// Change '%20' to '+' if this is encoded form body content (gh-2658)
			} else if ( s.data && s.processData &&
				( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
				s.data = s.data.replace( r20, "+" );
			}

			// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
			if ( s.ifModified ) {
				if ( jQuery$1.lastModified[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-Modified-Since", jQuery$1.lastModified[ cacheURL ] );
				}
				if ( jQuery$1.etag[ cacheURL ] ) {
					jqXHR.setRequestHeader( "If-None-Match", jQuery$1.etag[ cacheURL ] );
				}
			}

			// Set the correct header, if data is being sent
			if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
				jqXHR.setRequestHeader( "Content-Type", s.contentType );
			}

			// Set the Accepts header for the server, depending on the dataType
			jqXHR.setRequestHeader(
				"Accept",
				s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
					s.accepts[ s.dataTypes[ 0 ] ] +
						( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
					s.accepts[ "*" ]
			);

			// Check for headers option
			for ( i in s.headers ) {
				jqXHR.setRequestHeader( i, s.headers[ i ] );
			}

			// Allow custom headers/mimetypes and early abort
			if ( s.beforeSend &&
				( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

				// Abort if not done already and return
				return jqXHR.abort();
			}

			// Aborting is no longer a cancellation
			strAbort = "abort";

			// Install callbacks on deferreds
			completeDeferred.add( s.complete );
			jqXHR.done( s.success );
			jqXHR.fail( s.error );

			// Get transport
			transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

			// If no transport, we auto-abort
			if ( !transport ) {
				done( -1, "No Transport" );
			} else {
				jqXHR.readyState = 1;

				// Send global event
				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
				}

				// If request was aborted inside ajaxSend, stop there
				if ( completed ) {
					return jqXHR;
				}

				// Timeout
				if ( s.async && s.timeout > 0 ) {
					timeoutTimer = window.setTimeout( function() {
						jqXHR.abort( "timeout" );
					}, s.timeout );
				}

				try {
					completed = false;
					transport.send( requestHeaders, done );
				} catch ( e ) {

					// Rethrow post-completion exceptions
					if ( completed ) {
						throw e;
					}

					// Propagate others as results
					done( -1, e );
				}
			}

			// Callback for when everything is done
			function done( status, nativeStatusText, responses, headers ) {
				var isSuccess, success, error, response, modified,
					statusText = nativeStatusText;

				// Ignore repeat invocations
				if ( completed ) {
					return;
				}

				completed = true;

				// Clear timeout if it exists
				if ( timeoutTimer ) {
					window.clearTimeout( timeoutTimer );
				}

				// Dereference transport for early garbage collection
				// (no matter how long the jqXHR object will be used)
				transport = undefined;

				// Cache response headers
				responseHeadersString = headers || "";

				// Set readyState
				jqXHR.readyState = status > 0 ? 4 : 0;

				// Determine if successful
				isSuccess = status >= 200 && status < 300 || status === 304;

				// Get response data
				if ( responses ) {
					response = ajaxHandleResponses( s, jqXHR, responses );
				}

				// Use a noop converter for missing script
				if ( !isSuccess && jQuery$1.inArray( "script", s.dataTypes ) > -1 ) {
					s.converters[ "text script" ] = function() {};
				}

				// Convert no matter what (that way responseXXX fields are always set)
				response = ajaxConvert( s, response, jqXHR, isSuccess );

				// If successful, handle type chaining
				if ( isSuccess ) {

					// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
					if ( s.ifModified ) {
						modified = jqXHR.getResponseHeader( "Last-Modified" );
						if ( modified ) {
							jQuery$1.lastModified[ cacheURL ] = modified;
						}
						modified = jqXHR.getResponseHeader( "etag" );
						if ( modified ) {
							jQuery$1.etag[ cacheURL ] = modified;
						}
					}

					// if no content
					if ( status === 204 || s.type === "HEAD" ) {
						statusText = "nocontent";

					// if not modified
					} else if ( status === 304 ) {
						statusText = "notmodified";

					// If we have data, let's convert it
					} else {
						statusText = response.state;
						success = response.data;
						error = response.error;
						isSuccess = !error;
					}
				} else {

					// Extract error from statusText and normalize for non-aborts
					error = statusText;
					if ( status || !statusText ) {
						statusText = "error";
						if ( status < 0 ) {
							status = 0;
						}
					}
				}

				// Set data for the fake xhr object
				jqXHR.status = status;
				jqXHR.statusText = ( nativeStatusText || statusText ) + "";

				// Success/Error
				if ( isSuccess ) {
					deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
				} else {
					deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
				}

				// Status-dependent callbacks
				jqXHR.statusCode( statusCode );
				statusCode = undefined;

				if ( fireGlobals ) {
					globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
						[ jqXHR, s, isSuccess ? success : error ] );
				}

				// Complete
				completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

				if ( fireGlobals ) {
					globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

					// Handle the global AJAX counter
					if ( !( --jQuery$1.active ) ) {
						jQuery$1.event.trigger( "ajaxStop" );
					}
				}
			}

			return jqXHR;
		},

		getJSON: function( url, data, callback ) {
			return jQuery$1.get( url, data, callback, "json" );
		},

		getScript: function( url, callback ) {
			return jQuery$1.get( url, undefined, callback, "script" );
		}
	} );

	jQuery$1.each( [ "get", "post" ], function( _i, method ) {
		jQuery$1[ method ] = function( url, data, callback, type ) {

			// Shift arguments if data argument was omitted
			if ( typeof data === "function" ) {
				type = type || callback;
				callback = data;
				data = undefined;
			}

			// The url can be an options object (which then must have .url)
			return jQuery$1.ajax( jQuery$1.extend( {
				url: url,
				type: method,
				dataType: type,
				data: data,
				success: callback
			}, jQuery$1.isPlainObject( url ) && url ) );
		};
	} );

	jQuery$1._evalUrl = function( url, options, doc ) {
		return jQuery$1.ajax( {
			url: url,

			// Make this explicit, since user can override this through ajaxSetup (#11264)
			type: "GET",
			dataType: "script",
			cache: true,
			async: false,
			global: false,

			// Only evaluate the response if it is successful (gh-4126)
			// dataFilter is not invoked for failure responses, so using it instead
			// of the default converter is kludgy but it works.
			converters: {
				"text script": function() {}
			},
			dataFilter: function( response ) {
				jQuery$1.globalEval( response, options, doc );
			}
		} );
	};

	jQuery$1.fn.extend( {
		wrapAll: function( html ) {
			var wrap;

			if ( this[ 0 ] ) {
				if ( typeof html === "function" ) {
					html = html.call( this[ 0 ] );
				}

				// The elements to wrap the target around
				wrap = jQuery$1( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

				if ( this[ 0 ].parentNode ) {
					wrap.insertBefore( this[ 0 ] );
				}

				wrap.map( function() {
					var elem = this;

					while ( elem.firstElementChild ) {
						elem = elem.firstElementChild;
					}

					return elem;
				} ).append( this );
			}

			return this;
		},

		wrapInner: function( html ) {
			if ( typeof html === "function" ) {
				return this.each( function( i ) {
					jQuery$1( this ).wrapInner( html.call( this, i ) );
				} );
			}

			return this.each( function() {
				var self = jQuery$1( this ),
					contents = self.contents();

				if ( contents.length ) {
					contents.wrapAll( html );

				} else {
					self.append( html );
				}
			} );
		},

		wrap: function( html ) {
			var htmlIsFunction = typeof html === "function";

			return this.each( function( i ) {
				jQuery$1( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
			} );
		},

		unwrap: function( selector ) {
			this.parent( selector ).not( "body" ).each( function() {
				jQuery$1( this ).replaceWith( this.childNodes );
			} );
			return this;
		}
	} );

	jQuery$1.expr.pseudos.hidden = function( elem ) {
		return !jQuery$1.expr.pseudos.visible( elem );
	};
	jQuery$1.expr.pseudos.visible = function( elem ) {
		return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
	};

	jQuery$1.ajaxSettings.xhr = function() {
		return new window.XMLHttpRequest();
	};

	var xhrSuccessStatus = {

			// File protocol always yields status code 0, assume 200
			0: 200
		};

	jQuery$1.ajaxTransport( function( options ) {
		var callback;

		// Cross domain only allowed if supported through XMLHttpRequest
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {
								complete(

									// File: protocol always yields status 0; see #8605, #14207
									xhr.status,
									xhr.statusText
								);
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) === "text" ?
										{ text: xhr.responseText } :
										{ binary: xhr.response },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				xhr.onabort = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	} );

	// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
	jQuery$1.ajaxPrefilter( function( s ) {
		if ( s.crossDomain ) {
			s.contents.script = false;
		}
	} );

	// Install script dataType
	jQuery$1.ajaxSetup( {
		accepts: {
			script: "text/javascript, application/javascript, " +
				"application/ecmascript, application/x-ecmascript"
		},
		contents: {
			script: /\b(?:java|ecma)script\b/
		},
		converters: {
			"text script": function( text ) {
				jQuery$1.globalEval( text );
				return text;
			}
		}
	} );

	// Handle cache's special case and crossDomain
	jQuery$1.ajaxPrefilter( "script", function( s ) {
		if ( s.cache === undefined ) {
			s.cache = false;
		}
		if ( s.crossDomain ) {
			s.type = "GET";
		}
	} );

	// Bind script tag hack transport
	jQuery$1.ajaxTransport( "script", function( s ) {

		// This transport only deals with cross domain or forced-by-attrs requests
		if ( s.crossDomain || s.scriptAttrs ) {
			var script, callback;
			return {
				send: function( _, complete ) {
					script = jQuery$1( "<script>" )
						.attr( s.scriptAttrs || {} )
						.prop( { charset: s.scriptCharset, src: s.url } )
						.on( "load error", callback = function( evt ) {
							script.remove();
							callback = null;
							if ( evt ) {
								complete( evt.type === "error" ? 404 : 200, evt.type );
							}
						} );

					// Use native DOM manipulation to avoid our domManip AJAX trickery
					document$1.head.appendChild( script[ 0 ] );
				},
				abort: function() {
					if ( callback ) {
						callback();
					}
				}
			};
		}
	} );

	var oldCallbacks = [],
		rjsonp = /(=)\?(?=&|$)|\?\?/;

	// Default jsonp settings
	jQuery$1.ajaxSetup( {
		jsonp: "callback",
		jsonpCallback: function() {
			var callback = oldCallbacks.pop() || ( jQuery$1.expando + "_" + ( nonce.guid++ ) );
			this[ callback ] = true;
			return callback;
		}
	} );

	// Detect, normalize options and install callbacks for jsonp requests
	jQuery$1.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

		var callbackName, overwritten, responseContainer,
			jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
				"url" :
				typeof s.data === "string" &&
					( s.contentType || "" )
						.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
					rjsonp.test( s.data ) && "data"
			);

		// Handle iff the expected data type is "jsonp" or we have a parameter to set
		if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

			// Get callback name, remembering preexisting value associated with it
			callbackName = s.jsonpCallback = typeof s.jsonpCallback === "function" ?
				s.jsonpCallback() :
				s.jsonpCallback;

			// Insert callback into url or form data
			if ( jsonProp ) {
				s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
			} else if ( s.jsonp !== false ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
			}

			// Use data converter to retrieve json after script execution
			s.converters[ "script json" ] = function() {
				if ( !responseContainer ) {
					jQuery$1.error( callbackName + " was not called" );
				}
				return responseContainer[ 0 ];
			};

			// Force json dataType
			s.dataTypes[ 0 ] = "json";

			// Install callback
			overwritten = window[ callbackName ];
			window[ callbackName ] = function() {
				responseContainer = arguments;
			};

			// Clean-up function (fires after converters)
			jqXHR.always( function() {

				// If previous value didn't exist - remove it
				if ( overwritten === undefined ) {
					jQuery$1( window ).removeProp( callbackName );

				// Otherwise restore preexisting value
				} else {
					window[ callbackName ] = overwritten;
				}

				// Save back as free
				if ( s[ callbackName ] ) {

					// Make sure that re-using the options doesn't screw things around
					s.jsonpCallback = originalSettings.jsonpCallback;

					// Save the callback name for future use
					oldCallbacks.push( callbackName );
				}

				// Call if it was a function and we have a response
				if ( responseContainer && typeof overwritten === "function" ) {
					overwritten( responseContainer[ 0 ] );
				}

				responseContainer = overwritten = undefined;
			} );

			// Delegate to script
			return "script";
		}
	} );

	// Argument "data" should be string of html
	// context (optional): If specified, the fragment will be created in this context,
	// defaults to document
	// keepScripts (optional): If true, will include scripts passed in the html string
	jQuery$1.parseHTML = function( data, context, keepScripts ) {
		if ( typeof data !== "string" ) {
			return [];
		}
		if ( typeof context === "boolean" ) {
			keepScripts = context;
			context = false;
		}

		var base, parsed, scripts;

		if ( !context ) {

			// Stop scripts or inline event handlers from being executed immediately
			// by using document.implementation
			context = document$1.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document$1.location.href;
			context.head.appendChild( base );
		}

		parsed = rsingleTag.exec( data );
		scripts = !keepScripts && [];

		// Single tag
		if ( parsed ) {
			return [ context.createElement( parsed[ 1 ] ) ];
		}

		parsed = buildFragment( [ data ], context, scripts );

		if ( scripts && scripts.length ) {
			jQuery$1( scripts ).remove();
		}

		return jQuery$1.merge( [], parsed.childNodes );
	};

	/**
	 * Load a url into a page
	 */
	jQuery$1.fn.load = function( url, params, callback ) {
		var selector, type, response,
			self = this,
			off = url.indexOf( " " );

		if ( off > -1 ) {
			selector = stripAndCollapse( url.slice( off ) );
			url = url.slice( 0, off );
		}

		// If it's a function
		if ( typeof params === "function" ) {

			// We assume that it's the callback
			callback = params;
			params = undefined;

		// Otherwise, build a param string
		} else if ( params && typeof params === "object" ) {
			type = "POST";
		}

		// If we have elements to modify, make the request
		if ( self.length > 0 ) {
			jQuery$1.ajax( {
				url: url,

				// If "type" variable is undefined, then "GET" method will be used.
				// Make value of this field explicit since
				// user can override it through ajaxSetup method
				type: type || "GET",
				dataType: "html",
				data: params
			} ).done( function( responseText ) {

				// Save response for use in complete callback
				response = arguments;

				self.html( selector ?

					// If a selector was specified, locate the right elements in a dummy div
					// Exclude scripts to avoid IE 'Permission Denied' errors
					jQuery$1( "<div>" ).append( jQuery$1.parseHTML( responseText ) ).find( selector ) :

					// Otherwise use the full result
					responseText );

			// If the request succeeds, this function gets "data", "status", "jqXHR"
			// but they are ignored because response was set above.
			// If it fails, this function gets "jqXHR", "status", "error"
			} ).always( callback && function( jqXHR, status ) {
				self.each( function() {
					callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
				} );
			} );
		}

		return this;
	};

	jQuery$1.expr.pseudos.animated = function( elem ) {
		return jQuery$1.grep( jQuery$1.timers, function( fn ) {
			return elem === fn.elem;
		} ).length;
	};

	jQuery$1.offset = {
		setOffset: function( elem, options, i ) {
			var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
				position = jQuery$1.css( elem, "position" ),
				curElem = jQuery$1( elem ),
				props = {};

			// Set position first, in-case top/left are set even on static elem
			if ( position === "static" ) {
				elem.style.position = "relative";
			}

			curOffset = curElem.offset();
			curCSSTop = jQuery$1.css( elem, "top" );
			curCSSLeft = jQuery$1.css( elem, "left" );
			calculatePosition = ( position === "absolute" || position === "fixed" ) &&
				( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

			// Need to be able to calculate position if either
			// top or left is auto and position is either absolute or fixed
			if ( calculatePosition ) {
				curPosition = curElem.position();
				curTop = curPosition.top;
				curLeft = curPosition.left;

			} else {
				curTop = parseFloat( curCSSTop ) || 0;
				curLeft = parseFloat( curCSSLeft ) || 0;
			}

			if ( typeof options === "function" ) {

				// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
				options = options.call( elem, i, jQuery$1.extend( {}, curOffset ) );
			}

			if ( options.top != null ) {
				props.top = ( options.top - curOffset.top ) + curTop;
			}
			if ( options.left != null ) {
				props.left = ( options.left - curOffset.left ) + curLeft;
			}

			if ( "using" in options ) {
				options.using.call( elem, props );

			} else {
				curElem.css( props );
			}
		}
	};

	jQuery$1.fn.extend( {

		// offset() relates an element's border box to the document origin
		offset: function( options ) {

			// Preserve chaining for setter
			if ( arguments.length ) {
				return options === undefined ?
					this :
					this.each( function( i ) {
						jQuery$1.offset.setOffset( this, options, i );
					} );
			}

			var rect, win,
				elem = this[ 0 ];

			if ( !elem ) {
				return;
			}

			// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
			// Support: IE <=11+
			// Running getBoundingClientRect on a
			// disconnected node in IE throws an error
			if ( !elem.getClientRects().length ) {
				return { top: 0, left: 0 };
			}

			// Get document-relative position by adding viewport scroll to viewport-relative gBCR
			rect = elem.getBoundingClientRect();
			win = elem.ownerDocument.defaultView;
			return {
				top: rect.top + win.pageYOffset,
				left: rect.left + win.pageXOffset
			};
		},

		// position() relates an element's margin box to its offset parent's padding box
		// This corresponds to the behavior of CSS absolute positioning
		position: function() {
			if ( !this[ 0 ] ) {
				return;
			}

			var offsetParent, offset, doc,
				elem = this[ 0 ],
				parentOffset = { top: 0, left: 0 };

			// position:fixed elements are offset from the viewport, which itself always has zero offset
			if ( jQuery$1.css( elem, "position" ) === "fixed" ) {

				// Assume position:fixed implies availability of getBoundingClientRect
				offset = elem.getBoundingClientRect();

			} else {
				offset = this.offset();

				// Account for the *real* offset parent, which can be the document or its root element
				// when a statically positioned element is identified
				doc = elem.ownerDocument;
				offsetParent = elem.offsetParent || doc.documentElement;
				while ( offsetParent &&
					( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
					jQuery$1.css( offsetParent, "position" ) === "static" ) {

					offsetParent = offsetParent.parentNode;
				}
				if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

					// Incorporate borders into its offset, since they are outside its content origin
					parentOffset = jQuery$1( offsetParent ).offset();
					parentOffset.top += jQuery$1.css( offsetParent, "borderTopWidth", true );
					parentOffset.left += jQuery$1.css( offsetParent, "borderLeftWidth", true );
				}
			}

			// Subtract parent offsets and element margins
			return {
				top: offset.top - parentOffset.top - jQuery$1.css( elem, "marginTop", true ),
				left: offset.left - parentOffset.left - jQuery$1.css( elem, "marginLeft", true )
			};
		},

		// This method will return documentElement in the following cases:
		// 1) For the element inside the iframe without offsetParent, this method will return
		//    documentElement of the parent window
		// 2) For the hidden or detached element
		// 3) For body or html element, i.e. in case of the html node - it will return itself
		//
		// but those exceptions were never presented as a real life use-cases
		// and might be considered as more preferable results.
		//
		// This logic, however, is not guaranteed and can change at any point in the future
		offsetParent: function() {
			return this.map( function() {
				var offsetParent = this.offsetParent;

				while ( offsetParent && jQuery$1.css( offsetParent, "position" ) === "static" ) {
					offsetParent = offsetParent.offsetParent;
				}

				return offsetParent || documentElement;
			} );
		}
	} );

	// Create scrollLeft and scrollTop methods
	jQuery$1.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
		var top = "pageYOffset" === prop;

		jQuery$1.fn[ method ] = function( val ) {
			return access( this, function( elem, method, val ) {

				// Coalesce documents and windows
				var win;
				if ( isWindow( elem ) ) {
					win = elem;
				} else if ( elem.nodeType === 9 ) {
					win = elem.defaultView;
				}

				if ( val === undefined ) {
					return win ? win[ prop ] : elem[ method ];
				}

				if ( win ) {
					win.scrollTo(
						!top ? val : win.pageXOffset,
						top ? val : win.pageYOffset
					);

				} else {
					elem[ method ] = val;
				}
			}, method, val, arguments.length );
		};
	} );

	// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
	jQuery$1.each( { Height: "height", Width: "width" }, function( name, type ) {
		jQuery$1.each( { padding: "inner" + name, content: type, "": "outer" + name },
			function( defaultExtra, funcName ) {

			// Margin is only for outerHeight, outerWidth
			jQuery$1.fn[ funcName ] = function( margin, value ) {
				var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
					extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

				return access( this, function( elem, type, value ) {
					var doc;

					if ( isWindow( elem ) ) {

						// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
						return funcName.indexOf( "outer" ) === 0 ?
							elem[ "inner" + name ] :
							elem.document.documentElement[ "client" + name ];
					}

					// Get document width or height
					if ( elem.nodeType === 9 ) {
						doc = elem.documentElement;

						// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
						// whichever is greatest
						return Math.max(
							elem.body[ "scroll" + name ], doc[ "scroll" + name ],
							elem.body[ "offset" + name ], doc[ "offset" + name ],
							doc[ "client" + name ]
						);
					}

					return value === undefined ?

						// Get width or height on the element, requesting but not forcing parseFloat
						jQuery$1.css( elem, type, extra ) :

						// Set width or height on the element
						jQuery$1.style( elem, type, value, extra );
				}, type, chainable ? margin : undefined, chainable );
			};
		} );
	} );

	var trim$1 = "".trim;

	jQuery$1.each( [
		"ajaxStart",
		"ajaxStop",
		"ajaxComplete",
		"ajaxError",
		"ajaxSuccess",
		"ajaxSend"
	], function( _i, type ) {
		jQuery$1.fn[ type ] = function( fn ) {
			return this.on( type, fn );
		};
	} );

	jQuery$1.fn.extend( {

		bind: function( types, data, fn ) {
			return this.on( types, null, data, fn );
		},
		unbind: function( types, fn ) {
			return this.off( types, null, fn );
		},

		delegate: function( selector, types, data, fn ) {
			return this.on( types, selector, data, fn );
		},
		undelegate: function( selector, types, fn ) {

			// ( namespace ) or ( selector, types [, fn] )
			return arguments.length === 1 ?
				this.off( selector, "**" ) :
				this.off( types, selector || "**", fn );
		},

		hover: function( fnOver, fnOut ) {
			return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
		}
	} );

	jQuery$1.each( ( "blur focus focusin focusout resize scroll click dblclick " +
		"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
		"change select submit keydown keypress keyup contextmenu" ).split( " " ),
		function( _i, name ) {

			// Handle event binding
			jQuery$1.fn[ name ] = function( data, fn ) {
				return arguments.length > 0 ?
					this.on( name, null, data, fn ) :
					this.trigger( name );
			};
		} );

	// Bind a function to a context, optionally partially applying any
	// arguments.
	// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
	// However, it is not slated for removal any time soon
	jQuery$1.proxy = function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( typeof fn !== "function" ) {
			return undefined;
		}

		// Simulated bind
		args = slice$1.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice$1.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery$1.guid++;

		return proxy;
	};

	jQuery$1.holdReady = function( hold ) {
		if ( hold ) {
			jQuery$1.readyWait++;
		} else {
			jQuery$1.ready( true );
		}
	};

	jQuery$1.trim = function( text ) {
		return text == null ? "" : trim$1.call( text );
	};

	var

		// Map over jQuery in case of overwrite
		_jQuery = window.jQuery,

		// Map over the $ in case of overwrite
		_$ = window.$;

	jQuery$1.noConflict = function( deep ) {
		if ( window.$ === jQuery$1 ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery$1 ) {
			window.jQuery = _jQuery;
		}

		return jQuery$1;
	};

	// Expose jQuery and $ identifiers, even in AMD
	// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
	// and CommonJS for browser emulators (#13566)
	if ( typeof noGlobal === "undefined" ) {
		window.jQuery = window.$ = jQuery$1;
	}

	function slice$2(arrayLike, start) {
	    start = start|0;
	    var newLen = Math.max(arrayLike.length - start, 0);
	    var newArr = Array(newLen);
	    for(var idx = 0; idx < newLen; idx++)  {
	        newArr[idx] = arrayLike[start + idx];
	    }
	    return newArr;
	}

	/**
	 * Creates a continuation function with some arguments already applied.
	 *
	 * Useful as a shorthand when combined with other control flow functions. Any
	 * arguments passed to the returned function are added to the arguments
	 * originally passed to apply.
	 *
	 * @name apply
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @category Util
	 * @param {Function} fn - The function you want to eventually apply all
	 * arguments to. Invokes with (arguments...).
	 * @param {...*} arguments... - Any number of arguments to automatically apply
	 * when the continuation is called.
	 * @returns {Function} the partially-applied function
	 * @example
	 *
	 * // using apply
	 * async.parallel([
	 *     async.apply(fs.writeFile, 'testfile1', 'test1'),
	 *     async.apply(fs.writeFile, 'testfile2', 'test2')
	 * ]);
	 *
	 *
	 * // the same process without using apply
	 * async.parallel([
	 *     function(callback) {
	 *         fs.writeFile('testfile1', 'test1', callback);
	 *     },
	 *     function(callback) {
	 *         fs.writeFile('testfile2', 'test2', callback);
	 *     }
	 * ]);
	 *
	 * // It's possible to pass any number of additional arguments when calling the
	 * // continuation:
	 *
	 * node> var fn = async.apply(sys.puts, 'one');
	 * node> fn('two', 'three');
	 * one
	 * two
	 * three
	 */
	function apply$1(fn/*, ...args*/) {
	    var args = slice$2(arguments, 1);
	    return function(/*callArgs*/) {
	        var callArgs = slice$2(arguments);
	        return fn.apply(null, args.concat(callArgs));
	    };
	}

	function initialParams (fn) {
	    return function (/*...args, callback*/) {
	        var args = slice$2(arguments);
	        var callback = args.pop();
	        fn.call(this, args, callback);
	    };
	}

	var hasSetImmediate = typeof setImmediate === 'function' && setImmediate;
	var hasNextTick = typeof process === 'object' && typeof process.nextTick === 'function';

	function fallback(fn) {
	    setTimeout(fn, 0);
	}

	function wrap$1(defer) {
	    return function (fn/*, ...args*/) {
	        var args = slice$2(arguments, 1);
	        defer(function () {
	            fn.apply(null, args);
	        });
	    };
	}

	var _defer;

	if (hasSetImmediate) {
	    _defer = setImmediate;
	} else if (hasNextTick) {
	    _defer = process.nextTick;
	} else {
	    _defer = fallback;
	}

	var setImmediate$1 = wrap$1(_defer);

	/**
	 * Take a sync function and make it async, passing its return value to a
	 * callback. This is useful for plugging sync functions into a waterfall,
	 * series, or other async functions. Any arguments passed to the generated
	 * function will be passed to the wrapped function (except for the final
	 * callback argument). Errors thrown will be passed to the callback.
	 *
	 * If the function passed to `asyncify` returns a Promise, that promises's
	 * resolved/rejected state will be used to call the callback, rather than simply
	 * the synchronous return value.
	 *
	 * This also means you can asyncify ES2017 `async` functions.
	 *
	 * @name asyncify
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @alias wrapSync
	 * @category Util
	 * @param {Function} func - The synchronous function, or Promise-returning
	 * function to convert to an {@link AsyncFunction}.
	 * @returns {AsyncFunction} An asynchronous wrapper of the `func`. To be
	 * invoked with `(args..., callback)`.
	 * @example
	 *
	 * // passing a regular synchronous function
	 * async.waterfall([
	 *     async.apply(fs.readFile, filename, "utf8"),
	 *     async.asyncify(JSON.parse),
	 *     function (data, next) {
	 *         // data is the result of parsing the text.
	 *         // If there was a parsing error, it would have been caught.
	 *     }
	 * ], callback);
	 *
	 * // passing a function returning a promise
	 * async.waterfall([
	 *     async.apply(fs.readFile, filename, "utf8"),
	 *     async.asyncify(function (contents) {
	 *         return db.model.create(contents);
	 *     }),
	 *     function (model, next) {
	 *         // `model` is the instantiated model object.
	 *         // If there was an error, this function would be skipped.
	 *     }
	 * ], callback);
	 *
	 * // es2017 example, though `asyncify` is not needed if your JS environment
	 * // supports async functions out of the box
	 * var q = async.queue(async.asyncify(async function(file) {
	 *     var intermediateStep = await processFile(file);
	 *     return await somePromise(intermediateStep)
	 * }));
	 *
	 * q.push(files);
	 */
	function asyncify(func) {
	    return initialParams(function (args, callback) {
	        var result;
	        try {
	            result = func.apply(this, args);
	        } catch (e) {
	            return callback(e);
	        }
	        // if result is Promise object
	        if (isObject(result) && typeof result.then === 'function') {
	            result.then(function(value) {
	                invokeCallback(callback, null, value);
	            }, function(err) {
	                invokeCallback(callback, err.message ? err : new Error(err));
	            });
	        } else {
	            callback(null, result);
	        }
	    });
	}

	function invokeCallback(callback, error, value) {
	    try {
	        callback(error, value);
	    } catch (e) {
	        setImmediate$1(rethrow, e);
	    }
	}

	function rethrow(error) {
	    throw error;
	}

	var supportsSymbol = typeof Symbol === 'function';

	function isAsync(fn) {
	    return supportsSymbol && fn[Symbol.toStringTag] === 'AsyncFunction';
	}

	function wrapAsync(asyncFn) {
	    return isAsync(asyncFn) ? asyncify(asyncFn) : asyncFn;
	}

	function applyEach(eachfn) {
	    return function(fns/*, ...args*/) {
	        var args = slice$2(arguments, 1);
	        var go = initialParams(function(args, callback) {
	            var that = this;
	            return eachfn(fns, function (fn, cb) {
	                wrapAsync(fn).apply(that, args.concat(cb));
	            }, callback);
	        });
	        if (args.length) {
	            return go.apply(this, args);
	        }
	        else {
	            return go;
	        }
	    };
	}

	// A temporary value used to identify if the loop should be broken.
	// See #1064, #1293
	var breakLoop = {};

	function once$1(fn) {
	    return function () {
	        if (fn === null) return;
	        var callFn = fn;
	        fn = null;
	        callFn.apply(this, arguments);
	    };
	}

	var iteratorSymbol = typeof Symbol === 'function' && Symbol.iterator;

	function getIterator (coll) {
	    return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();
	}

	function createArrayIterator(coll) {
	    var i = -1;
	    var len = coll.length;
	    return function next() {
	        return ++i < len ? {value: coll[i], key: i} : null;
	    }
	}

	function createES2015Iterator(iterator) {
	    var i = -1;
	    return function next() {
	        var item = iterator.next();
	        if (item.done)
	            return null;
	        i++;
	        return {value: item.value, key: i};
	    }
	}

	function createObjectIterator(obj) {
	    var okeys = keys(obj);
	    var i = -1;
	    var len = okeys.length;
	    return function next() {
	        var key = okeys[++i];
	        return i < len ? {value: obj[key], key: key} : null;
	    };
	}

	function iterator(coll) {
	    if (isArrayLike(coll)) {
	        return createArrayIterator(coll);
	    }

	    var iterator = getIterator(coll);
	    return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
	}

	function onlyOnce(fn) {
	    return function() {
	        if (fn === null) throw new Error("Callback was already called.");
	        var callFn = fn;
	        fn = null;
	        callFn.apply(this, arguments);
	    };
	}

	function _eachOfLimit(limit) {
	    return function (obj, iteratee, callback) {
	        callback = once$1(callback || noop);
	        if (limit <= 0 || !obj) {
	            return callback(null);
	        }
	        var nextElem = iterator(obj);
	        var done = false;
	        var running = 0;
	        var looping = false;

	        function iterateeCallback(err, value) {
	            running -= 1;
	            if (err) {
	                done = true;
	                callback(err);
	            }
	            else if (value === breakLoop || (done && running <= 0)) {
	                done = true;
	                return callback(null);
	            }
	            else if (!looping) {
	                replenish();
	            }
	        }

	        function replenish () {
	            looping = true;
	            while (running < limit && !done) {
	                var elem = nextElem();
	                if (elem === null) {
	                    done = true;
	                    if (running <= 0) {
	                        callback(null);
	                    }
	                    return;
	                }
	                running += 1;
	                iteratee(elem.value, elem.key, onlyOnce(iterateeCallback));
	            }
	            looping = false;
	        }

	        replenish();
	    };
	}

	/**
	 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs a maximum of `limit` async operations at a
	 * time.
	 *
	 * @name eachOfLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.eachOf]{@link module:Collections.eachOf}
	 * @alias forEachOfLimit
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {AsyncFunction} iteratee - An async function to apply to each
	 * item in `coll`. The `key` is the item's key, or index in the case of an
	 * array.
	 * Invoked with (item, key, callback).
	 * @param {Function} [callback] - A callback which is called when all
	 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
	 */
	function eachOfLimit(coll, limit, iteratee, callback) {
	    _eachOfLimit(limit)(coll, wrapAsync(iteratee), callback);
	}

	function doLimit(fn, limit) {
	    return function (iterable, iteratee, callback) {
	        return fn(iterable, limit, iteratee, callback);
	    };
	}

	// eachOf implementation optimized for array-likes
	function eachOfArrayLike(coll, iteratee, callback) {
	    callback = once$1(callback || noop);
	    var index = 0,
	        completed = 0,
	        length = coll.length;
	    if (length === 0) {
	        callback(null);
	    }

	    function iteratorCallback(err, value) {
	        if (err) {
	            callback(err);
	        } else if ((++completed === length) || value === breakLoop) {
	            callback(null);
	        }
	    }

	    for (; index < length; index++) {
	        iteratee(coll[index], index, onlyOnce(iteratorCallback));
	    }
	}

	// a generic version of eachOf which can handle array, object, and iterator cases.
	var eachOfGeneric = doLimit(eachOfLimit, Infinity);

	/**
	 * Like [`each`]{@link module:Collections.each}, except that it passes the key (or index) as the second argument
	 * to the iteratee.
	 *
	 * @name eachOf
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @alias forEachOf
	 * @category Collection
	 * @see [async.each]{@link module:Collections.each}
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {AsyncFunction} iteratee - A function to apply to each
	 * item in `coll`.
	 * The `key` is the item's key, or index in the case of an array.
	 * Invoked with (item, key, callback).
	 * @param {Function} [callback] - A callback which is called when all
	 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
	 * @example
	 *
	 * var obj = {dev: "/dev.json", test: "/test.json", prod: "/prod.json"};
	 * var configs = {};
	 *
	 * async.forEachOf(obj, function (value, key, callback) {
	 *     fs.readFile(__dirname + value, "utf8", function (err, data) {
	 *         if (err) return callback(err);
	 *         try {
	 *             configs[key] = JSON.parse(data);
	 *         } catch (e) {
	 *             return callback(e);
	 *         }
	 *         callback();
	 *     });
	 * }, function (err) {
	 *     if (err) console.error(err.message);
	 *     // configs is now a map of JSON data
	 *     doSomethingWith(configs);
	 * });
	 */
	function eachOf(coll, iteratee, callback) {
	    var eachOfImplementation = isArrayLike(coll) ? eachOfArrayLike : eachOfGeneric;
	    eachOfImplementation(coll, wrapAsync(iteratee), callback);
	}

	function doParallel(fn) {
	    return function (obj, iteratee, callback) {
	        return fn(eachOf, obj, wrapAsync(iteratee), callback);
	    };
	}

	function _asyncMap(eachfn, arr, iteratee, callback) {
	    callback = callback || noop;
	    arr = arr || [];
	    var results = [];
	    var counter = 0;
	    var _iteratee = wrapAsync(iteratee);

	    eachfn(arr, function (value, _, callback) {
	        var index = counter++;
	        _iteratee(value, function (err, v) {
	            results[index] = v;
	            callback(err);
	        });
	    }, function (err) {
	        callback(err, results);
	    });
	}

	/**
	 * Produces a new collection of values by mapping each value in `coll` through
	 * the `iteratee` function. The `iteratee` is called with an item from `coll`
	 * and a callback for when it has finished processing. Each of these callback
	 * takes 2 arguments: an `error`, and the transformed item from `coll`. If
	 * `iteratee` passes an error to its callback, the main `callback` (for the
	 * `map` function) is immediately called with the error.
	 *
	 * Note, that since this function applies the `iteratee` to each item in
	 * parallel, there is no guarantee that the `iteratee` functions will complete
	 * in order. However, the results array will be in the same order as the
	 * original `coll`.
	 *
	 * If `map` is passed an Object, the results will be an Array.  The results
	 * will roughly be in the order of the original Objects' keys (but this can
	 * vary across JavaScript engines).
	 *
	 * @name map
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {AsyncFunction} iteratee - An async function to apply to each item in
	 * `coll`.
	 * The iteratee should complete with the transformed item.
	 * Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called when all `iteratee`
	 * functions have finished, or an error occurs. Results is an Array of the
	 * transformed items from the `coll`. Invoked with (err, results).
	 * @example
	 *
	 * async.map(['file1','file2','file3'], fs.stat, function(err, results) {
	 *     // results is now an array of stats for each file
	 * });
	 */
	var map$1 = doParallel(_asyncMap);

	/**
	 * Applies the provided arguments to each function in the array, calling
	 * `callback` after all functions have completed. If you only provide the first
	 * argument, `fns`, then it will return a function which lets you pass in the
	 * arguments as if it were a single function call. If more arguments are
	 * provided, `callback` is required while `args` is still optional.
	 *
	 * @name applyEach
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Array|Iterable|Object} fns - A collection of {@link AsyncFunction}s
	 * to all call with the same arguments
	 * @param {...*} [args] - any number of separate arguments to pass to the
	 * function.
	 * @param {Function} [callback] - the final argument should be the callback,
	 * called when all functions have completed processing.
	 * @returns {Function} - If only the first argument, `fns`, is provided, it will
	 * return a function which lets you pass in the arguments as if it were a single
	 * function call. The signature is `(..args, callback)`. If invoked with any
	 * arguments, `callback` is required.
	 * @example
	 *
	 * async.applyEach([enableSearch, updateSchema], 'bucket', callback);
	 *
	 * // partial application example:
	 * async.each(
	 *     buckets,
	 *     async.applyEach([enableSearch, updateSchema]),
	 *     callback
	 * );
	 */
	var applyEach$1 = applyEach(map$1);

	function doParallelLimit(fn) {
	    return function (obj, limit, iteratee, callback) {
	        return fn(_eachOfLimit(limit), obj, wrapAsync(iteratee), callback);
	    };
	}

	/**
	 * The same as [`map`]{@link module:Collections.map} but runs a maximum of `limit` async operations at a time.
	 *
	 * @name mapLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.map]{@link module:Collections.map}
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {AsyncFunction} iteratee - An async function to apply to each item in
	 * `coll`.
	 * The iteratee should complete with the transformed item.
	 * Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called when all `iteratee`
	 * functions have finished, or an error occurs. Results is an array of the
	 * transformed items from the `coll`. Invoked with (err, results).
	 */
	var mapLimit = doParallelLimit(_asyncMap);

	/**
	 * The same as [`map`]{@link module:Collections.map} but runs only a single async operation at a time.
	 *
	 * @name mapSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.map]{@link module:Collections.map}
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {AsyncFunction} iteratee - An async function to apply to each item in
	 * `coll`.
	 * The iteratee should complete with the transformed item.
	 * Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called when all `iteratee`
	 * functions have finished, or an error occurs. Results is an array of the
	 * transformed items from the `coll`. Invoked with (err, results).
	 */
	var mapSeries = doLimit(mapLimit, 1);

	/**
	 * The same as [`applyEach`]{@link module:ControlFlow.applyEach} but runs only a single async operation at a time.
	 *
	 * @name applyEachSeries
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.applyEach]{@link module:ControlFlow.applyEach}
	 * @category Control Flow
	 * @param {Array|Iterable|Object} fns - A collection of {@link AsyncFunction}s to all
	 * call with the same arguments
	 * @param {...*} [args] - any number of separate arguments to pass to the
	 * function.
	 * @param {Function} [callback] - the final argument should be the callback,
	 * called when all functions have completed processing.
	 * @returns {Function} - If only the first argument is provided, it will return
	 * a function which lets you pass in the arguments as if it were a single
	 * function call.
	 */
	var applyEachSeries = applyEach(mapSeries);

	/**
	 * Determines the best order for running the {@link AsyncFunction}s in `tasks`, based on
	 * their requirements. Each function can optionally depend on other functions
	 * being completed first, and each function is run as soon as its requirements
	 * are satisfied.
	 *
	 * If any of the {@link AsyncFunction}s pass an error to their callback, the `auto` sequence
	 * will stop. Further tasks will not execute (so any other functions depending
	 * on it will not run), and the main `callback` is immediately called with the
	 * error.
	 *
	 * {@link AsyncFunction}s also receive an object containing the results of functions which
	 * have completed so far as the first argument, if they have dependencies. If a
	 * task function has no dependencies, it will only be passed a callback.
	 *
	 * @name auto
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Object} tasks - An object. Each of its properties is either a
	 * function or an array of requirements, with the {@link AsyncFunction} itself the last item
	 * in the array. The object's key of a property serves as the name of the task
	 * defined by that property, i.e. can be used when specifying requirements for
	 * other tasks. The function receives one or two arguments:
	 * * a `results` object, containing the results of the previously executed
	 *   functions, only passed if the task has any dependencies,
	 * * a `callback(err, result)` function, which must be called when finished,
	 *   passing an `error` (which can be `null`) and the result of the function's
	 *   execution.
	 * @param {number} [concurrency=Infinity] - An optional `integer` for
	 * determining the maximum number of tasks that can be run in parallel. By
	 * default, as many as possible.
	 * @param {Function} [callback] - An optional callback which is called when all
	 * the tasks have been completed. It receives the `err` argument if any `tasks`
	 * pass an error to their callback. Results are always returned; however, if an
	 * error occurs, no further `tasks` will be performed, and the results object
	 * will only contain partial results. Invoked with (err, results).
	 * @returns undefined
	 * @example
	 *
	 * async.auto({
	 *     // this function will just be passed a callback
	 *     readData: async.apply(fs.readFile, 'data.txt', 'utf-8'),
	 *     showData: ['readData', function(results, cb) {
	 *         // results.readData is the file's contents
	 *         // ...
	 *     }]
	 * }, callback);
	 *
	 * async.auto({
	 *     get_data: function(callback) {
	 *         console.log('in get_data');
	 *         // async code to get some data
	 *         callback(null, 'data', 'converted to array');
	 *     },
	 *     make_folder: function(callback) {
	 *         console.log('in make_folder');
	 *         // async code to create a directory to store a file in
	 *         // this is run at the same time as getting the data
	 *         callback(null, 'folder');
	 *     },
	 *     write_file: ['get_data', 'make_folder', function(results, callback) {
	 *         console.log('in write_file', JSON.stringify(results));
	 *         // once there is some data and the directory exists,
	 *         // write the data to a file in the directory
	 *         callback(null, 'filename');
	 *     }],
	 *     email_link: ['write_file', function(results, callback) {
	 *         console.log('in email_link', JSON.stringify(results));
	 *         // once the file is written let's email a link to it...
	 *         // results.write_file contains the filename returned by write_file.
	 *         callback(null, {'file':results.write_file, 'email':'user@example.com'});
	 *     }]
	 * }, function(err, results) {
	 *     console.log('err = ', err);
	 *     console.log('results = ', results);
	 * });
	 */
	function auto (tasks, concurrency, callback) {
	    if (typeof concurrency === 'function') {
	        // concurrency is optional, shift the args.
	        callback = concurrency;
	        concurrency = null;
	    }
	    callback = once$1(callback || noop);
	    var keys$1 = keys(tasks);
	    var numTasks = keys$1.length;
	    if (!numTasks) {
	        return callback(null);
	    }
	    if (!concurrency) {
	        concurrency = numTasks;
	    }

	    var results = {};
	    var runningTasks = 0;
	    var hasError = false;

	    var listeners = Object.create(null);

	    var readyTasks = [];

	    // for cycle detection:
	    var readyToCheck = []; // tasks that have been identified as reachable
	    // without the possibility of returning to an ancestor task
	    var uncheckedDependencies = {};

	    baseForOwn(tasks, function (task, key) {
	        if (!isArray(task)) {
	            // no dependencies
	            enqueueTask(key, [task]);
	            readyToCheck.push(key);
	            return;
	        }

	        var dependencies = task.slice(0, task.length - 1);
	        var remainingDependencies = dependencies.length;
	        if (remainingDependencies === 0) {
	            enqueueTask(key, task);
	            readyToCheck.push(key);
	            return;
	        }
	        uncheckedDependencies[key] = remainingDependencies;

	        arrayEach(dependencies, function (dependencyName) {
	            if (!tasks[dependencyName]) {
	                throw new Error('async.auto task `' + key +
	                    '` has a non-existent dependency `' +
	                    dependencyName + '` in ' +
	                    dependencies.join(', '));
	            }
	            addListener(dependencyName, function () {
	                remainingDependencies--;
	                if (remainingDependencies === 0) {
	                    enqueueTask(key, task);
	                }
	            });
	        });
	    });

	    checkForDeadlocks();
	    processQueue();

	    function enqueueTask(key, task) {
	        readyTasks.push(function () {
	            runTask(key, task);
	        });
	    }

	    function processQueue() {
	        if (readyTasks.length === 0 && runningTasks === 0) {
	            return callback(null, results);
	        }
	        while(readyTasks.length && runningTasks < concurrency) {
	            var run = readyTasks.shift();
	            run();
	        }

	    }

	    function addListener(taskName, fn) {
	        var taskListeners = listeners[taskName];
	        if (!taskListeners) {
	            taskListeners = listeners[taskName] = [];
	        }

	        taskListeners.push(fn);
	    }

	    function taskComplete(taskName) {
	        var taskListeners = listeners[taskName] || [];
	        arrayEach(taskListeners, function (fn) {
	            fn();
	        });
	        processQueue();
	    }


	    function runTask(key, task) {
	        if (hasError) return;

	        var taskCallback = onlyOnce(function(err, result) {
	            runningTasks--;
	            if (arguments.length > 2) {
	                result = slice$2(arguments, 1);
	            }
	            if (err) {
	                var safeResults = {};
	                baseForOwn(results, function(val, rkey) {
	                    safeResults[rkey] = val;
	                });
	                safeResults[key] = result;
	                hasError = true;
	                listeners = Object.create(null);

	                callback(err, safeResults);
	            } else {
	                results[key] = result;
	                taskComplete(key);
	            }
	        });

	        runningTasks++;
	        var taskFn = wrapAsync(task[task.length - 1]);
	        if (task.length > 1) {
	            taskFn(results, taskCallback);
	        } else {
	            taskFn(taskCallback);
	        }
	    }

	    function checkForDeadlocks() {
	        // Kahn's algorithm
	        // https://en.wikipedia.org/wiki/Topological_sorting#Kahn.27s_algorithm
	        // http://connalle.blogspot.com/2013/10/topological-sortingkahn-algorithm.html
	        var currentTask;
	        var counter = 0;
	        while (readyToCheck.length) {
	            currentTask = readyToCheck.pop();
	            counter++;
	            arrayEach(getDependents(currentTask), function (dependent) {
	                if (--uncheckedDependencies[dependent] === 0) {
	                    readyToCheck.push(dependent);
	                }
	            });
	        }

	        if (counter !== numTasks) {
	            throw new Error(
	                'async.auto cannot execute tasks due to a recursive dependency'
	            );
	        }
	    }

	    function getDependents(taskName) {
	        var result = [];
	        baseForOwn(tasks, function (task, key) {
	            if (isArray(task) && baseIndexOf(task, taskName, 0) >= 0) {
	                result.push(key);
	            }
	        });
	        return result;
	    }
	}

	var FN_ARGS = /^(?:async\s+)?(function)?\s*[^\(]*\(\s*([^\)]*)\)/m;
	var FN_ARG_SPLIT = /,/;
	var FN_ARG = /(=.+)?(\s*)$/;
	var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;

	function parseParams(func) {
	    func = func.toString().replace(STRIP_COMMENTS, '');
	    func = func.match(FN_ARGS)[2].replace(' ', '');
	    func = func ? func.split(FN_ARG_SPLIT) : [];
	    func = func.map(function (arg){
	        return trim(arg.replace(FN_ARG, ''));
	    });
	    return func;
	}

	/**
	 * A dependency-injected version of the [async.auto]{@link module:ControlFlow.auto} function. Dependent
	 * tasks are specified as parameters to the function, after the usual callback
	 * parameter, with the parameter names matching the names of the tasks it
	 * depends on. This can provide even more readable task graphs which can be
	 * easier to maintain.
	 *
	 * If a final callback is specified, the task results are similarly injected,
	 * specified as named parameters after the initial error parameter.
	 *
	 * The autoInject function is purely syntactic sugar and its semantics are
	 * otherwise equivalent to [async.auto]{@link module:ControlFlow.auto}.
	 *
	 * @name autoInject
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.auto]{@link module:ControlFlow.auto}
	 * @category Control Flow
	 * @param {Object} tasks - An object, each of whose properties is an {@link AsyncFunction} of
	 * the form 'func([dependencies...], callback). The object's key of a property
	 * serves as the name of the task defined by that property, i.e. can be used
	 * when specifying requirements for other tasks.
	 * * The `callback` parameter is a `callback(err, result)` which must be called
	 *   when finished, passing an `error` (which can be `null`) and the result of
	 *   the function's execution. The remaining parameters name other tasks on
	 *   which the task is dependent, and the results from those tasks are the
	 *   arguments of those parameters.
	 * @param {Function} [callback] - An optional callback which is called when all
	 * the tasks have been completed. It receives the `err` argument if any `tasks`
	 * pass an error to their callback, and a `results` object with any completed
	 * task results, similar to `auto`.
	 * @example
	 *
	 * //  The example from `auto` can be rewritten as follows:
	 * async.autoInject({
	 *     get_data: function(callback) {
	 *         // async code to get some data
	 *         callback(null, 'data', 'converted to array');
	 *     },
	 *     make_folder: function(callback) {
	 *         // async code to create a directory to store a file in
	 *         // this is run at the same time as getting the data
	 *         callback(null, 'folder');
	 *     },
	 *     write_file: function(get_data, make_folder, callback) {
	 *         // once there is some data and the directory exists,
	 *         // write the data to a file in the directory
	 *         callback(null, 'filename');
	 *     },
	 *     email_link: function(write_file, callback) {
	 *         // once the file is written let's email a link to it...
	 *         // write_file contains the filename returned by write_file.
	 *         callback(null, {'file':write_file, 'email':'user@example.com'});
	 *     }
	 * }, function(err, results) {
	 *     console.log('err = ', err);
	 *     console.log('email_link = ', results.email_link);
	 * });
	 *
	 * // If you are using a JS minifier that mangles parameter names, `autoInject`
	 * // will not work with plain functions, since the parameter names will be
	 * // collapsed to a single letter identifier.  To work around this, you can
	 * // explicitly specify the names of the parameters your task function needs
	 * // in an array, similar to Angular.js dependency injection.
	 *
	 * // This still has an advantage over plain `auto`, since the results a task
	 * // depends on are still spread into arguments.
	 * async.autoInject({
	 *     //...
	 *     write_file: ['get_data', 'make_folder', function(get_data, make_folder, callback) {
	 *         callback(null, 'filename');
	 *     }],
	 *     email_link: ['write_file', function(write_file, callback) {
	 *         callback(null, {'file':write_file, 'email':'user@example.com'});
	 *     }]
	 *     //...
	 * }, function(err, results) {
	 *     console.log('err = ', err);
	 *     console.log('email_link = ', results.email_link);
	 * });
	 */
	function autoInject(tasks, callback) {
	    var newTasks = {};

	    baseForOwn(tasks, function (taskFn, key) {
	        var params;
	        var fnIsAsync = isAsync(taskFn);
	        var hasNoDeps =
	            (!fnIsAsync && taskFn.length === 1) ||
	            (fnIsAsync && taskFn.length === 0);

	        if (isArray(taskFn)) {
	            params = taskFn.slice(0, -1);
	            taskFn = taskFn[taskFn.length - 1];

	            newTasks[key] = params.concat(params.length > 0 ? newTask : taskFn);
	        } else if (hasNoDeps) {
	            // no dependencies, use the function as-is
	            newTasks[key] = taskFn;
	        } else {
	            params = parseParams(taskFn);
	            if (taskFn.length === 0 && !fnIsAsync && params.length === 0) {
	                throw new Error("autoInject task functions require explicit parameters.");
	            }

	            // remove callback param
	            if (!fnIsAsync) params.pop();

	            newTasks[key] = params.concat(newTask);
	        }

	        function newTask(results, taskCb) {
	            var newArgs = arrayMap(params, function (name) {
	                return results[name];
	            });
	            newArgs.push(taskCb);
	            wrapAsync(taskFn).apply(null, newArgs);
	        }
	    });

	    auto(newTasks, callback);
	}

	// Simple doubly linked list (https://en.wikipedia.org/wiki/Doubly_linked_list) implementation
	// used for queues. This implementation assumes that the node provided by the user can be modified
	// to adjust the next and last properties. We implement only the minimal functionality
	// for queue support.
	function DLL() {
	    this.head = this.tail = null;
	    this.length = 0;
	}

	function setInitial(dll, node) {
	    dll.length = 1;
	    dll.head = dll.tail = node;
	}

	DLL.prototype.removeLink = function(node) {
	    if (node.prev) node.prev.next = node.next;
	    else this.head = node.next;
	    if (node.next) node.next.prev = node.prev;
	    else this.tail = node.prev;

	    node.prev = node.next = null;
	    this.length -= 1;
	    return node;
	};

	DLL.prototype.empty = function () {
	    while(this.head) this.shift();
	    return this;
	};

	DLL.prototype.insertAfter = function(node, newNode) {
	    newNode.prev = node;
	    newNode.next = node.next;
	    if (node.next) node.next.prev = newNode;
	    else this.tail = newNode;
	    node.next = newNode;
	    this.length += 1;
	};

	DLL.prototype.insertBefore = function(node, newNode) {
	    newNode.prev = node.prev;
	    newNode.next = node;
	    if (node.prev) node.prev.next = newNode;
	    else this.head = newNode;
	    node.prev = newNode;
	    this.length += 1;
	};

	DLL.prototype.unshift = function(node) {
	    if (this.head) this.insertBefore(this.head, node);
	    else setInitial(this, node);
	};

	DLL.prototype.push = function(node) {
	    if (this.tail) this.insertAfter(this.tail, node);
	    else setInitial(this, node);
	};

	DLL.prototype.shift = function() {
	    return this.head && this.removeLink(this.head);
	};

	DLL.prototype.pop = function() {
	    return this.tail && this.removeLink(this.tail);
	};

	DLL.prototype.toArray = function () {
	    var arr = Array(this.length);
	    var curr = this.head;
	    for(var idx = 0; idx < this.length; idx++) {
	        arr[idx] = curr.data;
	        curr = curr.next;
	    }
	    return arr;
	};

	DLL.prototype.remove = function (testFn) {
	    var curr = this.head;
	    while(!!curr) {
	        var next = curr.next;
	        if (testFn(curr)) {
	            this.removeLink(curr);
	        }
	        curr = next;
	    }
	    return this;
	};

	function queue(worker, concurrency, payload) {
	    if (concurrency == null) {
	        concurrency = 1;
	    }
	    else if(concurrency === 0) {
	        throw new Error('Concurrency must not be zero');
	    }

	    var _worker = wrapAsync(worker);
	    var numRunning = 0;
	    var workersList = [];

	    var processingScheduled = false;
	    function _insert(data, insertAtFront, callback) {
	        if (callback != null && typeof callback !== 'function') {
	            throw new Error('task callback must be a function');
	        }
	        q.started = true;
	        if (!isArray(data)) {
	            data = [data];
	        }
	        if (data.length === 0 && q.idle()) {
	            // call drain immediately if there are no tasks
	            return setImmediate$1(function() {
	                q.drain();
	            });
	        }

	        for (var i = 0, l = data.length; i < l; i++) {
	            var item = {
	                data: data[i],
	                callback: callback || noop
	            };

	            if (insertAtFront) {
	                q._tasks.unshift(item);
	            } else {
	                q._tasks.push(item);
	            }
	        }

	        if (!processingScheduled) {
	            processingScheduled = true;
	            setImmediate$1(function() {
	                processingScheduled = false;
	                q.process();
	            });
	        }
	    }

	    function _next(tasks) {
	        return function(err){
	            numRunning -= 1;

	            for (var i = 0, l = tasks.length; i < l; i++) {
	                var task = tasks[i];

	                var index = baseIndexOf(workersList, task, 0);
	                if (index === 0) {
	                    workersList.shift();
	                } else if (index > 0) {
	                    workersList.splice(index, 1);
	                }

	                task.callback.apply(task, arguments);

	                if (err != null) {
	                    q.error(err, task.data);
	                }
	            }

	            if (numRunning <= (q.concurrency - q.buffer) ) {
	                q.unsaturated();
	            }

	            if (q.idle()) {
	                q.drain();
	            }
	            q.process();
	        };
	    }

	    var isProcessing = false;
	    var q = {
	        _tasks: new DLL(),
	        concurrency: concurrency,
	        payload: payload,
	        saturated: noop,
	        unsaturated:noop,
	        buffer: concurrency / 4,
	        empty: noop,
	        drain: noop,
	        error: noop,
	        started: false,
	        paused: false,
	        push: function (data, callback) {
	            _insert(data, false, callback);
	        },
	        kill: function () {
	            q.drain = noop;
	            q._tasks.empty();
	        },
	        unshift: function (data, callback) {
	            _insert(data, true, callback);
	        },
	        remove: function (testFn) {
	            q._tasks.remove(testFn);
	        },
	        process: function () {
	            // Avoid trying to start too many processing operations. This can occur
	            // when callbacks resolve synchronously (#1267).
	            if (isProcessing) {
	                return;
	            }
	            isProcessing = true;
	            while(!q.paused && numRunning < q.concurrency && q._tasks.length){
	                var tasks = [], data = [];
	                var l = q._tasks.length;
	                if (q.payload) l = Math.min(l, q.payload);
	                for (var i = 0; i < l; i++) {
	                    var node = q._tasks.shift();
	                    tasks.push(node);
	                    workersList.push(node);
	                    data.push(node.data);
	                }

	                numRunning += 1;

	                if (q._tasks.length === 0) {
	                    q.empty();
	                }

	                if (numRunning === q.concurrency) {
	                    q.saturated();
	                }

	                var cb = onlyOnce(_next(tasks));
	                _worker(data, cb);
	            }
	            isProcessing = false;
	        },
	        length: function () {
	            return q._tasks.length;
	        },
	        running: function () {
	            return numRunning;
	        },
	        workersList: function () {
	            return workersList;
	        },
	        idle: function() {
	            return q._tasks.length + numRunning === 0;
	        },
	        pause: function () {
	            q.paused = true;
	        },
	        resume: function () {
	            if (q.paused === false) { return; }
	            q.paused = false;
	            setImmediate$1(q.process);
	        }
	    };
	    return q;
	}

	/**
	 * A cargo of tasks for the worker function to complete. Cargo inherits all of
	 * the same methods and event callbacks as [`queue`]{@link module:ControlFlow.queue}.
	 * @typedef {Object} CargoObject
	 * @memberOf module:ControlFlow
	 * @property {Function} length - A function returning the number of items
	 * waiting to be processed. Invoke like `cargo.length()`.
	 * @property {number} payload - An `integer` for determining how many tasks
	 * should be process per round. This property can be changed after a `cargo` is
	 * created to alter the payload on-the-fly.
	 * @property {Function} push - Adds `task` to the `queue`. The callback is
	 * called once the `worker` has finished processing the task. Instead of a
	 * single task, an array of `tasks` can be submitted. The respective callback is
	 * used for every task in the list. Invoke like `cargo.push(task, [callback])`.
	 * @property {Function} saturated - A callback that is called when the
	 * `queue.length()` hits the concurrency and further tasks will be queued.
	 * @property {Function} empty - A callback that is called when the last item
	 * from the `queue` is given to a `worker`.
	 * @property {Function} drain - A callback that is called when the last item
	 * from the `queue` has returned from the `worker`.
	 * @property {Function} idle - a function returning false if there are items
	 * waiting or being processed, or true if not. Invoke like `cargo.idle()`.
	 * @property {Function} pause - a function that pauses the processing of tasks
	 * until `resume()` is called. Invoke like `cargo.pause()`.
	 * @property {Function} resume - a function that resumes the processing of
	 * queued tasks when the queue is paused. Invoke like `cargo.resume()`.
	 * @property {Function} kill - a function that removes the `drain` callback and
	 * empties remaining tasks from the queue forcing it to go idle. Invoke like `cargo.kill()`.
	 */

	/**
	 * Creates a `cargo` object with the specified payload. Tasks added to the
	 * cargo will be processed altogether (up to the `payload` limit). If the
	 * `worker` is in progress, the task is queued until it becomes available. Once
	 * the `worker` has completed some tasks, each callback of those tasks is
	 * called. Check out [these](https://camo.githubusercontent.com/6bbd36f4cf5b35a0f11a96dcd2e97711ffc2fb37/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130382f62626330636662302d356632392d313165322d393734662d3333393763363464633835382e676966) [animations](https://camo.githubusercontent.com/f4810e00e1c5f5f8addbe3e9f49064fd5d102699/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f313637363837312f36383130312f38346339323036362d356632392d313165322d383134662d3964336430323431336266642e676966)
	 * for how `cargo` and `queue` work.
	 *
	 * While [`queue`]{@link module:ControlFlow.queue} passes only one task to one of a group of workers
	 * at a time, cargo passes an array of tasks to a single worker, repeating
	 * when the worker is finished.
	 *
	 * @name cargo
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.queue]{@link module:ControlFlow.queue}
	 * @category Control Flow
	 * @param {AsyncFunction} worker - An asynchronous function for processing an array
	 * of queued tasks. Invoked with `(tasks, callback)`.
	 * @param {number} [payload=Infinity] - An optional `integer` for determining
	 * how many tasks should be processed per round; if omitted, the default is
	 * unlimited.
	 * @returns {module:ControlFlow.CargoObject} A cargo object to manage the tasks. Callbacks can
	 * attached as certain properties to listen for specific events during the
	 * lifecycle of the cargo and inner queue.
	 * @example
	 *
	 * // create a cargo object with payload 2
	 * var cargo = async.cargo(function(tasks, callback) {
	 *     for (var i=0; i<tasks.length; i++) {
	 *         console.log('hello ' + tasks[i].name);
	 *     }
	 *     callback();
	 * }, 2);
	 *
	 * // add some items
	 * cargo.push({name: 'foo'}, function(err) {
	 *     console.log('finished processing foo');
	 * });
	 * cargo.push({name: 'bar'}, function(err) {
	 *     console.log('finished processing bar');
	 * });
	 * cargo.push({name: 'baz'}, function(err) {
	 *     console.log('finished processing baz');
	 * });
	 */
	function cargo(worker, payload) {
	    return queue(worker, 1, payload);
	}

	/**
	 * The same as [`eachOf`]{@link module:Collections.eachOf} but runs only a single async operation at a time.
	 *
	 * @name eachOfSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.eachOf]{@link module:Collections.eachOf}
	 * @alias forEachOfSeries
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {AsyncFunction} iteratee - An async function to apply to each item in
	 * `coll`.
	 * Invoked with (item, key, callback).
	 * @param {Function} [callback] - A callback which is called when all `iteratee`
	 * functions have finished, or an error occurs. Invoked with (err).
	 */
	var eachOfSeries = doLimit(eachOfLimit, 1);

	/**
	 * Reduces `coll` into a single value using an async `iteratee` to return each
	 * successive step. `memo` is the initial state of the reduction. This function
	 * only operates in series.
	 *
	 * For performance reasons, it may make sense to split a call to this function
	 * into a parallel map, and then use the normal `Array.prototype.reduce` on the
	 * results. This function is for situations where each step in the reduction
	 * needs to be async; if you can get the data before reducing it, then it's
	 * probably a good idea to do so.
	 *
	 * @name reduce
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @alias inject
	 * @alias foldl
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {*} memo - The initial state of the reduction.
	 * @param {AsyncFunction} iteratee - A function applied to each item in the
	 * array to produce the next step in the reduction.
	 * The `iteratee` should complete with the next state of the reduction.
	 * If the iteratee complete with an error, the reduction is stopped and the
	 * main `callback` is immediately called with the error.
	 * Invoked with (memo, item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Result is the reduced value. Invoked with
	 * (err, result).
	 * @example
	 *
	 * async.reduce([1,2,3], 0, function(memo, item, callback) {
	 *     // pointless async:
	 *     process.nextTick(function() {
	 *         callback(null, memo + item)
	 *     });
	 * }, function(err, result) {
	 *     // result is now equal to the last value of memo, which is 6
	 * });
	 */
	function reduce$1(coll, memo, iteratee, callback) {
	    callback = once$1(callback || noop);
	    var _iteratee = wrapAsync(iteratee);
	    eachOfSeries(coll, function(x, i, callback) {
	        _iteratee(memo, x, function(err, v) {
	            memo = v;
	            callback(err);
	        });
	    }, function(err) {
	        callback(err, memo);
	    });
	}

	/**
	 * Version of the compose function that is more natural to read. Each function
	 * consumes the return value of the previous function. It is the equivalent of
	 * [compose]{@link module:ControlFlow.compose} with the arguments reversed.
	 *
	 * Each function is executed with the `this` binding of the composed function.
	 *
	 * @name seq
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.compose]{@link module:ControlFlow.compose}
	 * @category Control Flow
	 * @param {...AsyncFunction} functions - the asynchronous functions to compose
	 * @returns {Function} a function that composes the `functions` in order
	 * @example
	 *
	 * // Requires lodash (or underscore), express3 and dresende's orm2.
	 * // Part of an app, that fetches cats of the logged user.
	 * // This example uses `seq` function to avoid overnesting and error
	 * // handling clutter.
	 * app.get('/cats', function(request, response) {
	 *     var User = request.models.User;
	 *     async.seq(
	 *         _.bind(User.get, User),  // 'User.get' has signature (id, callback(err, data))
	 *         function(user, fn) {
	 *             user.getCats(fn);      // 'getCats' has signature (callback(err, data))
	 *         }
	 *     )(req.session.user_id, function (err, cats) {
	 *         if (err) {
	 *             console.error(err);
	 *             response.json({ status: 'error', message: err.message });
	 *         } else {
	 *             response.json({ status: 'ok', message: 'Cats found', data: cats });
	 *         }
	 *     });
	 * });
	 */
	function seq$1(/*...functions*/) {
	    var _functions = arrayMap(arguments, wrapAsync);
	    return function(/*...args*/) {
	        var args = slice$2(arguments);
	        var that = this;

	        var cb = args[args.length - 1];
	        if (typeof cb == 'function') {
	            args.pop();
	        } else {
	            cb = noop;
	        }

	        reduce$1(_functions, args, function(newargs, fn, cb) {
	            fn.apply(that, newargs.concat(function(err/*, ...nextargs*/) {
	                var nextargs = slice$2(arguments, 1);
	                cb(err, nextargs);
	            }));
	        },
	        function(err, results) {
	            cb.apply(that, [err].concat(results));
	        });
	    };
	}

	/**
	 * Creates a function which is a composition of the passed asynchronous
	 * functions. Each function consumes the return value of the function that
	 * follows. Composing functions `f()`, `g()`, and `h()` would produce the result
	 * of `f(g(h()))`, only this version uses callbacks to obtain the return values.
	 *
	 * Each function is executed with the `this` binding of the composed function.
	 *
	 * @name compose
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {...AsyncFunction} functions - the asynchronous functions to compose
	 * @returns {Function} an asynchronous function that is the composed
	 * asynchronous `functions`
	 * @example
	 *
	 * function add1(n, callback) {
	 *     setTimeout(function () {
	 *         callback(null, n + 1);
	 *     }, 10);
	 * }
	 *
	 * function mul3(n, callback) {
	 *     setTimeout(function () {
	 *         callback(null, n * 3);
	 *     }, 10);
	 * }
	 *
	 * var add1mul3 = async.compose(mul3, add1);
	 * add1mul3(4, function (err, result) {
	 *     // result now equals 15
	 * });
	 */
	function compose(/*...args*/) {
	    return seq$1.apply(null, slice$2(arguments).reverse());
	}

	var _concat = Array.prototype.concat;

	/**
	 * The same as [`concat`]{@link module:Collections.concat} but runs a maximum of `limit` async operations at a time.
	 *
	 * @name concatLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.concat]{@link module:Collections.concat}
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,
	 * which should use an array as its result. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished, or an error occurs. Results is an array
	 * containing the concatenated results of the `iteratee` function. Invoked with
	 * (err, results).
	 */
	function concatLimit(coll, limit, iteratee, callback) {
	    callback = callback || noop;
	    var _iteratee = wrapAsync(iteratee);
	    mapLimit(coll, limit, function(val, callback) {
	        _iteratee(val, function(err /*, ...args*/) {
	            if (err) return callback(err);
	            return callback(null, slice$2(arguments, 1));
	        });
	    }, function(err, mapResults) {
	        var result = [];
	        for (var i = 0; i < mapResults.length; i++) {
	            if (mapResults[i]) {
	                result = _concat.apply(result, mapResults[i]);
	            }
	        }

	        return callback(err, result);
	    });
	}

	/**
	 * Applies `iteratee` to each item in `coll`, concatenating the results. Returns
	 * the concatenated list. The `iteratee`s are called in parallel, and the
	 * results are concatenated as they return. There is no guarantee that the
	 * results array will be returned in the original order of `coll` passed to the
	 * `iteratee` function.
	 *
	 * @name concat
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`,
	 * which should use an array as its result. Invoked with (item, callback).
	 * @param {Function} [callback(err)] - A callback which is called after all the
	 * `iteratee` functions have finished, or an error occurs. Results is an array
	 * containing the concatenated results of the `iteratee` function. Invoked with
	 * (err, results).
	 * @example
	 *
	 * async.concat(['dir1','dir2','dir3'], fs.readdir, function(err, files) {
	 *     // files is now a list of filenames that exist in the 3 directories
	 * });
	 */
	var concat$1 = doLimit(concatLimit, Infinity);

	/**
	 * The same as [`concat`]{@link module:Collections.concat} but runs only a single async operation at a time.
	 *
	 * @name concatSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.concat]{@link module:Collections.concat}
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {AsyncFunction} iteratee - A function to apply to each item in `coll`.
	 * The iteratee should complete with an array an array of results.
	 * Invoked with (item, callback).
	 * @param {Function} [callback(err)] - A callback which is called after all the
	 * `iteratee` functions have finished, or an error occurs. Results is an array
	 * containing the concatenated results of the `iteratee` function. Invoked with
	 * (err, results).
	 */
	var concatSeries = doLimit(concatLimit, 1);

	/**
	 * Returns a function that when called, calls-back with the values provided.
	 * Useful as the first function in a [`waterfall`]{@link module:ControlFlow.waterfall}, or for plugging values in to
	 * [`auto`]{@link module:ControlFlow.auto}.
	 *
	 * @name constant
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @category Util
	 * @param {...*} arguments... - Any number of arguments to automatically invoke
	 * callback with.
	 * @returns {AsyncFunction} Returns a function that when invoked, automatically
	 * invokes the callback with the previous given arguments.
	 * @example
	 *
	 * async.waterfall([
	 *     async.constant(42),
	 *     function (value, next) {
	 *         // value === 42
	 *     },
	 *     //...
	 * ], callback);
	 *
	 * async.waterfall([
	 *     async.constant(filename, "utf8"),
	 *     fs.readFile,
	 *     function (fileData, next) {
	 *         //...
	 *     }
	 *     //...
	 * ], callback);
	 *
	 * async.auto({
	 *     hostname: async.constant("https://server.net/"),
	 *     port: findFreePort,
	 *     launchServer: ["hostname", "port", function (options, cb) {
	 *         startServer(options, cb);
	 *     }],
	 *     //...
	 * }, callback);
	 */
	function constant$1(/*...values*/) {
	    var values = slice$2(arguments);
	    var args = [null].concat(values);
	    return function (/*...ignoredArgs, callback*/) {
	        var callback = arguments[arguments.length - 1];
	        return callback.apply(this, args);
	    };
	}

	function _createTester(check, getResult) {
	    return function(eachfn, arr, iteratee, cb) {
	        cb = cb || noop;
	        var testPassed = false;
	        var testResult;
	        eachfn(arr, function(value, _, callback) {
	            iteratee(value, function(err, result) {
	                if (err) {
	                    callback(err);
	                } else if (check(result) && !testResult) {
	                    testPassed = true;
	                    testResult = getResult(true, value);
	                    callback(null, breakLoop);
	                } else {
	                    callback();
	                }
	            });
	        }, function(err) {
	            if (err) {
	                cb(err);
	            } else {
	                cb(null, testPassed ? testResult : getResult(false));
	            }
	        });
	    };
	}

	function _findGetResult(v, x) {
	    return x;
	}

	/**
	 * Returns the first value in `coll` that passes an async truth test. The
	 * `iteratee` is applied in parallel, meaning the first iteratee to return
	 * `true` will fire the detect `callback` with that result. That means the
	 * result might not be the first item in the original `coll` (in terms of order)
	 * that passes the test.

	 * If order within the original `coll` is important, then look at
	 * [`detectSeries`]{@link module:Collections.detectSeries}.
	 *
	 * @name detect
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @alias find
	 * @category Collections
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
	 * The iteratee must complete with a boolean value as its result.
	 * Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called as soon as any
	 * iteratee returns `true`, or after all the `iteratee` functions have finished.
	 * Result will be the first item in the array that passes the truth test
	 * (iteratee) or the value `undefined` if none passed. Invoked with
	 * (err, result).
	 * @example
	 *
	 * async.detect(['file1','file2','file3'], function(filePath, callback) {
	 *     fs.access(filePath, function(err) {
	 *         callback(null, !err)
	 *     });
	 * }, function(err, result) {
	 *     // result now equals the first file in the list that exists
	 * });
	 */
	var detect = doParallel(_createTester(identity, _findGetResult));

	/**
	 * The same as [`detect`]{@link module:Collections.detect} but runs a maximum of `limit` async operations at a
	 * time.
	 *
	 * @name detectLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.detect]{@link module:Collections.detect}
	 * @alias findLimit
	 * @category Collections
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
	 * The iteratee must complete with a boolean value as its result.
	 * Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called as soon as any
	 * iteratee returns `true`, or after all the `iteratee` functions have finished.
	 * Result will be the first item in the array that passes the truth test
	 * (iteratee) or the value `undefined` if none passed. Invoked with
	 * (err, result).
	 */
	var detectLimit = doParallelLimit(_createTester(identity, _findGetResult));

	/**
	 * The same as [`detect`]{@link module:Collections.detect} but runs only a single async operation at a time.
	 *
	 * @name detectSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.detect]{@link module:Collections.detect}
	 * @alias findSeries
	 * @category Collections
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {AsyncFunction} iteratee - A truth test to apply to each item in `coll`.
	 * The iteratee must complete with a boolean value as its result.
	 * Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called as soon as any
	 * iteratee returns `true`, or after all the `iteratee` functions have finished.
	 * Result will be the first item in the array that passes the truth test
	 * (iteratee) or the value `undefined` if none passed. Invoked with
	 * (err, result).
	 */
	var detectSeries = doLimit(detectLimit, 1);

	function consoleFunc(name) {
	    return function (fn/*, ...args*/) {
	        var args = slice$2(arguments, 1);
	        args.push(function (err/*, ...args*/) {
	            var args = slice$2(arguments, 1);
	            if (typeof console === 'object') {
	                if (err) {
	                    if (console.error) {
	                        console.error(err);
	                    }
	                } else if (console[name]) {
	                    arrayEach(args, function (x) {
	                        console[name](x);
	                    });
	                }
	            }
	        });
	        wrapAsync(fn).apply(null, args);
	    };
	}

	/**
	 * Logs the result of an [`async` function]{@link AsyncFunction} to the
	 * `console` using `console.dir` to display the properties of the resulting object.
	 * Only works in Node.js or in browsers that support `console.dir` and
	 * `console.error` (such as FF and Chrome).
	 * If multiple arguments are returned from the async function,
	 * `console.dir` is called on each argument in order.
	 *
	 * @name dir
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @category Util
	 * @param {AsyncFunction} function - The function you want to eventually apply
	 * all arguments to.
	 * @param {...*} arguments... - Any number of arguments to apply to the function.
	 * @example
	 *
	 * // in a module
	 * var hello = function(name, callback) {
	 *     setTimeout(function() {
	 *         callback(null, {hello: name});
	 *     }, 1000);
	 * };
	 *
	 * // in the node repl
	 * node> async.dir(hello, 'world');
	 * {hello: 'world'}
	 */
	var dir$1 = consoleFunc('dir');

	/**
	 * The post-check version of [`during`]{@link module:ControlFlow.during}. To reflect the difference in
	 * the order of operations, the arguments `test` and `fn` are switched.
	 *
	 * Also a version of [`doWhilst`]{@link module:ControlFlow.doWhilst} with asynchronous `test` function.
	 * @name doDuring
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.during]{@link module:ControlFlow.during}
	 * @category Control Flow
	 * @param {AsyncFunction} fn - An async function which is called each time
	 * `test` passes. Invoked with (callback).
	 * @param {AsyncFunction} test - asynchronous truth test to perform before each
	 * execution of `fn`. Invoked with (...args, callback), where `...args` are the
	 * non-error args from the previous callback of `fn`.
	 * @param {Function} [callback] - A callback which is called after the test
	 * function has failed and repeated execution of `fn` has stopped. `callback`
	 * will be passed an error if one occurred, otherwise `null`.
	 */
	function doDuring(fn, test, callback) {
	    callback = onlyOnce(callback || noop);
	    var _fn = wrapAsync(fn);
	    var _test = wrapAsync(test);

	    function next(err/*, ...args*/) {
	        if (err) return callback(err);
	        var args = slice$2(arguments, 1);
	        args.push(check);
	        _test.apply(this, args);
	    }
	    function check(err, truth) {
	        if (err) return callback(err);
	        if (!truth) return callback(null);
	        _fn(next);
	    }

	    check(null, true);

	}

	/**
	 * The post-check version of [`whilst`]{@link module:ControlFlow.whilst}. To reflect the difference in
	 * the order of operations, the arguments `test` and `iteratee` are switched.
	 *
	 * `doWhilst` is to `whilst` as `do while` is to `while` in plain JavaScript.
	 *
	 * @name doWhilst
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.whilst]{@link module:ControlFlow.whilst}
	 * @category Control Flow
	 * @param {AsyncFunction} iteratee - A function which is called each time `test`
	 * passes. Invoked with (callback).
	 * @param {Function} test - synchronous truth test to perform after each
	 * execution of `iteratee`. Invoked with any non-error callback results of
	 * `iteratee`.
	 * @param {Function} [callback] - A callback which is called after the test
	 * function has failed and repeated execution of `iteratee` has stopped.
	 * `callback` will be passed an error and any arguments passed to the final
	 * `iteratee`'s callback. Invoked with (err, [results]);
	 */
	function doWhilst(iteratee, test, callback) {
	    callback = onlyOnce(callback || noop);
	    var _iteratee = wrapAsync(iteratee);
	    var next = function(err/*, ...args*/) {
	        if (err) return callback(err);
	        var args = slice$2(arguments, 1);
	        if (test.apply(this, args)) return _iteratee(next);
	        callback.apply(null, [null].concat(args));
	    };
	    _iteratee(next);
	}

	/**
	 * Like ['doWhilst']{@link module:ControlFlow.doWhilst}, except the `test` is inverted. Note the
	 * argument ordering differs from `until`.
	 *
	 * @name doUntil
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.doWhilst]{@link module:ControlFlow.doWhilst}
	 * @category Control Flow
	 * @param {AsyncFunction} iteratee - An async function which is called each time
	 * `test` fails. Invoked with (callback).
	 * @param {Function} test - synchronous truth test to perform after each
	 * execution of `iteratee`. Invoked with any non-error callback results of
	 * `iteratee`.
	 * @param {Function} [callback] - A callback which is called after the test
	 * function has passed and repeated execution of `iteratee` has stopped. `callback`
	 * will be passed an error and any arguments passed to the final `iteratee`'s
	 * callback. Invoked with (err, [results]);
	 */
	function doUntil(iteratee, test, callback) {
	    doWhilst(iteratee, function() {
	        return !test.apply(this, arguments);
	    }, callback);
	}

	/**
	 * Like [`whilst`]{@link module:ControlFlow.whilst}, except the `test` is an asynchronous function that
	 * is passed a callback in the form of `function (err, truth)`. If error is
	 * passed to `test` or `fn`, the main callback is immediately called with the
	 * value of the error.
	 *
	 * @name during
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.whilst]{@link module:ControlFlow.whilst}
	 * @category Control Flow
	 * @param {AsyncFunction} test - asynchronous truth test to perform before each
	 * execution of `fn`. Invoked with (callback).
	 * @param {AsyncFunction} fn - An async function which is called each time
	 * `test` passes. Invoked with (callback).
	 * @param {Function} [callback] - A callback which is called after the test
	 * function has failed and repeated execution of `fn` has stopped. `callback`
	 * will be passed an error, if one occurred, otherwise `null`.
	 * @example
	 *
	 * var count = 0;
	 *
	 * async.during(
	 *     function (callback) {
	 *         return callback(null, count < 5);
	 *     },
	 *     function (callback) {
	 *         count++;
	 *         setTimeout(callback, 1000);
	 *     },
	 *     function (err) {
	 *         // 5 seconds have passed
	 *     }
	 * );
	 */
	function during(test, fn, callback) {
	    callback = onlyOnce(callback || noop);
	    var _fn = wrapAsync(fn);
	    var _test = wrapAsync(test);

	    function next(err) {
	        if (err) return callback(err);
	        _test(check);
	    }

	    function check(err, truth) {
	        if (err) return callback(err);
	        if (!truth) return callback(null);
	        _fn(next);
	    }

	    _test(check);
	}

	function _withoutIndex(iteratee) {
	    return function (value, index, callback) {
	        return iteratee(value, callback);
	    };
	}

	/**
	 * Applies the function `iteratee` to each item in `coll`, in parallel.
	 * The `iteratee` is called with an item from the list, and a callback for when
	 * it has finished. If the `iteratee` passes an error to its `callback`, the
	 * main `callback` (for the `each` function) is immediately called with the
	 * error.
	 *
	 * Note, that since this function applies `iteratee` to each item in parallel,
	 * there is no guarantee that the iteratee functions will complete in order.
	 *
	 * @name each
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @alias forEach
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {AsyncFunction} iteratee - An async function to apply to
	 * each item in `coll`. Invoked with (item, callback).
	 * The array index is not passed to the iteratee.
	 * If you need the index, use `eachOf`.
	 * @param {Function} [callback] - A callback which is called when all
	 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
	 * @example
	 *
	 * // assuming openFiles is an array of file names and saveFile is a function
	 * // to save the modified contents of that file:
	 *
	 * async.each(openFiles, saveFile, function(err){
	 *   // if any of the saves produced an error, err would equal that error
	 * });
	 *
	 * // assuming openFiles is an array of file names
	 * async.each(openFiles, function(file, callback) {
	 *
	 *     // Perform operation on file here.
	 *     console.log('Processing file ' + file);
	 *
	 *     if( file.length > 32 ) {
	 *       console.log('This file name is too long');
	 *       callback('File name too long');
	 *     } else {
	 *       // Do work to process file here
	 *       console.log('File processed');
	 *       callback();
	 *     }
	 * }, function(err) {
	 *     // if any of the file processing produced an error, err would equal that error
	 *     if( err ) {
	 *       // One of the iterations produced an error.
	 *       // All processing will now stop.
	 *       console.log('A file failed to process');
	 *     } else {
	 *       console.log('All files have been processed successfully');
	 *     }
	 * });
	 */
	function eachLimit(coll, iteratee, callback) {
	    eachOf(coll, _withoutIndex(wrapAsync(iteratee)), callback);
	}

	/**
	 * The same as [`each`]{@link module:Collections.each} but runs a maximum of `limit` async operations at a time.
	 *
	 * @name eachLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.each]{@link module:Collections.each}
	 * @alias forEachLimit
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {AsyncFunction} iteratee - An async function to apply to each item in
	 * `coll`.
	 * The array index is not passed to the iteratee.
	 * If you need the index, use `eachOfLimit`.
	 * Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called when all
	 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
	 */
	function eachLimit$1(coll, limit, iteratee, callback) {
	    _eachOfLimit(limit)(coll, _withoutIndex(wrapAsync(iteratee)), callback);
	}

	/**
	 * The same as [`each`]{@link module:Collections.each} but runs only a single async operation at a time.
	 *
	 * @name eachSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.each]{@link module:Collections.each}
	 * @alias forEachSeries
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {AsyncFunction} iteratee - An async function to apply to each
	 * item in `coll`.
	 * The array index is not passed to the iteratee.
	 * If you need the index, use `eachOfSeries`.
	 * Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called when all
	 * `iteratee` functions have finished, or an error occurs. Invoked with (err).
	 */
	var eachSeries = doLimit(eachLimit$1, 1);

	/**
	 * Wrap an async function and ensure it calls its callback on a later tick of
	 * the event loop.  If the function already calls its callback on a next tick,
	 * no extra deferral is added. This is useful for preventing stack overflows
	 * (`RangeError: Maximum call stack size exceeded`) and generally keeping
	 * [Zalgo](http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony)
	 * contained. ES2017 `async` functions are returned as-is -- they are immune
	 * to Zalgo's corrupting influences, as they always resolve on a later tick.
	 *
	 * @name ensureAsync
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @category Util
	 * @param {AsyncFunction} fn - an async function, one that expects a node-style
	 * callback as its last argument.
	 * @returns {AsyncFunction} Returns a wrapped function with the exact same call
	 * signature as the function passed in.
	 * @example
	 *
	 * function sometimesAsync(arg, callback) {
	 *     if (cache[arg]) {
	 *         return callback(null, cache[arg]); // this would be synchronous!!
	 *     } else {
	 *         doSomeIO(arg, callback); // this IO would be asynchronous
	 *     }
	 * }
	 *
	 * // this has a risk of stack overflows if many results are cached in a row
	 * async.mapSeries(args, sometimesAsync, done);
	 *
	 * // this will defer sometimesAsync's callback if necessary,
	 * // preventing stack overflows
	 * async.mapSeries(args, async.ensureAsync(sometimesAsync), done);
	 */
	function ensureAsync(fn) {
	    if (isAsync(fn)) return fn;
	    return initialParams(function (args, callback) {
	        var sync = true;
	        args.push(function () {
	            var innerArgs = arguments;
	            if (sync) {
	                setImmediate$1(function () {
	                    callback.apply(null, innerArgs);
	                });
	            } else {
	                callback.apply(null, innerArgs);
	            }
	        });
	        fn.apply(this, args);
	        sync = false;
	    });
	}

	function notId(v) {
	    return !v;
	}

	/**
	 * Returns `true` if every element in `coll` satisfies an async test. If any
	 * iteratee call returns `false`, the main `callback` is immediately called.
	 *
	 * @name every
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @alias all
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
	 * in the collection in parallel.
	 * The iteratee must complete with a boolean result value.
	 * Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Result will be either `true` or `false`
	 * depending on the values of the async tests. Invoked with (err, result).
	 * @example
	 *
	 * async.every(['file1','file2','file3'], function(filePath, callback) {
	 *     fs.access(filePath, function(err) {
	 *         callback(null, !err)
	 *     });
	 * }, function(err, result) {
	 *     // if result is true then every file exists
	 * });
	 */
	var every$1 = doParallel(_createTester(notId, notId));

	/**
	 * The same as [`every`]{@link module:Collections.every} but runs a maximum of `limit` async operations at a time.
	 *
	 * @name everyLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.every]{@link module:Collections.every}
	 * @alias allLimit
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
	 * in the collection in parallel.
	 * The iteratee must complete with a boolean result value.
	 * Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Result will be either `true` or `false`
	 * depending on the values of the async tests. Invoked with (err, result).
	 */
	var everyLimit = doParallelLimit(_createTester(notId, notId));

	/**
	 * The same as [`every`]{@link module:Collections.every} but runs only a single async operation at a time.
	 *
	 * @name everySeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.every]{@link module:Collections.every}
	 * @alias allSeries
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
	 * in the collection in series.
	 * The iteratee must complete with a boolean result value.
	 * Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Result will be either `true` or `false`
	 * depending on the values of the async tests. Invoked with (err, result).
	 */
	var everySeries = doLimit(everyLimit, 1);

	function filterArray(eachfn, arr, iteratee, callback) {
	    var truthValues = new Array(arr.length);
	    eachfn(arr, function (x, index, callback) {
	        iteratee(x, function (err, v) {
	            truthValues[index] = !!v;
	            callback(err);
	        });
	    }, function (err) {
	        if (err) return callback(err);
	        var results = [];
	        for (var i = 0; i < arr.length; i++) {
	            if (truthValues[i]) results.push(arr[i]);
	        }
	        callback(null, results);
	    });
	}

	function filterGeneric(eachfn, coll, iteratee, callback) {
	    var results = [];
	    eachfn(coll, function (x, index, callback) {
	        iteratee(x, function (err, v) {
	            if (err) {
	                callback(err);
	            } else {
	                if (v) {
	                    results.push({index: index, value: x});
	                }
	                callback();
	            }
	        });
	    }, function (err) {
	        if (err) {
	            callback(err);
	        } else {
	            callback(null, arrayMap(results.sort(function (a, b) {
	                return a.index - b.index;
	            }), baseProperty('value')));
	        }
	    });
	}

	function _filter(eachfn, coll, iteratee, callback) {
	    var filter = isArrayLike(coll) ? filterArray : filterGeneric;
	    filter(eachfn, coll, wrapAsync(iteratee), callback || noop);
	}

	/**
	 * Returns a new array of all the values in `coll` which pass an async truth
	 * test. This operation is performed in parallel, but the results array will be
	 * in the same order as the original.
	 *
	 * @name filter
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @alias select
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
	 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
	 * with a boolean argument once it has completed. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Invoked with (err, results).
	 * @example
	 *
	 * async.filter(['file1','file2','file3'], function(filePath, callback) {
	 *     fs.access(filePath, function(err) {
	 *         callback(null, !err)
	 *     });
	 * }, function(err, results) {
	 *     // results now equals an array of the existing files
	 * });
	 */
	var filter$1 = doParallel(_filter);

	/**
	 * The same as [`filter`]{@link module:Collections.filter} but runs a maximum of `limit` async operations at a
	 * time.
	 *
	 * @name filterLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.filter]{@link module:Collections.filter}
	 * @alias selectLimit
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
	 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
	 * with a boolean argument once it has completed. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Invoked with (err, results).
	 */
	var filterLimit = doParallelLimit(_filter);

	/**
	 * The same as [`filter`]{@link module:Collections.filter} but runs only a single async operation at a time.
	 *
	 * @name filterSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.filter]{@link module:Collections.filter}
	 * @alias selectSeries
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - A truth test to apply to each item in `coll`.
	 * The `iteratee` is passed a `callback(err, truthValue)`, which must be called
	 * with a boolean argument once it has completed. Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Invoked with (err, results)
	 */
	var filterSeries = doLimit(filterLimit, 1);

	/**
	 * Calls the asynchronous function `fn` with a callback parameter that allows it
	 * to call itself again, in series, indefinitely.

	 * If an error is passed to the callback then `errback` is called with the
	 * error, and execution stops, otherwise it will never be called.
	 *
	 * @name forever
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {AsyncFunction} fn - an async function to call repeatedly.
	 * Invoked with (next).
	 * @param {Function} [errback] - when `fn` passes an error to it's callback,
	 * this function will be called, and execution stops. Invoked with (err).
	 * @example
	 *
	 * async.forever(
	 *     function(next) {
	 *         // next is suitable for passing to things that need a callback(err [, whatever]);
	 *         // it will result in this function being called again.
	 *     },
	 *     function(err) {
	 *         // if next is called with a value in its first parameter, it will appear
	 *         // in here as 'err', and execution will stop.
	 *     }
	 * );
	 */
	function forever(fn, errback) {
	    var done = onlyOnce(errback || noop);
	    var task = wrapAsync(ensureAsync(fn));

	    function next(err) {
	        if (err) return done(err);
	        task(next);
	    }
	    next();
	}

	/**
	 * The same as [`groupBy`]{@link module:Collections.groupBy} but runs a maximum of `limit` async operations at a time.
	 *
	 * @name groupByLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.groupBy]{@link module:Collections.groupBy}
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {AsyncFunction} iteratee - An async function to apply to each item in
	 * `coll`.
	 * The iteratee should complete with a `key` to group the value under.
	 * Invoked with (value, callback).
	 * @param {Function} [callback] - A callback which is called when all `iteratee`
	 * functions have finished, or an error occurs. Result is an `Object` whoses
	 * properties are arrays of values which returned the corresponding key.
	 */
	function groupByLimit(coll, limit, iteratee, callback) {
	    callback = callback || noop;
	    var _iteratee = wrapAsync(iteratee);
	    mapLimit(coll, limit, function(val, callback) {
	        _iteratee(val, function(err, key) {
	            if (err) return callback(err);
	            return callback(null, {key: key, val: val});
	        });
	    }, function(err, mapResults) {
	        var result = {};
	        // from MDN, handle object having an `hasOwnProperty` prop
	        var hasOwnProperty = Object.prototype.hasOwnProperty;

	        for (var i = 0; i < mapResults.length; i++) {
	            if (mapResults[i]) {
	                var key = mapResults[i].key;
	                var val = mapResults[i].val;

	                if (hasOwnProperty.call(result, key)) {
	                    result[key].push(val);
	                } else {
	                    result[key] = [val];
	                }
	            }
	        }

	        return callback(err, result);
	    });
	}

	/**
	 * Returns a new object, where each value corresponds to an array of items, from
	 * `coll`, that returned the corresponding key. That is, the keys of the object
	 * correspond to the values passed to the `iteratee` callback.
	 *
	 * Note: Since this function applies the `iteratee` to each item in parallel,
	 * there is no guarantee that the `iteratee` functions will complete in order.
	 * However, the values for each key in the `result` will be in the same order as
	 * the original `coll`. For Objects, the values will roughly be in the order of
	 * the original Objects' keys (but this can vary across JavaScript engines).
	 *
	 * @name groupBy
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {AsyncFunction} iteratee - An async function to apply to each item in
	 * `coll`.
	 * The iteratee should complete with a `key` to group the value under.
	 * Invoked with (value, callback).
	 * @param {Function} [callback] - A callback which is called when all `iteratee`
	 * functions have finished, or an error occurs. Result is an `Object` whoses
	 * properties are arrays of values which returned the corresponding key.
	 * @example
	 *
	 * async.groupBy(['userId1', 'userId2', 'userId3'], function(userId, callback) {
	 *     db.findById(userId, function(err, user) {
	 *         if (err) return callback(err);
	 *         return callback(null, user.age);
	 *     });
	 * }, function(err, result) {
	 *     // result is object containing the userIds grouped by age
	 *     // e.g. { 30: ['userId1', 'userId3'], 42: ['userId2']};
	 * });
	 */
	var groupBy$1 = doLimit(groupByLimit, Infinity);

	/**
	 * The same as [`groupBy`]{@link module:Collections.groupBy} but runs only a single async operation at a time.
	 *
	 * @name groupBySeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.groupBy]{@link module:Collections.groupBy}
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {AsyncFunction} iteratee - An async function to apply to each item in
	 * `coll`.
	 * The iteratee should complete with a `key` to group the value under.
	 * Invoked with (value, callback).
	 * @param {Function} [callback] - A callback which is called when all `iteratee`
	 * functions have finished, or an error occurs. Result is an `Object` whoses
	 * properties are arrays of values which returned the corresponding key.
	 */
	var groupBySeries = doLimit(groupByLimit, 1);

	/**
	 * Logs the result of an `async` function to the `console`. Only works in
	 * Node.js or in browsers that support `console.log` and `console.error` (such
	 * as FF and Chrome). If multiple arguments are returned from the async
	 * function, `console.log` is called on each argument in order.
	 *
	 * @name log
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @category Util
	 * @param {AsyncFunction} function - The function you want to eventually apply
	 * all arguments to.
	 * @param {...*} arguments... - Any number of arguments to apply to the function.
	 * @example
	 *
	 * // in a module
	 * var hello = function(name, callback) {
	 *     setTimeout(function() {
	 *         callback(null, 'hello ' + name);
	 *     }, 1000);
	 * };
	 *
	 * // in the node repl
	 * node> async.log(hello, 'world');
	 * 'hello world'
	 */
	var log = consoleFunc('log');

	/**
	 * The same as [`mapValues`]{@link module:Collections.mapValues} but runs a maximum of `limit` async operations at a
	 * time.
	 *
	 * @name mapValuesLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.mapValues]{@link module:Collections.mapValues}
	 * @category Collection
	 * @param {Object} obj - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {AsyncFunction} iteratee - A function to apply to each value and key
	 * in `coll`.
	 * The iteratee should complete with the transformed value as its result.
	 * Invoked with (value, key, callback).
	 * @param {Function} [callback] - A callback which is called when all `iteratee`
	 * functions have finished, or an error occurs. `result` is a new object consisting
	 * of each key from `obj`, with each transformed value on the right-hand side.
	 * Invoked with (err, result).
	 */
	function mapValuesLimit(obj, limit, iteratee, callback) {
	    callback = once$1(callback || noop);
	    var newObj = {};
	    var _iteratee = wrapAsync(iteratee);
	    eachOfLimit(obj, limit, function(val, key, next) {
	        _iteratee(val, key, function (err, result) {
	            if (err) return next(err);
	            newObj[key] = result;
	            next();
	        });
	    }, function (err) {
	        callback(err, newObj);
	    });
	}

	/**
	 * A relative of [`map`]{@link module:Collections.map}, designed for use with objects.
	 *
	 * Produces a new Object by mapping each value of `obj` through the `iteratee`
	 * function. The `iteratee` is called each `value` and `key` from `obj` and a
	 * callback for when it has finished processing. Each of these callbacks takes
	 * two arguments: an `error`, and the transformed item from `obj`. If `iteratee`
	 * passes an error to its callback, the main `callback` (for the `mapValues`
	 * function) is immediately called with the error.
	 *
	 * Note, the order of the keys in the result is not guaranteed.  The keys will
	 * be roughly in the order they complete, (but this is very engine-specific)
	 *
	 * @name mapValues
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @category Collection
	 * @param {Object} obj - A collection to iterate over.
	 * @param {AsyncFunction} iteratee - A function to apply to each value and key
	 * in `coll`.
	 * The iteratee should complete with the transformed value as its result.
	 * Invoked with (value, key, callback).
	 * @param {Function} [callback] - A callback which is called when all `iteratee`
	 * functions have finished, or an error occurs. `result` is a new object consisting
	 * of each key from `obj`, with each transformed value on the right-hand side.
	 * Invoked with (err, result).
	 * @example
	 *
	 * async.mapValues({
	 *     f1: 'file1',
	 *     f2: 'file2',
	 *     f3: 'file3'
	 * }, function (file, key, callback) {
	 *   fs.stat(file, callback);
	 * }, function(err, result) {
	 *     // result is now a map of stats for each file, e.g.
	 *     // {
	 *     //     f1: [stats for file1],
	 *     //     f2: [stats for file2],
	 *     //     f3: [stats for file3]
	 *     // }
	 * });
	 */

	var mapValues$1 = doLimit(mapValuesLimit, Infinity);

	/**
	 * The same as [`mapValues`]{@link module:Collections.mapValues} but runs only a single async operation at a time.
	 *
	 * @name mapValuesSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.mapValues]{@link module:Collections.mapValues}
	 * @category Collection
	 * @param {Object} obj - A collection to iterate over.
	 * @param {AsyncFunction} iteratee - A function to apply to each value and key
	 * in `coll`.
	 * The iteratee should complete with the transformed value as its result.
	 * Invoked with (value, key, callback).
	 * @param {Function} [callback] - A callback which is called when all `iteratee`
	 * functions have finished, or an error occurs. `result` is a new object consisting
	 * of each key from `obj`, with each transformed value on the right-hand side.
	 * Invoked with (err, result).
	 */
	var mapValuesSeries = doLimit(mapValuesLimit, 1);

	function has$1(obj, key) {
	    return key in obj;
	}

	/**
	 * Caches the results of an async function. When creating a hash to store
	 * function results against, the callback is omitted from the hash and an
	 * optional hash function can be used.
	 *
	 * If no hash function is specified, the first argument is used as a hash key,
	 * which may work reasonably if it is a string or a data type that converts to a
	 * distinct string. Note that objects and arrays will not behave reasonably.
	 * Neither will cases where the other arguments are significant. In such cases,
	 * specify your own hash function.
	 *
	 * The cache of results is exposed as the `memo` property of the function
	 * returned by `memoize`.
	 *
	 * @name memoize
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @category Util
	 * @param {AsyncFunction} fn - The async function to proxy and cache results from.
	 * @param {Function} hasher - An optional function for generating a custom hash
	 * for storing results. It has all the arguments applied to it apart from the
	 * callback, and must be synchronous.
	 * @returns {AsyncFunction} a memoized version of `fn`
	 * @example
	 *
	 * var slow_fn = function(name, callback) {
	 *     // do something
	 *     callback(null, result);
	 * };
	 * var fn = async.memoize(slow_fn);
	 *
	 * // fn can now be used as if it were slow_fn
	 * fn('some name', function() {
	 *     // callback
	 * });
	 */
	function memoize$1(fn, hasher) {
	    var memo = Object.create(null);
	    var queues = Object.create(null);
	    hasher = hasher || identity;
	    var _fn = wrapAsync(fn);
	    var memoized = initialParams(function memoized(args, callback) {
	        var key = hasher.apply(null, args);
	        if (has$1(memo, key)) {
	            setImmediate$1(function() {
	                callback.apply(null, memo[key]);
	            });
	        } else if (has$1(queues, key)) {
	            queues[key].push(callback);
	        } else {
	            queues[key] = [callback];
	            _fn.apply(null, args.concat(function(/*args*/) {
	                var args = slice$2(arguments);
	                memo[key] = args;
	                var q = queues[key];
	                delete queues[key];
	                for (var i = 0, l = q.length; i < l; i++) {
	                    q[i].apply(null, args);
	                }
	            }));
	        }
	    });
	    memoized.memo = memo;
	    memoized.unmemoized = fn;
	    return memoized;
	}

	/**
	 * Calls `callback` on a later loop around the event loop. In Node.js this just
	 * calls `process.nextTick`.  In the browser it will use `setImmediate` if
	 * available, otherwise `setTimeout(callback, 0)`, which means other higher
	 * priority events may precede the execution of `callback`.
	 *
	 * This is used internally for browser-compatibility purposes.
	 *
	 * @name nextTick
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @see [async.setImmediate]{@link module:Utils.setImmediate}
	 * @category Util
	 * @param {Function} callback - The function to call on a later loop around
	 * the event loop. Invoked with (args...).
	 * @param {...*} args... - any number of additional arguments to pass to the
	 * callback on the next tick.
	 * @example
	 *
	 * var call_order = [];
	 * async.nextTick(function() {
	 *     call_order.push('two');
	 *     // call_order now equals ['one','two']
	 * });
	 * call_order.push('one');
	 *
	 * async.setImmediate(function (a, b, c) {
	 *     // a, b, and c equal 1, 2, and 3
	 * }, 1, 2, 3);
	 */
	var _defer$1;

	if (hasNextTick) {
	    _defer$1 = process.nextTick;
	} else if (hasSetImmediate) {
	    _defer$1 = setImmediate;
	} else {
	    _defer$1 = fallback;
	}

	var nextTick = wrap$1(_defer$1);

	function _parallel(eachfn, tasks, callback) {
	    callback = callback || noop;
	    var results = isArrayLike(tasks) ? [] : {};

	    eachfn(tasks, function (task, key, callback) {
	        wrapAsync(task)(function (err, result) {
	            if (arguments.length > 2) {
	                result = slice$2(arguments, 1);
	            }
	            results[key] = result;
	            callback(err);
	        });
	    }, function (err) {
	        callback(err, results);
	    });
	}

	/**
	 * Run the `tasks` collection of functions in parallel, without waiting until
	 * the previous function has completed. If any of the functions pass an error to
	 * its callback, the main `callback` is immediately called with the value of the
	 * error. Once the `tasks` have completed, the results are passed to the final
	 * `callback` as an array.
	 *
	 * **Note:** `parallel` is about kicking-off I/O tasks in parallel, not about
	 * parallel execution of code.  If your tasks do not use any timers or perform
	 * any I/O, they will actually be executed in series.  Any synchronous setup
	 * sections for each task will happen one after the other.  JavaScript remains
	 * single-threaded.
	 *
	 * **Hint:** Use [`reflect`]{@link module:Utils.reflect} to continue the
	 * execution of other tasks when a task fails.
	 *
	 * It is also possible to use an object instead of an array. Each property will
	 * be run as a function and the results will be passed to the final `callback`
	 * as an object instead of an array. This can be a more readable way of handling
	 * results from {@link async.parallel}.
	 *
	 * @name parallel
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Array|Iterable|Object} tasks - A collection of
	 * [async functions]{@link AsyncFunction} to run.
	 * Each async function can complete with any number of optional `result` values.
	 * @param {Function} [callback] - An optional callback to run once all the
	 * functions have completed successfully. This function gets a results array
	 * (or object) containing all the result arguments passed to the task callbacks.
	 * Invoked with (err, results).
	 *
	 * @example
	 * async.parallel([
	 *     function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 'one');
	 *         }, 200);
	 *     },
	 *     function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 'two');
	 *         }, 100);
	 *     }
	 * ],
	 * // optional callback
	 * function(err, results) {
	 *     // the results array will equal ['one','two'] even though
	 *     // the second function had a shorter timeout.
	 * });
	 *
	 * // an example using an object instead of an array
	 * async.parallel({
	 *     one: function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 1);
	 *         }, 200);
	 *     },
	 *     two: function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 2);
	 *         }, 100);
	 *     }
	 * }, function(err, results) {
	 *     // results is now equals to: {one: 1, two: 2}
	 * });
	 */
	function parallelLimit(tasks, callback) {
	    _parallel(eachOf, tasks, callback);
	}

	/**
	 * The same as [`parallel`]{@link module:ControlFlow.parallel} but runs a maximum of `limit` async operations at a
	 * time.
	 *
	 * @name parallelLimit
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.parallel]{@link module:ControlFlow.parallel}
	 * @category Control Flow
	 * @param {Array|Iterable|Object} tasks - A collection of
	 * [async functions]{@link AsyncFunction} to run.
	 * Each async function can complete with any number of optional `result` values.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} [callback] - An optional callback to run once all the
	 * functions have completed successfully. This function gets a results array
	 * (or object) containing all the result arguments passed to the task callbacks.
	 * Invoked with (err, results).
	 */
	function parallelLimit$1(tasks, limit, callback) {
	    _parallel(_eachOfLimit(limit), tasks, callback);
	}

	/**
	 * A queue of tasks for the worker function to complete.
	 * @typedef {Object} QueueObject
	 * @memberOf module:ControlFlow
	 * @property {Function} length - a function returning the number of items
	 * waiting to be processed. Invoke with `queue.length()`.
	 * @property {boolean} started - a boolean indicating whether or not any
	 * items have been pushed and processed by the queue.
	 * @property {Function} running - a function returning the number of items
	 * currently being processed. Invoke with `queue.running()`.
	 * @property {Function} workersList - a function returning the array of items
	 * currently being processed. Invoke with `queue.workersList()`.
	 * @property {Function} idle - a function returning false if there are items
	 * waiting or being processed, or true if not. Invoke with `queue.idle()`.
	 * @property {number} concurrency - an integer for determining how many `worker`
	 * functions should be run in parallel. This property can be changed after a
	 * `queue` is created to alter the concurrency on-the-fly.
	 * @property {Function} push - add a new task to the `queue`. Calls `callback`
	 * once the `worker` has finished processing the task. Instead of a single task,
	 * a `tasks` array can be submitted. The respective callback is used for every
	 * task in the list. Invoke with `queue.push(task, [callback])`,
	 * @property {Function} unshift - add a new task to the front of the `queue`.
	 * Invoke with `queue.unshift(task, [callback])`.
	 * @property {Function} remove - remove items from the queue that match a test
	 * function.  The test function will be passed an object with a `data` property,
	 * and a `priority` property, if this is a
	 * [priorityQueue]{@link module:ControlFlow.priorityQueue} object.
	 * Invoked with `queue.remove(testFn)`, where `testFn` is of the form
	 * `function ({data, priority}) {}` and returns a Boolean.
	 * @property {Function} saturated - a callback that is called when the number of
	 * running workers hits the `concurrency` limit, and further tasks will be
	 * queued.
	 * @property {Function} unsaturated - a callback that is called when the number
	 * of running workers is less than the `concurrency` & `buffer` limits, and
	 * further tasks will not be queued.
	 * @property {number} buffer - A minimum threshold buffer in order to say that
	 * the `queue` is `unsaturated`.
	 * @property {Function} empty - a callback that is called when the last item
	 * from the `queue` is given to a `worker`.
	 * @property {Function} drain - a callback that is called when the last item
	 * from the `queue` has returned from the `worker`.
	 * @property {Function} error - a callback that is called when a task errors.
	 * Has the signature `function(error, task)`.
	 * @property {boolean} paused - a boolean for determining whether the queue is
	 * in a paused state.
	 * @property {Function} pause - a function that pauses the processing of tasks
	 * until `resume()` is called. Invoke with `queue.pause()`.
	 * @property {Function} resume - a function that resumes the processing of
	 * queued tasks when the queue is paused. Invoke with `queue.resume()`.
	 * @property {Function} kill - a function that removes the `drain` callback and
	 * empties remaining tasks from the queue forcing it to go idle. No more tasks
	 * should be pushed to the queue after calling this function. Invoke with `queue.kill()`.
	 */

	/**
	 * Creates a `queue` object with the specified `concurrency`. Tasks added to the
	 * `queue` are processed in parallel (up to the `concurrency` limit). If all
	 * `worker`s are in progress, the task is queued until one becomes available.
	 * Once a `worker` completes a `task`, that `task`'s callback is called.
	 *
	 * @name queue
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {AsyncFunction} worker - An async function for processing a queued task.
	 * If you want to handle errors from an individual task, pass a callback to
	 * `q.push()`. Invoked with (task, callback).
	 * @param {number} [concurrency=1] - An `integer` for determining how many
	 * `worker` functions should be run in parallel.  If omitted, the concurrency
	 * defaults to `1`.  If the concurrency is `0`, an error is thrown.
	 * @returns {module:ControlFlow.QueueObject} A queue object to manage the tasks. Callbacks can
	 * attached as certain properties to listen for specific events during the
	 * lifecycle of the queue.
	 * @example
	 *
	 * // create a queue object with concurrency 2
	 * var q = async.queue(function(task, callback) {
	 *     console.log('hello ' + task.name);
	 *     callback();
	 * }, 2);
	 *
	 * // assign a callback
	 * q.drain = function() {
	 *     console.log('all items have been processed');
	 * };
	 *
	 * // add some items to the queue
	 * q.push({name: 'foo'}, function(err) {
	 *     console.log('finished processing foo');
	 * });
	 * q.push({name: 'bar'}, function (err) {
	 *     console.log('finished processing bar');
	 * });
	 *
	 * // add some items to the queue (batch-wise)
	 * q.push([{name: 'baz'},{name: 'bay'},{name: 'bax'}], function(err) {
	 *     console.log('finished processing item');
	 * });
	 *
	 * // add some items to the front of the queue
	 * q.unshift({name: 'bar'}, function (err) {
	 *     console.log('finished processing bar');
	 * });
	 */
	function queue$1 (worker, concurrency) {
	    var _worker = wrapAsync(worker);
	    return queue(function (items, cb) {
	        _worker(items[0], cb);
	    }, concurrency, 1);
	}

	/**
	 * The same as [async.queue]{@link module:ControlFlow.queue} only tasks are assigned a priority and
	 * completed in ascending priority order.
	 *
	 * @name priorityQueue
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.queue]{@link module:ControlFlow.queue}
	 * @category Control Flow
	 * @param {AsyncFunction} worker - An async function for processing a queued task.
	 * If you want to handle errors from an individual task, pass a callback to
	 * `q.push()`.
	 * Invoked with (task, callback).
	 * @param {number} concurrency - An `integer` for determining how many `worker`
	 * functions should be run in parallel.  If omitted, the concurrency defaults to
	 * `1`.  If the concurrency is `0`, an error is thrown.
	 * @returns {module:ControlFlow.QueueObject} A priorityQueue object to manage the tasks. There are two
	 * differences between `queue` and `priorityQueue` objects:
	 * * `push(task, priority, [callback])` - `priority` should be a number. If an
	 *   array of `tasks` is given, all tasks will be assigned the same priority.
	 * * The `unshift` method was removed.
	 */
	function priorityQueue(worker, concurrency) {
	    // Start with a normal queue
	    var q = queue$1(worker, concurrency);

	    // Override push to accept second parameter representing priority
	    q.push = function(data, priority, callback) {
	        if (callback == null) callback = noop;
	        if (typeof callback !== 'function') {
	            throw new Error('task callback must be a function');
	        }
	        q.started = true;
	        if (!isArray(data)) {
	            data = [data];
	        }
	        if (data.length === 0) {
	            // call drain immediately if there are no tasks
	            return setImmediate$1(function() {
	                q.drain();
	            });
	        }

	        priority = priority || 0;
	        var nextNode = q._tasks.head;
	        while (nextNode && priority >= nextNode.priority) {
	            nextNode = nextNode.next;
	        }

	        for (var i = 0, l = data.length; i < l; i++) {
	            var item = {
	                data: data[i],
	                priority: priority,
	                callback: callback
	            };

	            if (nextNode) {
	                q._tasks.insertBefore(nextNode, item);
	            } else {
	                q._tasks.push(item);
	            }
	        }
	        setImmediate$1(q.process);
	    };

	    // Remove unshift function
	    delete q.unshift;

	    return q;
	}

	/**
	 * Runs the `tasks` array of functions in parallel, without waiting until the
	 * previous function has completed. Once any of the `tasks` complete or pass an
	 * error to its callback, the main `callback` is immediately called. It's
	 * equivalent to `Promise.race()`.
	 *
	 * @name race
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Array} tasks - An array containing [async functions]{@link AsyncFunction}
	 * to run. Each function can complete with an optional `result` value.
	 * @param {Function} callback - A callback to run once any of the functions have
	 * completed. This function gets an error or result from the first function that
	 * completed. Invoked with (err, result).
	 * @returns undefined
	 * @example
	 *
	 * async.race([
	 *     function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 'one');
	 *         }, 200);
	 *     },
	 *     function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 'two');
	 *         }, 100);
	 *     }
	 * ],
	 * // main callback
	 * function(err, result) {
	 *     // the result will be equal to 'two' as it finishes earlier
	 * });
	 */
	function race(tasks, callback) {
	    callback = once$1(callback || noop);
	    if (!isArray(tasks)) return callback(new TypeError('First argument to race must be an array of functions'));
	    if (!tasks.length) return callback();
	    for (var i = 0, l = tasks.length; i < l; i++) {
	        wrapAsync(tasks[i])(callback);
	    }
	}

	/**
	 * Same as [`reduce`]{@link module:Collections.reduce}, only operates on `array` in reverse order.
	 *
	 * @name reduceRight
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.reduce]{@link module:Collections.reduce}
	 * @alias foldr
	 * @category Collection
	 * @param {Array} array - A collection to iterate over.
	 * @param {*} memo - The initial state of the reduction.
	 * @param {AsyncFunction} iteratee - A function applied to each item in the
	 * array to produce the next step in the reduction.
	 * The `iteratee` should complete with the next state of the reduction.
	 * If the iteratee complete with an error, the reduction is stopped and the
	 * main `callback` is immediately called with the error.
	 * Invoked with (memo, item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Result is the reduced value. Invoked with
	 * (err, result).
	 */
	function reduceRight$1 (array, memo, iteratee, callback) {
	    var reversed = slice$2(array).reverse();
	    reduce$1(reversed, memo, iteratee, callback);
	}

	/**
	 * Wraps the async function in another function that always completes with a
	 * result object, even when it errors.
	 *
	 * The result object has either the property `error` or `value`.
	 *
	 * @name reflect
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @category Util
	 * @param {AsyncFunction} fn - The async function you want to wrap
	 * @returns {Function} - A function that always passes null to it's callback as
	 * the error. The second argument to the callback will be an `object` with
	 * either an `error` or a `value` property.
	 * @example
	 *
	 * async.parallel([
	 *     async.reflect(function(callback) {
	 *         // do some stuff ...
	 *         callback(null, 'one');
	 *     }),
	 *     async.reflect(function(callback) {
	 *         // do some more stuff but error ...
	 *         callback('bad stuff happened');
	 *     }),
	 *     async.reflect(function(callback) {
	 *         // do some more stuff ...
	 *         callback(null, 'two');
	 *     })
	 * ],
	 * // optional callback
	 * function(err, results) {
	 *     // values
	 *     // results[0].value = 'one'
	 *     // results[1].error = 'bad stuff happened'
	 *     // results[2].value = 'two'
	 * });
	 */
	function reflect(fn) {
	    var _fn = wrapAsync(fn);
	    return initialParams(function reflectOn(args, reflectCallback) {
	        args.push(function callback(error, cbArg) {
	            if (error) {
	                reflectCallback(null, { error: error });
	            } else {
	                var value;
	                if (arguments.length <= 2) {
	                    value = cbArg;
	                } else {
	                    value = slice$2(arguments, 1);
	                }
	                reflectCallback(null, { value: value });
	            }
	        });

	        return _fn.apply(this, args);
	    });
	}

	/**
	 * A helper function that wraps an array or an object of functions with `reflect`.
	 *
	 * @name reflectAll
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @see [async.reflect]{@link module:Utils.reflect}
	 * @category Util
	 * @param {Array|Object|Iterable} tasks - The collection of
	 * [async functions]{@link AsyncFunction} to wrap in `async.reflect`.
	 * @returns {Array} Returns an array of async functions, each wrapped in
	 * `async.reflect`
	 * @example
	 *
	 * let tasks = [
	 *     function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 'one');
	 *         }, 200);
	 *     },
	 *     function(callback) {
	 *         // do some more stuff but error ...
	 *         callback(new Error('bad stuff happened'));
	 *     },
	 *     function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 'two');
	 *         }, 100);
	 *     }
	 * ];
	 *
	 * async.parallel(async.reflectAll(tasks),
	 * // optional callback
	 * function(err, results) {
	 *     // values
	 *     // results[0].value = 'one'
	 *     // results[1].error = Error('bad stuff happened')
	 *     // results[2].value = 'two'
	 * });
	 *
	 * // an example using an object instead of an array
	 * let tasks = {
	 *     one: function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 'one');
	 *         }, 200);
	 *     },
	 *     two: function(callback) {
	 *         callback('two');
	 *     },
	 *     three: function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 'three');
	 *         }, 100);
	 *     }
	 * };
	 *
	 * async.parallel(async.reflectAll(tasks),
	 * // optional callback
	 * function(err, results) {
	 *     // values
	 *     // results.one.value = 'one'
	 *     // results.two.error = 'two'
	 *     // results.three.value = 'three'
	 * });
	 */
	function reflectAll(tasks) {
	    var results;
	    if (isArray(tasks)) {
	        results = arrayMap(tasks, reflect);
	    } else {
	        results = {};
	        baseForOwn(tasks, function(task, key) {
	            results[key] = reflect.call(this, task);
	        });
	    }
	    return results;
	}

	function reject$1(eachfn, arr, iteratee, callback) {
	    _filter(eachfn, arr, function(value, cb) {
	        iteratee(value, function(err, v) {
	            cb(err, !v);
	        });
	    }, callback);
	}

	/**
	 * The opposite of [`filter`]{@link module:Collections.filter}. Removes values that pass an `async` truth test.
	 *
	 * @name reject
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.filter]{@link module:Collections.filter}
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - An async truth test to apply to each item in
	 * `coll`.
	 * The should complete with a boolean value as its `result`.
	 * Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Invoked with (err, results).
	 * @example
	 *
	 * async.reject(['file1','file2','file3'], function(filePath, callback) {
	 *     fs.access(filePath, function(err) {
	 *         callback(null, !err)
	 *     });
	 * }, function(err, results) {
	 *     // results now equals an array of missing files
	 *     createFiles(results);
	 * });
	 */
	var reject$2 = doParallel(reject$1);

	/**
	 * The same as [`reject`]{@link module:Collections.reject} but runs a maximum of `limit` async operations at a
	 * time.
	 *
	 * @name rejectLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.reject]{@link module:Collections.reject}
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {Function} iteratee - An async truth test to apply to each item in
	 * `coll`.
	 * The should complete with a boolean value as its `result`.
	 * Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Invoked with (err, results).
	 */
	var rejectLimit = doParallelLimit(reject$1);

	/**
	 * The same as [`reject`]{@link module:Collections.reject} but runs only a single async operation at a time.
	 *
	 * @name rejectSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.reject]{@link module:Collections.reject}
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {Function} iteratee - An async truth test to apply to each item in
	 * `coll`.
	 * The should complete with a boolean value as its `result`.
	 * Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Invoked with (err, results).
	 */
	var rejectSeries = doLimit(rejectLimit, 1);

	/**
	 * Attempts to get a successful response from `task` no more than `times` times
	 * before returning an error. If the task is successful, the `callback` will be
	 * passed the result of the successful task. If all attempts fail, the callback
	 * will be passed the error and result (if any) of the final attempt.
	 *
	 * @name retry
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @see [async.retryable]{@link module:ControlFlow.retryable}
	 * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - Can be either an
	 * object with `times` and `interval` or a number.
	 * * `times` - The number of attempts to make before giving up.  The default
	 *   is `5`.
	 * * `interval` - The time to wait between retries, in milliseconds.  The
	 *   default is `0`. The interval may also be specified as a function of the
	 *   retry count (see example).
	 * * `errorFilter` - An optional synchronous function that is invoked on
	 *   erroneous result. If it returns `true` the retry attempts will continue;
	 *   if the function returns `false` the retry flow is aborted with the current
	 *   attempt's error and result being returned to the final callback.
	 *   Invoked with (err).
	 * * If `opts` is a number, the number specifies the number of times to retry,
	 *   with the default interval of `0`.
	 * @param {AsyncFunction} task - An async function to retry.
	 * Invoked with (callback).
	 * @param {Function} [callback] - An optional callback which is called when the
	 * task has succeeded, or after the final failed attempt. It receives the `err`
	 * and `result` arguments of the last attempt at completing the `task`. Invoked
	 * with (err, results).
	 *
	 * @example
	 *
	 * // The `retry` function can be used as a stand-alone control flow by passing
	 * // a callback, as shown below:
	 *
	 * // try calling apiMethod 3 times
	 * async.retry(3, apiMethod, function(err, result) {
	 *     // do something with the result
	 * });
	 *
	 * // try calling apiMethod 3 times, waiting 200 ms between each retry
	 * async.retry({times: 3, interval: 200}, apiMethod, function(err, result) {
	 *     // do something with the result
	 * });
	 *
	 * // try calling apiMethod 10 times with exponential backoff
	 * // (i.e. intervals of 100, 200, 400, 800, 1600, ... milliseconds)
	 * async.retry({
	 *   times: 10,
	 *   interval: function(retryCount) {
	 *     return 50 * Math.pow(2, retryCount);
	 *   }
	 * }, apiMethod, function(err, result) {
	 *     // do something with the result
	 * });
	 *
	 * // try calling apiMethod the default 5 times no delay between each retry
	 * async.retry(apiMethod, function(err, result) {
	 *     // do something with the result
	 * });
	 *
	 * // try calling apiMethod only when error condition satisfies, all other
	 * // errors will abort the retry control flow and return to final callback
	 * async.retry({
	 *   errorFilter: function(err) {
	 *     return err.message === 'Temporary error'; // only retry on a specific error
	 *   }
	 * }, apiMethod, function(err, result) {
	 *     // do something with the result
	 * });
	 *
	 * // to retry individual methods that are not as reliable within other
	 * // control flow functions, use the `retryable` wrapper:
	 * async.auto({
	 *     users: api.getUsers.bind(api),
	 *     payments: async.retryable(3, api.getPayments.bind(api))
	 * }, function(err, results) {
	 *     // do something with the results
	 * });
	 *
	 */
	function retry(opts, task, callback) {
	    var DEFAULT_TIMES = 5;
	    var DEFAULT_INTERVAL = 0;

	    var options = {
	        times: DEFAULT_TIMES,
	        intervalFunc: constant(DEFAULT_INTERVAL)
	    };

	    function parseTimes(acc, t) {
	        if (typeof t === 'object') {
	            acc.times = +t.times || DEFAULT_TIMES;

	            acc.intervalFunc = typeof t.interval === 'function' ?
	                t.interval :
	                constant(+t.interval || DEFAULT_INTERVAL);

	            acc.errorFilter = t.errorFilter;
	        } else if (typeof t === 'number' || typeof t === 'string') {
	            acc.times = +t || DEFAULT_TIMES;
	        } else {
	            throw new Error("Invalid arguments for async.retry");
	        }
	    }

	    if (arguments.length < 3 && typeof opts === 'function') {
	        callback = task || noop;
	        task = opts;
	    } else {
	        parseTimes(options, opts);
	        callback = callback || noop;
	    }

	    if (typeof task !== 'function') {
	        throw new Error("Invalid arguments for async.retry");
	    }

	    var _task = wrapAsync(task);

	    var attempt = 1;
	    function retryAttempt() {
	        _task(function(err) {
	            if (err && attempt++ < options.times &&
	                (typeof options.errorFilter != 'function' ||
	                    options.errorFilter(err))) {
	                setTimeout(retryAttempt, options.intervalFunc(attempt));
	            } else {
	                callback.apply(null, arguments);
	            }
	        });
	    }

	    retryAttempt();
	}

	/**
	 * A close relative of [`retry`]{@link module:ControlFlow.retry}.  This method
	 * wraps a task and makes it retryable, rather than immediately calling it
	 * with retries.
	 *
	 * @name retryable
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.retry]{@link module:ControlFlow.retry}
	 * @category Control Flow
	 * @param {Object|number} [opts = {times: 5, interval: 0}| 5] - optional
	 * options, exactly the same as from `retry`
	 * @param {AsyncFunction} task - the asynchronous function to wrap.
	 * This function will be passed any arguments passed to the returned wrapper.
	 * Invoked with (...args, callback).
	 * @returns {AsyncFunction} The wrapped function, which when invoked, will
	 * retry on an error, based on the parameters specified in `opts`.
	 * This function will accept the same parameters as `task`.
	 * @example
	 *
	 * async.auto({
	 *     dep1: async.retryable(3, getFromFlakyService),
	 *     process: ["dep1", async.retryable(3, function (results, cb) {
	 *         maybeProcessData(results.dep1, cb);
	 *     })]
	 * }, callback);
	 */
	function retryable (opts, task) {
	    if (!task) {
	        task = opts;
	        opts = null;
	    }
	    var _task = wrapAsync(task);
	    return initialParams(function (args, callback) {
	        function taskFn(cb) {
	            _task.apply(null, args.concat(cb));
	        }

	        if (opts) retry(opts, taskFn, callback);
	        else retry(taskFn, callback);

	    });
	}

	/**
	 * Run the functions in the `tasks` collection in series, each one running once
	 * the previous function has completed. If any functions in the series pass an
	 * error to its callback, no more functions are run, and `callback` is
	 * immediately called with the value of the error. Otherwise, `callback`
	 * receives an array of results when `tasks` have completed.
	 *
	 * It is also possible to use an object instead of an array. Each property will
	 * be run as a function, and the results will be passed to the final `callback`
	 * as an object instead of an array. This can be a more readable way of handling
	 *  results from {@link async.series}.
	 *
	 * **Note** that while many implementations preserve the order of object
	 * properties, the [ECMAScript Language Specification](http://www.ecma-international.org/ecma-262/5.1/#sec-8.6)
	 * explicitly states that
	 *
	 * > The mechanics and order of enumerating the properties is not specified.
	 *
	 * So if you rely on the order in which your series of functions are executed,
	 * and want this to work on all platforms, consider using an array.
	 *
	 * @name series
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Array|Iterable|Object} tasks - A collection containing
	 * [async functions]{@link AsyncFunction} to run in series.
	 * Each function can complete with any number of optional `result` values.
	 * @param {Function} [callback] - An optional callback to run once all the
	 * functions have completed. This function gets a results array (or object)
	 * containing all the result arguments passed to the `task` callbacks. Invoked
	 * with (err, result).
	 * @example
	 * async.series([
	 *     function(callback) {
	 *         // do some stuff ...
	 *         callback(null, 'one');
	 *     },
	 *     function(callback) {
	 *         // do some more stuff ...
	 *         callback(null, 'two');
	 *     }
	 * ],
	 * // optional callback
	 * function(err, results) {
	 *     // results is now equal to ['one', 'two']
	 * });
	 *
	 * async.series({
	 *     one: function(callback) {
	 *         setTimeout(function() {
	 *             callback(null, 1);
	 *         }, 200);
	 *     },
	 *     two: function(callback){
	 *         setTimeout(function() {
	 *             callback(null, 2);
	 *         }, 100);
	 *     }
	 * }, function(err, results) {
	 *     // results is now equal to: {one: 1, two: 2}
	 * });
	 */
	function series(tasks, callback) {
	    _parallel(eachOfSeries, tasks, callback);
	}

	/**
	 * Returns `true` if at least one element in the `coll` satisfies an async test.
	 * If any iteratee call returns `true`, the main `callback` is immediately
	 * called.
	 *
	 * @name some
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @alias any
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
	 * in the collections in parallel.
	 * The iteratee should complete with a boolean `result` value.
	 * Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called as soon as any
	 * iteratee returns `true`, or after all the iteratee functions have finished.
	 * Result will be either `true` or `false` depending on the values of the async
	 * tests. Invoked with (err, result).
	 * @example
	 *
	 * async.some(['file1','file2','file3'], function(filePath, callback) {
	 *     fs.access(filePath, function(err) {
	 *         callback(null, !err)
	 *     });
	 * }, function(err, result) {
	 *     // if result is true then at least one of the files exists
	 * });
	 */
	var some$1 = doParallel(_createTester(Boolean, identity));

	/**
	 * The same as [`some`]{@link module:Collections.some} but runs a maximum of `limit` async operations at a time.
	 *
	 * @name someLimit
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.some]{@link module:Collections.some}
	 * @alias anyLimit
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
	 * in the collections in parallel.
	 * The iteratee should complete with a boolean `result` value.
	 * Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called as soon as any
	 * iteratee returns `true`, or after all the iteratee functions have finished.
	 * Result will be either `true` or `false` depending on the values of the async
	 * tests. Invoked with (err, result).
	 */
	var someLimit = doParallelLimit(_createTester(Boolean, identity));

	/**
	 * The same as [`some`]{@link module:Collections.some} but runs only a single async operation at a time.
	 *
	 * @name someSeries
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @see [async.some]{@link module:Collections.some}
	 * @alias anySeries
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {AsyncFunction} iteratee - An async truth test to apply to each item
	 * in the collections in series.
	 * The iteratee should complete with a boolean `result` value.
	 * Invoked with (item, callback).
	 * @param {Function} [callback] - A callback which is called as soon as any
	 * iteratee returns `true`, or after all the iteratee functions have finished.
	 * Result will be either `true` or `false` depending on the values of the async
	 * tests. Invoked with (err, result).
	 */
	var someSeries = doLimit(someLimit, 1);

	/**
	 * Sorts a list by the results of running each `coll` value through an async
	 * `iteratee`.
	 *
	 * @name sortBy
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {AsyncFunction} iteratee - An async function to apply to each item in
	 * `coll`.
	 * The iteratee should complete with a value to use as the sort criteria as
	 * its `result`.
	 * Invoked with (item, callback).
	 * @param {Function} callback - A callback which is called after all the
	 * `iteratee` functions have finished, or an error occurs. Results is the items
	 * from the original `coll` sorted by the values returned by the `iteratee`
	 * calls. Invoked with (err, results).
	 * @example
	 *
	 * async.sortBy(['file1','file2','file3'], function(file, callback) {
	 *     fs.stat(file, function(err, stats) {
	 *         callback(err, stats.mtime);
	 *     });
	 * }, function(err, results) {
	 *     // results is now the original array of files sorted by
	 *     // modified date
	 * });
	 *
	 * // By modifying the callback parameter the
	 * // sorting order can be influenced:
	 *
	 * // ascending order
	 * async.sortBy([1,9,3,5], function(x, callback) {
	 *     callback(null, x);
	 * }, function(err,result) {
	 *     // result callback
	 * });
	 *
	 * // descending order
	 * async.sortBy([1,9,3,5], function(x, callback) {
	 *     callback(null, x*-1);    //<- x*-1 instead of x, turns the order around
	 * }, function(err,result) {
	 *     // result callback
	 * });
	 */
	function sortBy$1 (coll, iteratee, callback) {
	    var _iteratee = wrapAsync(iteratee);
	    map$1(coll, function (x, callback) {
	        _iteratee(x, function (err, criteria) {
	            if (err) return callback(err);
	            callback(null, {value: x, criteria: criteria});
	        });
	    }, function (err, results) {
	        if (err) return callback(err);
	        callback(null, arrayMap(results.sort(comparator), baseProperty('value')));
	    });

	    function comparator(left, right) {
	        var a = left.criteria, b = right.criteria;
	        return a < b ? -1 : a > b ? 1 : 0;
	    }
	}

	/**
	 * Sets a time limit on an asynchronous function. If the function does not call
	 * its callback within the specified milliseconds, it will be called with a
	 * timeout error. The code property for the error object will be `'ETIMEDOUT'`.
	 *
	 * @name timeout
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @category Util
	 * @param {AsyncFunction} asyncFn - The async function to limit in time.
	 * @param {number} milliseconds - The specified time limit.
	 * @param {*} [info] - Any variable you want attached (`string`, `object`, etc)
	 * to timeout Error for more information..
	 * @returns {AsyncFunction} Returns a wrapped function that can be used with any
	 * of the control flow functions.
	 * Invoke this function with the same parameters as you would `asyncFunc`.
	 * @example
	 *
	 * function myFunction(foo, callback) {
	 *     doAsyncTask(foo, function(err, data) {
	 *         // handle errors
	 *         if (err) return callback(err);
	 *
	 *         // do some stuff ...
	 *
	 *         // return processed data
	 *         return callback(null, data);
	 *     });
	 * }
	 *
	 * var wrapped = async.timeout(myFunction, 1000);
	 *
	 * // call `wrapped` as you would `myFunction`
	 * wrapped({ bar: 'bar' }, function(err, data) {
	 *     // if `myFunction` takes < 1000 ms to execute, `err`
	 *     // and `data` will have their expected values
	 *
	 *     // else `err` will be an Error with the code 'ETIMEDOUT'
	 * });
	 */
	function timeout(asyncFn, milliseconds, info) {
	    var fn = wrapAsync(asyncFn);

	    return initialParams(function (args, callback) {
	        var timedOut = false;
	        var timer;

	        function timeoutCallback() {
	            var name = asyncFn.name || 'anonymous';
	            var error  = new Error('Callback function "' + name + '" timed out.');
	            error.code = 'ETIMEDOUT';
	            if (info) {
	                error.info = info;
	            }
	            timedOut = true;
	            callback(error);
	        }

	        args.push(function () {
	            if (!timedOut) {
	                callback.apply(null, arguments);
	                clearTimeout(timer);
	            }
	        });

	        // setup timer and call original function
	        timer = setTimeout(timeoutCallback, milliseconds);
	        fn.apply(null, args);
	    });
	}

	/**
	 * The same as [times]{@link module:ControlFlow.times} but runs a maximum of `limit` async operations at a
	 * time.
	 *
	 * @name timesLimit
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.times]{@link module:ControlFlow.times}
	 * @category Control Flow
	 * @param {number} count - The number of times to run the function.
	 * @param {number} limit - The maximum number of async operations at a time.
	 * @param {AsyncFunction} iteratee - The async function to call `n` times.
	 * Invoked with the iteration index and a callback: (n, next).
	 * @param {Function} callback - see [async.map]{@link module:Collections.map}.
	 */
	function timeLimit(count, limit, iteratee, callback) {
	    var _iteratee = wrapAsync(iteratee);
	    mapLimit(baseRange(0, count, 1), limit, _iteratee, callback);
	}

	/**
	 * Calls the `iteratee` function `n` times, and accumulates results in the same
	 * manner you would use with [map]{@link module:Collections.map}.
	 *
	 * @name times
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.map]{@link module:Collections.map}
	 * @category Control Flow
	 * @param {number} n - The number of times to run the function.
	 * @param {AsyncFunction} iteratee - The async function to call `n` times.
	 * Invoked with the iteration index and a callback: (n, next).
	 * @param {Function} callback - see {@link module:Collections.map}.
	 * @example
	 *
	 * // Pretend this is some complicated async factory
	 * var createUser = function(id, callback) {
	 *     callback(null, {
	 *         id: 'user' + id
	 *     });
	 * };
	 *
	 * // generate 5 users
	 * async.times(5, function(n, next) {
	 *     createUser(n, function(err, user) {
	 *         next(err, user);
	 *     });
	 * }, function(err, users) {
	 *     // we should now have 5 users
	 * });
	 */
	var times$1 = doLimit(timeLimit, Infinity);

	/**
	 * The same as [times]{@link module:ControlFlow.times} but runs only a single async operation at a time.
	 *
	 * @name timesSeries
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.times]{@link module:ControlFlow.times}
	 * @category Control Flow
	 * @param {number} n - The number of times to run the function.
	 * @param {AsyncFunction} iteratee - The async function to call `n` times.
	 * Invoked with the iteration index and a callback: (n, next).
	 * @param {Function} callback - see {@link module:Collections.map}.
	 */
	var timesSeries = doLimit(timeLimit, 1);

	/**
	 * A relative of `reduce`.  Takes an Object or Array, and iterates over each
	 * element in series, each step potentially mutating an `accumulator` value.
	 * The type of the accumulator defaults to the type of collection passed in.
	 *
	 * @name transform
	 * @static
	 * @memberOf module:Collections
	 * @method
	 * @category Collection
	 * @param {Array|Iterable|Object} coll - A collection to iterate over.
	 * @param {*} [accumulator] - The initial state of the transform.  If omitted,
	 * it will default to an empty Object or Array, depending on the type of `coll`
	 * @param {AsyncFunction} iteratee - A function applied to each item in the
	 * collection that potentially modifies the accumulator.
	 * Invoked with (accumulator, item, key, callback).
	 * @param {Function} [callback] - A callback which is called after all the
	 * `iteratee` functions have finished. Result is the transformed accumulator.
	 * Invoked with (err, result).
	 * @example
	 *
	 * async.transform([1,2,3], function(acc, item, index, callback) {
	 *     // pointless async:
	 *     process.nextTick(function() {
	 *         acc.push(item * 2)
	 *         callback(null)
	 *     });
	 * }, function(err, result) {
	 *     // result is now equal to [2, 4, 6]
	 * });
	 *
	 * @example
	 *
	 * async.transform({a: 1, b: 2, c: 3}, function (obj, val, key, callback) {
	 *     setImmediate(function () {
	 *         obj[key] = val * 2;
	 *         callback();
	 *     })
	 * }, function (err, result) {
	 *     // result is equal to {a: 2, b: 4, c: 6}
	 * })
	 */
	function transform$1 (coll, accumulator, iteratee, callback) {
	    if (arguments.length <= 3) {
	        callback = iteratee;
	        iteratee = accumulator;
	        accumulator = isArray(coll) ? [] : {};
	    }
	    callback = once$1(callback || noop);
	    var _iteratee = wrapAsync(iteratee);

	    eachOf(coll, function(v, k, cb) {
	        _iteratee(accumulator, v, k, cb);
	    }, function(err) {
	        callback(err, accumulator);
	    });
	}

	/**
	 * It runs each task in series but stops whenever any of the functions were
	 * successful. If one of the tasks were successful, the `callback` will be
	 * passed the result of the successful task. If all tasks fail, the callback
	 * will be passed the error and result (if any) of the final attempt.
	 *
	 * @name tryEach
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Array|Iterable|Object} tasks - A collection containing functions to
	 * run, each function is passed a `callback(err, result)` it must call on
	 * completion with an error `err` (which can be `null`) and an optional `result`
	 * value.
	 * @param {Function} [callback] - An optional callback which is called when one
	 * of the tasks has succeeded, or all have failed. It receives the `err` and
	 * `result` arguments of the last attempt at completing the `task`. Invoked with
	 * (err, results).
	 * @example
	 * async.tryEach([
	 *     function getDataFromFirstWebsite(callback) {
	 *         // Try getting the data from the first website
	 *         callback(err, data);
	 *     },
	 *     function getDataFromSecondWebsite(callback) {
	 *         // First website failed,
	 *         // Try getting the data from the backup website
	 *         callback(err, data);
	 *     }
	 * ],
	 * // optional callback
	 * function(err, results) {
	 *     Now do something with the data.
	 * });
	 *
	 */
	function tryEach(tasks, callback) {
	    var error = null;
	    var result;
	    callback = callback || noop;
	    eachSeries(tasks, function(task, callback) {
	        wrapAsync(task)(function (err, res/*, ...args*/) {
	            if (arguments.length > 2) {
	                result = slice$2(arguments, 1);
	            } else {
	                result = res;
	            }
	            error = err;
	            callback(!err);
	        });
	    }, function () {
	        callback(error, result);
	    });
	}

	/**
	 * Undoes a [memoize]{@link module:Utils.memoize}d function, reverting it to the original,
	 * unmemoized form. Handy for testing.
	 *
	 * @name unmemoize
	 * @static
	 * @memberOf module:Utils
	 * @method
	 * @see [async.memoize]{@link module:Utils.memoize}
	 * @category Util
	 * @param {AsyncFunction} fn - the memoized function
	 * @returns {AsyncFunction} a function that calls the original unmemoized function
	 */
	function unmemoize(fn) {
	    return function () {
	        return (fn.unmemoized || fn).apply(null, arguments);
	    };
	}

	/**
	 * Repeatedly call `iteratee`, while `test` returns `true`. Calls `callback` when
	 * stopped, or an error occurs.
	 *
	 * @name whilst
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Function} test - synchronous truth test to perform before each
	 * execution of `iteratee`. Invoked with ().
	 * @param {AsyncFunction} iteratee - An async function which is called each time
	 * `test` passes. Invoked with (callback).
	 * @param {Function} [callback] - A callback which is called after the test
	 * function has failed and repeated execution of `iteratee` has stopped. `callback`
	 * will be passed an error and any arguments passed to the final `iteratee`'s
	 * callback. Invoked with (err, [results]);
	 * @returns undefined
	 * @example
	 *
	 * var count = 0;
	 * async.whilst(
	 *     function() { return count < 5; },
	 *     function(callback) {
	 *         count++;
	 *         setTimeout(function() {
	 *             callback(null, count);
	 *         }, 1000);
	 *     },
	 *     function (err, n) {
	 *         // 5 seconds have passed, n = 5
	 *     }
	 * );
	 */
	function whilst(test, iteratee, callback) {
	    callback = onlyOnce(callback || noop);
	    var _iteratee = wrapAsync(iteratee);
	    if (!test()) return callback(null);
	    var next = function(err/*, ...args*/) {
	        if (err) return callback(err);
	        if (test()) return _iteratee(next);
	        var args = slice$2(arguments, 1);
	        callback.apply(null, [null].concat(args));
	    };
	    _iteratee(next);
	}

	/**
	 * Repeatedly call `iteratee` until `test` returns `true`. Calls `callback` when
	 * stopped, or an error occurs. `callback` will be passed an error and any
	 * arguments passed to the final `iteratee`'s callback.
	 *
	 * The inverse of [whilst]{@link module:ControlFlow.whilst}.
	 *
	 * @name until
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @see [async.whilst]{@link module:ControlFlow.whilst}
	 * @category Control Flow
	 * @param {Function} test - synchronous truth test to perform before each
	 * execution of `iteratee`. Invoked with ().
	 * @param {AsyncFunction} iteratee - An async function which is called each time
	 * `test` fails. Invoked with (callback).
	 * @param {Function} [callback] - A callback which is called after the test
	 * function has passed and repeated execution of `iteratee` has stopped. `callback`
	 * will be passed an error and any arguments passed to the final `iteratee`'s
	 * callback. Invoked with (err, [results]);
	 */
	function until(test, iteratee, callback) {
	    whilst(function() {
	        return !test.apply(this, arguments);
	    }, iteratee, callback);
	}

	/**
	 * Runs the `tasks` array of functions in series, each passing their results to
	 * the next in the array. However, if any of the `tasks` pass an error to their
	 * own callback, the next function is not executed, and the main `callback` is
	 * immediately called with the error.
	 *
	 * @name waterfall
	 * @static
	 * @memberOf module:ControlFlow
	 * @method
	 * @category Control Flow
	 * @param {Array} tasks - An array of [async functions]{@link AsyncFunction}
	 * to run.
	 * Each function should complete with any number of `result` values.
	 * The `result` values will be passed as arguments, in order, to the next task.
	 * @param {Function} [callback] - An optional callback to run once all the
	 * functions have completed. This will be passed the results of the last task's
	 * callback. Invoked with (err, [results]).
	 * @returns undefined
	 * @example
	 *
	 * async.waterfall([
	 *     function(callback) {
	 *         callback(null, 'one', 'two');
	 *     },
	 *     function(arg1, arg2, callback) {
	 *         // arg1 now equals 'one' and arg2 now equals 'two'
	 *         callback(null, 'three');
	 *     },
	 *     function(arg1, callback) {
	 *         // arg1 now equals 'three'
	 *         callback(null, 'done');
	 *     }
	 * ], function (err, result) {
	 *     // result now equals 'done'
	 * });
	 *
	 * // Or, with named functions:
	 * async.waterfall([
	 *     myFirstFunction,
	 *     mySecondFunction,
	 *     myLastFunction,
	 * ], function (err, result) {
	 *     // result now equals 'done'
	 * });
	 * function myFirstFunction(callback) {
	 *     callback(null, 'one', 'two');
	 * }
	 * function mySecondFunction(arg1, arg2, callback) {
	 *     // arg1 now equals 'one' and arg2 now equals 'two'
	 *     callback(null, 'three');
	 * }
	 * function myLastFunction(arg1, callback) {
	 *     // arg1 now equals 'three'
	 *     callback(null, 'done');
	 * }
	 */
	function waterfall(tasks, callback) {
	    callback = once$1(callback || noop);
	    if (!isArray(tasks)) return callback(new Error('First argument to waterfall must be an array of functions'));
	    if (!tasks.length) return callback();
	    var taskIndex = 0;

	    function nextTask(args) {
	        var task = wrapAsync(tasks[taskIndex++]);
	        args.push(onlyOnce(next));
	        task.apply(null, args);
	    }

	    function next(err/*, ...args*/) {
	        if (err || taskIndex === tasks.length) {
	            return callback.apply(null, arguments);
	        }
	        nextTask(slice$2(arguments, 1));
	    }

	    nextTask([]);
	}

	/**
	 * An "async function" in the context of Async is an asynchronous function with
	 * a variable number of parameters, with the final parameter being a callback.
	 * (`function (arg1, arg2, ..., callback) {}`)
	 * The final callback is of the form `callback(err, results...)`, which must be
	 * called once the function is completed.  The callback should be called with a
	 * Error as its first argument to signal that an error occurred.
	 * Otherwise, if no error occurred, it should be called with `null` as the first
	 * argument, and any additional `result` arguments that may apply, to signal
	 * successful completion.
	 * The callback must be called exactly once, ideally on a later tick of the
	 * JavaScript event loop.
	 *
	 * This type of function is also referred to as a "Node-style async function",
	 * or a "continuation passing-style function" (CPS). Most of the methods of this
	 * library are themselves CPS/Node-style async functions, or functions that
	 * return CPS/Node-style async functions.
	 *
	 * Wherever we accept a Node-style async function, we also directly accept an
	 * [ES2017 `async` function]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function}.
	 * In this case, the `async` function will not be passed a final callback
	 * argument, and any thrown error will be used as the `err` argument of the
	 * implicit callback, and the return value will be used as the `result` value.
	 * (i.e. a `rejected` of the returned Promise becomes the `err` callback
	 * argument, and a `resolved` value becomes the `result`.)
	 *
	 * Note, due to JavaScript limitations, we can only detect native `async`
	 * functions and not transpilied implementations.
	 * Your environment must have `async`/`await` support for this to work.
	 * (e.g. Node > v7.6, or a recent version of a modern browser).
	 * If you are using `async` functions through a transpiler (e.g. Babel), you
	 * must still wrap the function with [asyncify]{@link module:Utils.asyncify},
	 * because the `async function` will be compiled to an ordinary function that
	 * returns a promise.
	 *
	 * @typedef {Function} AsyncFunction
	 * @static
	 */

	var async = {
	    apply: apply$1,
	    applyEach: applyEach$1,
	    applyEachSeries: applyEachSeries,
	    asyncify: asyncify,
	    auto: auto,
	    autoInject: autoInject,
	    cargo: cargo,
	    compose: compose,
	    concat: concat$1,
	    concatLimit: concatLimit,
	    concatSeries: concatSeries,
	    constant: constant$1,
	    detect: detect,
	    detectLimit: detectLimit,
	    detectSeries: detectSeries,
	    dir: dir$1,
	    doDuring: doDuring,
	    doUntil: doUntil,
	    doWhilst: doWhilst,
	    during: during,
	    each: eachLimit,
	    eachLimit: eachLimit$1,
	    eachOf: eachOf,
	    eachOfLimit: eachOfLimit,
	    eachOfSeries: eachOfSeries,
	    eachSeries: eachSeries,
	    ensureAsync: ensureAsync,
	    every: every$1,
	    everyLimit: everyLimit,
	    everySeries: everySeries,
	    filter: filter$1,
	    filterLimit: filterLimit,
	    filterSeries: filterSeries,
	    forever: forever,
	    groupBy: groupBy$1,
	    groupByLimit: groupByLimit,
	    groupBySeries: groupBySeries,
	    log: log,
	    map: map$1,
	    mapLimit: mapLimit,
	    mapSeries: mapSeries,
	    mapValues: mapValues$1,
	    mapValuesLimit: mapValuesLimit,
	    mapValuesSeries: mapValuesSeries,
	    memoize: memoize$1,
	    nextTick: nextTick,
	    parallel: parallelLimit,
	    parallelLimit: parallelLimit$1,
	    priorityQueue: priorityQueue,
	    queue: queue$1,
	    race: race,
	    reduce: reduce$1,
	    reduceRight: reduceRight$1,
	    reflect: reflect,
	    reflectAll: reflectAll,
	    reject: reject$2,
	    rejectLimit: rejectLimit,
	    rejectSeries: rejectSeries,
	    retry: retry,
	    retryable: retryable,
	    seq: seq$1,
	    series: series,
	    setImmediate: setImmediate$1,
	    some: some$1,
	    someLimit: someLimit,
	    someSeries: someSeries,
	    sortBy: sortBy$1,
	    timeout: timeout,
	    times: times$1,
	    timesLimit: timeLimit,
	    timesSeries: timesSeries,
	    transform: transform$1,
	    tryEach: tryEach,
	    unmemoize: unmemoize,
	    until: until,
	    waterfall: waterfall,
	    whilst: whilst,

	    // aliases
	    all: every$1,
	    allLimit: everyLimit,
	    allSeries: everySeries,
	    any: some$1,
	    anyLimit: someLimit,
	    anySeries: someSeries,
	    find: detect,
	    findLimit: detectLimit,
	    findSeries: detectSeries,
	    forEach: eachLimit,
	    forEachSeries: eachSeries,
	    forEachLimit: eachLimit$1,
	    forEachOf: eachOf,
	    forEachOfSeries: eachOfSeries,
	    forEachOfLimit: eachOfLimit,
	    inject: reduce$1,
	    foldl: reduce$1,
	    foldr: reduceRight$1,
	    select: filter$1,
	    selectLimit: filterLimit,
	    selectSeries: filterSeries,
	    wrapSync: asyncify
	};

	/*jshint esversion: 6 */

	const EPSILON = 1e-5,
	    COPLANAR = 0,
	    FRONT = 1,
	    BACK = 2,
	    SPANNING = 3;

	class ThreeBSP {
	    constructor(geometry) {
	        // Convert THREE.Geometry to ThreeBSP
	        var i, _length_i,
	            face, vertex, faceVertexUvs, uvs,
	            polygon,
	            polygons = [];

	        this.Polygon = Polygon;
	        this.Vertex = Vertex$1;
	        this.Node = Node$1;
	        if (geometry instanceof THREE.Geometry) {
	            this.matrix = new THREE.Matrix4();
	        } else if (geometry instanceof THREE.Mesh) {
	            // #todo: add hierarchy support
	            geometry.updateMatrix();
	            this.matrix = geometry.matrix.clone();
	            geometry = geometry.geometry;
	        } else if (geometry instanceof Node$1) {
	            this.tree = geometry;
	            this.matrix = new THREE.Matrix4();
	            return this;
	        } else {
	            throw 'ThreeBSP: Given geometry is unsupported';
	        }

	        for (i = 0, _length_i = geometry.faces.length; i < _length_i; i++) {
	            face = geometry.faces[i];
	            faceVertexUvs = geometry.faceVertexUvs[0][i];
	            polygon = new Polygon();

	            if (face instanceof THREE.Face3) {
	                vertex = geometry.vertices[face.a];
	                uvs = faceVertexUvs ? new THREE.Vector2(faceVertexUvs[0].x, faceVertexUvs[0].y) : null;
	                vertex = new Vertex$1(vertex.x, vertex.y, vertex.z, face.vertexNormals[0], uvs);
	                vertex.applyMatrix4(this.matrix);
	                polygon.vertices.push(vertex);

	                vertex = geometry.vertices[face.b];
	                uvs = faceVertexUvs ? new THREE.Vector2(faceVertexUvs[1].x, faceVertexUvs[1].y) : null;
	                vertex = new Vertex$1(vertex.x, vertex.y, vertex.z, face.vertexNormals[1], uvs);
	                vertex.applyMatrix4(this.matrix);
	                polygon.vertices.push(vertex);

	                vertex = geometry.vertices[face.c];
	                uvs = faceVertexUvs ? new THREE.Vector2(faceVertexUvs[2].x, faceVertexUvs[2].y) : null;
	                vertex = new Vertex$1(vertex.x, vertex.y, vertex.z, face.vertexNormals[2], uvs);
	                vertex.applyMatrix4(this.matrix);
	                polygon.vertices.push(vertex);
	            } else if (typeof THREE.Face4) {
	                vertex = geometry.vertices[face.a];
	                uvs = faceVertexUvs ? new THREE.Vector2(faceVertexUvs[0].x, faceVertexUvs[0].y) : null;
	                vertex = new Vertex$1(vertex.x, vertex.y, vertex.z, face.vertexNormals[0], uvs);
	                vertex.applyMatrix4(this.matrix);
	                polygon.vertices.push(vertex);

	                vertex = geometry.vertices[face.b];
	                uvs = faceVertexUvs ? new THREE.Vector2(faceVertexUvs[1].x, faceVertexUvs[1].y) : null;
	                vertex = new Vertex$1(vertex.x, vertex.y, vertex.z, face.vertexNormals[1], uvs);
	                vertex.applyMatrix4(this.matrix);
	                polygon.vertices.push(vertex);

	                vertex = geometry.vertices[face.c];
	                uvs = faceVertexUvs ? new THREE.Vector2(faceVertexUvs[2].x, faceVertexUvs[2].y) : null;
	                vertex = new Vertex$1(vertex.x, vertex.y, vertex.z, face.vertexNormals[2], uvs);
	                vertex.applyMatrix4(this.matrix);
	                polygon.vertices.push(vertex);

	                vertex = geometry.vertices[face.d];
	                uvs = faceVertexUvs ? new THREE.Vector2(faceVertexUvs[3].x, faceVertexUvs[3].y) : null;
	                vertex = new Vertex$1(vertex.x, vertex.y, vertex.z, face.vertexNormals[3], uvs);
	                vertex.applyMatrix4(this.matrix);
	                polygon.vertices.push(vertex);
	            } else {
	                throw 'Invalid face type at index ' + i;
	            }

	            polygon.calculateProperties();
	            polygons.push(polygon);
	        }

	        this.tree = new Node$1(polygons);
	    }

	    subtract(other_tree) {
	        var a = this.tree.clone(),
	            b = other_tree.tree.clone();

	        a.invert();
	        a.clipTo(b);
	        b.clipTo(a);
	        b.invert();
	        b.clipTo(a);
	        b.invert();
	        a.build(b.allPolygons());
	        a.invert();
	        a = new ThreeBSP(a);
	        a.matrix = this.matrix;
	        return a;
	    }

	    union(other_tree) {
	        var a = this.tree.clone(),
	            b = other_tree.tree.clone();

	        a.clipTo(b);
	        b.clipTo(a);
	        b.invert();
	        b.clipTo(a);
	        b.invert();
	        a.build(b.allPolygons());
	        a = new ThreeBSP(a);
	        a.matrix = this.matrix;
	        return a;
	    }

	    intersect(other_tree) {
	        var a = this.tree.clone(),
	            b = other_tree.tree.clone();

	        a.invert();
	        b.clipTo(a);
	        b.invert();
	        a.clipTo(b);
	        b.clipTo(a);
	        a.build(b.allPolygons());
	        a.invert();
	        a = new ThreeBSP(a);
	        a.matrix = this.matrix;
	        return a;
	    }

	    toGeometry() {
	        var i, j,
	            matrix = new THREE.Matrix4().getInverse(this.matrix),
	            geometry = new THREE.Geometry(),
	            polygons = this.tree.allPolygons(),
	            polygon_count = polygons.length,
	            polygon, polygon_vertice_count,
	            vertice_dict = {},
	            vertex_idx_a, vertex_idx_b, vertex_idx_c,
	            vertex, face,
	            verticeUvs;

	        for (i = 0; i < polygon_count; i++) {
	            polygon = polygons[i];
	            polygon_vertice_count = polygon.vertices.length;

	            for (j = 2; j < polygon_vertice_count; j++) {
	                verticeUvs = [];

	                vertex = polygon.vertices[0];
	                verticeUvs.push(new THREE.Vector2(vertex.uv.x, vertex.uv.y));
	                vertex = new THREE.Vector3(vertex.x, vertex.y, vertex.z);
	                vertex.applyMatrix4(matrix);

	                if (typeof vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z] !== 'undefined') {
	                    vertex_idx_a = vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z];
	                } else {
	                    geometry.vertices.push(vertex);
	                    vertex_idx_a = vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z] = geometry.vertices.length - 1;
	                }

	                vertex = polygon.vertices[j - 1];
	                verticeUvs.push(new THREE.Vector2(vertex.uv.x, vertex.uv.y));
	                vertex = new THREE.Vector3(vertex.x, vertex.y, vertex.z);
	                vertex.applyMatrix4(matrix);
	                if (typeof vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z] !== 'undefined') {
	                    vertex_idx_b = vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z];
	                } else {
	                    geometry.vertices.push(vertex);
	                    vertex_idx_b = vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z] = geometry.vertices.length - 1;
	                }

	                vertex = polygon.vertices[j];
	                verticeUvs.push(new THREE.Vector2(vertex.uv.x, vertex.uv.y));
	                vertex = new THREE.Vector3(vertex.x, vertex.y, vertex.z);
	                vertex.applyMatrix4(matrix);
	                if (typeof vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z] !== 'undefined') {
	                    vertex_idx_c = vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z];
	                } else {
	                    geometry.vertices.push(vertex);
	                    vertex_idx_c = vertice_dict[vertex.x + ',' + vertex.y + ',' + vertex.z] = geometry.vertices.length - 1;
	                }

	                face = new THREE.Face3(
	                    vertex_idx_a,
	                    vertex_idx_b,
	                    vertex_idx_c,
	                    new THREE.Vector3(polygon.normal.x, polygon.normal.y, polygon.normal.z)
	                );

	                geometry.faces.push(face);
	                geometry.faceVertexUvs[0].push(verticeUvs);
	            }

	        }
	        return geometry;
	    }

	    toMesh (material) {
	        var geometry = this.toGeometry(),
	            mesh = new THREE.Mesh(geometry, material);

	        mesh.position.setFromMatrixPosition(this.matrix);
	        mesh.rotation.setFromRotationMatrix(this.matrix);

	        return mesh;
	    }
	}
	class Polygon {
	    constructor(vertices, normal, w) {
	        if (!( vertices instanceof Array )) {
	            vertices = [];
	        }

	        this.vertices = vertices;
	        if (vertices.length > 0) {
	            this.calculateProperties();
	        } else {
	            this.normal = this.w = undefined;
	        }
	    }

	    calculateProperties() {
	        var a = this.vertices[0],
	            b = this.vertices[1],
	            c = this.vertices[2];

	        this.normal = b.clone().subtract(a).cross(
	            c.clone().subtract(a)
	        ).normalize();

	        this.w = this.normal.clone().dot(a);

	        return this;
	    }

	    clone() {
	        var i, vertice_count,
	            polygon = new Polygon();

	        for (i = 0, vertice_count = this.vertices.length; i < vertice_count; i++) {
	            polygon.vertices.push(this.vertices[i].clone());
	        }
	        polygon.calculateProperties();

	        return polygon;
	    }

	    flip() {
	        var i, vertices = [];

	        this.normal.multiplyScalar(-1);
	        this.w *= -1;

	        for (i = this.vertices.length - 1; i >= 0; i--) {
	            vertices.push(this.vertices[i]);
	        }
	        this.vertices = vertices;

	        return this;
	    }

	    classifyVertex(vertex) {
	        var side_value = this.normal.dot(vertex) - this.w;

	        if (side_value < -EPSILON) {
	            return BACK;
	        } else if (side_value > EPSILON) {
	            return FRONT;
	        } else {
	            return COPLANAR;
	        }
	    }

	    classifySide(polygon) {
	        var i, vertex, classification,
	            num_positive = 0,
	            num_negative = 0,
	            vertice_count = polygon.vertices.length;

	        for (i = 0; i < vertice_count; i++) {
	            vertex = polygon.vertices[i];
	            classification = this.classifyVertex(vertex);
	            if (classification === FRONT) {
	                num_positive++;
	            } else if (classification === BACK) {
	                num_negative++;
	            }
	        }

	        if (num_positive === vertice_count && num_negative === 0) {
	            return FRONT;
	        } else if (num_positive === 0 && num_negative === vertice_count) {
	            return BACK;
	        } else if (num_positive > 0 && num_negative > 0) {
	            return SPANNING;
	        } else {
	            return COPLANAR;
	        }
	    }

	    splitPolygon(polygon, coplanar_front, coplanar_back, front, back) {
	        var classification = this.classifySide(polygon);

	        if (classification === COPLANAR) {

	            ( this.normal.dot(polygon.normal) > 0 ? coplanar_front : coplanar_back ).push(polygon);

	        } else if (classification === FRONT) {

	            front.push(polygon);

	        } else if (classification === BACK) {

	            back.push(polygon);

	        } else {

	            var vertice_count,
	                i, j, ti, tj, vi, vj,
	                t, v,
	                f = [],
	                b = [];

	            for (i = 0, vertice_count = polygon.vertices.length; i < vertice_count; i++) {

	                j = (i + 1) % vertice_count;
	                vi = polygon.vertices[i];
	                vj = polygon.vertices[j];
	                ti = this.classifyVertex(vi);
	                tj = this.classifyVertex(vj);

	                if (ti != BACK) f.push(vi);
	                if (ti != FRONT) b.push(vi);
	                if ((ti | tj) === SPANNING) {
	                    t = ( this.w - this.normal.dot(vi) ) / this.normal.dot(vj.clone().subtract(vi));
	                    v = vi.interpolate(vj, t);
	                    f.push(v);
	                    b.push(v);
	                }
	            }


	            if (f.length >= 3) front.push(new Polygon(f).calculateProperties());
	            if (b.length >= 3) back.push(new Polygon(b).calculateProperties());
	        }
	    }
	}
	class Vertex$1 {
	    constructor(x, y, z, normal, uv) {
	        this.x = x;
	        this.y = y;
	        this.z = z;
	        this.normal = normal || new THREE.Vector3();
	        this.uv = uv || new THREE.Vector2();
	    }

	    clone() {
	        return new Vertex$1(this.x, this.y, this.z, this.normal.clone(), this.uv.clone());
	    }

	    add(vertex) {
	        this.x += vertex.x;
	        this.y += vertex.y;
	        this.z += vertex.z;
	        return this;
	    }

	    subtract(vertex) {
	        this.x -= vertex.x;
	        this.y -= vertex.y;
	        this.z -= vertex.z;
	        return this;
	    }

	    multiplyScalar(scalar) {
	        this.x *= scalar;
	        this.y *= scalar;
	        this.z *= scalar;
	        return this;
	    }

	    cross(vertex) {
	        var x = this.x,
	            y = this.y,
	            z = this.z;

	        this.x = y * vertex.z - z * vertex.y;
	        this.y = z * vertex.x - x * vertex.z;
	        this.z = x * vertex.y - y * vertex.x;

	        return this;
	    }

	    normalize() {
	        var length = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);

	        this.x /= length;
	        this.y /= length;
	        this.z /= length;

	        return this;
	    }

	    dot(vertex) {
	        return this.x * vertex.x + this.y * vertex.y + this.z * vertex.z;
	    }

	    lerp(a, t) {
	        this.add(
	            a.clone().subtract(this).multiplyScalar(t)
	        );

	        this.normal.add(
	            a.normal.clone().sub(this.normal).multiplyScalar(t)
	        );

	        this.uv.add(
	            a.uv.clone().sub(this.uv).multiplyScalar(t)
	        );

	        return this;
	    }

	    interpolate(other, t) {
	        return this.clone().lerp(other, t);
	    }

	    applyMatrix4(m) {

	        // input: THREE.Matrix4 affine matrix

	        var x = this.x, y = this.y, z = this.z;

	        var e = m.elements;

	        this.x = e[0] * x + e[4] * y + e[8] * z + e[12];
	        this.y = e[1] * x + e[5] * y + e[9] * z + e[13];
	        this.z = e[2] * x + e[6] * y + e[10] * z + e[14];

	        return this;

	    }
	}
	class Node$1 {
	    constructor(polygons) {
	        var i, polygon_count,
	            front = [],
	            back = [];

	        this.polygons = [];
	        this.front = this.back = undefined;

	        if (!(polygons instanceof Array) || polygons.length === 0) return;

	        this.divider = polygons[0].clone();

	        for (i = 0, polygon_count = polygons.length; i < polygon_count; i++) {
	            this.divider.splitPolygon(polygons[i], this.polygons, this.polygons, front, back);
	        }

	        if (front.length > 0) {
	            this.front = new Node$1(front);
	        }

	        if (back.length > 0) {
	            this.back = new Node$1(back);
	        }
	    }

	    isConvex(polygons) {
	        var i, j;
	        for (i = 0; i < polygons.length; i++) {
	            for (j = 0; j < polygons.length; j++) {
	                if (i !== j && polygons[i].classifySide(polygons[j]) !== BACK) {
	                    return false;
	                }
	            }
	        }
	        return true;
	    }

	    build(polygons) {
	        var i, polygon_count,
	            front = [],
	            back = [];

	        if (!this.divider) {
	            this.divider = polygons[0].clone();
	        }

	        for (i = 0, polygon_count = polygons.length; i < polygon_count; i++) {
	            this.divider.splitPolygon(polygons[i], this.polygons, this.polygons, front, back);
	        }

	        if (front.length > 0) {
	            if (!this.front) this.front = new Node$1();
	            this.front.build(front);
	        }

	        if (back.length > 0) {
	            if (!this.back) this.back = new Node$1();
	            this.back.build(back);
	        }
	    }

	    allPolygons() {
	        var polygons = this.polygons.slice();
	        if (this.front) polygons = polygons.concat(this.front.allPolygons());
	        if (this.back) polygons = polygons.concat(this.back.allPolygons());
	        return polygons;
	    }

	    clone() {
	        var node = new Node$1();

	        node.divider = this.divider.clone();
	        node.polygons = this.polygons.map(function (polygon) {
	            return polygon.clone();
	        });
	        node.front = this.front && this.front.clone();
	        node.back = this.back && this.back.clone();

	        return node;
	    }

	    invert() {
	        var i, polygon_count, temp;

	        for (i = 0, polygon_count = this.polygons.length; i < polygon_count; i++) {
	            this.polygons[i].flip();
	        }

	        this.divider.flip();
	        if (this.front) this.front.invert();
	        if (this.back) this.back.invert();

	        temp = this.front;
	        this.front = this.back;
	        this.back = temp;

	        return this;
	    }

	    clipPolygons(polygons) {
	        var i, polygon_count,
	            front, back;

	        if (!this.divider) return polygons.slice();

	        front = [];
	        back = [];

	        for (i = 0, polygon_count = polygons.length; i < polygon_count; i++) {
	            this.divider.splitPolygon(polygons[i], front, back, front, back);
	        }

	        if (this.front) front = this.front.clipPolygons(front);
	        if (this.back) back = this.back.clipPolygons(back);
	        else back = [];

	        return front.concat(back);
	    }

	    clipTo(node) {
	        this.polygons = node.clipPolygons(this.polygons);
	        if (this.front) this.front.clipTo(node);
	        if (this.back) this.back.clipTo(node);
	    }
	}

	window.ThreeBSP = ThreeBSP;

	/**
	 * BackboneProxy -- Provides a proxy for the actual created Backbone instance. This is initialized in the constructor
	 * for Backbone (backbone-es6/src/Backbone.js). Anywhere a reference is needed for the composed Backbone instance
	 * import BackboneProxy and access it by "BackboneProxy.backbone".
	 *
	 * @example
	 * import BackboneProxy from 'backbone-es6/src/BackboneProxy.js';
	 *
	 * BackboneProxy.backbone.sync(...)
	 */

	/**
	 * Defines a proxy Object to hold a reference of the Backbone object instantiated.
	 *
	 * @type {{backbone: null}}
	 */
	const BackboneProxy =
	{
	   backbone: null
	};

	/**
	 * Backbone.js
	 *
	 * (c) 2010-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Backbone may be freely distributed under the MIT license.
	 *
	 * For all details and documentation:
	 * http://backbonejs.org
	 *
	 * ---------
	 *
	 * backbone-es6
	 * https://github.com/typhonjs/backbone-es6
	 * (c) 2015 Michael Leahy
	 * backbone-es6 may be freely distributed under the MPLv2 license.
	 *
	 * This fork of Backbone converts it to ES6 and provides extension through constructor injection for easy modification.
	 * The only major difference from Backbone is that Backbone itself is not a global Events instance anymore. Please
	 * see @link{Events.js} for documentation on easily setting up an ES6 event module for global usage.
	 *
	 * @see http://backbonejs.org
	 * @see https://github.com/typhonjs/backbone-es6
	 * @author Michael Leahy
	 * @version 1.3.3
	 * @copyright Michael Leahy 2015
	 */
	class Backbone
	{
	   /**
	    * Initializes Backbone by constructor injection. You may provide variations on any component below by passing
	    * in a different version. The "runtime" initializing Backbone is responsible for further modification like
	    * supporting the older "extend" support. See backbone-es6/src/ModuleRuntime.js and backbone-es6/src/extend.js
	    * for an example on composing Backbone for usage.
	    *
	    * @param {Collection}  Collection  - A class defining Backbone.Collection.
	    * @param {Events}      Events      - A class defining Backbone.Events.
	    * @param {History}     History     - A class defining Backbone.History.
	    * @param {Model}       Model       - A class defining Backbone.Model.
	    * @param {Router}      Router      - A class defining Backbone.Router.
	    * @param {View}        View        - A class defining Backbone.View.
	    * @param {function}    sync        - A function defining synchronization for Collection & Model.
	    * @param {object}      options     - Options to mixin to Backbone.
	    * @constructor
	    */
	   constructor(Collection, Events, History, Model, Router, View, sync, options = {})
	   {
	      /**
	       * Establish the root object, `window` (`self`) in the browser, or `global` on the server.
	       * We use `self` instead of `window` for `WebWorker` support.
	       *
	       * @type {object|global}
	       */
	      const root = (typeof self === 'object' && self.self === self && self) ||
	       (typeof global === 'object' && global.global === global && global);

	      /**
	       * jQuery or equivalent
	       * @type {*}
	       */
	      this.$ = (jQuery$1 || root.jQuery || root.Zepto || root.ender || root.$);

	      if (typeof this.$ === 'undefined')
	      {
	         throw new Error("Backbone - ctor - could not locate global '$' (jQuery or equivalent).");
	      }

	      /**
	       * Initial setup. Mixin options and set the BackboneProxy instance to this.
	       */
	      if (lodash.isObject(options))
	      {
	         lodash.extend(this, options);
	      }

	      BackboneProxy.backbone = this;

	      /**
	       * A public reference of the Collection class.
	       * @class
	       */
	      this.Collection = Collection;

	      /**
	       * A public reference of the Events class.
	       * @class
	       */
	      this.Events = Events;

	      /**
	       * A public reference of the History class.
	       * @class
	       */
	      this.History = History;

	      /**
	       * A public reference of the Model class.
	       * @class
	       */
	      this.Model = Model;

	      /**
	       * A public reference of the Router class.
	       * @class
	       */
	      this.Router = Router;

	      /**
	       * A public reference of the View class.
	       * @class
	       */
	      this.View = View;

	      /**
	       * A public instance of History.
	       * @instance
	       */
	      this.history = new History();

	      /**
	       * A public instance of the sync function.
	       * @instance
	       */
	      this.sync = sync;

	      /**
	       * Set the default implementation of `Backbone.ajax` to proxy through to `$`.
	       * Override this if you'd like to use a different library.
	       *
	       * @returns {XMLHttpRequest}   XMLHttpRequest
	       */
	      this.ajax = () =>
	      {
	         return this.$.ajax(...arguments);
	      };
	   }
	}

	/**
	 * Backbone.Events - Provides the ability to bind and trigger custom named events. (http://backbonejs.org/#Events)
	 * ---------------
	 *
	 * An important consideration of Backbone-ES6 is that Events are no longer an object literal, but a full blown ES6
	 * class. This is the biggest potential breaking change for Backbone-ES6 when compared to the original Backbone.
	 *
	 * Previously Events could be mixed in to any object. This is no longer possible with Backbone-ES6 when working from
	 * source or the bundled versions. It should be noted that Events is also no longer mixed into Backbone itself, so
	 * Backbone is not a Global events instance.
	 *
	 * Catalog of Events:
	 * Here's the complete list of built-in Backbone events, with arguments. You're also free to trigger your own events on
	 * Models, Collections and Views as you see fit.
	 *
	 * "add" (model, collection, options) — when a model is added to a collection.
	 * "remove" (model, collection, options) — when a model is removed from a collection.
	 * "update" (collection, options) — single event triggered after any number of models have been added or removed from a
	 * collection.
	 * "reset" (collection, options) — when the collection's entire contents have been reset.
	 * "sort" (collection, options) — when the collection has been re-sorted.
	 * "change" (model, options) — when a model's attributes have changed.
	 * "change:[attribute]" (model, value, options) — when a specific attribute has been updated.
	 * "destroy" (model, collection, options) — when a model is destroyed.
	 * "request" (model_or_collection, xhr, options) — when a model or collection has started a request to the server.
	 * "sync" (model_or_collection, response, options) — when a model or collection has been successfully synced with the
	 * server.
	 * "error" (model_or_collection, response, options) — when a model's or collection's request to the server has failed.
	 * "invalid" (model, error, options) — when a model's validation fails on the client.
	 * "route:[name]" (params) — Fired by the router when a specific route is matched.
	 * "route" (route, params) — Fired by the router when any route has been matched.
	 * "route" (router, route, params) — Fired by history when any route has been matched.
	 * "all" — this special event fires for any triggered event, passing the event name as the first argument followed by
	 * all trigger arguments.
	 *
	 * Generally speaking, when calling a function that emits an event (model.set, collection.add, and so on...), if you'd
	 * like to prevent the event from being triggered, you may pass {silent: true} as an option. Note that this is rarely,
	 * perhaps even never, a good idea. Passing through a specific flag in the options for your event callback to look at,
	 * and choose to ignore, will usually work out better.
	 *
	 * @example
	 * This no longer works:
	 *
	 * let object = {};
	 * _.extend(object, Backbone.Events);
	 * object.on('expand', function(){ alert('expanded'); });
	 * object.trigger('expand');
	 *
	 * One must now use ES6 extends syntax for Backbone.Events when inheriting events functionality:
	 * import Backbone from 'backbone';
	 *
	 * class MyClass extends Backbone.Events {}
	 *
	 * @example
	 * A nice ES6 pattern for creating a named events instance is the following:
	 *
	 * import Backbone from 'backbone';
	 *
	 * export default new Backbone.Events();
	 *
	 * This module / Events instance can then be imported by full path or if consuming in a modular runtime by creating
	 * a mapped path to it.
	 */
	class Events
	{
	   /** */
	   constructor() {}

	   /**
	    * Delegates to `on`.
	    *
	    * @returns {*}
	    */
	   bind()
	   {
	      return this.on(...arguments);
	   }

	   /**
	    * Tell an object to listen to a particular event on an other object. The advantage of using this form, instead of
	    * other.on(event, callback, object), is that listenTo allows the object to keep track of the events, and they can
	    * be removed all at once later on. The callback will always be called with object as context.
	    *
	    * @example
	    * view.listenTo(model, 'change', view.render);
	    *
	    * @see http://backbonejs.org/#Events-listenTo
	    *
	    * @param {object}   obj      - Event context
	    * @param {string}   name     - Event name(s)
	    * @param {function} callback - Event callback function
	    * @returns {Events}
	    */
	   listenTo(obj, name, callback)
	   {
	      if (!obj) { return this; }
	      const id = obj._listenId || (obj._listenId = lodash.uniqueId('l'));
	      const listeningTo = this._listeningTo || (this._listeningTo = {});
	      let listening = listeningTo[id];

	      // This object is not listening to any other events on `obj` yet.
	      // Setup the necessary references to track the listening callbacks.
	      if (!listening)
	      {
	         const thisId = this._listenId || (this._listenId = lodash.uniqueId('l'));
	         listening = listeningTo[id] = { obj, objId: id, id: thisId, listeningTo, count: 0 };
	      }

	      // Bind callbacks on obj, and keep track of them on listening.
	      s_INTERNAL_ON(obj, name, callback, this, listening);
	      return this;
	   }

	   /**
	    * Just like `listenTo`, but causes the bound callback to fire only once before being removed.
	    *
	    * @see http://backbonejs.org/#Events-listenToOnce
	    *
	    * @param {object}   obj      - Event context
	    * @param {string}   name     - Event name(s)
	    * @param {function} callback - Event callback function
	    * @returns {Events}
	    */
	   listenToOnce(obj, name, callback)
	   {
	      // Map the event into a `{event: once}` object.
	      const events = s_EVENTS_API(s_ONCE_MAP, {}, name, callback, lodash.bind(this.stopListening, this, obj));
	      return this.listenTo(obj, events, void 0);
	   }

	   /**
	    * Remove a previously-bound callback function from an object. If no context is specified, all of the versions of
	    * the callback with different contexts will be removed. If no callback is specified, all callbacks for the event
	    * will be removed. If no event is specified, callbacks for all events will be removed.
	    *
	    * Note that calling model.off(), for example, will indeed remove all events on the model — including events that
	    * Backbone uses for internal bookkeeping.
	    *
	    * @example
	    * // Removes just the `onChange` callback.
	    * object.off("change", onChange);
	    *
	    * // Removes all "change" callbacks.
	    * object.off("change");
	    *
	    * // Removes the `onChange` callback for all events.
	    * object.off(null, onChange);
	    *
	    * // Removes all callbacks for `context` for all events.
	    * object.off(null, null, context);
	    *
	    * // Removes all callbacks on `object`.
	    * object.off();
	    *
	    * @see http://backbonejs.org/#Events-off
	    *
	    * @param {string}   name     - Event name(s)
	    * @param {function} callback - Event callback function
	    * @param {object}   context  - Event context
	    * @returns {Events}
	    */
	   off(name, callback, context)
	   {
	      /* istanbul ignore if */
	      if (!this._events) { return this; }
	      this._events = s_EVENTS_API(s_OFF_API, this._events, name, callback, { context, listeners: this._listeners });
	      return this;
	   }

	   /**
	    * Bind a callback function to an object. The callback will be invoked whenever the event is fired. If you have a
	    * large number of different events on a page, the convention is to use colons to namespace them: "poll:start", or
	    * "change:selection".
	    *
	    * To supply a context value for this when the callback is invoked, pass the optional last argument:
	    * model.on('change', this.render, this) or model.on({change: this.render}, this).
	    *
	    * @example
	    * The event string may also be a space-delimited list of several events...
	    * book.on("change:title change:author", ...);
	    *
	    * @example
	    * Callbacks bound to the special "all" event will be triggered when any event occurs, and are passed the name of
	    * the event as the first argument. For example, to proxy all events from one object to another:
	    * proxy.on("all", function(eventName) {
	    *    object.trigger(eventName);
	    * });
	    *
	    * @example
	    * All Backbone event methods also support an event map syntax, as an alternative to positional arguments:
	    * book.on({
	    *    "change:author": authorPane.update,
	    *    "change:title change:subtitle": titleView.update,
	    *    "destroy": bookView.remove
	    * });
	    *
	    * @see http://backbonejs.org/#Events-on
	    *
	    * @param {string}   name     - Event name(s)
	    * @param {function} callback - Event callback function
	    * @param {object}   context  - Event context
	    * @returns {*}
	    */
	   on(name, callback, context)
	   {
	      return s_INTERNAL_ON(this, name, callback, context, void 0);
	   }

	   /**
	    * Just like `on`, but causes the bound callback to fire only once before being removed. Handy for saying "the next
	    * time that X happens, do this". When multiple events are passed in using the space separated syntax, the event
	    * will fire once for every event you passed in, not once for a combination of all events
	    *
	    * @see http://backbonejs.org/#Events-once
	    *
	    * @param {string}   name     - Event name(s)
	    * @param {function} callback - Event callback function
	    * @param {object}   context  - Event context
	    * @returns {*}
	    */
	   once(name, callback, context)
	   {
	      // Map the event into a `{event: once}` object.
	      const events = s_EVENTS_API(s_ONCE_MAP, {}, name, callback, lodash.bind(this.off, this));

	      if (typeof name === 'string' && (context === null || typeof context === 'undefined')) { callback = void 0; }

	      return this.on(events, callback, context);
	   }

	   /**
	    * Tell an object to stop listening to events. Either call stopListening with no arguments to have the object remove
	    * all of its registered callbacks ... or be more precise by telling it to remove just the events it's listening to
	    * on a specific object, or a specific event, or just a specific callback.
	    *
	    * @example
	    * view.stopListening();
	    *
	    * view.stopListening(model);
	    *
	    * @see http://backbonejs.org/#Events-stopListening
	    *
	    * @param {object}   obj      - Event context
	    * @param {string}   name     - Event name(s)
	    * @param {function} callback - Event callback function
	    * @returns {Events}
	    */
	   stopListening(obj, name, callback)
	   {
	      const listeningTo = this._listeningTo;
	      if (!listeningTo) { return this; }

	      const ids = obj ? [obj._listenId] : lodash.keys(listeningTo);

	      for (let i = 0; i < ids.length; i++)
	      {
	         const listening = listeningTo[ids[i]];

	         // If listening doesn't exist, this object is not currently listening to obj. Break out early.
	         if (!listening) { break; }

	         listening.obj.off(name, callback, this);
	      }

	      return this;
	   }

	   /**
	    * Trigger callbacks for the given event, or space-delimited list of events. Subsequent arguments to trigger will be
	    * passed along to the event callbacks.
	    *
	    * @see http://backbonejs.org/#Events-trigger
	    *
	    * @param {string}   name  - Event name(s)
	    * @returns {Events}
	    */
	   trigger(name)
	   {
	      /* istanbul ignore if */
	      if (!this._events) { return this; }

	      const length = Math.max(0, arguments.length - 1);
	      const args = new Array(length);

	      for (let i = 0; i < length; i++) { args[i] = arguments[i + 1]; }

	      s_EVENTS_API(s_TRIGGER_API, this._events, name, void 0, args);

	      return this;
	   }

	   /**
	    * Delegates to `off`.
	    *
	    * @returns {*}
	    */
	   unbind()
	   {
	      return this.off(...arguments);
	   }
	}

	// Private / internal methods ---------------------------------------------------------------------------------------

	/**
	 * Regular expression used to split event strings.
	 * @type {RegExp}
	 */
	const s_EVENT_SPLITTER = /\s+/;

	/**
	 * Iterates over the standard `event, callback` (as well as the fancy multiple space-separated events `"change blur",
	 * callback` and jQuery-style event maps `{event: callback}`).
	 *
	 * @param {function} iteratee    - Event operation to invoke.
	 * @param {Object.<{callback: function, context: object, ctx: object, listening:{}}>} events - Events object
	 * @param {string|object} name   - A single event name, compound event names, or a hash of event names.
	 * @param {function} callback    - Event callback function
	 * @param {object}   opts        - Optional parameters
	 * @returns {*}
	 */
	const s_EVENTS_API = (iteratee, events, name, callback, opts) =>
	{
	   let i = 0, names;
	   if (name && typeof name === 'object')
	   {
	      // Handle event maps.
	      if (callback !== void 0 && 'context' in opts && opts.context === void 0) { opts.context = callback; }
	      for (names = lodash.keys(name); i < names.length; i++)
	      {
	         events = s_EVENTS_API(iteratee, events, names[i], name[names[i]], opts);
	      }
	   }
	   else if (name && s_EVENT_SPLITTER.test(name))
	   {
	      // Handle space-separated event names by delegating them individually.
	      for (names = name.split(s_EVENT_SPLITTER); i < names.length; i++)
	      {
	         events = iteratee(events, names[i], callback, opts);
	      }
	   }
	   else
	   {
	      // Finally, standard events.
	      events = iteratee(events, name, callback, opts);
	   }
	   return events;
	};

	/**
	 * Guard the `listening` argument from the public API.
	 *
	 * @param {Events}   obj      - The Events instance
	 * @param {string}   name     - Event name
	 * @param {function} callback - Event callback
	 * @param {object}   context  - Event context
	 * @param {Object.<{obj: object, objId: string, id: string, listeningTo: object, count: number}>} listening -
	 *                              Listening object
	 * @returns {*}
	 */
	const s_INTERNAL_ON = (obj, name, callback, context, listening) =>
	{
	   obj._events = s_EVENTS_API(s_ON_API, obj._events || {}, name, callback, { context, ctx: obj, listening });

	   if (listening)
	   {
	      const listeners = obj._listeners || (obj._listeners = {});
	      listeners[listening.id] = listening;
	   }

	   return obj;
	};

	/**
	 * The reducing API that removes a callback from the `events` object.
	 *
	 * @param {Object.<{callback: function, context: object, ctx: object, listening:{}}>} events - Events object
	 * @param {string}   name     - Event name
	 * @param {function} callback - Event callback
	 * @param {object}   options  - Optional parameters
	 * @returns {*}
	 */
	const s_OFF_API = (events, name, callback, options) =>
	{
	   if (!events) { return; }

	   let i = 0, listening;
	   const context = options.context, listeners = options.listeners;

	   // Delete all events listeners and "drop" events.
	   if (!name && !callback && !context)
	   {
	      const ids = lodash.keys(listeners);
	      for (; i < ids.length; i++)
	      {
	         listening = listeners[ids[i]];
	         delete listeners[listening.id];
	         delete listening.listeningTo[listening.objId];
	      }
	      return;
	   }

	   const names = name ? [name] : lodash.keys(events);
	   for (; i < names.length; i++)
	   {
	      name = names[i];
	      const handlers = events[name];

	      // Bail out if there are no events stored.
	      /* istanbul ignore if */
	      if (!handlers) { break; }

	      // Replace events if there are any remaining.  Otherwise, clean up.
	      const remaining = [];
	      for (let j = 0; j < handlers.length; j++)
	      {
	         const handler = handlers[j];
	         if (
	          callback && callback !== handler.callback &&
	          callback !== handler.callback._callback ||
	          context && context !== handler.context
	         )
	         {
	            remaining.push(handler);
	         }
	         else
	         {
	            listening = handler.listening;
	            if (listening && --listening.count === 0)
	            {
	               delete listeners[listening.id];
	               delete listening.listeningTo[listening.objId];
	            }
	         }
	      }

	      // Update tail event if the list has any events.  Otherwise, clean up.
	      if (remaining.length)
	      {
	         events[name] = remaining;
	      }
	      else
	      {
	         delete events[name];
	      }
	   }

	   return events;
	};

	/**
	 * The reducing API that adds a callback to the `events` object.
	 *
	 * @param {Object.<{callback: function, context: object, ctx: object, listening:{}}>} events - Events object
	 * @param {string}   name     - Event name
	 * @param {function} callback - Event callback
	 * @param {object}   options  - Optional parameters
	 * @returns {*}
	 */
	const s_ON_API = (events, name, callback, options) =>
	{
	   if (callback)
	   {
	      const handlers = events[name] || (events[name] = []);
	      const context = options.context, ctx = options.ctx, listening = options.listening;

	      if (listening) { listening.count++; }

	      handlers.push({ callback, context, ctx: context || ctx, listening });
	   }
	   return events;
	};

	/**
	 * Reduces the event callbacks into a map of `{event: onceWrapper}`. `offer` unbinds the `onceWrapper` after
	 * it has been called.
	 *
	 * @param {Object.<{callback: function, context: object, ctx: object, listening:{}}>} map - Events object
	 * @param {string}   name     - Event name
	 * @param {function} callback - Event callback
	 * @param {function} offer    - Function to invoke after event has been triggered once; `off()`
	 * @returns {*}
	 */
	const s_ONCE_MAP = function(map, name, callback, offer)
	{
	   if (callback)
	   {
	      const once = map[name] = lodash.once(function()
	      {
	         offer(name, once);
	         callback.apply(this, arguments);
	      });
	      once._callback = callback;
	   }
	   return map;
	};

	/**
	 * Handles triggering the appropriate event callbacks.
	 *
	 * @param {Object.<{callback: function, context: object, ctx: object, listening:{}}>} objEvents - Events object
	 * @param {string}   name  - Event name
	 * @param {function} callback - Event callback
	 * @param {Array<*>} args  - Event arguments
	 * @returns {*}
	 */
	const s_TRIGGER_API = (objEvents, name, callback, args) =>
	{
	   if (objEvents)
	   {
	      const events = objEvents[name];
	      let allEvents = objEvents.all;
	      if (events && allEvents) { allEvents = allEvents.slice(); }
	      if (events) { s_TRIGGER_EVENTS(events, args); }
	      if (allEvents) { s_TRIGGER_EVENTS(allEvents, [name].concat(args)); }
	   }
	   return objEvents;
	};

	/**
	 * A difficult-to-believe, but optimized internal dispatch function for triggering events. Tries to keep the usual
	 * cases speedy (most internal Backbone events have 3 arguments).
	 *
	 * @param {Object.<{callback: function, context: object, ctx: object, listening:{}}>}  events - events array
	 * @param {Array<*>} args - event argument array
	 */
	const s_TRIGGER_EVENTS = (events, args) =>
	{
	   let ev, i = -1;
	   const a1 = args[0], a2 = args[1], a3 = args[2], l = events.length;

	   switch (args.length)
	   {
	      case 0:
	         while (++i < l) { (ev = events[i]).callback.call(ev.ctx); }
	         return;
	      case 1:
	         while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1); }
	         return;
	      case 2:
	         while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1, a2); }
	         return;
	      case 3:
	         while (++i < l) { (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); }
	         return;
	      default:
	         while (++i < l) { (ev = events[i]).callback.apply(ev.ctx, args); }
	         return;
	   }
	};

	/**
	 * Provides static utility functions.
	 * --------
	 *
	 * Proxy Backbone class methods to Underscore functions, wrapping the model's `attributes` object or collection's
	 * `models` array behind the scenes.
	 *
	 * `Function#apply` can be slow so we use the method's arg count, if we know it.
	 *
	 * @example
	 * collection.filter(function(model) { return model.get('age') > 10 });
	 * collection.each(this.addView);
	 */
	class Utils
	{
	   /**
	    * Adds Underscore methods if they exist from keys of the `methods` hash to `Class` running against the variable
	    * defined by `attribute`
	    *
	    * @param {Class}    Class       -  Class to add Underscore methods to.
	    * @param {object}   methods     -  Hash with keys as method names and values as argument length.
	    * @param {string}   attribute   -  The variable to run Underscore methods against. Often "attributes"
	    */
	   static addUnderscoreMethods(Class, methods, attribute)
	   {
	      lodash.each(methods, (length, method) =>
	      {
	         if (lodash[method]) { Class.prototype[method] = s_ADD_METHOD(length, method, attribute); }
	      });
	   }

	   /**
	    * Method for checking whether an unknown variable is an instance of `Backbone.Model`.
	    *
	    * @param {*}  unknown - Variable to test.
	    * @returns {boolean}
	    */
	   static isModel(unknown)
	   {
	      return unknown instanceof BackboneProxy.backbone.Model;
	   }

	   /**
	    * Method for checking whether a variable is undefined or null.
	    *
	    * @param {*}  unknown - Variable to test.
	    * @returns {boolean}
	    */
	   static isNullOrUndef(unknown)
	   {
	      return unknown === null || typeof unknown === 'undefined';
	   }

	   /**
	    * Throw an error when a URL is needed, and none is supplied.
	    */
	   static urlError()
	   {
	      throw new Error('A "url" property or function must be specified');
	   }

	   /**
	    * Wrap an optional error callback with a fallback error event.
	    *
	    * @param {Model|Collection}  model    - Model or Collection target to construct and error callback against.
	    * @param {object}            options  - Options hash to store error callback inside.
	    */
	   static wrapError(model, options)
	   {
	      const error = options.error;
	      options.error = (resp) =>
	      {
	         if (error) { error.call(options.context, model, resp, options); }
	         model.trigger('error', model, resp, options);
	      };
	   }
	}

	// Private / internal methods ---------------------------------------------------------------------------------------

	/**
	 * Creates an optimized function that dispatches to an associated Underscore function.
	 *
	 * @param {number}   length      - Length of variables for given Underscore method to dispatch.
	 * @param {string}   method      - Function name of Underscore to invoke.
	 * @param {string}   attribute   - Attribute to associate with the Underscore function invoked.
	 * @returns {Function}
	 */
	const s_ADD_METHOD = (length, method, attribute) =>
	{
	   switch (length)
	   {
	      case 1:
	         return function()
	         {
	            return lodash[method](this[attribute]);
	         };
	      case 2:
	         return function(value)
	         {
	            return lodash[method](this[attribute], value);
	         };
	      case 3:
	         return function(iteratee, context)
	         {
	            return lodash[method](this[attribute], s_CB(iteratee), context);
	         };
	      case 4:
	         return function(iteratee, defaultVal, context)
	         {
	            return lodash[method](this[attribute], s_CB(iteratee), defaultVal, context);
	         };
	      default:
	         return function()
	         {
	            const args = Array.prototype.slice.call(arguments);
	            args.unshift(this[attribute]);
	            return lodash[method](...args);
	         };
	   }
	};

	/**
	 * Support `collection.sortBy('attr')` and `collection.findWhere({id: 1})`.
	 *
	 * @param {*} iteratee  -
	 * @returns {*}
	 */
	const s_CB = (iteratee) =>
	{
	   if (lodash.isFunction(iteratee)) { return iteratee; }
	   if (lodash.isObject(iteratee) && !Utils.isModel(iteratee)) { return s_MODEL_MATCHER(iteratee); }
	   if (lodash.isString(iteratee))
	   {
	      return function(model)
	      {
	         return model.get(iteratee);
	      };
	   }
	   return iteratee;
	};

	/**
	 * Creates a matching function against `attrs`.
	 *
	 * @param {*} attrs -
	 * @returns {Function}
	 */
	const s_MODEL_MATCHER = (attrs) =>
	{
	   const matcher = lodash.matches(attrs);
	   return (model) =>
	   {
	      return matcher(model.attributes);
	   };
	};

	class Model extends Events {
	  constructor(attributes = {}, options = {}) {
	    super();
	    if (lodash.isBoolean(options.abortCtor) && options.abortCtor) {
	      return;
	    }
	    let attrs = attributes;
	    this.cidPrefix = "c";
	    this.cid = lodash.uniqueId(this.cidPrefix);
	    this.attributes = {};
	    if (options.collection) {
	      this.collection = options.collection;
	    }
	    this.changed = {};
	    this.validationError = null;
	    if (lodash.isBoolean(options.abortCtorInit) && options.abortCtorInit) {
	      return;
	    }
	    if (options.parse) {
	      attrs = this.parse(attrs, options) || ({});
	    }
	    const defaults = lodash.result(this, "defaults");
	    attrs = lodash.defaults(lodash.extend({}, defaults, attrs), defaults);
	    this.set(attrs, options);
	    this.initialize(this, arguments);
	  }
	  changedAttributes(diff) {
	    if (!diff) {
	      return this.hasChanged() ? lodash.clone(this.changed) : false;
	    }
	    const old = this._changing ? this._previousAttributes : this.attributes;
	    const changed = {};
	    for (const attr in diff) {
	      const val = diff[attr];
	      if (lodash.isEqual(old[attr], val)) {
	        continue;
	      }
	      changed[attr] = val;
	    }
	    return lodash.size(changed) ? changed : false;
	  }
	  clear(options) {
	    const attrs = {};
	    for (const key in this.attributes) {
	      attrs[key] = void 0;
	    }
	    return this.set(attrs, lodash.extend({}, options, {
	      unset: true
	    }));
	  }
	  clone() {
	    return new this.constructor(this.attributes);
	  }
	  destroy(options) {
	    options = options ? lodash.clone(options) : {};
	    const success = options.success;
	    const wait = options.wait;
	    const destroy = () => {
	      this.stopListening();
	      this.trigger("destroy", this, this.collection, options);
	    };
	    options.success = resp => {
	      if (wait) {
	        destroy();
	      }
	      if (success) {
	        success.call(options.context, this, resp, options);
	      }
	      if (!this.isNew()) {
	        this.trigger("sync", this, resp, options);
	      }
	    };
	    let xhr = false;
	    if (this.isNew()) {
	      lodash.defer(options.success);
	    } else {
	      Utils.wrapError(this, options);
	      xhr = this.sync("delete", this, options);
	    }
	    if (!wait) {
	      destroy();
	    }
	    return xhr;
	  }
	  escape(attr) {
	    return lodash.escape(this.get(attr));
	  }
	  fetch(options) {
	    options = lodash.extend({
	      parse: true
	    }, options);
	    const success = options.success;
	    options.success = resp => {
	      const serverAttrs = options.parse ? this.parse(resp, options) : resp;
	      if (!this.set(serverAttrs, options)) {
	        return false;
	      }
	      if (success) {
	        success.call(options.context, this, resp, options);
	      }
	      this.trigger("sync", this, resp, options);
	    };
	    Utils.wrapError(this, options);
	    return this.sync("read", this, options);
	  }
	  get(attr) {
	    return this.attributes[attr];
	  }
	  has(attr) {
	    return !Utils.isNullOrUndef(this.get(attr));
	  }
	  hasChanged(attr) {
	    if (Utils.isNullOrUndef(attr)) {
	      return !lodash.isEmpty(this.changed);
	    }
	    return lodash.has(this.changed, attr);
	  }
	  initialize() {}
	  isNew() {
	    return !this.has(this.idAttribute);
	  }
	  isValid(options) {
	    return this._validate({}, lodash.extend({}, options, {
	      validate: true
	    }));
	  }
	  matches(attrs) {
	    return !!lodash.iteratee(attrs, this)(this.attributes);
	  }
	  parse(resp, options) {
	    return resp;
	  }
	  previous(attr) {
	    if (Utils.isNullOrUndef(attr) || !this._previousAttributes) {
	      return null;
	    }
	    return this._previousAttributes[attr];
	  }
	  previousAttributes() {
	    return lodash.clone(this._previousAttributes);
	  }
	  save(key, val, options) {
	    let attrs;
	    if (Utils.isNullOrUndef(key) || typeof key === "object") {
	      attrs = key;
	      options = val;
	    } else {
	      (attrs = {})[key] = val;
	    }
	    options = lodash.extend({
	      validate: true,
	      parse: true
	    }, options);
	    const wait = options.wait;
	    if (attrs && !wait) {
	      if (!this.set(attrs, options)) {
	        return false;
	      }
	    } else if (!this._validate(attrs, options)) {
	      return false;
	    }
	    const success = options.success;
	    const attributes = this.attributes;
	    options.success = resp => {
	      this.attributes = attributes;
	      let serverAttrs = options.parse ? this.parse(resp, options) : resp;
	      if (wait) {
	        serverAttrs = lodash.extend({}, attrs, serverAttrs);
	      }
	      if (serverAttrs && !this.set(serverAttrs, options)) {
	        return false;
	      }
	      if (success) {
	        success.call(options.context, this, resp, options);
	      }
	      this.trigger("sync", this, resp, options);
	    };
	    Utils.wrapError(this, options);
	    if (attrs && wait) {
	      this.attributes = lodash.extend({}, attributes, attrs);
	    }
	    const method = this.isNew() ? "create" : options.patch ? "patch" : "update";
	    if (method === "patch" && !options.attrs) {
	      options.attrs = attrs;
	    }
	    const xhr = this.sync(method, this, options);
	    this.attributes = attributes;
	    return xhr;
	  }
	  set(key, val, options = {}) {
	    if (Utils.isNullOrUndef(key)) {
	      return this;
	    }
	    let attrs;
	    if (typeof key === "object") {
	      attrs = key;
	      options = val || ({});
	    } else {
	      (attrs = {})[key] = val;
	    }
	    if (!this._validate(attrs, options)) {
	      return false;
	    }
	    const unset = options.unset;
	    const silent = options.silent;
	    const changes = [];
	    const changing = this._changing;
	    this._changing = true;
	    if (!changing) {
	      this._previousAttributes = lodash.clone(this.attributes);
	      this.changed = {};
	    }
	    const current = this.attributes;
	    const changed = this.changed;
	    const prev = this._previousAttributes;
	    for (const attr in attrs) {
	      val = attrs[attr];
	      if (!lodash.isEqual(current[attr], val)) {
	        changes.push(attr);
	      }
	      if (!lodash.isEqual(prev[attr], val)) {
	        changed[attr] = val;
	      } else {
	        delete changed[attr];
	      }
	      if (unset) {
	        delete current[attr];
	      } else {
	        current[attr] = val;
	      }
	    }
	    if ((this.idAttribute in attrs)) {
	      this.id = this.get(this.idAttribute);
	    }
	    if (!silent) {
	      if (changes.length) {
	        this._pending = options;
	      }
	      for (let i = 0; i < changes.length; i++) {
	        this.trigger(`change:${changes[i]}`, this, current[changes[i]], options);
	      }
	    }
	    if (changing) {
	      return this;
	    }
	    if (!silent) {
	      while (this._pending) {
	        options = this._pending;
	        this._pending = false;
	        this.trigger("change", this, options);
	      }
	    }
	    this._pending = false;
	    this._changing = false;
	    return this;
	  }
	  sync() {
	    return BackboneProxy.backbone.sync.apply(this, arguments);
	  }
	  toJSON() {
	    return lodash.clone(this.attributes);
	  }
	  unset(attr, options) {
	    return this.set(attr, void 0, lodash.extend({}, options, {
	      unset: true
	    }));
	  }
	  url() {
	    const base = lodash.result(this, "urlRoot") || lodash.result(this.collection, "url") || Utils.urlError();
	    if (this.isNew()) {
	      return base;
	    }
	    const id = this.get(this.idAttribute);
	    return base.replace(/[^\/]$/, "$&/") + encodeURIComponent(id);
	  }
	  _validate(attrs, options) {
	    if (!options.validate || !this.validate) {
	      return true;
	    }
	    attrs = lodash.extend({}, this.attributes, attrs);
	    const error = this.validationError = this.validate(attrs, options) || null;
	    if (!error) {
	      return true;
	    }
	    this.trigger("invalid", this, error, lodash.extend(options, {
	      validationError: error
	    }));
	    return false;
	  }
	}
	Model.prototype.idAttribute = "id";
	const modelMethods = {
	  keys: 1,
	  values: 1,
	  pairs: 1,
	  invert: 1,
	  pick: 0,
	  omit: 0,
	  chain: 1,
	  isEmpty: 1
	};
	Utils.addUnderscoreMethods(Model, modelMethods, "attributes");

	const s_DEBUG_TRACE = false;

	/* eslint-disable no-console */

	/**
	 * Debug.js - Provides basic logging functionality that can be turned on via setting s_DEBUG_LOG = true;
	 *
	 * This is temporary until stability is fully tested.
	 */
	class Debug
	{
	   /**
	    * Posts a log message to console.
	    *
	    * @param {string}   message  - A message to log
	    * @param {boolean}  trace    - A boolean indicating whether to also log `console.trace()`
	    */
	   static log(message, trace = s_DEBUG_TRACE)
	   {
	   }
	}

	class Collection extends Events {
	  constructor(models = [], options = {}) {
	    super();
	    if (lodash.isBoolean(options.abortCtor) && options.abortCtor) {
	      return;
	    }
	    const hasModelGetter = !lodash.isUndefined(this.model);
	    const hasComparatorGetter = !lodash.isUndefined(this.comparator);
	    if (!hasModelGetter) {
	      this.model = Model;
	    }
	    if (options.model && !hasModelGetter) {
	      this.model = options.model;
	    }
	    if (options.comparator !== void 0 && !hasComparatorGetter) {
	      this.comparator = options.comparator;
	    }
	    if (lodash.isBoolean(options.abortCtorInit) && options.abortCtorInit) {
	      return;
	    }
	    this._reset();
	    this.initialize(...arguments);
	    if (models) {
	      this.reset(models, lodash.extend({
	        silent: true
	      }, options));
	    }
	  }
	  add(models, options) {
	    return this.set(models, lodash.extend({
	      merge: false
	    }, options, s_ADD_OPTIONS));
	  }
	  at(index) {
	    if (index < 0) {
	      index += this.length;
	    }
	    return this.models[index];
	  }
	  clone() {
	    return new this.constructor(this.models, {
	      model: this.model,
	      comparator: this.comparator
	    });
	  }
	  create(attrs, options) {
	    options = options ? lodash.clone(options) : {};
	    const wait = options.wait;
	    const model = this._prepareModel(attrs, options);
	    if (!model) {
	      return false;
	    }
	    if (!wait) {
	      this.add(model, options);
	    }
	    const collection = this;
	    const success = options.success;
	    options.success = (m, resp, callbackOpts) => {
	      if (wait) {
	        collection.add(m, callbackOpts);
	      }
	      if (success) {
	        success.call(callbackOpts.context, m, resp, callbackOpts);
	      }
	    };
	    model.save(null, options);
	    return model;
	  }
	  fetch(options) {
	    options = lodash.extend({
	      parse: true
	    }, options);
	    const success = options.success;
	    options.success = resp => {
	      const method = options.reset ? "reset" : "set";
	      Debug.log(`Collection - fetch - success callback - method: ${method}`, true);
	      this[method](resp, options);
	      if (success) {
	        success.call(options.context, this, resp, options);
	      }
	      this.trigger("sync", this, resp, options);
	    };
	    Utils.wrapError(this, options);
	    return this.sync("read", this, options);
	  }
	  findWhere(attrs) {
	    return this.where(attrs, true);
	  }
	  get(obj) {
	    if (Utils.isNullOrUndef(obj)) {
	      return void 0;
	    }
	    const id = this.modelId(obj.attributes || obj);
	    Debug.log(`Collection - get - id: ${id}`);
	    return this._byId[obj] || this._byId[id] || obj.cid && this._byId[obj.cid];
	  }
	  has(obj) {
	    return !Utils.isNullOrUndef(this.get(obj));
	  }
	  initialize() {}
	  modelId(attrs) {
	    Debug.log(`Collection - modelId - 0 - this.model.prototype.idAttribute: ${this.model.prototype.idAttribute}`, true);
	    Debug.log(`Collection - modelId - 1 - attrs: ${JSON.stringify(attrs)}`);
	    return attrs[this.model.prototype.idAttribute || "id"];
	  }
	  parse(resp, options) {
	    return resp;
	  }
	  pluck(attr) {
	    return this.map(`${attr}`);
	  }
	  pop(options) {
	    const model = this.at(this.length - 1);
	    return this.remove(model, options);
	  }
	  _prepareModel(attrs, options) {
	    if (Utils.isModel(attrs)) {
	      Debug.log(`Collection - _prepareModel - 0`, true);
	      if (!attrs.collection) {
	        attrs.collection = this;
	      }
	      return attrs;
	    }
	    options = options ? lodash.clone(options) : {};
	    options.collection = this;
	    Debug.log(`Collection - _prepareModel - 1 - attrs.parseObject: ${attrs.parseObject}`);
	    const model = new this.model(attrs, options);
	    if (!model.validationError) {
	      return model;
	    }
	    this.trigger("invalid", this, model.validationError, options);
	    return false;
	  }
	  push(model, options) {
	    return this.add(model, lodash.extend({
	      at: this.length
	    }, options));
	  }
	  remove(models, options) {
	    options = lodash.extend({}, options);
	    const singular = !lodash.isArray(models);
	    models = singular ? [models] : models.slice();
	    const removed = s_REMOVE_MODELS(this, models, options);
	    if (!options.silent && removed.length) {
	      options.changes = {
	        added: [],
	        merged: [],
	        removed
	      };
	      this.trigger("update", this, options);
	    }
	    return singular ? removed[0] : removed;
	  }
	  _reset() {
	    this.length = 0;
	    this.models = [];
	    this._byId = {};
	  }
	  reset(models, options) {
	    options = options ? lodash.clone(options) : {};
	    for (let i = 0; i < this.models.length; i++) {
	      s_REMOVE_REFERENCE(this, this.models[i]);
	    }
	    options.previousModels = this.models;
	    this._reset();
	    models = this.add(models, lodash.extend({
	      silent: true
	    }, options));
	    if (!options.silent) {
	      this.trigger("reset", this, options);
	    }
	    return models;
	  }
	  set(models, options) {
	    Debug.log(`Collection - set - 0`, true);
	    if (Utils.isNullOrUndef(models)) {
	      return;
	    }
	    options = lodash.extend({}, s_SET_OPTIONS, options);
	    if (options.parse && !Utils.isModel(models)) {
	      models = this.parse(models, options) || [];
	    }
	    const singular = !lodash.isArray(models);
	    models = singular ? [models] : models.slice();
	    let at = options.at;
	    if (!Utils.isNullOrUndef(at)) {
	      at = +at;
	    }
	    if (at > this.length) {
	      at = this.length;
	    }
	    if (at < 0) {
	      at += this.length + 1;
	    }
	    Debug.log(`Collection - set - 1 - at: ${at}; models.length: ${models.length}`);
	    const set = [];
	    const toAdd = [];
	    const toMerge = [];
	    const toRemove = [];
	    const modelMap = {};
	    const add = options.add;
	    const merge = options.merge;
	    const remove = options.remove;
	    let sort = false;
	    const sortable = this.comparator && Utils.isNullOrUndef(at) && options.sort !== false;
	    const sortAttr = lodash.isString(this.comparator) ? this.comparator : null;
	    let model;
	    for (let i = 0; i < models.length; i++) {
	      model = models[i];
	      const existing = this.get(model);
	      if (existing) {
	        Debug.log(`Collection - set - 2 - existing`);
	        if (merge && model !== existing) {
	          Debug.log(`Collection - set - 3 - merge && model !== existing`);
	          let attrs = Utils.isModel(model) ? model.attributes : model;
	          if (options.parse) {
	            attrs = existing.parse(attrs, options);
	          }
	          existing.set(attrs, options);
	          toMerge.push(existing);
	          if (sortable && !sort) {
	            sort = existing.hasChanged(sortAttr);
	          }
	        }
	        if (!modelMap[existing.cid]) {
	          Debug.log(`Collection - set - 4 - !modelMap[existing.cid]`);
	          modelMap[existing.cid] = true;
	          set.push(existing);
	        }
	        models[i] = existing;
	      } else if (add) {
	        Debug.log(`Collection - set - 5 - add`);
	        model = models[i] = this._prepareModel(model, options);
	        if (model) {
	          Debug.log(`Collection - set - 6 - toAdd`);
	          toAdd.push(model);
	          s_ADD_REFERENCE(this, model);
	          modelMap[model.cid] = true;
	          set.push(model);
	        }
	      }
	    }
	    if (remove) {
	      for (let i = 0; i < this.length; i++) {
	        model = this.models[i];
	        if (!modelMap[model.cid]) {
	          Debug.log(`Collection - set - 7 - toRemove push`);
	          toRemove.push(model);
	        }
	      }
	      if (toRemove.length) {
	        Debug.log(`Collection - set - 8 - before invoking s_REMOVE_MODELS`);
	        s_REMOVE_MODELS(this, toRemove, options);
	      }
	    }
	    let orderChanged = false;
	    const replace = !sortable && add && remove;
	    if (set.length && replace) {
	      orderChanged = this.length !== set.length || lodash.some(this.models, (m, index) => {
	        return m !== set[index];
	      });
	      Debug.log(`Collection - set - 9 - set.length > 0 && replace - orderChanged: ${orderChanged}`);
	      this.models.length = 0;
	      s_SPLICE(this.models, set, 0);
	      this.length = this.models.length;
	    } else if (toAdd.length) {
	      if (sortable) {
	        sort = true;
	      }
	      Debug.log(`Collection - set - 10 - toAdd.length > 0 - sort: ${sort}; at: ${at}`);
	      s_SPLICE(this.models, toAdd, Utils.isNullOrUndef(at) ? this.length : at);
	      this.length = this.models.length;
	    }
	    if (sort) {
	      Debug.log(`Collection - set - 11 - sorting silent`);
	      this.sort({
	        silent: true
	      });
	    }
	    if (!options.silent) {
	      Debug.log(`Collection - set - 12 - !options.silent: ${!options.silent}`);
	      for (let i = 0; i < toAdd.length; i++) {
	        if (!Utils.isNullOrUndef(at)) {
	          options.index = at + i;
	        }
	        model = toAdd[i];
	        model.trigger("add", model, this, options);
	      }
	      if (sort || orderChanged) {
	        this.trigger("sort", this, options);
	      }
	      if (toAdd.length || toRemove.length || toMerge.length) {
	        options.changes = {
	          added: toAdd,
	          removed: toRemove,
	          merged: toMerge
	        };
	        this.trigger("update", this, options);
	      }
	    }
	    return singular ? models[0] : models;
	  }
	  shift(options) {
	    const model = this.at(0);
	    return this.remove(model, options);
	  }
	  slice() {
	    return Array.prototype.slice.apply(this.models, arguments);
	  }
	  sort(options = {}) {
	    let comparator = this.comparator;
	    if (!comparator) {
	      throw new Error("Cannot sort a set without a comparator");
	    }
	    const length = comparator.length;
	    if (lodash.isFunction(comparator)) {
	      comparator = lodash.bind(comparator, this);
	    }
	    if (length === 1 || lodash.isString(comparator)) {
	      this.models = this.sortBy(comparator);
	    } else {
	      this.models.sort(comparator);
	    }
	    if (!options.silent) {
	      this.trigger("sort", this, options);
	    }
	    return this;
	  }
	  sync() {
	    Debug.log("Collection - sync", true);
	    return BackboneProxy.backbone.sync.apply(this, arguments);
	  }
	  toJSON(options) {
	    return this.map(model => {
	      return model.toJSON(options);
	    });
	  }
	  unshift(model, options) {
	    return this.add(model, lodash.extend({
	      at: 0
	    }, options));
	  }
	  where(attrs, first) {
	    return this[first ? "find" : "filter"](attrs);
	  }
	}
	const collectionMethods = {
	  forEach: 3,
	  each: 3,
	  map: 3,
	  collect: 3,
	  reduce: 0,
	  foldl: 0,
	  inject: 0,
	  reduceRight: 0,
	  foldr: 0,
	  find: 3,
	  detect: 3,
	  filter: 3,
	  select: 3,
	  reject: 3,
	  every: 3,
	  all: 3,
	  some: 3,
	  any: 3,
	  include: 3,
	  includes: 3,
	  contains: 3,
	  invoke: 0,
	  max: 3,
	  min: 3,
	  toArray: 1,
	  size: 1,
	  first: 3,
	  head: 3,
	  take: 3,
	  initial: 3,
	  rest: 3,
	  tail: 3,
	  drop: 3,
	  last: 3,
	  without: 0,
	  difference: 0,
	  indexOf: 3,
	  shuffle: 1,
	  lastIndexOf: 3,
	  isEmpty: 1,
	  chain: 1,
	  sample: 3,
	  partition: 3,
	  groupBy: 3,
	  countBy: 3,
	  sortBy: 3,
	  indexBy: 3,
	  findIndex: 3,
	  findLastIndex: 3
	};
	Utils.addUnderscoreMethods(Collection, collectionMethods, "models");
	const s_ADD_OPTIONS = {
	  add: true,
	  remove: false
	};
	const s_SET_OPTIONS = {
	  add: true,
	  remove: true,
	  merge: true
	};
	const s_ADD_REFERENCE = (collection, model) => {
	  collection._byId[model.cid] = model;
	  const id = collection.modelId(model.attributes);
	  Debug.log(`Collection - s_ADD_REFERENCE - id: ${id}; model.cid: ${model.cid}`, true);
	  if (!Utils.isNullOrUndef(id)) {
	    collection._byId[id] = model;
	  }
	  model.on("all", s_ON_MODEL_EVENT, collection);
	};
	const s_ON_MODEL_EVENT = function (event, model, collection, options) {
	  if (model) {
	    Debug.log(`Collection - s_ON_MODEL_EVENT - 0 - event: ${event}`, true);
	    if ((event === "add" || event === "remove") && collection !== this) {
	      return;
	    }
	    if (event === "destroy") {
	      this.remove(model, options);
	    }
	    if (event === "change") {
	      const prevId = this.modelId(model.previousAttributes());
	      const id = this.modelId(model.attributes);
	      Debug.log(`Collection - s_ON_MODEL_EVENT - 1 - change - id: ${id}; prevId: ${prevId}`);
	      if (prevId !== id) {
	        if (!Utils.isNullOrUndef(prevId)) {
	          delete this._byId[prevId];
	        }
	        if (!Utils.isNullOrUndef(id)) {
	          this._byId[id] = model;
	        }
	      }
	    }
	    this.trigger(...arguments);
	  }
	};
	const s_REMOVE_MODELS = (collection, models, options) => {
	  const removed = [];
	  for (let i = 0; i < models.length; i++) {
	    const model = collection.get(models[i]);
	    Debug.log(`Collection - s_REMOVE_MODELS - 0 - model: ${model}`, true);
	    if (!model) {
	      continue;
	    }
	    Debug.log(`Collection - s_REMOVE_MODELS - 1 - model: ${model.toJSON()}`);
	    const index = collection.indexOf(model);
	    Debug.log(`Collection - s_REMOVE_MODELS - 2 - index: ${index}`);
	    collection.models.splice(index, 1);
	    collection.length--;
	    delete collection._byId[model.cid];
	    const id = collection.modelId(model.attributes);
	    if (!Utils.isNullOrUndef(id)) {
	      delete collection._byId[id];
	    }
	    if (!options.silent) {
	      options.index = index;
	      model.trigger("remove", model, collection, options);
	    }
	    removed.push(model);
	    s_REMOVE_REFERENCE(collection, model);
	  }
	  return removed;
	};
	const s_REMOVE_REFERENCE = (collection, model) => {
	  delete collection._byId[model.cid];
	  const id = collection.modelId(model.attributes);
	  Debug.log(`Collection - s_REMOVE_REFERENCE - id: ${id}; model.cid: ${model.cid}`);
	  if (!Utils.isNullOrUndef(id)) {
	    delete collection._byId[id];
	  }
	  if (collection === model.collection) {
	    delete model.collection;
	  }
	  model.off("all", s_ON_MODEL_EVENT, collection);
	};
	const s_SPLICE = (array, insert, at) => {
	  at = Math.min(Math.max(at, 0), array.length);
	  const tail = new Array(array.length - at);
	  const length = insert.length;
	  for (let i = 0; i < tail.length; i++) {
	    tail[i] = array[i + at];
	  }
	  for (let i = 0; i < length; i++) {
	    array[i + at] = insert[i];
	  }
	  for (let i = 0; i < tail.length; i++) {
	    array[i + length + at] = tail[i];
	  }
	};

	/**
	 * Backbone.History - History serves as a global router. (http://backbonejs.org/#History)
	 * ----------------
	 *
	 * History serves as a global router (per frame) to handle hashchange events or pushState, match the appropriate route,
	 * and trigger callbacks. You shouldn't ever have to create one of these yourself since Backbone.history already
	 * contains one.
	 *
	 * pushState support exists on a purely opt-in basis in Backbone. Older browsers that don't support pushState will
	 * continue to use hash-based URL fragments, and if a hash URL is visited by a pushState-capable browser, it will be
	 * transparently upgraded to the true URL. Note that using real URLs requires your web server to be able to correctly
	 * render those pages, so back-end changes are required as well. For example, if you have a route of /documents/100,
	 * your web server must be able to serve that page, if the browser visits that URL directly. For full search-engine
	 * crawlability, it's best to have the server generate the complete HTML for the page ... but if it's a web application,
	 * just rendering the same content you would have for the root URL, and filling in the rest with Backbone Views and
	 * JavaScript works fine.
	 *
	 * Handles cross-browser history management, based on either [pushState](http://diveintohtml5.info/history.html) and
	 * real URLs, or [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange) and URL fragments.
	 * If the browser supports neither (old IE, natch), falls back to polling.
	 */
	class History extends Events
	{
	   /** */
	   constructor()
	   {
	      super();

	      /**
	       * Stores route / callback pairs for validation.
	       * @type {Array<Object<string, function>>}
	       */
	      this.handlers = [];
	      this.checkUrl = lodash.bind(this.checkUrl, this);

	      // Ensure that `History` can be used outside of the browser.
	      if (typeof window !== 'undefined')
	      {
	         /**
	          * Browser Location or URL string.
	          * @type {Location|String}
	          */
	         this.location = window.location;

	         /**
	          * Browser history
	          * @type {History}
	          */
	         this.history = window.history;
	      }

	      /**
	       * Has the history handling already been started?
	       * @type {boolean}
	       */
	      this.started = false;

	      /**
	       * The default interval to poll for hash changes, if necessary, is twenty times a second.
	       * @type {number}
	       */
	      this.interval = 50;
	   }

	   /**
	    * Are we at the app root?
	    *
	    * @returns {boolean}
	    */
	   atRoot()
	   {
	      const path = this.location.pathname.replace(/[^\/]$/, '$&/');
	      return path === this.root && !this.getSearch();
	   }

	   /**
	    * Checks the current URL to see if it has changed, and if it has, calls `loadUrl`, normalizing across the
	    * hidden iframe.
	    *
	    * @returns {boolean}
	    */
	   checkUrl()
	   {
	      let current = this.getFragment();

	      // If the user pressed the back button, the iframe's hash will have changed and we should use that for comparison.
	      if (current === this.fragment && this.iframe)
	      {
	         current = this.getHash(this.iframe.contentWindow);
	      }

	      if (current === this.fragment) { return false; }
	      if (this.iframe) { this.navigate(current); }
	      this.loadUrl();
	   }

	   /**
	    * Unicode characters in `location.pathname` are percent encoded so they're decoded for comparison. `%25` should
	    * not be decoded since it may be part of an encoded parameter.
	    *
	    * @param {string}   fragment - URL fragment
	    * @return {string}
	    */
	   decodeFragment(fragment)
	   {
	      return decodeURI(fragment.replace(/%25/g, '%2525'));
	   }

	   /**
	    * Get the cross-browser normalized URL fragment from the path or hash.
	    *
	    * @param {string} fragment   -- URL fragment
	    * @returns {*|void|string|XML}
	    */
	   getFragment(fragment)
	   {
	      if (Utils.isNullOrUndef(fragment))
	      {
	         if (this._usePushState || !this._wantsHashChange)
	         {
	            fragment = this.getPath();
	         }
	         else
	         {
	            fragment = this.getHash();
	         }
	      }
	      return fragment.replace(s_ROUTE_STRIPPER, '');
	   }

	   /**
	    * Gets the true hash value. Cannot use location.hash directly due to bug in Firefox where location.hash will
	    * always be decoded.
	    *
	    * @param {object}   window   - Browser `window`
	    * @returns {*}
	    */
	   getHash(window)
	   {
	      const match = (window || this).location.href.match(/#(.*)$/);
	      return match ? match[1] : '';
	   }

	   /**
	    * Get the pathname and search params, without the root.
	    *
	    * @returns {*}
	    */
	   getPath()
	   {
	      const path = this.decodeFragment(this.location.pathname + this.getSearch()).slice(this.root.length - 1);
	      return path.charAt(0) === '/' ? path.slice(1) : path;
	   }

	   /**
	    * In IE6, the hash fragment and search params are incorrect if the fragment contains `?`.
	    *
	    * @returns {string}
	    */
	   getSearch()
	   {
	      const match = this.location.href.replace(/#.*/, '').match(/\?.+/);
	      return match ? match[0] : '';
	   }

	   /**
	    * Attempt to load the current URL fragment. If a route succeeds with a match, returns `true`. If no defined routes
	    * matches the fragment, returns `false`.
	    *
	    * @param {string}   fragment - URL fragment
	    * @returns {boolean}
	    */
	   loadUrl(fragment)
	   {
	      // If the root doesn't match, no routes can match either.
	      if (!this.matchRoot()) { return false; }
	      fragment = this.fragment = this.getFragment(fragment);
	      return lodash.some(this.handlers, (handler) =>
	      {
	         if (handler.route.test(fragment))
	         {
	            handler.callback(fragment);
	            return true;
	         }
	      });
	   }

	   /**
	    * Does the pathname match the root?
	    *
	    * @returns {boolean}
	    */
	   matchRoot()
	   {
	      const path = this.decodeFragment(this.location.pathname);
	      const rootPath = `${path.slice(0, this.root.length - 1)}/`;
	      return rootPath === this.root;
	   }

	   /**
	    * Save a fragment into the hash history, or replace the URL state if the 'replace' option is passed. You are
	    * responsible for properly URL-encoding the fragment in advance.
	    *
	    * The options object can contain `trigger: true` if you wish to have the route callback be fired (not usually
	    * desirable), or `replace: true`, if you wish to modify the current URL without adding an entry to the history.
	    *
	    * @param {string}   fragment - String representing an URL fragment.
	    * @param {object}   options - Optional hash containing parameters for navigate.
	    * @returns {*}
	    */
	   navigate(fragment, options)
	   {
	      if (!History.started) { return false; }
	      if (!options || options === true) { options = { trigger: !!options }; }

	      // Normalize the fragment.
	      fragment = this.getFragment(fragment || '');

	      // Don't include a trailing slash on the root.
	      let rootPath = this.root;

	      if (fragment === '' || fragment.charAt(0) === '?')
	      {
	         rootPath = rootPath.slice(0, -1) || '/';
	      }

	      const url = rootPath + fragment;

	      // Strip the hash and decode for matching.
	      fragment = this.decodeFragment(fragment.replace(s_PATH_STRIPPER, ''));

	      if (this.fragment === fragment) { return; }

	      /**
	       * URL fragment
	       * @type {*|void|string|XML}
	       */
	      this.fragment = fragment;

	      // If pushState is available, we use it to set the fragment as a real URL.
	      if (this._usePushState)
	      {
	         this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

	         // If hash changes haven't been explicitly disabled, update the hash fragment to store history.
	      }
	      else if (this._wantsHashChange)
	      {
	         s_UPDATE_HASH(this.location, fragment, options.replace);

	         if (this.iframe && fragment !== this.getHash(this.iframe.contentWindow))
	         {
	            const iWindow = this.iframe.contentWindow;

	            // Opening and closing the iframe tricks IE7 and earlier to push a history
	            // entry on hash-tag change.  When replace is true, we don't want this.
	            if (!options.replace)
	            {
	               iWindow.document.open();
	               iWindow.document.close();
	            }

	            s_UPDATE_HASH(iWindow.location, fragment, options.replace);
	         }

	         // If you've told us that you explicitly don't want fallback hashchange-
	         // based history, then `navigate` becomes a page refresh.
	      }
	      else
	      {
	         return this.location.assign(url);
	      }

	      if (options.trigger) { return this.loadUrl(fragment); }
	   }

	   /**
	    * When all of your Routers have been created, and all of the routes are set up properly, call
	    * Backbone.history.start() to begin monitoring hashchange events, and dispatching routes. Subsequent calls to
	    * Backbone.history.start() will throw an error, and Backbone.History.started is a boolean value indicating whether
	    * it has already been called.
	    *
	    * To indicate that you'd like to use HTML5 pushState support in your application, use
	    * Backbone.history.start({pushState: true}). If you'd like to use pushState, but have browsers that don't support
	    * it natively use full page refreshes instead, you can add {hashChange: false} to the options.
	    *
	    * If your application is not being served from the root url / of your domain, be sure to tell History where the
	    * root really is, as an option: Backbone.history.start({pushState: true, root: "/public/search/"})
	    *
	    * When called, if a route succeeds with a match for the current URL, Backbone.history.start() returns true. If no
	    * defined route matches the current URL, it returns false.
	    *
	    * If the server has already rendered the entire page, and you don't want the initial route to trigger when starting
	    * History, pass silent: true.
	    *
	    * Because hash-based history in Internet Explorer relies on an <iframe>, be sure to call start() only after the DOM
	    * is ready.
	    *
	    * @example
	    * import WorkspaceRouter from 'WorkspaceRouter.js';
	    * import HelpPaneRouter  from 'HelpPaneRouter.js';
	    *
	    * new WorkspaceRouter();
	    * new HelpPaneRouter();
	    * Backbone.history.start({pushState: true});
	    *
	    * @param {object}   options  - Optional parameters
	    * @returns {*}
	    */
	   start(options)
	   {
	      if (History.started) { throw new Error('Backbone.history has already been started'); }

	      History.started = true;

	      /**
	       * Figure out the initial configuration. Do we need an iframe?
	       * @type {Object}
	       */
	      this.options = lodash.extend({ root: '/' }, this.options, options);

	      /**
	       * URL root
	       * @type {string}
	       */
	      this.root = this.options.root;

	      this._wantsHashChange = this.options.hashChange !== false;
	      this._hasHashChange = 'onhashchange' in window && (document.documentMode === void 0 || document.documentMode > 7);
	      this._useHashChange = this._wantsHashChange && this._hasHashChange;

	      // Is pushState desired ... is it available?
	      this._wantsPushState = !!this.options.pushState;
	      this._hasPushState = !!(this.history && this.history.pushState);
	      this._usePushState = this._wantsPushState && this._hasPushState;

	      this.fragment = this.getFragment();

	      // Normalize root to always include a leading and trailing slash.
	      this.root = (`/${this.root}/`).replace(s_ROOT_STRIPPER, '/');

	      // Transition from hashChange to pushState or vice versa if both are requested.
	      if (this._wantsHashChange && this._wantsPushState)
	      {

	         // If we've started off with a route from a `pushState`-enabled
	         // browser, but we're currently in a browser that doesn't support it...
	         if (!this._hasPushState && !this.atRoot())
	         {
	            const rootPath = this.root.slice(0, -1) || '/';
	            this.location.replace(`${rootPath}#${this.getPath()}`);

	            // Return immediately as browser will do redirect to new url
	            return true;

	            // Or if we've started out with a hash-based route, but we're currently
	            // in a browser where it could be `pushState`-based instead...
	         }
	         else if (this._hasPushState && this.atRoot())
	         {
	            this.navigate(this.getHash(), { replace: true });
	         }
	      }

	      // Proxy an iframe to handle location events if the browser doesn't support the `hashchange` event, HTML5
	      // history, or the user wants `hashChange` but not `pushState`.
	      if (!this._hasHashChange && this._wantsHashChange && !this._usePushState)
	      {
	         /**
	          * Proxy iframe
	          * @type {Element}
	          */
	         this.iframe = document.createElement('iframe');
	         this.iframe.src = 'javascript:0';
	         this.iframe.style.display = 'none';
	         this.iframe.tabIndex = -1;

	         const body = document.body;

	         // Using `appendChild` will throw on IE < 9 if the document is not ready.
	         const iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;
	         iWindow.document.open();
	         iWindow.document.close();
	         iWindow.location.hash = `#${this.fragment}`;
	      }

	      // Add a cross-platform `addEventListener` shim for older browsers.
	      const addEventListener = window.addEventListener || function(eventName, listener)
	      {
	         /* eslint-disable no-undef */
	         return attachEvent(`on${eventName}`, listener);
	         /* eslint-enable no-undef */
	      };

	      // Depending on whether we're using pushState or hashes, and whether
	      // 'onhashchange' is supported, determine how we check the URL state.
	      if (this._usePushState)
	      {
	         addEventListener('popstate', this.checkUrl, false);
	      }
	      else if (this._useHashChange && !this.iframe)
	      {
	         addEventListener('hashchange', this.checkUrl, false);
	      }
	      else if (this._wantsHashChange)
	      {
	         this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
	      }

	      if (!this.options.silent) { return this.loadUrl(); }
	   }

	   /**
	    * Disable Backbone.history, perhaps temporarily. Not useful in a real app, but possibly useful for unit
	    * testing Routers.
	    */
	   stop()
	   {
	      // Add a cross-platform `removeEventListener` shim for older browsers.
	      const removeEventListener = window.removeEventListener || function(eventName, listener)
	      {
	         /* eslint-disable no-undef */
	         return detachEvent(`on${eventName}`, listener);
	         /* eslint-enable no-undef */
	      };

	      // Remove window listeners.
	      if (this._usePushState)
	      {
	         removeEventListener('popstate', this.checkUrl, false);
	      }
	      else if (this._useHashChange && !this.iframe)
	      {
	         removeEventListener('hashchange', this.checkUrl, false);
	      }

	      // Clean up the iframe if necessary.
	      if (this.iframe)
	      {
	         document.body.removeChild(this.iframe);
	         this.iframe = null;
	      }

	      // Some environments will throw when clearing an undefined interval.
	      if (this._checkUrlInterval) { clearInterval(this._checkUrlInterval); }
	      History.started = false;
	   }

	   /**
	    * Add a route to be tested when the fragment changes. Routes added later may override previous routes.
	    *
	    * @param {string}   route    -  Route to add for checking.
	    * @param {function} callback -  Callback function to invoke on match.
	    */
	   route(route, callback)
	   {
	      this.handlers.unshift({ route, callback });
	   }
	}

	// Private / internal methods ---------------------------------------------------------------------------------------

	/**
	 * Cached regex for stripping a leading hash/slash and trailing space.
	 */
	const s_ROUTE_STRIPPER = /^[#\/]|\s+$/g;

	/**
	 * Cached regex for stripping leading and trailing slashes.
	 */
	const s_ROOT_STRIPPER = /^\/+|\/+$/g;

	/**
	 * Cached regex for stripping urls of hash.
	 */
	const s_PATH_STRIPPER = /#.*$/;

	/**
	 * Update the hash location, either replacing the current entry, or adding a new one to the browser history.
	 *
	 * @param {object}   location - URL / current location
	 * @param {string}   fragment - URL fragment
	 * @param {boolean}  replace  - conditional replace
	 */
	const s_UPDATE_HASH = (location, fragment, replace) =>
	{
	   if (replace)
	   {
	      const href = location.href.replace(/(javascript:|#).*$/, '');
	      location.replace(`${href}#${fragment}`);
	   }
	   else
	   {
	      // Some browsers require that `hash` contains a leading #.
	      location.hash = `#${fragment}`;
	   }
	};

	class Router extends Events {
	  constructor(options = {}) {
	    super();
	    const hasRoutesGetter = !lodash.isUndefined(this.routes);
	    if (!hasRoutesGetter && options.routes) {
	      this.routes = options.routes;
	    }
	    s_BIND_ROUTES(this);
	    this.initialize(...arguments);
	  }
	  execute(callback, args, name) {
	    if (callback) {
	      callback.apply(this, args);
	    }
	  }
	  initialize() {}
	  navigate(fragment, options) {
	    BackboneProxy.backbone.history.navigate(fragment, options);
	    return this;
	  }
	  route(route, name, callback) {
	    if (!lodash.isRegExp(route)) {
	      route = s_ROUTE_TO_REGEX(route);
	    }
	    if (lodash.isFunction(name)) {
	      callback = name;
	      name = "";
	    }
	    if (!callback) {
	      callback = this[name];
	    }
	    BackboneProxy.backbone.history.route(route, fragment => {
	      const args = s_EXTRACT_PARAMETERS(route, fragment);
	      if (this.execute(callback, args, name) !== false) {
	        this.trigger(...[`route:${name}`].concat(args));
	        this.trigger("route", name, args);
	        BackboneProxy.backbone.history.trigger("route", this, name, args);
	      }
	    });
	    return this;
	  }
	}
	const s_ESCAPE_REGEX = /[\-{}\[\]+?.,\\\^$|#\s]/g;
	const s_NAMED_PARAM = /(\(\?)?:\w+/g;
	const s_OPTIONAL_PARAM = /\((.*?)\)/g;
	const s_SPLAT_PARAM = /\*\w+/g;
	const s_BIND_ROUTES = router => {
	  if (!router.routes) {
	    return;
	  }
	  router.routes = lodash.result(router, "routes");
	  lodash.each(lodash.keys(router.routes), route => {
	    router.route(route, router.routes[route]);
	  });
	};
	const s_EXTRACT_PARAMETERS = (route, fragment) => {
	  const params = route.exec(fragment).slice(1);
	  return lodash.map(params, (param, i) => {
	    if (i === params.length - 1) {
	      return param || null;
	    }
	    return param ? decodeURIComponent(param) : null;
	  });
	};
	const s_ROUTE_TO_REGEX = route => {
	  route = route.replace(s_ESCAPE_REGEX, "\\$&").replace(s_OPTIONAL_PARAM, "(?:$1)?").replace(s_NAMED_PARAM, (match, optional) => {
	    return optional ? match : "([^/?]+)";
	  }).replace(s_SPLAT_PARAM, "([^?]*?)");
	  return new RegExp(`^${route}(?:\\?([\\s\\S]*))?$`);
	};

	class View extends Events {
	  get tagName() {
	    return "div";
	  }
	  constructor(options) {
	    super();
	    this.cid = lodash.uniqueId("view");
	    lodash.extend(this, lodash.pick(options, s_VIEW_OPTIONS));
	    this._ensureElement();
	    this.initialize(...arguments);
	  }
	  $(selector) {
	    return this.$el.find(selector);
	  }
	  _createElement(tagName) {
	    return document.createElement(tagName);
	  }
	  delegate(eventName, selector, listener) {
	    this.$el.on(`${eventName}.delegateEvents${this.cid}`, selector, listener);
	    return this;
	  }
	  delegateEvents(events) {
	    events = events || lodash.result(this, "events");
	    if (!events) {
	      return this;
	    }
	    this.undelegateEvents();
	    for (const key in events) {
	      let method = events[key];
	      if (!lodash.isFunction(method)) {
	        method = this[method];
	      }
	      if (!method) {
	        continue;
	      }
	      const match = key.match(s_DELEGATE_EVENT_SPLITTER);
	      this.delegate(match[1], match[2], lodash.bind(method, this));
	    }
	    return this;
	  }
	  _ensureElement() {
	    if (!this.el) {
	      const attrs = lodash.extend({}, lodash.result(this, "attributes"));
	      if (this.id) {
	        attrs.id = lodash.result(this, "id");
	      }
	      if (this.className) {
	        attrs["class"] = lodash.result(this, "className");
	      }
	      this.setElement(this._createElement(lodash.result(this, "tagName")));
	      this._setAttributes(attrs);
	    } else {
	      this.setElement(lodash.result(this, "el"));
	    }
	  }
	  initialize() {}
	  remove() {
	    this._removeElement();
	    this.stopListening();
	    return this;
	  }
	  _removeElement() {
	    this.$el.remove();
	  }
	  render() {
	    return this;
	  }
	  _setAttributes(attributes) {
	    this.$el.attr(attributes);
	  }
	  _setElement(el) {
	    this.$el = el instanceof BackboneProxy.backbone.$ ? el : BackboneProxy.backbone.$(el);
	    this.el = this.$el[0];
	  }
	  setElement(element) {
	    this.undelegateEvents();
	    this._setElement(element);
	    this.delegateEvents();
	    return this;
	  }
	  undelegate(eventName, selector, listener) {
	    this.$el.off(`${eventName}.delegateEvents${this.cid}`, selector, listener);
	    return this;
	  }
	  undelegateEvents() {
	    if (this.$el) {
	      this.$el.off(`.delegateEvents${this.cid}`);
	    }
	    return this;
	  }
	}
	const s_DELEGATE_EVENT_SPLITTER = /^(\S+)\s*(.*)$/;
	const s_VIEW_OPTIONS = ["model", "collection", "el", "id", "attributes", "className", "tagName", "events"];

	/**
	 * Provides older "extend" functionality for Backbone. While it is still accessible it is recommended
	 * to adopt the new Backbone-ES6 patterns and ES6 sub-classing via "extends".
	 *
	 * Helper function to correctly set up the prototype chain for subclasses. Similar to `goog.inherits`, but uses a hash
	 * of prototype properties and class properties to be extended.
	 *
	 * @see http://backbonejs.org/#Collection-extend
	 * @see http://backbonejs.org/#Model-extend
	 * @see http://backbonejs.org/#Router-extend
	 * @see http://backbonejs.org/#View-extend
	 *
	 * @param {object}   protoProps  - instance properties
	 * @param {object}   staticProps - class properties
	 * @returns {*}      Subclass of parent class.
	 */
	function extend(protoProps, staticProps)
	{
	   const parent = this;
	   let child;

	   // The constructor function for the new subclass is either defined by you (the "constructor" property in your
	   // `extend` definition), or defaulted by us to simply call the parent constructor.
	   if (protoProps && lodash.has(protoProps, 'constructor'))
	   {
	      child = protoProps.constructor;
	   }
	   else
	   {
	      child = function()
	      {
	         return parent.apply(this, arguments);
	      };
	   }

	   // Add static properties to the constructor function, if supplied.
	   lodash.extend(child, parent, staticProps);

	   // Set the prototype chain to inherit from `parent`, without calling
	   // `parent`'s constructor function and add the prototype properties.
	   child.prototype = lodash.create(parent.prototype, protoProps);
	   child.prototype.constructor = child;

	   // backbone-es6 addition: Because View defines a getter for tagName we must actually redefine this getter
	   // from the `protoProps.tagName` if it exists.
	   if (protoProps && protoProps.tagName)
	   {
	      Object.defineProperty(child.prototype, 'tagName', { get: () => { return protoProps.tagName; } });
	   }

	   // Set a convenience property in case the parent's prototype is needed later.
	   child.__super__ = parent.prototype;

	   return child;
	}

	/**
	 * Map from CRUD to HTTP for our default `Backbone.sync` implementation.
	 * @type {{create: string, update: string, patch: string, delete: string, read: string}}
	 */
	const s_METHOD_MAP =
	{
	   'create': 'POST',
	   'update': 'PUT',
	   'patch': 'PATCH',
	   'delete': 'DELETE',
	   'read': 'GET'
	};

	/**
	 * Backbone.sync - Persists models to the server. (http://backbonejs.org/#Sync)
	 * -------------
	 *
	 * Override this function to change the manner in which Backbone persists models to the server. You will be passed the
	 * type of request, and the model in question. By default, makes a RESTful Ajax request to the model's `url()`. Some
	 * possible customizations could be:
	 *
	 * Use `setTimeout` to batch rapid-fire updates into a single request.
	 * Send up the models as XML instead of JSON.
	 * Persist models via WebSockets instead of Ajax.
	 *
	 * Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests as `POST`, with a `_method` parameter
	 * containing the true HTTP method, as well as all requests with the body as `application/x-www-form-urlencoded`
	 * instead of `application/json` with the model in a param named `model`. Useful when interfacing with server-side
	 * languages like **PHP** that make it difficult to read the body of `PUT` requests.
	 *
	 * @param {string}            method   - A string that defines the synchronization action to perform.
	 * @param {Model|Collection}  model    - The model or collection instance to synchronize.
	 * @param {object}            options  - Optional parameters
	 * @returns {XMLHttpRequest}  An XMLHttpRequest
	 */
	function sync(method, model, options = {})
	{
	   const type = s_METHOD_MAP[method];

	   // Default options, unless specified.
	   lodash.defaults(options,
	   {
	      emulateHTTP: BackboneProxy.backbone.emulateHTTP,
	      emulateJSON: BackboneProxy.backbone.emulateJSON
	   });

	   // Default JSON-request options.
	   const params = { type, dataType: 'json' };

	   // Ensure that we have a URL.
	   if (!options.url)
	   {
	      params.url = lodash.result(model, 'url') || Utils.urlError();
	   }

	   // Ensure that we have the appropriate request data.
	   if (Utils.isNullOrUndef(options.data) && model && (method === 'create' || method === 'update' || method === 'patch'))
	   {
	      params.contentType = 'application/json';
	      params.data = JSON.stringify(options.attrs || model.toJSON(options));
	   }

	   // For older servers, emulate JSON by encoding the request into an HTML-form.
	   if (options.emulateJSON)
	   {
	      params.contentType = 'application/x-www-form-urlencoded';
	      params.data = params.data ? { model: params.data } : {};
	   }

	   // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
	   // And an `X-HTTP-Method-Override` header.
	   if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH'))
	   {
	      params.type = 'POST';

	      if (options.emulateJSON) { params.data._method = type; }

	      const beforeSend = options.beforeSend;

	      options.beforeSend = function(xhr)
	      {
	         xhr.setRequestHeader('X-HTTP-Method-Override', type);
	         if (beforeSend) { return beforeSend.apply(this, arguments); }
	      };
	   }

	   // Don't process data on a non-GET request.
	   if (params.type !== 'GET' && !options.emulateJSON)
	   {
	      params.processData = false;
	   }

	   // Pass along `textStatus` and `errorThrown` from jQuery.
	   const error = options.error;

	   options.error = function(xhr, textStatus, errorThrown)
	   {
	      options.textStatus = textStatus;
	      options.errorThrown = errorThrown;
	      if (error) { error.call(options.context, xhr, textStatus, errorThrown); }
	   };

	   // Make the request, allowing the user to override any Ajax options.
	   const xhr = options.xhr = BackboneProxy.backbone.ajax(lodash.extend(params, options));

	   model.trigger('request', model, xhr, options);

	   return xhr;
	}

	/**
	 * ModuleRuntime.js -- Provides the standard / default configuration that is the same as Backbone 1.2.3
	 */

	const options =
	{
	   // Current version of the library. Keep in sync with Backbone version supported.
	   VERSION: '1.3.3',

	   // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option will fake `"PATCH"`, `"PUT"` and
	   // `"DELETE"` requests via the `_method` parameter and set a `X-Http-Method-Override` header.
	   emulateHTTP: false,

	   // Turn on `emulateJSON` to support legacy servers that can't deal with direct `application/json` requests ... this
	   // will encode the body as `application/x-www-form-urlencoded` instead and will send the model in a form param
	   // named `model`.
	   emulateJSON: false
	};

	const backbone = new Backbone(Collection, Events, History, Model, Router, View, sync, options);

	// Set up older extends inheritance support for the model, collection, router, view and history.
	backbone.Model.extend = backbone.Collection.extend = backbone.Router.extend = backbone.View.extend =
	 backbone.History.extend = extend;

	var punycode = require("punycode");
	var util$1 = require("./util");
	exports.parse = urlParse;
	exports.resolve = urlResolve;
	exports.resolveObject = urlResolveObject;
	exports.format = urlFormat;
	exports.Url = Url;
	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}
	var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", "\"", "`", " ", "\r", "\n", "\t"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
	  "javascript": true,
	  "javascript:": true
	}, hostlessProtocol = {
	  "javascript": true,
	  "javascript:": true
	}, slashedProtocol = {
	  "http": true,
	  "https": true,
	  "ftp": true,
	  "gopher": true,
	  "file": true,
	  "http:": true,
	  "https:": true,
	  "ftp:": true,
	  "gopher:": true,
	  "file:": true
	}, querystring = require("querystring");
	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && util$1.isObject(url) && url instanceof Url) return url;
	  var u = new Url();
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}
	Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
	  if (!util$1.isString(url)) {
	    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
	  }
	  var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
	  uSplit[0] = uSplit[0].replace(slashRegex, "/");
	  url = uSplit.join(splitter);
	  var rest = url;
	  rest = rest.trim();
	  if (!slashesDenoteHost && url.split("#").length === 1) {
	    var simplePath = simplePathPattern.exec(rest);
	    if (simplePath) {
	      this.path = rest;
	      this.href = rest;
	      this.pathname = simplePath[1];
	      if (simplePath[2]) {
	        this.search = simplePath[2];
	        if (parseQueryString) {
	          this.query = querystring.parse(this.search.substr(1));
	        } else {
	          this.query = this.search.substr(1);
	        }
	      } else if (parseQueryString) {
	        this.search = "";
	        this.query = {};
	      }
	      return this;
	    }
	  }
	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    var slashes = rest.substr(0, 2) === "//";
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }
	  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
	    }
	    var auth, atSign;
	    if (hostEnd === -1) {
	      atSign = rest.lastIndexOf("@");
	    } else {
	      atSign = rest.lastIndexOf("@", hostEnd);
	    }
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
	    }
	    if (hostEnd === -1) hostEnd = rest.length;
	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);
	    this.parseHost();
	    this.hostname = this.hostname || "";
	    var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) continue;
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = "";
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              newpart += "x";
	            } else {
	              newpart += part[j];
	            }
	          }
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = "/" + notHost.join(".") + rest;
	            }
	            this.hostname = validParts.join(".");
	            break;
	          }
	        }
	      }
	    }
	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = "";
	    } else {
	      this.hostname = this.hostname.toLowerCase();
	    }
	    if (!ipv6Hostname) {
	      this.hostname = punycode.toASCII(this.hostname);
	    }
	    var p = this.port ? ":" + this.port : "";
	    var h = this.hostname || "";
	    this.host = h + p;
	    this.href += this.host;
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== "/") {
	        rest = "/" + rest;
	      }
	    }
	  }
	  if (!unsafeProtocol[lowerProto]) {
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      if (rest.indexOf(ae) === -1) continue;
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }
	  var hash = rest.indexOf("#");
	  if (hash !== -1) {
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf("?");
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    this.search = "";
	    this.query = {};
	  }
	  if (rest) this.pathname = rest;
	  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
	    this.pathname = "/";
	  }
	  if (this.pathname || this.search) {
	    var p = this.pathname || "";
	    var s = this.search || "";
	    this.path = p + s;
	  }
	  this.href = this.format();
	  return this;
	};
	function urlFormat(obj) {
	  if (util$1.isString(obj)) obj = urlParse(obj);
	  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
	  return obj.format();
	}
	Url.prototype.format = function () {
	  var auth = this.auth || "";
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ":");
	    auth += "@";
	  }
	  var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
	    if (this.port) {
	      host += ":" + this.port;
	    }
	  }
	  if (this.query && util$1.isObject(this.query) && Object.keys(this.query).length) {
	    query = querystring.stringify(this.query);
	  }
	  var search = this.search || query && "?" + query || "";
	  if (protocol && protocol.substr(-1) !== ":") protocol += ":";
	  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = "//" + (host || "");
	    if (pathname && pathname.charAt(0) !== "/") pathname = "/" + pathname;
	  } else if (!host) {
	    host = "";
	  }
	  if (hash && hash.charAt(0) !== "#") hash = "#" + hash;
	  if (search && search.charAt(0) !== "?") search = "?" + search;
	  pathname = pathname.replace(/[?#]/g, function (match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace("#", "%23");
	  return protocol + host + pathname + search + hash;
	};
	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}
	Url.prototype.resolve = function (relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};
	function urlResolveObject(source, relative) {
	  if (!source) return relative;
	  return urlParse(source, false, true).resolveObject(relative);
	}
	Url.prototype.resolveObject = function (relative) {
	  if (util$1.isString(relative)) {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }
	  var result = new Url();
	  var tkeys = Object.keys(this);
	  for (var tk = 0; tk < tkeys.length; tk++) {
	    var tkey = tkeys[tk];
	    result[tkey] = this[tkey];
	  }
	  result.hash = relative.hash;
	  if (relative.href === "") {
	    result.href = result.format();
	    return result;
	  }
	  if (relative.slashes && !relative.protocol) {
	    var rkeys = Object.keys(relative);
	    for (var rk = 0; rk < rkeys.length; rk++) {
	      var rkey = rkeys[rk];
	      if (rkey !== "protocol") result[rkey] = relative[rkey];
	    }
	    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
	      result.path = result.pathname = "/";
	    }
	    result.href = result.format();
	    return result;
	  }
	  if (relative.protocol && relative.protocol !== result.protocol) {
	    if (!slashedProtocol[relative.protocol]) {
	      var keys = Object.keys(relative);
	      for (var v = 0; v < keys.length; v++) {
	        var k = keys[v];
	        result[k] = relative[k];
	      }
	      result.href = result.format();
	      return result;
	    }
	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || "").split("/");
	      while (relPath.length && !(relative.host = relPath.shift())) ;
	      if (!relative.host) relative.host = "";
	      if (!relative.hostname) relative.hostname = "";
	      if (relPath[0] !== "") relPath.unshift("");
	      if (relPath.length < 2) relPath.unshift("");
	      result.pathname = relPath.join("/");
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || "";
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    if (result.pathname || result.search) {
	      var p = result.pathname || "";
	      var s = result.search || "";
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }
	  var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
	  if (psychotic) {
	    result.hostname = "";
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === "") srcPath[0] = result.host; else srcPath.unshift(result.host);
	    }
	    result.host = "";
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === "") relPath[0] = relative.host; else relPath.unshift(relative.host);
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
	  }
	  if (isRelAbs) {
	    result.host = relative.host || relative.host === "" ? relative.host : result.host;
	    result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	  } else if (relPath.length) {
	    if (!srcPath) srcPath = [];
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (!util$1.isNullOrUndefined(relative.search)) {
	    if (psychotic) {
	      result.hostname = result.host = srcPath.shift();
	      var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.host = result.hostname = authInHost.shift();
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    if (!util$1.isNull(result.pathname) || !util$1.isNull(result.search)) {
	      result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
	    }
	    result.href = result.format();
	    return result;
	  }
	  if (!srcPath.length) {
	    result.pathname = null;
	    if (result.search) {
	      result.path = "/" + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last === ".") {
	      srcPath.splice(i, 1);
	    } else if (last === "..") {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift("..");
	    }
	  }
	  if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
	    srcPath.unshift("");
	  }
	  if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
	    srcPath.push("");
	  }
	  var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
	  if (psychotic) {
	    result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
	    var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.host = result.hostname = authInHost.shift();
	    }
	  }
	  mustEndAbs = mustEndAbs || result.host && srcPath.length;
	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift("");
	  }
	  if (!srcPath.length) {
	    result.pathname = null;
	    result.path = null;
	  } else {
	    result.pathname = srcPath.join("/");
	  }
	  if (!util$1.isNull(result.pathname) || !util$1.isNull(result.search)) {
	    result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};
	Url.prototype.parseHost = function () {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ":") {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) this.hostname = host;
	};

	/**
	 * dat-gui JavaScript Controller Library
	 * http://code.google.com/p/dat-gui
	 *
	 * Copyright 2011 Data Arts Team, Google Creative Lab
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 */

	function ___$insertStyle(css) {
	  if (!css) {
	    return;
	  }
	  if (typeof window === 'undefined') {
	    return;
	  }

	  var style = document.createElement('style');

	  style.setAttribute('type', 'text/css');
	  style.innerHTML = css;
	  document.head.appendChild(style);

	  return css;
	}

	function colorToString (color, forceCSSHex) {
	  var colorFormat = color.__state.conversionName.toString();
	  var r = Math.round(color.r);
	  var g = Math.round(color.g);
	  var b = Math.round(color.b);
	  var a = color.a;
	  var h = Math.round(color.h);
	  var s = color.s.toFixed(1);
	  var v = color.v.toFixed(1);
	  if (forceCSSHex || colorFormat === 'THREE_CHAR_HEX' || colorFormat === 'SIX_CHAR_HEX') {
	    var str = color.hex.toString(16);
	    while (str.length < 6) {
	      str = '0' + str;
	    }
	    return '#' + str;
	  } else if (colorFormat === 'CSS_RGB') {
	    return 'rgb(' + r + ',' + g + ',' + b + ')';
	  } else if (colorFormat === 'CSS_RGBA') {
	    return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
	  } else if (colorFormat === 'HEX') {
	    return '0x' + color.hex.toString(16);
	  } else if (colorFormat === 'RGB_ARRAY') {
	    return '[' + r + ',' + g + ',' + b + ']';
	  } else if (colorFormat === 'RGBA_ARRAY') {
	    return '[' + r + ',' + g + ',' + b + ',' + a + ']';
	  } else if (colorFormat === 'RGB_OBJ') {
	    return '{r:' + r + ',g:' + g + ',b:' + b + '}';
	  } else if (colorFormat === 'RGBA_OBJ') {
	    return '{r:' + r + ',g:' + g + ',b:' + b + ',a:' + a + '}';
	  } else if (colorFormat === 'HSV_OBJ') {
	    return '{h:' + h + ',s:' + s + ',v:' + v + '}';
	  } else if (colorFormat === 'HSVA_OBJ') {
	    return '{h:' + h + ',s:' + s + ',v:' + v + ',a:' + a + '}';
	  }
	  return 'unknown format';
	}

	var ARR_EACH = Array.prototype.forEach;
	var ARR_SLICE = Array.prototype.slice;
	var Common = {
	  BREAK: {},
	  extend: function extend(target) {
	    this.each(ARR_SLICE.call(arguments, 1), function (obj) {
	      var keys = this.isObject(obj) ? Object.keys(obj) : [];
	      keys.forEach(function (key) {
	        if (!this.isUndefined(obj[key])) {
	          target[key] = obj[key];
	        }
	      }.bind(this));
	    }, this);
	    return target;
	  },
	  defaults: function defaults(target) {
	    this.each(ARR_SLICE.call(arguments, 1), function (obj) {
	      var keys = this.isObject(obj) ? Object.keys(obj) : [];
	      keys.forEach(function (key) {
	        if (this.isUndefined(target[key])) {
	          target[key] = obj[key];
	        }
	      }.bind(this));
	    }, this);
	    return target;
	  },
	  compose: function compose() {
	    var toCall = ARR_SLICE.call(arguments);
	    return function () {
	      var args = ARR_SLICE.call(arguments);
	      for (var i = toCall.length - 1; i >= 0; i--) {
	        args = [toCall[i].apply(this, args)];
	      }
	      return args[0];
	    };
	  },
	  each: function each(obj, itr, scope) {
	    if (!obj) {
	      return;
	    }
	    if (ARR_EACH && obj.forEach && obj.forEach === ARR_EACH) {
	      obj.forEach(itr, scope);
	    } else if (obj.length === obj.length + 0) {
	      var key = void 0;
	      var l = void 0;
	      for (key = 0, l = obj.length; key < l; key++) {
	        if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) {
	          return;
	        }
	      }
	    } else {
	      for (var _key in obj) {
	        if (itr.call(scope, obj[_key], _key) === this.BREAK) {
	          return;
	        }
	      }
	    }
	  },
	  defer: function defer(fnc) {
	    setTimeout(fnc, 0);
	  },
	  debounce: function debounce(func, threshold, callImmediately) {
	    var timeout = void 0;
	    return function () {
	      var obj = this;
	      var args = arguments;
	      function delayed() {
	        timeout = null;
	        if (!callImmediately) func.apply(obj, args);
	      }
	      var callNow = callImmediately || !timeout;
	      clearTimeout(timeout);
	      timeout = setTimeout(delayed, threshold);
	      if (callNow) {
	        func.apply(obj, args);
	      }
	    };
	  },
	  toArray: function toArray(obj) {
	    if (obj.toArray) return obj.toArray();
	    return ARR_SLICE.call(obj);
	  },
	  isUndefined: function isUndefined(obj) {
	    return obj === undefined;
	  },
	  isNull: function isNull(obj) {
	    return obj === null;
	  },
	  isNaN: function (_isNaN) {
	    function isNaN(_x) {
	      return _isNaN.apply(this, arguments);
	    }
	    isNaN.toString = function () {
	      return _isNaN.toString();
	    };
	    return isNaN;
	  }(function (obj) {
	    return isNaN(obj);
	  }),
	  isArray: Array.isArray || function (obj) {
	    return obj.constructor === Array;
	  },
	  isObject: function isObject(obj) {
	    return obj === Object(obj);
	  },
	  isNumber: function isNumber(obj) {
	    return obj === obj + 0;
	  },
	  isString: function isString(obj) {
	    return obj === obj + '';
	  },
	  isBoolean: function isBoolean(obj) {
	    return obj === false || obj === true;
	  },
	  isFunction: function isFunction(obj) {
	    return Object.prototype.toString.call(obj) === '[object Function]';
	  }
	};

	var INTERPRETATIONS = [
	{
	  litmus: Common.isString,
	  conversions: {
	    THREE_CHAR_HEX: {
	      read: function read(original) {
	        var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
	        if (test === null) {
	          return false;
	        }
	        return {
	          space: 'HEX',
	          hex: parseInt('0x' + test[1].toString() + test[1].toString() + test[2].toString() + test[2].toString() + test[3].toString() + test[3].toString(), 0)
	        };
	      },
	      write: colorToString
	    },
	    SIX_CHAR_HEX: {
	      read: function read(original) {
	        var test = original.match(/^#([A-F0-9]{6})$/i);
	        if (test === null) {
	          return false;
	        }
	        return {
	          space: 'HEX',
	          hex: parseInt('0x' + test[1].toString(), 0)
	        };
	      },
	      write: colorToString
	    },
	    CSS_RGB: {
	      read: function read(original) {
	        var test = original.match(/^rgb\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
	        if (test === null) {
	          return false;
	        }
	        return {
	          space: 'RGB',
	          r: parseFloat(test[1]),
	          g: parseFloat(test[2]),
	          b: parseFloat(test[3])
	        };
	      },
	      write: colorToString
	    },
	    CSS_RGBA: {
	      read: function read(original) {
	        var test = original.match(/^rgba\(\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*,\s*(.+)\s*\)/);
	        if (test === null) {
	          return false;
	        }
	        return {
	          space: 'RGB',
	          r: parseFloat(test[1]),
	          g: parseFloat(test[2]),
	          b: parseFloat(test[3]),
	          a: parseFloat(test[4])
	        };
	      },
	      write: colorToString
	    }
	  }
	},
	{
	  litmus: Common.isNumber,
	  conversions: {
	    HEX: {
	      read: function read(original) {
	        return {
	          space: 'HEX',
	          hex: original,
	          conversionName: 'HEX'
	        };
	      },
	      write: function write(color) {
	        return color.hex;
	      }
	    }
	  }
	},
	{
	  litmus: Common.isArray,
	  conversions: {
	    RGB_ARRAY: {
	      read: function read(original) {
	        if (original.length !== 3) {
	          return false;
	        }
	        return {
	          space: 'RGB',
	          r: original[0],
	          g: original[1],
	          b: original[2]
	        };
	      },
	      write: function write(color) {
	        return [color.r, color.g, color.b];
	      }
	    },
	    RGBA_ARRAY: {
	      read: function read(original) {
	        if (original.length !== 4) return false;
	        return {
	          space: 'RGB',
	          r: original[0],
	          g: original[1],
	          b: original[2],
	          a: original[3]
	        };
	      },
	      write: function write(color) {
	        return [color.r, color.g, color.b, color.a];
	      }
	    }
	  }
	},
	{
	  litmus: Common.isObject,
	  conversions: {
	    RGBA_OBJ: {
	      read: function read(original) {
	        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b) && Common.isNumber(original.a)) {
	          return {
	            space: 'RGB',
	            r: original.r,
	            g: original.g,
	            b: original.b,
	            a: original.a
	          };
	        }
	        return false;
	      },
	      write: function write(color) {
	        return {
	          r: color.r,
	          g: color.g,
	          b: color.b,
	          a: color.a
	        };
	      }
	    },
	    RGB_OBJ: {
	      read: function read(original) {
	        if (Common.isNumber(original.r) && Common.isNumber(original.g) && Common.isNumber(original.b)) {
	          return {
	            space: 'RGB',
	            r: original.r,
	            g: original.g,
	            b: original.b
	          };
	        }
	        return false;
	      },
	      write: function write(color) {
	        return {
	          r: color.r,
	          g: color.g,
	          b: color.b
	        };
	      }
	    },
	    HSVA_OBJ: {
	      read: function read(original) {
	        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v) && Common.isNumber(original.a)) {
	          return {
	            space: 'HSV',
	            h: original.h,
	            s: original.s,
	            v: original.v,
	            a: original.a
	          };
	        }
	        return false;
	      },
	      write: function write(color) {
	        return {
	          h: color.h,
	          s: color.s,
	          v: color.v,
	          a: color.a
	        };
	      }
	    },
	    HSV_OBJ: {
	      read: function read(original) {
	        if (Common.isNumber(original.h) && Common.isNumber(original.s) && Common.isNumber(original.v)) {
	          return {
	            space: 'HSV',
	            h: original.h,
	            s: original.s,
	            v: original.v
	          };
	        }
	        return false;
	      },
	      write: function write(color) {
	        return {
	          h: color.h,
	          s: color.s,
	          v: color.v
	        };
	      }
	    }
	  }
	}];
	var result$1 = void 0;
	var toReturn = void 0;
	var interpret = function interpret() {
	  toReturn = false;
	  var original = arguments.length > 1 ? Common.toArray(arguments) : arguments[0];
	  Common.each(INTERPRETATIONS, function (family) {
	    if (family.litmus(original)) {
	      Common.each(family.conversions, function (conversion, conversionName) {
	        result$1 = conversion.read(original);
	        if (toReturn === false && result$1 !== false) {
	          toReturn = result$1;
	          result$1.conversionName = conversionName;
	          result$1.conversion = conversion;
	          return Common.BREAK;
	        }
	      });
	      return Common.BREAK;
	    }
	  });
	  return toReturn;
	};

	var tmpComponent = void 0;
	var ColorMath = {
	  hsv_to_rgb: function hsv_to_rgb(h, s, v) {
	    var hi = Math.floor(h / 60) % 6;
	    var f = h / 60 - Math.floor(h / 60);
	    var p = v * (1.0 - s);
	    var q = v * (1.0 - f * s);
	    var t = v * (1.0 - (1.0 - f) * s);
	    var c = [[v, t, p], [q, v, p], [p, v, t], [p, q, v], [t, p, v], [v, p, q]][hi];
	    return {
	      r: c[0] * 255,
	      g: c[1] * 255,
	      b: c[2] * 255
	    };
	  },
	  rgb_to_hsv: function rgb_to_hsv(r, g, b) {
	    var min = Math.min(r, g, b);
	    var max = Math.max(r, g, b);
	    var delta = max - min;
	    var h = void 0;
	    var s = void 0;
	    if (max !== 0) {
	      s = delta / max;
	    } else {
	      return {
	        h: NaN,
	        s: 0,
	        v: 0
	      };
	    }
	    if (r === max) {
	      h = (g - b) / delta;
	    } else if (g === max) {
	      h = 2 + (b - r) / delta;
	    } else {
	      h = 4 + (r - g) / delta;
	    }
	    h /= 6;
	    if (h < 0) {
	      h += 1;
	    }
	    return {
	      h: h * 360,
	      s: s,
	      v: max / 255
	    };
	  },
	  rgb_to_hex: function rgb_to_hex(r, g, b) {
	    var hex = this.hex_with_component(0, 2, r);
	    hex = this.hex_with_component(hex, 1, g);
	    hex = this.hex_with_component(hex, 0, b);
	    return hex;
	  },
	  component_from_hex: function component_from_hex(hex, componentIndex) {
	    return hex >> componentIndex * 8 & 0xFF;
	  },
	  hex_with_component: function hex_with_component(hex, componentIndex, value) {
	    return value << (tmpComponent = componentIndex * 8) | hex & ~(0xFF << tmpComponent);
	  }
	};

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
	  return typeof obj;
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	};











	var classCallCheck = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

	var createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }

	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();







	var get$1 = function get(object, property, receiver) {
	  if (object === null) object = Function.prototype;
	  var desc = Object.getOwnPropertyDescriptor(object, property);

	  if (desc === undefined) {
	    var parent = Object.getPrototypeOf(object);

	    if (parent === null) {
	      return undefined;
	    } else {
	      return get(parent, property, receiver);
	    }
	  } else if ("value" in desc) {
	    return desc.value;
	  } else {
	    var getter = desc.get;

	    if (getter === undefined) {
	      return undefined;
	    }

	    return getter.call(receiver);
	  }
	};

	var inherits = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
	  }

	  subClass.prototype = Object.create(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
	};











	var possibleConstructorReturn = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }

	  return call && (typeof call === "object" || typeof call === "function") ? call : self;
	};

	var Color$1 = function () {
	  function Color() {
	    classCallCheck(this, Color);
	    this.__state = interpret.apply(this, arguments);
	    if (this.__state === false) {
	      throw new Error('Failed to interpret color arguments');
	    }
	    this.__state.a = this.__state.a || 1;
	  }
	  createClass(Color, [{
	    key: 'toString',
	    value: function toString() {
	      return colorToString(this);
	    }
	  }, {
	    key: 'toHexString',
	    value: function toHexString() {
	      return colorToString(this, true);
	    }
	  }, {
	    key: 'toOriginal',
	    value: function toOriginal() {
	      return this.__state.conversion.write(this);
	    }
	  }]);
	  return Color;
	}();
	function defineRGBComponent(target, component, componentHexIndex) {
	  Object.defineProperty(target, component, {
	    get: function get$$1() {
	      if (this.__state.space === 'RGB') {
	        return this.__state[component];
	      }
	      Color$1.recalculateRGB(this, component, componentHexIndex);
	      return this.__state[component];
	    },
	    set: function set$$1(v) {
	      if (this.__state.space !== 'RGB') {
	        Color$1.recalculateRGB(this, component, componentHexIndex);
	        this.__state.space = 'RGB';
	      }
	      this.__state[component] = v;
	    }
	  });
	}
	function defineHSVComponent(target, component) {
	  Object.defineProperty(target, component, {
	    get: function get$$1() {
	      if (this.__state.space === 'HSV') {
	        return this.__state[component];
	      }
	      Color$1.recalculateHSV(this);
	      return this.__state[component];
	    },
	    set: function set$$1(v) {
	      if (this.__state.space !== 'HSV') {
	        Color$1.recalculateHSV(this);
	        this.__state.space = 'HSV';
	      }
	      this.__state[component] = v;
	    }
	  });
	}
	Color$1.recalculateRGB = function (color, component, componentHexIndex) {
	  if (color.__state.space === 'HEX') {
	    color.__state[component] = ColorMath.component_from_hex(color.__state.hex, componentHexIndex);
	  } else if (color.__state.space === 'HSV') {
	    Common.extend(color.__state, ColorMath.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v));
	  } else {
	    throw new Error('Corrupted color state');
	  }
	};
	Color$1.recalculateHSV = function (color) {
	  var result = ColorMath.rgb_to_hsv(color.r, color.g, color.b);
	  Common.extend(color.__state, {
	    s: result.s,
	    v: result.v
	  });
	  if (!Common.isNaN(result.h)) {
	    color.__state.h = result.h;
	  } else if (Common.isUndefined(color.__state.h)) {
	    color.__state.h = 0;
	  }
	};
	Color$1.COMPONENTS = ['r', 'g', 'b', 'h', 's', 'v', 'hex', 'a'];
	defineRGBComponent(Color$1.prototype, 'r', 2);
	defineRGBComponent(Color$1.prototype, 'g', 1);
	defineRGBComponent(Color$1.prototype, 'b', 0);
	defineHSVComponent(Color$1.prototype, 'h');
	defineHSVComponent(Color$1.prototype, 's');
	defineHSVComponent(Color$1.prototype, 'v');
	Object.defineProperty(Color$1.prototype, 'a', {
	  get: function get$$1() {
	    return this.__state.a;
	  },
	  set: function set$$1(v) {
	    this.__state.a = v;
	  }
	});
	Object.defineProperty(Color$1.prototype, 'hex', {
	  get: function get$$1() {
	    if (!this.__state.space !== 'HEX') {
	      this.__state.hex = ColorMath.rgb_to_hex(this.r, this.g, this.b);
	    }
	    return this.__state.hex;
	  },
	  set: function set$$1(v) {
	    this.__state.space = 'HEX';
	    this.__state.hex = v;
	  }
	});

	var Controller = function () {
	  function Controller(object, property) {
	    classCallCheck(this, Controller);
	    this.initialValue = object[property];
	    this.domElement = document.createElement('div');
	    this.object = object;
	    this.property = property;
	    this.__onChange = undefined;
	    this.__onFinishChange = undefined;
	  }
	  createClass(Controller, [{
	    key: 'onChange',
	    value: function onChange(fnc) {
	      this.__onChange = fnc;
	      return this;
	    }
	  }, {
	    key: 'onFinishChange',
	    value: function onFinishChange(fnc) {
	      this.__onFinishChange = fnc;
	      return this;
	    }
	  }, {
	    key: 'setValue',
	    value: function setValue(newValue) {
	      this.object[this.property] = newValue;
	      if (this.__onChange) {
	        this.__onChange.call(this, newValue);
	      }
	      this.updateDisplay();
	      return this;
	    }
	  }, {
	    key: 'getValue',
	    value: function getValue() {
	      return this.object[this.property];
	    }
	  }, {
	    key: 'updateDisplay',
	    value: function updateDisplay() {
	      return this;
	    }
	  }, {
	    key: 'isModified',
	    value: function isModified() {
	      return this.initialValue !== this.getValue();
	    }
	  }]);
	  return Controller;
	}();

	var EVENT_MAP = {
	  HTMLEvents: ['change'],
	  MouseEvents: ['click', 'mousemove', 'mousedown', 'mouseup', 'mouseover'],
	  KeyboardEvents: ['keydown']
	};
	var EVENT_MAP_INV = {};
	Common.each(EVENT_MAP, function (v, k) {
	  Common.each(v, function (e) {
	    EVENT_MAP_INV[e] = k;
	  });
	});
	var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/;
	function cssValueToPixels(val) {
	  if (val === '0' || Common.isUndefined(val)) {
	    return 0;
	  }
	  var match = val.match(CSS_VALUE_PIXELS);
	  if (!Common.isNull(match)) {
	    return parseFloat(match[1]);
	  }
	  return 0;
	}
	var dom = {
	  makeSelectable: function makeSelectable(elem, selectable) {
	    if (elem === undefined || elem.style === undefined) return;
	    elem.onselectstart = selectable ? function () {
	      return false;
	    } : function () {};
	    elem.style.MozUserSelect = selectable ? 'auto' : 'none';
	    elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none';
	    elem.unselectable = selectable ? 'on' : 'off';
	  },
	  makeFullscreen: function makeFullscreen(elem, hor, vert) {
	    var vertical = vert;
	    var horizontal = hor;
	    if (Common.isUndefined(horizontal)) {
	      horizontal = true;
	    }
	    if (Common.isUndefined(vertical)) {
	      vertical = true;
	    }
	    elem.style.position = 'absolute';
	    if (horizontal) {
	      elem.style.left = 0;
	      elem.style.right = 0;
	    }
	    if (vertical) {
	      elem.style.top = 0;
	      elem.style.bottom = 0;
	    }
	  },
	  fakeEvent: function fakeEvent(elem, eventType, pars, aux) {
	    var params = pars || {};
	    var className = EVENT_MAP_INV[eventType];
	    if (!className) {
	      throw new Error('Event type ' + eventType + ' not supported.');
	    }
	    var evt = document.createEvent(className);
	    switch (className) {
	      case 'MouseEvents':
	        {
	          var clientX = params.x || params.clientX || 0;
	          var clientY = params.y || params.clientY || 0;
	          evt.initMouseEvent(eventType, params.bubbles || false, params.cancelable || true, window, params.clickCount || 1, 0,
	          0,
	          clientX,
	          clientY,
	          false, false, false, false, 0, null);
	          break;
	        }
	      case 'KeyboardEvents':
	        {
	          var init = evt.initKeyboardEvent || evt.initKeyEvent;
	          Common.defaults(params, {
	            cancelable: true,
	            ctrlKey: false,
	            altKey: false,
	            shiftKey: false,
	            metaKey: false,
	            keyCode: undefined,
	            charCode: undefined
	          });
	          init(eventType, params.bubbles || false, params.cancelable, window, params.ctrlKey, params.altKey, params.shiftKey, params.metaKey, params.keyCode, params.charCode);
	          break;
	        }
	      default:
	        {
	          evt.initEvent(eventType, params.bubbles || false, params.cancelable || true);
	          break;
	        }
	    }
	    Common.defaults(evt, aux);
	    elem.dispatchEvent(evt);
	  },
	  bind: function bind(elem, event, func, newBool) {
	    var bool = newBool || false;
	    if (elem.addEventListener) {
	      elem.addEventListener(event, func, bool);
	    } else if (elem.attachEvent) {
	      elem.attachEvent('on' + event, func);
	    }
	    return dom;
	  },
	  unbind: function unbind(elem, event, func, newBool) {
	    var bool = newBool || false;
	    if (elem.removeEventListener) {
	      elem.removeEventListener(event, func, bool);
	    } else if (elem.detachEvent) {
	      elem.detachEvent('on' + event, func);
	    }
	    return dom;
	  },
	  addClass: function addClass(elem, className) {
	    if (elem.className === undefined) {
	      elem.className = className;
	    } else if (elem.className !== className) {
	      var classes = elem.className.split(/ +/);
	      if (classes.indexOf(className) === -1) {
	        classes.push(className);
	        elem.className = classes.join(' ').replace(/^\s+/, '').replace(/\s+$/, '');
	      }
	    }
	    return dom;
	  },
	  removeClass: function removeClass(elem, className) {
	    if (className) {
	      if (elem.className === className) {
	        elem.removeAttribute('class');
	      } else {
	        var classes = elem.className.split(/ +/);
	        var index = classes.indexOf(className);
	        if (index !== -1) {
	          classes.splice(index, 1);
	          elem.className = classes.join(' ');
	        }
	      }
	    } else {
	      elem.className = undefined;
	    }
	    return dom;
	  },
	  hasClass: function hasClass(elem, className) {
	    return new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(elem.className) || false;
	  },
	  getWidth: function getWidth(elem) {
	    var style = getComputedStyle(elem);
	    return cssValueToPixels(style['border-left-width']) + cssValueToPixels(style['border-right-width']) + cssValueToPixels(style['padding-left']) + cssValueToPixels(style['padding-right']) + cssValueToPixels(style.width);
	  },
	  getHeight: function getHeight(elem) {
	    var style = getComputedStyle(elem);
	    return cssValueToPixels(style['border-top-width']) + cssValueToPixels(style['border-bottom-width']) + cssValueToPixels(style['padding-top']) + cssValueToPixels(style['padding-bottom']) + cssValueToPixels(style.height);
	  },
	  getOffset: function getOffset(el) {
	    var elem = el;
	    var offset = { left: 0, top: 0 };
	    if (elem.offsetParent) {
	      do {
	        offset.left += elem.offsetLeft;
	        offset.top += elem.offsetTop;
	        elem = elem.offsetParent;
	      } while (elem);
	    }
	    return offset;
	  },
	  isActive: function isActive(elem) {
	    return elem === document.activeElement && (elem.type || elem.href);
	  }
	};

	var BooleanController = function (_Controller) {
	  inherits(BooleanController, _Controller);
	  function BooleanController(object, property) {
	    classCallCheck(this, BooleanController);
	    var _this2 = possibleConstructorReturn(this, (BooleanController.__proto__ || Object.getPrototypeOf(BooleanController)).call(this, object, property));
	    var _this = _this2;
	    _this2.__prev = _this2.getValue();
	    _this2.__checkbox = document.createElement('input');
	    _this2.__checkbox.setAttribute('type', 'checkbox');
	    function onChange() {
	      _this.setValue(!_this.__prev);
	    }
	    dom.bind(_this2.__checkbox, 'change', onChange, false);
	    _this2.domElement.appendChild(_this2.__checkbox);
	    _this2.updateDisplay();
	    return _this2;
	  }
	  createClass(BooleanController, [{
	    key: 'setValue',
	    value: function setValue(v) {
	      var toReturn = get$1(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'setValue', this).call(this, v);
	      if (this.__onFinishChange) {
	        this.__onFinishChange.call(this, this.getValue());
	      }
	      this.__prev = this.getValue();
	      return toReturn;
	    }
	  }, {
	    key: 'updateDisplay',
	    value: function updateDisplay() {
	      if (this.getValue() === true) {
	        this.__checkbox.setAttribute('checked', 'checked');
	        this.__checkbox.checked = true;
	        this.__prev = true;
	      } else {
	        this.__checkbox.checked = false;
	        this.__prev = false;
	      }
	      return get$1(BooleanController.prototype.__proto__ || Object.getPrototypeOf(BooleanController.prototype), 'updateDisplay', this).call(this);
	    }
	  }]);
	  return BooleanController;
	}(Controller);

	var OptionController = function (_Controller) {
	  inherits(OptionController, _Controller);
	  function OptionController(object, property, opts) {
	    classCallCheck(this, OptionController);
	    var _this2 = possibleConstructorReturn(this, (OptionController.__proto__ || Object.getPrototypeOf(OptionController)).call(this, object, property));
	    var options = opts;
	    var _this = _this2;
	    _this2.__select = document.createElement('select');
	    if (Common.isArray(options)) {
	      var map = {};
	      Common.each(options, function (element) {
	        map[element] = element;
	      });
	      options = map;
	    }
	    Common.each(options, function (value, key) {
	      var opt = document.createElement('option');
	      opt.innerHTML = key;
	      opt.setAttribute('value', value);
	      _this.__select.appendChild(opt);
	    });
	    _this2.updateDisplay();
	    dom.bind(_this2.__select, 'change', function () {
	      var desiredValue = this.options[this.selectedIndex].value;
	      _this.setValue(desiredValue);
	    });
	    _this2.domElement.appendChild(_this2.__select);
	    return _this2;
	  }
	  createClass(OptionController, [{
	    key: 'setValue',
	    value: function setValue(v) {
	      var toReturn = get$1(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'setValue', this).call(this, v);
	      if (this.__onFinishChange) {
	        this.__onFinishChange.call(this, this.getValue());
	      }
	      return toReturn;
	    }
	  }, {
	    key: 'updateDisplay',
	    value: function updateDisplay() {
	      if (dom.isActive(this.__select)) return this;
	      this.__select.value = this.getValue();
	      return get$1(OptionController.prototype.__proto__ || Object.getPrototypeOf(OptionController.prototype), 'updateDisplay', this).call(this);
	    }
	  }]);
	  return OptionController;
	}(Controller);

	var StringController = function (_Controller) {
	  inherits(StringController, _Controller);
	  function StringController(object, property) {
	    classCallCheck(this, StringController);
	    var _this2 = possibleConstructorReturn(this, (StringController.__proto__ || Object.getPrototypeOf(StringController)).call(this, object, property));
	    var _this = _this2;
	    function onChange() {
	      _this.setValue(_this.__input.value);
	    }
	    function onBlur() {
	      if (_this.__onFinishChange) {
	        _this.__onFinishChange.call(_this, _this.getValue());
	      }
	    }
	    _this2.__input = document.createElement('input');
	    _this2.__input.setAttribute('type', 'text');
	    dom.bind(_this2.__input, 'keyup', onChange);
	    dom.bind(_this2.__input, 'change', onChange);
	    dom.bind(_this2.__input, 'blur', onBlur);
	    dom.bind(_this2.__input, 'keydown', function (e) {
	      if (e.keyCode === 13) {
	        this.blur();
	      }
	    });
	    _this2.updateDisplay();
	    _this2.domElement.appendChild(_this2.__input);
	    return _this2;
	  }
	  createClass(StringController, [{
	    key: 'updateDisplay',
	    value: function updateDisplay() {
	      if (!dom.isActive(this.__input)) {
	        this.__input.value = this.getValue();
	      }
	      return get$1(StringController.prototype.__proto__ || Object.getPrototypeOf(StringController.prototype), 'updateDisplay', this).call(this);
	    }
	  }]);
	  return StringController;
	}(Controller);

	function numDecimals(x) {
	  var _x = x.toString();
	  if (_x.indexOf('.') > -1) {
	    return _x.length - _x.indexOf('.') - 1;
	  }
	  return 0;
	}
	var NumberController = function (_Controller) {
	  inherits(NumberController, _Controller);
	  function NumberController(object, property, params) {
	    classCallCheck(this, NumberController);
	    var _this = possibleConstructorReturn(this, (NumberController.__proto__ || Object.getPrototypeOf(NumberController)).call(this, object, property));
	    var _params = params || {};
	    _this.__min = _params.min;
	    _this.__max = _params.max;
	    _this.__step = _params.step;
	    if (Common.isUndefined(_this.__step)) {
	      if (_this.initialValue === 0) {
	        _this.__impliedStep = 1;
	      } else {
	        _this.__impliedStep = Math.pow(10, Math.floor(Math.log(Math.abs(_this.initialValue)) / Math.LN10)) / 10;
	      }
	    } else {
	      _this.__impliedStep = _this.__step;
	    }
	    _this.__precision = numDecimals(_this.__impliedStep);
	    return _this;
	  }
	  createClass(NumberController, [{
	    key: 'setValue',
	    value: function setValue(v) {
	      var _v = v;
	      if (this.__min !== undefined && _v < this.__min) {
	        _v = this.__min;
	      } else if (this.__max !== undefined && _v > this.__max) {
	        _v = this.__max;
	      }
	      if (this.__step !== undefined && _v % this.__step !== 0) {
	        _v = Math.round(_v / this.__step) * this.__step;
	      }
	      return get$1(NumberController.prototype.__proto__ || Object.getPrototypeOf(NumberController.prototype), 'setValue', this).call(this, _v);
	    }
	  }, {
	    key: 'min',
	    value: function min(minValue) {
	      this.__min = minValue;
	      return this;
	    }
	  }, {
	    key: 'max',
	    value: function max(maxValue) {
	      this.__max = maxValue;
	      return this;
	    }
	  }, {
	    key: 'step',
	    value: function step(stepValue) {
	      this.__step = stepValue;
	      this.__impliedStep = stepValue;
	      this.__precision = numDecimals(stepValue);
	      return this;
	    }
	  }]);
	  return NumberController;
	}(Controller);

	function roundToDecimal(value, decimals) {
	  var tenTo = Math.pow(10, decimals);
	  return Math.round(value * tenTo) / tenTo;
	}
	var NumberControllerBox = function (_NumberController) {
	  inherits(NumberControllerBox, _NumberController);
	  function NumberControllerBox(object, property, params) {
	    classCallCheck(this, NumberControllerBox);
	    var _this2 = possibleConstructorReturn(this, (NumberControllerBox.__proto__ || Object.getPrototypeOf(NumberControllerBox)).call(this, object, property, params));
	    _this2.__truncationSuspended = false;
	    var _this = _this2;
	    var prevY = void 0;
	    function onChange() {
	      var attempted = parseFloat(_this.__input.value);
	      if (!Common.isNaN(attempted)) {
	        _this.setValue(attempted);
	      }
	    }
	    function onFinish() {
	      if (_this.__onFinishChange) {
	        _this.__onFinishChange.call(_this, _this.getValue());
	      }
	    }
	    function onBlur() {
	      onFinish();
	    }
	    function onMouseDrag(e) {
	      var diff = prevY - e.clientY;
	      _this.setValue(_this.getValue() + diff * _this.__impliedStep);
	      prevY = e.clientY;
	    }
	    function onMouseUp() {
	      dom.unbind(window, 'mousemove', onMouseDrag);
	      dom.unbind(window, 'mouseup', onMouseUp);
	      onFinish();
	    }
	    function onMouseDown(e) {
	      dom.bind(window, 'mousemove', onMouseDrag);
	      dom.bind(window, 'mouseup', onMouseUp);
	      prevY = e.clientY;
	    }
	    _this2.__input = document.createElement('input');
	    _this2.__input.setAttribute('type', 'text');
	    dom.bind(_this2.__input, 'change', onChange);
	    dom.bind(_this2.__input, 'blur', onBlur);
	    dom.bind(_this2.__input, 'mousedown', onMouseDown);
	    dom.bind(_this2.__input, 'keydown', function (e) {
	      if (e.keyCode === 13) {
	        _this.__truncationSuspended = true;
	        this.blur();
	        _this.__truncationSuspended = false;
	        onFinish();
	      }
	    });
	    _this2.updateDisplay();
	    _this2.domElement.appendChild(_this2.__input);
	    return _this2;
	  }
	  createClass(NumberControllerBox, [{
	    key: 'updateDisplay',
	    value: function updateDisplay() {
	      this.__input.value = this.__truncationSuspended ? this.getValue() : roundToDecimal(this.getValue(), this.__precision);
	      return get$1(NumberControllerBox.prototype.__proto__ || Object.getPrototypeOf(NumberControllerBox.prototype), 'updateDisplay', this).call(this);
	    }
	  }]);
	  return NumberControllerBox;
	}(NumberController);

	function map$2(v, i1, i2, o1, o2) {
	  return o1 + (o2 - o1) * ((v - i1) / (i2 - i1));
	}
	var NumberControllerSlider = function (_NumberController) {
	  inherits(NumberControllerSlider, _NumberController);
	  function NumberControllerSlider(object, property, min, max, step) {
	    classCallCheck(this, NumberControllerSlider);
	    var _this2 = possibleConstructorReturn(this, (NumberControllerSlider.__proto__ || Object.getPrototypeOf(NumberControllerSlider)).call(this, object, property, { min: min, max: max, step: step }));
	    var _this = _this2;
	    _this2.__background = document.createElement('div');
	    _this2.__foreground = document.createElement('div');
	    dom.bind(_this2.__background, 'mousedown', onMouseDown);
	    dom.bind(_this2.__background, 'touchstart', onTouchStart);
	    dom.addClass(_this2.__background, 'slider');
	    dom.addClass(_this2.__foreground, 'slider-fg');
	    function onMouseDown(e) {
	      document.activeElement.blur();
	      dom.bind(window, 'mousemove', onMouseDrag);
	      dom.bind(window, 'mouseup', onMouseUp);
	      onMouseDrag(e);
	    }
	    function onMouseDrag(e) {
	      e.preventDefault();
	      var bgRect = _this.__background.getBoundingClientRect();
	      _this.setValue(map$2(e.clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
	      return false;
	    }
	    function onMouseUp() {
	      dom.unbind(window, 'mousemove', onMouseDrag);
	      dom.unbind(window, 'mouseup', onMouseUp);
	      if (_this.__onFinishChange) {
	        _this.__onFinishChange.call(_this, _this.getValue());
	      }
	    }
	    function onTouchStart(e) {
	      if (e.touches.length !== 1) {
	        return;
	      }
	      dom.bind(window, 'touchmove', onTouchMove);
	      dom.bind(window, 'touchend', onTouchEnd);
	      onTouchMove(e);
	    }
	    function onTouchMove(e) {
	      var clientX = e.touches[0].clientX;
	      var bgRect = _this.__background.getBoundingClientRect();
	      _this.setValue(map$2(clientX, bgRect.left, bgRect.right, _this.__min, _this.__max));
	    }
	    function onTouchEnd() {
	      dom.unbind(window, 'touchmove', onTouchMove);
	      dom.unbind(window, 'touchend', onTouchEnd);
	      if (_this.__onFinishChange) {
	        _this.__onFinishChange.call(_this, _this.getValue());
	      }
	    }
	    _this2.updateDisplay();
	    _this2.__background.appendChild(_this2.__foreground);
	    _this2.domElement.appendChild(_this2.__background);
	    return _this2;
	  }
	  createClass(NumberControllerSlider, [{
	    key: 'updateDisplay',
	    value: function updateDisplay() {
	      var pct = (this.getValue() - this.__min) / (this.__max - this.__min);
	      this.__foreground.style.width = pct * 100 + '%';
	      return get$1(NumberControllerSlider.prototype.__proto__ || Object.getPrototypeOf(NumberControllerSlider.prototype), 'updateDisplay', this).call(this);
	    }
	  }]);
	  return NumberControllerSlider;
	}(NumberController);

	var FunctionController = function (_Controller) {
	  inherits(FunctionController, _Controller);
	  function FunctionController(object, property, text) {
	    classCallCheck(this, FunctionController);
	    var _this2 = possibleConstructorReturn(this, (FunctionController.__proto__ || Object.getPrototypeOf(FunctionController)).call(this, object, property));
	    var _this = _this2;
	    _this2.__button = document.createElement('div');
	    _this2.__button.innerHTML = text === undefined ? 'Fire' : text;
	    dom.bind(_this2.__button, 'click', function (e) {
	      e.preventDefault();
	      _this.fire();
	      return false;
	    });
	    dom.addClass(_this2.__button, 'button');
	    _this2.domElement.appendChild(_this2.__button);
	    return _this2;
	  }
	  createClass(FunctionController, [{
	    key: 'fire',
	    value: function fire() {
	      if (this.__onChange) {
	        this.__onChange.call(this);
	      }
	      this.getValue().call(this.object);
	      if (this.__onFinishChange) {
	        this.__onFinishChange.call(this, this.getValue());
	      }
	    }
	  }]);
	  return FunctionController;
	}(Controller);

	var ColorController = function (_Controller) {
	  inherits(ColorController, _Controller);
	  function ColorController(object, property) {
	    classCallCheck(this, ColorController);
	    var _this2 = possibleConstructorReturn(this, (ColorController.__proto__ || Object.getPrototypeOf(ColorController)).call(this, object, property));
	    _this2.__color = new Color$1(_this2.getValue());
	    _this2.__temp = new Color$1(0);
	    var _this = _this2;
	    _this2.domElement = document.createElement('div');
	    dom.makeSelectable(_this2.domElement, false);
	    _this2.__selector = document.createElement('div');
	    _this2.__selector.className = 'selector';
	    _this2.__saturation_field = document.createElement('div');
	    _this2.__saturation_field.className = 'saturation-field';
	    _this2.__field_knob = document.createElement('div');
	    _this2.__field_knob.className = 'field-knob';
	    _this2.__field_knob_border = '2px solid ';
	    _this2.__hue_knob = document.createElement('div');
	    _this2.__hue_knob.className = 'hue-knob';
	    _this2.__hue_field = document.createElement('div');
	    _this2.__hue_field.className = 'hue-field';
	    _this2.__input = document.createElement('input');
	    _this2.__input.type = 'text';
	    _this2.__input_textShadow = '0 1px 1px ';
	    dom.bind(_this2.__input, 'keydown', function (e) {
	      if (e.keyCode === 13) {
	        onBlur.call(this);
	      }
	    });
	    dom.bind(_this2.__input, 'blur', onBlur);
	    dom.bind(_this2.__selector, 'mousedown', function ()        {
	      dom.addClass(this, 'drag').bind(window, 'mouseup', function ()        {
	        dom.removeClass(_this.__selector, 'drag');
	      });
	    });
	    dom.bind(_this2.__selector, 'touchstart', function ()        {
	      dom.addClass(this, 'drag').bind(window, 'touchend', function ()        {
	        dom.removeClass(_this.__selector, 'drag');
	      });
	    });
	    var valueField = document.createElement('div');
	    Common.extend(_this2.__selector.style, {
	      width: '122px',
	      height: '102px',
	      padding: '3px',
	      backgroundColor: '#222',
	      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)'
	    });
	    Common.extend(_this2.__field_knob.style, {
	      position: 'absolute',
	      width: '12px',
	      height: '12px',
	      border: _this2.__field_knob_border + (_this2.__color.v < 0.5 ? '#fff' : '#000'),
	      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
	      borderRadius: '12px',
	      zIndex: 1
	    });
	    Common.extend(_this2.__hue_knob.style, {
	      position: 'absolute',
	      width: '15px',
	      height: '2px',
	      borderRight: '4px solid #fff',
	      zIndex: 1
	    });
	    Common.extend(_this2.__saturation_field.style, {
	      width: '100px',
	      height: '100px',
	      border: '1px solid #555',
	      marginRight: '3px',
	      display: 'inline-block',
	      cursor: 'pointer'
	    });
	    Common.extend(valueField.style, {
	      width: '100%',
	      height: '100%',
	      background: 'none'
	    });
	    linearGradient(valueField, 'top', 'rgba(0,0,0,0)', '#000');
	    Common.extend(_this2.__hue_field.style, {
	      width: '15px',
	      height: '100px',
	      border: '1px solid #555',
	      cursor: 'ns-resize',
	      position: 'absolute',
	      top: '3px',
	      right: '3px'
	    });
	    hueGradient(_this2.__hue_field);
	    Common.extend(_this2.__input.style, {
	      outline: 'none',
	      textAlign: 'center',
	      color: '#fff',
	      border: 0,
	      fontWeight: 'bold',
	      textShadow: _this2.__input_textShadow + 'rgba(0,0,0,0.7)'
	    });
	    dom.bind(_this2.__saturation_field, 'mousedown', fieldDown);
	    dom.bind(_this2.__saturation_field, 'touchstart', fieldDown);
	    dom.bind(_this2.__field_knob, 'mousedown', fieldDown);
	    dom.bind(_this2.__field_knob, 'touchstart', fieldDown);
	    dom.bind(_this2.__hue_field, 'mousedown', fieldDownH);
	    dom.bind(_this2.__hue_field, 'touchstart', fieldDownH);
	    function fieldDown(e) {
	      setSV(e);
	      dom.bind(window, 'mousemove', setSV);
	      dom.bind(window, 'touchmove', setSV);
	      dom.bind(window, 'mouseup', fieldUpSV);
	      dom.bind(window, 'touchend', fieldUpSV);
	    }
	    function fieldDownH(e) {
	      setH(e);
	      dom.bind(window, 'mousemove', setH);
	      dom.bind(window, 'touchmove', setH);
	      dom.bind(window, 'mouseup', fieldUpH);
	      dom.bind(window, 'touchend', fieldUpH);
	    }
	    function fieldUpSV() {
	      dom.unbind(window, 'mousemove', setSV);
	      dom.unbind(window, 'touchmove', setSV);
	      dom.unbind(window, 'mouseup', fieldUpSV);
	      dom.unbind(window, 'touchend', fieldUpSV);
	      onFinish();
	    }
	    function fieldUpH() {
	      dom.unbind(window, 'mousemove', setH);
	      dom.unbind(window, 'touchmove', setH);
	      dom.unbind(window, 'mouseup', fieldUpH);
	      dom.unbind(window, 'touchend', fieldUpH);
	      onFinish();
	    }
	    function onBlur() {
	      var i = interpret(this.value);
	      if (i !== false) {
	        _this.__color.__state = i;
	        _this.setValue(_this.__color.toOriginal());
	      } else {
	        this.value = _this.__color.toString();
	      }
	    }
	    function onFinish() {
	      if (_this.__onFinishChange) {
	        _this.__onFinishChange.call(_this, _this.__color.toOriginal());
	      }
	    }
	    _this2.__saturation_field.appendChild(valueField);
	    _this2.__selector.appendChild(_this2.__field_knob);
	    _this2.__selector.appendChild(_this2.__saturation_field);
	    _this2.__selector.appendChild(_this2.__hue_field);
	    _this2.__hue_field.appendChild(_this2.__hue_knob);
	    _this2.domElement.appendChild(_this2.__input);
	    _this2.domElement.appendChild(_this2.__selector);
	    _this2.updateDisplay();
	    function setSV(e) {
	      if (e.type.indexOf('touch') === -1) {
	        e.preventDefault();
	      }
	      var fieldRect = _this.__saturation_field.getBoundingClientRect();
	      var _ref = e.touches && e.touches[0] || e,
	          clientX = _ref.clientX,
	          clientY = _ref.clientY;
	      var s = (clientX - fieldRect.left) / (fieldRect.right - fieldRect.left);
	      var v = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
	      if (v > 1) {
	        v = 1;
	      } else if (v < 0) {
	        v = 0;
	      }
	      if (s > 1) {
	        s = 1;
	      } else if (s < 0) {
	        s = 0;
	      }
	      _this.__color.v = v;
	      _this.__color.s = s;
	      _this.setValue(_this.__color.toOriginal());
	      return false;
	    }
	    function setH(e) {
	      if (e.type.indexOf('touch') === -1) {
	        e.preventDefault();
	      }
	      var fieldRect = _this.__hue_field.getBoundingClientRect();
	      var _ref2 = e.touches && e.touches[0] || e,
	          clientY = _ref2.clientY;
	      var h = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top);
	      if (h > 1) {
	        h = 1;
	      } else if (h < 0) {
	        h = 0;
	      }
	      _this.__color.h = h * 360;
	      _this.setValue(_this.__color.toOriginal());
	      return false;
	    }
	    return _this2;
	  }
	  createClass(ColorController, [{
	    key: 'updateDisplay',
	    value: function updateDisplay() {
	      var i = interpret(this.getValue());
	      if (i !== false) {
	        var mismatch = false;
	        Common.each(Color$1.COMPONENTS, function (component) {
	          if (!Common.isUndefined(i[component]) && !Common.isUndefined(this.__color.__state[component]) && i[component] !== this.__color.__state[component]) {
	            mismatch = true;
	            return {};
	          }
	        }, this);
	        if (mismatch) {
	          Common.extend(this.__color.__state, i);
	        }
	      }
	      Common.extend(this.__temp.__state, this.__color.__state);
	      this.__temp.a = 1;
	      var flip = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0;
	      var _flip = 255 - flip;
	      Common.extend(this.__field_knob.style, {
	        marginLeft: 100 * this.__color.s - 7 + 'px',
	        marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
	        backgroundColor: this.__temp.toHexString(),
	        border: this.__field_knob_border + 'rgb(' + flip + ',' + flip + ',' + flip + ')'
	      });
	      this.__hue_knob.style.marginTop = (1 - this.__color.h / 360) * 100 + 'px';
	      this.__temp.s = 1;
	      this.__temp.v = 1;
	      linearGradient(this.__saturation_field, 'left', '#fff', this.__temp.toHexString());
	      this.__input.value = this.__color.toString();
	      Common.extend(this.__input.style, {
	        backgroundColor: this.__color.toHexString(),
	        color: 'rgb(' + flip + ',' + flip + ',' + flip + ')',
	        textShadow: this.__input_textShadow + 'rgba(' + _flip + ',' + _flip + ',' + _flip + ',.7)'
	      });
	    }
	  }]);
	  return ColorController;
	}(Controller);
	var vendors = ['-moz-', '-o-', '-webkit-', '-ms-', ''];
	function linearGradient(elem, x, a, b) {
	  elem.style.background = '';
	  Common.each(vendors, function (vendor) {
	    elem.style.cssText += 'background: ' + vendor + 'linear-gradient(' + x + ', ' + a + ' 0%, ' + b + ' 100%); ';
	  });
	}
	function hueGradient(elem) {
	  elem.style.background = '';
	  elem.style.cssText += 'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);';
	  elem.style.cssText += 'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
	  elem.style.cssText += 'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
	  elem.style.cssText += 'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
	  elem.style.cssText += 'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);';
	}

	var css = {
	  load: function load(url, indoc) {
	    var doc = indoc || document;
	    var link = doc.createElement('link');
	    link.type = 'text/css';
	    link.rel = 'stylesheet';
	    link.href = url;
	    doc.getElementsByTagName('head')[0].appendChild(link);
	  },
	  inject: function inject(cssContent, indoc) {
	    var doc = indoc || document;
	    var injected = document.createElement('style');
	    injected.type = 'text/css';
	    injected.innerHTML = cssContent;
	    var head = doc.getElementsByTagName('head')[0];
	    try {
	      head.appendChild(injected);
	    } catch (e) {
	    }
	  }
	};

	var saveDialogContents = "<div id=\"dg-save\" class=\"dg dialogue\">\n\n  Here's the new load parameter for your <code>GUI</code>'s constructor:\n\n  <textarea id=\"dg-new-constructor\"></textarea>\n\n  <div id=\"dg-save-locally\">\n\n    <input id=\"dg-local-storage\" type=\"checkbox\"/> Automatically save\n    values to <code>localStorage</code> on exit.\n\n    <div id=\"dg-local-explain\">The values saved to <code>localStorage</code> will\n      override those passed to <code>dat.GUI</code>'s constructor. This makes it\n      easier to work incrementally, but <code>localStorage</code> is fragile,\n      and your friends may not see the same values you do.\n\n    </div>\n\n  </div>\n\n</div>";

	var ControllerFactory = function ControllerFactory(object, property) {
	  var initialValue = object[property];
	  if (Common.isArray(arguments[2]) || Common.isObject(arguments[2])) {
	    return new OptionController(object, property, arguments[2]);
	  }
	  if (Common.isNumber(initialValue)) {
	    if (Common.isNumber(arguments[2]) && Common.isNumber(arguments[3])) {
	      if (Common.isNumber(arguments[4])) {
	        return new NumberControllerSlider(object, property, arguments[2], arguments[3], arguments[4]);
	      }
	      return new NumberControllerSlider(object, property, arguments[2], arguments[3]);
	    }
	    if (Common.isNumber(arguments[4])) {
	      return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3], step: arguments[4] });
	    }
	    return new NumberControllerBox(object, property, { min: arguments[2], max: arguments[3] });
	  }
	  if (Common.isString(initialValue)) {
	    return new StringController(object, property);
	  }
	  if (Common.isFunction(initialValue)) {
	    return new FunctionController(object, property, '');
	  }
	  if (Common.isBoolean(initialValue)) {
	    return new BooleanController(object, property);
	  }
	  return null;
	};

	function requestAnimationFrame(callback) {
	  setTimeout(callback, 1000 / 60);
	}
	var requestAnimationFrame$1 = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || requestAnimationFrame;

	var CenteredDiv = function () {
	  function CenteredDiv() {
	    classCallCheck(this, CenteredDiv);
	    this.backgroundElement = document.createElement('div');
	    Common.extend(this.backgroundElement.style, {
	      backgroundColor: 'rgba(0,0,0,0.8)',
	      top: 0,
	      left: 0,
	      display: 'none',
	      zIndex: '1000',
	      opacity: 0,
	      WebkitTransition: 'opacity 0.2s linear',
	      transition: 'opacity 0.2s linear'
	    });
	    dom.makeFullscreen(this.backgroundElement);
	    this.backgroundElement.style.position = 'fixed';
	    this.domElement = document.createElement('div');
	    Common.extend(this.domElement.style, {
	      position: 'fixed',
	      display: 'none',
	      zIndex: '1001',
	      opacity: 0,
	      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear',
	      transition: 'transform 0.2s ease-out, opacity 0.2s linear'
	    });
	    document.body.appendChild(this.backgroundElement);
	    document.body.appendChild(this.domElement);
	    var _this = this;
	    dom.bind(this.backgroundElement, 'click', function () {
	      _this.hide();
	    });
	  }
	  createClass(CenteredDiv, [{
	    key: 'show',
	    value: function show() {
	      var _this = this;
	      this.backgroundElement.style.display = 'block';
	      this.domElement.style.display = 'block';
	      this.domElement.style.opacity = 0;
	      this.domElement.style.webkitTransform = 'scale(1.1)';
	      this.layout();
	      Common.defer(function () {
	        _this.backgroundElement.style.opacity = 1;
	        _this.domElement.style.opacity = 1;
	        _this.domElement.style.webkitTransform = 'scale(1)';
	      });
	    }
	  }, {
	    key: 'hide',
	    value: function hide() {
	      var _this = this;
	      var hide = function hide() {
	        _this.domElement.style.display = 'none';
	        _this.backgroundElement.style.display = 'none';
	        dom.unbind(_this.domElement, 'webkitTransitionEnd', hide);
	        dom.unbind(_this.domElement, 'transitionend', hide);
	        dom.unbind(_this.domElement, 'oTransitionEnd', hide);
	      };
	      dom.bind(this.domElement, 'webkitTransitionEnd', hide);
	      dom.bind(this.domElement, 'transitionend', hide);
	      dom.bind(this.domElement, 'oTransitionEnd', hide);
	      this.backgroundElement.style.opacity = 0;
	      this.domElement.style.opacity = 0;
	      this.domElement.style.webkitTransform = 'scale(1.1)';
	    }
	  }, {
	    key: 'layout',
	    value: function layout() {
	      this.domElement.style.left = window.innerWidth / 2 - dom.getWidth(this.domElement) / 2 + 'px';
	      this.domElement.style.top = window.innerHeight / 2 - dom.getHeight(this.domElement) / 2 + 'px';
	    }
	  }]);
	  return CenteredDiv;
	}();

	var styleSheet = ___$insertStyle(".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n");

	css.inject(styleSheet);
	var CSS_NAMESPACE = 'dg';
	var HIDE_KEY_CODE = 72;
	var CLOSE_BUTTON_HEIGHT = 20;
	var DEFAULT_DEFAULT_PRESET_NAME = 'Default';
	var SUPPORTS_LOCAL_STORAGE = function () {
	  try {
	    return !!window.localStorage;
	  } catch (e) {
	    return false;
	  }
	}();
	var SAVE_DIALOGUE = void 0;
	var autoPlaceVirgin = true;
	var autoPlaceContainer = void 0;
	var hide = false;
	var hideableGuis = [];
	var GUI = function GUI(pars) {
	  var _this = this;
	  var params = pars || {};
	  this.domElement = document.createElement('div');
	  this.__ul = document.createElement('ul');
	  this.domElement.appendChild(this.__ul);
	  dom.addClass(this.domElement, CSS_NAMESPACE);
	  this.__folders = {};
	  this.__controllers = [];
	  this.__rememberedObjects = [];
	  this.__rememberedObjectIndecesToControllers = [];
	  this.__listening = [];
	  params = Common.defaults(params, {
	    closeOnTop: false,
	    autoPlace: true,
	    width: GUI.DEFAULT_WIDTH
	  });
	  params = Common.defaults(params, {
	    resizable: params.autoPlace,
	    hideable: params.autoPlace
	  });
	  if (!Common.isUndefined(params.load)) {
	    if (params.preset) {
	      params.load.preset = params.preset;
	    }
	  } else {
	    params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME };
	  }
	  if (Common.isUndefined(params.parent) && params.hideable) {
	    hideableGuis.push(this);
	  }
	  params.resizable = Common.isUndefined(params.parent) && params.resizable;
	  if (params.autoPlace && Common.isUndefined(params.scrollable)) {
	    params.scrollable = true;
	  }
	  var useLocalStorage = SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true';
	  var saveToLocalStorage = void 0;
	  var titleRow = void 0;
	  Object.defineProperties(this,
	  {
	    parent: {
	      get: function get$$1() {
	        return params.parent;
	      }
	    },
	    scrollable: {
	      get: function get$$1() {
	        return params.scrollable;
	      }
	    },
	    autoPlace: {
	      get: function get$$1() {
	        return params.autoPlace;
	      }
	    },
	    closeOnTop: {
	      get: function get$$1() {
	        return params.closeOnTop;
	      }
	    },
	    preset: {
	      get: function get$$1() {
	        if (_this.parent) {
	          return _this.getRoot().preset;
	        }
	        return params.load.preset;
	      },
	      set: function set$$1(v) {
	        if (_this.parent) {
	          _this.getRoot().preset = v;
	        } else {
	          params.load.preset = v;
	        }
	        setPresetSelectIndex(this);
	        _this.revert();
	      }
	    },
	    width: {
	      get: function get$$1() {
	        return params.width;
	      },
	      set: function set$$1(v) {
	        params.width = v;
	        setWidth(_this, v);
	      }
	    },
	    name: {
	      get: function get$$1() {
	        return params.name;
	      },
	      set: function set$$1(v) {
	        params.name = v;
	        if (titleRow) {
	          titleRow.innerHTML = params.name;
	        }
	      }
	    },
	    closed: {
	      get: function get$$1() {
	        return params.closed;
	      },
	      set: function set$$1(v) {
	        params.closed = v;
	        if (params.closed) {
	          dom.addClass(_this.__ul, GUI.CLASS_CLOSED);
	        } else {
	          dom.removeClass(_this.__ul, GUI.CLASS_CLOSED);
	        }
	        this.onResize();
	        if (_this.__closeButton) {
	          _this.__closeButton.innerHTML = v ? GUI.TEXT_OPEN : GUI.TEXT_CLOSED;
	        }
	      }
	    },
	    load: {
	      get: function get$$1() {
	        return params.load;
	      }
	    },
	    useLocalStorage: {
	      get: function get$$1() {
	        return useLocalStorage;
	      },
	      set: function set$$1(bool) {
	        if (SUPPORTS_LOCAL_STORAGE) {
	          useLocalStorage = bool;
	          if (bool) {
	            dom.bind(window, 'unload', saveToLocalStorage);
	          } else {
	            dom.unbind(window, 'unload', saveToLocalStorage);
	          }
	          localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool);
	        }
	      }
	    }
	  });
	  if (Common.isUndefined(params.parent)) {
	    this.closed = params.closed || false;
	    dom.addClass(this.domElement, GUI.CLASS_MAIN);
	    dom.makeSelectable(this.domElement, false);
	    if (SUPPORTS_LOCAL_STORAGE) {
	      if (useLocalStorage) {
	        _this.useLocalStorage = true;
	        var savedGui = localStorage.getItem(getLocalStorageHash(this, 'gui'));
	        if (savedGui) {
	          params.load = JSON.parse(savedGui);
	        }
	      }
	    }
	    this.__closeButton = document.createElement('div');
	    this.__closeButton.innerHTML = GUI.TEXT_CLOSED;
	    dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BUTTON);
	    if (params.closeOnTop) {
	      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_TOP);
	      this.domElement.insertBefore(this.__closeButton, this.domElement.childNodes[0]);
	    } else {
	      dom.addClass(this.__closeButton, GUI.CLASS_CLOSE_BOTTOM);
	      this.domElement.appendChild(this.__closeButton);
	    }
	    dom.bind(this.__closeButton, 'click', function () {
	      _this.closed = !_this.closed;
	    });
	  } else {
	    if (params.closed === undefined) {
	      params.closed = true;
	    }
	    var titleRowName = document.createTextNode(params.name);
	    dom.addClass(titleRowName, 'controller-name');
	    titleRow = addRow(_this, titleRowName);
	    var onClickTitle = function onClickTitle(e) {
	      e.preventDefault();
	      _this.closed = !_this.closed;
	      return false;
	    };
	    dom.addClass(this.__ul, GUI.CLASS_CLOSED);
	    dom.addClass(titleRow, 'title');
	    dom.bind(titleRow, 'click', onClickTitle);
	    if (!params.closed) {
	      this.closed = false;
	    }
	  }
	  if (params.autoPlace) {
	    if (Common.isUndefined(params.parent)) {
	      if (autoPlaceVirgin) {
	        autoPlaceContainer = document.createElement('div');
	        dom.addClass(autoPlaceContainer, CSS_NAMESPACE);
	        dom.addClass(autoPlaceContainer, GUI.CLASS_AUTO_PLACE_CONTAINER);
	        document.body.appendChild(autoPlaceContainer);
	        autoPlaceVirgin = false;
	      }
	      autoPlaceContainer.appendChild(this.domElement);
	      dom.addClass(this.domElement, GUI.CLASS_AUTO_PLACE);
	    }
	    if (!this.parent) {
	      setWidth(_this, params.width);
	    }
	  }
	  this.__resizeHandler = function () {
	    _this.onResizeDebounced();
	  };
	  dom.bind(window, 'resize', this.__resizeHandler);
	  dom.bind(this.__ul, 'webkitTransitionEnd', this.__resizeHandler);
	  dom.bind(this.__ul, 'transitionend', this.__resizeHandler);
	  dom.bind(this.__ul, 'oTransitionEnd', this.__resizeHandler);
	  this.onResize();
	  if (params.resizable) {
	    addResizeHandle(this);
	  }
	  saveToLocalStorage = function saveToLocalStorage() {
	    if (SUPPORTS_LOCAL_STORAGE && localStorage.getItem(getLocalStorageHash(_this, 'isLocal')) === 'true') {
	      localStorage.setItem(getLocalStorageHash(_this, 'gui'), JSON.stringify(_this.getSaveObject()));
	    }
	  };
	  this.saveToLocalStorageIfPossible = saveToLocalStorage;
	  function resetWidth() {
	    var root = _this.getRoot();
	    root.width += 1;
	    Common.defer(function () {
	      root.width -= 1;
	    });
	  }
	  if (!params.parent) {
	    resetWidth();
	  }
	};
	GUI.toggleHide = function () {
	  hide = !hide;
	  Common.each(hideableGuis, function (gui) {
	    gui.domElement.style.display = hide ? 'none' : '';
	  });
	};
	GUI.CLASS_AUTO_PLACE = 'a';
	GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac';
	GUI.CLASS_MAIN = 'main';
	GUI.CLASS_CONTROLLER_ROW = 'cr';
	GUI.CLASS_TOO_TALL = 'taller-than-window';
	GUI.CLASS_CLOSED = 'closed';
	GUI.CLASS_CLOSE_BUTTON = 'close-button';
	GUI.CLASS_CLOSE_TOP = 'close-top';
	GUI.CLASS_CLOSE_BOTTOM = 'close-bottom';
	GUI.CLASS_DRAG = 'drag';
	GUI.DEFAULT_WIDTH = 245;
	GUI.TEXT_CLOSED = 'Close Controls';
	GUI.TEXT_OPEN = 'Open Controls';
	GUI._keydownHandler = function (e) {
	  if (document.activeElement.type !== 'text' && (e.which === HIDE_KEY_CODE || e.keyCode === HIDE_KEY_CODE)) {
	    GUI.toggleHide();
	  }
	};
	dom.bind(window, 'keydown', GUI._keydownHandler, false);
	Common.extend(GUI.prototype,
	{
	  add: function add(object, property) {
	    return _add(this, object, property, {
	      factoryArgs: Array.prototype.slice.call(arguments, 2)
	    });
	  },
	  addColor: function addColor(object, property) {
	    return _add(this, object, property, {
	      color: true
	    });
	  },
	  remove: function remove(controller) {
	    this.__ul.removeChild(controller.__li);
	    this.__controllers.splice(this.__controllers.indexOf(controller), 1);
	    var _this = this;
	    Common.defer(function () {
	      _this.onResize();
	    });
	  },
	  destroy: function destroy() {
	    if (this.parent) {
	      throw new Error('Only the root GUI should be removed with .destroy(). ' + 'For subfolders, use gui.removeFolder(folder) instead.');
	    }
	    if (this.autoPlace) {
	      autoPlaceContainer.removeChild(this.domElement);
	    }
	    var _this = this;
	    Common.each(this.__folders, function (subfolder) {
	      _this.removeFolder(subfolder);
	    });
	    dom.unbind(window, 'keydown', GUI._keydownHandler, false);
	    removeListeners(this);
	  },
	  addFolder: function addFolder(name) {
	    if (this.__folders[name] !== undefined) {
	      throw new Error('You already have a folder in this GUI by the' + ' name "' + name + '"');
	    }
	    var newGuiParams = { name: name, parent: this };
	    newGuiParams.autoPlace = this.autoPlace;
	    if (this.load &&
	    this.load.folders &&
	    this.load.folders[name]) {
	      newGuiParams.closed = this.load.folders[name].closed;
	      newGuiParams.load = this.load.folders[name];
	    }
	    var gui = new GUI(newGuiParams);
	    this.__folders[name] = gui;
	    var li = addRow(this, gui.domElement);
	    dom.addClass(li, 'folder');
	    return gui;
	  },
	  removeFolder: function removeFolder(folder) {
	    this.__ul.removeChild(folder.domElement.parentElement);
	    delete this.__folders[folder.name];
	    if (this.load &&
	    this.load.folders &&
	    this.load.folders[folder.name]) {
	      delete this.load.folders[folder.name];
	    }
	    removeListeners(folder);
	    var _this = this;
	    Common.each(folder.__folders, function (subfolder) {
	      folder.removeFolder(subfolder);
	    });
	    Common.defer(function () {
	      _this.onResize();
	    });
	  },
	  open: function open() {
	    this.closed = false;
	  },
	  close: function close() {
	    this.closed = true;
	  },
	  hide: function hide() {
	    this.domElement.style.display = 'none';
	  },
	  show: function show() {
	    this.domElement.style.display = '';
	  },
	  onResize: function onResize() {
	    var root = this.getRoot();
	    if (root.scrollable) {
	      var top = dom.getOffset(root.__ul).top;
	      var h = 0;
	      Common.each(root.__ul.childNodes, function (node) {
	        if (!(root.autoPlace && node === root.__save_row)) {
	          h += dom.getHeight(node);
	        }
	      });
	      if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h) {
	        dom.addClass(root.domElement, GUI.CLASS_TOO_TALL);
	        root.__ul.style.height = window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px';
	      } else {
	        dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL);
	        root.__ul.style.height = 'auto';
	      }
	    }
	    if (root.__resize_handle) {
	      Common.defer(function () {
	        root.__resize_handle.style.height = root.__ul.offsetHeight + 'px';
	      });
	    }
	    if (root.__closeButton) {
	      root.__closeButton.style.width = root.width + 'px';
	    }
	  },
	  onResizeDebounced: Common.debounce(function () {
	    this.onResize();
	  }, 50),
	  remember: function remember() {
	    if (Common.isUndefined(SAVE_DIALOGUE)) {
	      SAVE_DIALOGUE = new CenteredDiv();
	      SAVE_DIALOGUE.domElement.innerHTML = saveDialogContents;
	    }
	    if (this.parent) {
	      throw new Error('You can only call remember on a top level GUI.');
	    }
	    var _this = this;
	    Common.each(Array.prototype.slice.call(arguments), function (object) {
	      if (_this.__rememberedObjects.length === 0) {
	        addSaveMenu(_this);
	      }
	      if (_this.__rememberedObjects.indexOf(object) === -1) {
	        _this.__rememberedObjects.push(object);
	      }
	    });
	    if (this.autoPlace) {
	      setWidth(this, this.width);
	    }
	  },
	  getRoot: function getRoot() {
	    var gui = this;
	    while (gui.parent) {
	      gui = gui.parent;
	    }
	    return gui;
	  },
	  getSaveObject: function getSaveObject() {
	    var toReturn = this.load;
	    toReturn.closed = this.closed;
	    if (this.__rememberedObjects.length > 0) {
	      toReturn.preset = this.preset;
	      if (!toReturn.remembered) {
	        toReturn.remembered = {};
	      }
	      toReturn.remembered[this.preset] = getCurrentPreset(this);
	    }
	    toReturn.folders = {};
	    Common.each(this.__folders, function (element, key) {
	      toReturn.folders[key] = element.getSaveObject();
	    });
	    return toReturn;
	  },
	  save: function save() {
	    if (!this.load.remembered) {
	      this.load.remembered = {};
	    }
	    this.load.remembered[this.preset] = getCurrentPreset(this);
	    markPresetModified(this, false);
	    this.saveToLocalStorageIfPossible();
	  },
	  saveAs: function saveAs(presetName) {
	    if (!this.load.remembered) {
	      this.load.remembered = {};
	      this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(this, true);
	    }
	    this.load.remembered[presetName] = getCurrentPreset(this);
	    this.preset = presetName;
	    addPresetOption(this, presetName, true);
	    this.saveToLocalStorageIfPossible();
	  },
	  revert: function revert(gui) {
	    Common.each(this.__controllers, function (controller) {
	      if (!this.getRoot().load.remembered) {
	        controller.setValue(controller.initialValue);
	      } else {
	        recallSavedValue(gui || this.getRoot(), controller);
	      }
	      if (controller.__onFinishChange) {
	        controller.__onFinishChange.call(controller, controller.getValue());
	      }
	    }, this);
	    Common.each(this.__folders, function (folder) {
	      folder.revert(folder);
	    });
	    if (!gui) {
	      markPresetModified(this.getRoot(), false);
	    }
	  },
	  listen: function listen(controller) {
	    var init = this.__listening.length === 0;
	    this.__listening.push(controller);
	    if (init) {
	      updateDisplays(this.__listening);
	    }
	  },
	  updateDisplay: function updateDisplay() {
	    Common.each(this.__controllers, function (controller) {
	      controller.updateDisplay();
	    });
	    Common.each(this.__folders, function (folder) {
	      folder.updateDisplay();
	    });
	  }
	});
	function addRow(gui, newDom, liBefore) {
	  var li = document.createElement('li');
	  if (newDom) {
	    li.appendChild(newDom);
	  }
	  if (liBefore) {
	    gui.__ul.insertBefore(li, liBefore);
	  } else {
	    gui.__ul.appendChild(li);
	  }
	  gui.onResize();
	  return li;
	}
	function removeListeners(gui) {
	  dom.unbind(window, 'resize', gui.__resizeHandler);
	  if (gui.saveToLocalStorageIfPossible) {
	    dom.unbind(window, 'unload', gui.saveToLocalStorageIfPossible);
	  }
	}
	function markPresetModified(gui, modified) {
	  var opt = gui.__preset_select[gui.__preset_select.selectedIndex];
	  if (modified) {
	    opt.innerHTML = opt.value + '*';
	  } else {
	    opt.innerHTML = opt.value;
	  }
	}
	function augmentController(gui, li, controller) {
	  controller.__li = li;
	  controller.__gui = gui;
	  Common.extend(controller,                                   {
	    options: function options(_options) {
	      if (arguments.length > 1) {
	        var nextSibling = controller.__li.nextElementSibling;
	        controller.remove();
	        return _add(gui, controller.object, controller.property, {
	          before: nextSibling,
	          factoryArgs: [Common.toArray(arguments)]
	        });
	      }
	      if (Common.isArray(_options) || Common.isObject(_options)) {
	        var _nextSibling = controller.__li.nextElementSibling;
	        controller.remove();
	        return _add(gui, controller.object, controller.property, {
	          before: _nextSibling,
	          factoryArgs: [_options]
	        });
	      }
	    },
	    name: function name(_name) {
	      controller.__li.firstElementChild.firstElementChild.innerHTML = _name;
	      return controller;
	    },
	    listen: function listen() {
	      controller.__gui.listen(controller);
	      return controller;
	    },
	    remove: function remove() {
	      controller.__gui.remove(controller);
	      return controller;
	    }
	  });
	  if (controller instanceof NumberControllerSlider) {
	    var box = new NumberControllerBox(controller.object, controller.property, { min: controller.__min, max: controller.__max, step: controller.__step });
	    Common.each(['updateDisplay', 'onChange', 'onFinishChange', 'step', 'min', 'max'], function (method) {
	      var pc = controller[method];
	      var pb = box[method];
	      controller[method] = box[method] = function () {
	        var args = Array.prototype.slice.call(arguments);
	        pb.apply(box, args);
	        return pc.apply(controller, args);
	      };
	    });
	    dom.addClass(li, 'has-slider');
	    controller.domElement.insertBefore(box.domElement, controller.domElement.firstElementChild);
	  } else if (controller instanceof NumberControllerBox) {
	    var r = function r(returned) {
	      if (Common.isNumber(controller.__min) && Common.isNumber(controller.__max)) {
	        var oldName = controller.__li.firstElementChild.firstElementChild.innerHTML;
	        var wasListening = controller.__gui.__listening.indexOf(controller) > -1;
	        controller.remove();
	        var newController = _add(gui, controller.object, controller.property, {
	          before: controller.__li.nextElementSibling,
	          factoryArgs: [controller.__min, controller.__max, controller.__step]
	        });
	        newController.name(oldName);
	        if (wasListening) newController.listen();
	        return newController;
	      }
	      return returned;
	    };
	    controller.min = Common.compose(r, controller.min);
	    controller.max = Common.compose(r, controller.max);
	  } else if (controller instanceof BooleanController) {
	    dom.bind(li, 'click', function () {
	      dom.fakeEvent(controller.__checkbox, 'click');
	    });
	    dom.bind(controller.__checkbox, 'click', function (e) {
	      e.stopPropagation();
	    });
	  } else if (controller instanceof FunctionController) {
	    dom.bind(li, 'click', function () {
	      dom.fakeEvent(controller.__button, 'click');
	    });
	    dom.bind(li, 'mouseover', function () {
	      dom.addClass(controller.__button, 'hover');
	    });
	    dom.bind(li, 'mouseout', function () {
	      dom.removeClass(controller.__button, 'hover');
	    });
	  } else if (controller instanceof ColorController) {
	    dom.addClass(li, 'color');
	    controller.updateDisplay = Common.compose(function (val) {
	      li.style.borderLeftColor = controller.__color.toString();
	      return val;
	    }, controller.updateDisplay);
	    controller.updateDisplay();
	  }
	  controller.setValue = Common.compose(function (val) {
	    if (gui.getRoot().__preset_select && controller.isModified()) {
	      markPresetModified(gui.getRoot(), true);
	    }
	    return val;
	  }, controller.setValue);
	}
	function recallSavedValue(gui, controller) {
	  var root = gui.getRoot();
	  var matchedIndex = root.__rememberedObjects.indexOf(controller.object);
	  if (matchedIndex !== -1) {
	    var controllerMap = root.__rememberedObjectIndecesToControllers[matchedIndex];
	    if (controllerMap === undefined) {
	      controllerMap = {};
	      root.__rememberedObjectIndecesToControllers[matchedIndex] = controllerMap;
	    }
	    controllerMap[controller.property] = controller;
	    if (root.load && root.load.remembered) {
	      var presetMap = root.load.remembered;
	      var preset = void 0;
	      if (presetMap[gui.preset]) {
	        preset = presetMap[gui.preset];
	      } else if (presetMap[DEFAULT_DEFAULT_PRESET_NAME]) {
	        preset = presetMap[DEFAULT_DEFAULT_PRESET_NAME];
	      } else {
	        return;
	      }
	      if (preset[matchedIndex] && preset[matchedIndex][controller.property] !== undefined) {
	        var value = preset[matchedIndex][controller.property];
	        controller.initialValue = value;
	        controller.setValue(value);
	      }
	    }
	  }
	}
	function _add(gui, object, property, params) {
	  if (object[property] === undefined) {
	    throw new Error('Object "' + object + '" has no property "' + property + '"');
	  }
	  var controller = void 0;
	  if (params.color) {
	    controller = new ColorController(object, property);
	  } else {
	    var factoryArgs = [object, property].concat(params.factoryArgs);
	    controller = ControllerFactory.apply(gui, factoryArgs);
	  }
	  if (params.before instanceof Controller) {
	    params.before = params.before.__li;
	  }
	  recallSavedValue(gui, controller);
	  dom.addClass(controller.domElement, 'c');
	  var name = document.createElement('span');
	  dom.addClass(name, 'property-name');
	  name.innerHTML = controller.property;
	  var container = document.createElement('div');
	  container.appendChild(name);
	  container.appendChild(controller.domElement);
	  var li = addRow(gui, container, params.before);
	  dom.addClass(li, GUI.CLASS_CONTROLLER_ROW);
	  if (controller instanceof ColorController) {
	    dom.addClass(li, 'color');
	  } else {
	    dom.addClass(li, _typeof(controller.getValue()));
	  }
	  augmentController(gui, li, controller);
	  gui.__controllers.push(controller);
	  return controller;
	}
	function getLocalStorageHash(gui, key) {
	  return document.location.href + '.' + key;
	}
	function addPresetOption(gui, name, setSelected) {
	  var opt = document.createElement('option');
	  opt.innerHTML = name;
	  opt.value = name;
	  gui.__preset_select.appendChild(opt);
	  if (setSelected) {
	    gui.__preset_select.selectedIndex = gui.__preset_select.length - 1;
	  }
	}
	function showHideExplain(gui, explain) {
	  explain.style.display = gui.useLocalStorage ? 'block' : 'none';
	}
	function addSaveMenu(gui) {
	  var div = gui.__save_row = document.createElement('li');
	  dom.addClass(gui.domElement, 'has-save');
	  gui.__ul.insertBefore(div, gui.__ul.firstChild);
	  dom.addClass(div, 'save-row');
	  var gears = document.createElement('span');
	  gears.innerHTML = '&nbsp;';
	  dom.addClass(gears, 'button gears');
	  var button = document.createElement('span');
	  button.innerHTML = 'Save';
	  dom.addClass(button, 'button');
	  dom.addClass(button, 'save');
	  var button2 = document.createElement('span');
	  button2.innerHTML = 'New';
	  dom.addClass(button2, 'button');
	  dom.addClass(button2, 'save-as');
	  var button3 = document.createElement('span');
	  button3.innerHTML = 'Revert';
	  dom.addClass(button3, 'button');
	  dom.addClass(button3, 'revert');
	  var select = gui.__preset_select = document.createElement('select');
	  if (gui.load && gui.load.remembered) {
	    Common.each(gui.load.remembered, function (value, key) {
	      addPresetOption(gui, key, key === gui.preset);
	    });
	  } else {
	    addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false);
	  }
	  dom.bind(select, 'change', function () {
	    for (var index = 0; index < gui.__preset_select.length; index++) {
	      gui.__preset_select[index].innerHTML = gui.__preset_select[index].value;
	    }
	    gui.preset = this.value;
	  });
	  div.appendChild(select);
	  div.appendChild(gears);
	  div.appendChild(button);
	  div.appendChild(button2);
	  div.appendChild(button3);
	  if (SUPPORTS_LOCAL_STORAGE) {
	    var explain = document.getElementById('dg-local-explain');
	    var localStorageCheckBox = document.getElementById('dg-local-storage');
	    var saveLocally = document.getElementById('dg-save-locally');
	    saveLocally.style.display = 'block';
	    if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
	      localStorageCheckBox.setAttribute('checked', 'checked');
	    }
	    showHideExplain(gui, explain);
	    dom.bind(localStorageCheckBox, 'change', function () {
	      gui.useLocalStorage = !gui.useLocalStorage;
	      showHideExplain(gui, explain);
	    });
	  }
	  var newConstructorTextArea = document.getElementById('dg-new-constructor');
	  dom.bind(newConstructorTextArea, 'keydown', function (e) {
	    if (e.metaKey && (e.which === 67 || e.keyCode === 67)) {
	      SAVE_DIALOGUE.hide();
	    }
	  });
	  dom.bind(gears, 'click', function () {
	    newConstructorTextArea.innerHTML = JSON.stringify(gui.getSaveObject(), undefined, 2);
	    SAVE_DIALOGUE.show();
	    newConstructorTextArea.focus();
	    newConstructorTextArea.select();
	  });
	  dom.bind(button, 'click', function () {
	    gui.save();
	  });
	  dom.bind(button2, 'click', function () {
	    var presetName = prompt('Enter a new preset name.');
	    if (presetName) {
	      gui.saveAs(presetName);
	    }
	  });
	  dom.bind(button3, 'click', function () {
	    gui.revert();
	  });
	}
	function addResizeHandle(gui) {
	  var pmouseX = void 0;
	  gui.__resize_handle = document.createElement('div');
	  Common.extend(gui.__resize_handle.style, {
	    width: '6px',
	    marginLeft: '-3px',
	    height: '200px',
	    cursor: 'ew-resize',
	    position: 'absolute'
	  });
	  function drag(e) {
	    e.preventDefault();
	    gui.width += pmouseX - e.clientX;
	    gui.onResize();
	    pmouseX = e.clientX;
	    return false;
	  }
	  function dragStop() {
	    dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG);
	    dom.unbind(window, 'mousemove', drag);
	    dom.unbind(window, 'mouseup', dragStop);
	  }
	  function dragStart(e) {
	    e.preventDefault();
	    pmouseX = e.clientX;
	    dom.addClass(gui.__closeButton, GUI.CLASS_DRAG);
	    dom.bind(window, 'mousemove', drag);
	    dom.bind(window, 'mouseup', dragStop);
	    return false;
	  }
	  dom.bind(gui.__resize_handle, 'mousedown', dragStart);
	  dom.bind(gui.__closeButton, 'mousedown', dragStart);
	  gui.domElement.insertBefore(gui.__resize_handle, gui.domElement.firstElementChild);
	}
	function setWidth(gui, w) {
	  gui.domElement.style.width = w + 'px';
	  if (gui.__save_row && gui.autoPlace) {
	    gui.__save_row.style.width = w + 'px';
	  }
	  if (gui.__closeButton) {
	    gui.__closeButton.style.width = w + 'px';
	  }
	}
	function getCurrentPreset(gui, useInitialValues) {
	  var toReturn = {};
	  Common.each(gui.__rememberedObjects, function (val, index) {
	    var savedValues = {};
	    var controllerMap = gui.__rememberedObjectIndecesToControllers[index];
	    Common.each(controllerMap, function (controller, property) {
	      savedValues[property] = useInitialValues ? controller.initialValue : controller.getValue();
	    });
	    toReturn[index] = savedValues;
	  });
	  return toReturn;
	}
	function setPresetSelectIndex(gui) {
	  for (var index = 0; index < gui.__preset_select.length; index++) {
	    if (gui.__preset_select[index].value === gui.preset) {
	      gui.__preset_select.selectedIndex = index;
	    }
	  }
	}
	function updateDisplays(controllerArray) {
	  if (controllerArray.length !== 0) {
	    requestAnimationFrame$1.call(window, function () {
	      updateDisplays(controllerArray);
	    });
	  }
	  Common.each(controllerArray, function (c) {
	    c.updateDisplay();
	  });
	}

	var color = {
	  Color: Color$1,
	  math: ColorMath,
	  interpret: interpret
	};
	var controllers = {
	  Controller: Controller,
	  BooleanController: BooleanController,
	  OptionController: OptionController,
	  StringController: StringController,
	  NumberController: NumberController,
	  NumberControllerBox: NumberControllerBox,
	  NumberControllerSlider: NumberControllerSlider,
	  FunctionController: FunctionController,
	  ColorController: ColorController
	};
	var dom$1 = { dom: dom };
	var gui = { GUI: GUI };
	var GUI$1 = GUI;
	var index = {
	  color: color,
	  controllers: controllers,
	  dom: dom$1,
	  gui: gui,
	  GUI: GUI$1
	};

	/* 
	 * To change this license header, choose License Headers in Project Properties.
	 * To change this template file, choose Tools | Templates
	 * and open the template in the editor.
	 */

	let obj = {
	    "three"     : three, 
	    "_"         : _,
	    "$"         : jQuery$1,
	    "Backbone"  : backbone,
	    "async"     : async,
	    "ThreeBSP"  : ThreeBSP,
	    "url"       : url,
	    "dat"       : index
	    
	};

	exports.$ = jQuery$1;
	exports.Backbone = backbone;
	exports.ThreeBSP = ThreeBSP;
	exports._ = _;
	exports.async = async;
	exports.default = obj;
	exports.three = three;

	Object.defineProperty(exports, '__esModule', { value: true });

}));
